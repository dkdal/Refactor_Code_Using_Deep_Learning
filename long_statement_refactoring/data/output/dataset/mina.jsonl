{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport org.apache.mina.api.AbstractIoFilter;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.codec.ProtocolDecoder;\nimport org.apache.mina.codec.ProtocolDecoderException;\nimport org.apache.mina.codec.ProtocolEncoder;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.session.AttributeKey;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.util.Assert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into message objects and vice versa using\n * {@link ProtocolCodecFactory}, {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ProtocolCodecFilter<MESSAGE, ENCODED> extends AbstractIoFilter {\n    /** A logger for this class */\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolCodecFilter.class);\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n\n    /** key for session attribute holding the encoder */\n    @SuppressWarnings(\"rawtypes\")\n    private final AttributeKey<ProtocolEncoder> ENCODER = new AttributeKey<ProtocolEncoder>(ProtocolEncoder.class,\n            \"internal_encoder\");\n\n    /** key for session attribute holding the decoder */\n    @SuppressWarnings(\"rawtypes\")\n    private final AttributeKey<ProtocolDecoder> DECODER = new AttributeKey<ProtocolDecoder>(ProtocolDecoder.class,\n            \"internal_decoder\");\n\n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory<MESSAGE, ENCODED> factory;\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory for the creation of the encoder and decoder.\n     * \n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory<MESSAGE, ENCODED> factory) {\n        if (factory == null) {\n            throw new IllegalArgumentException(\"factory\");\n        }\n\n        this.factory = factory;\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory. The encoder/decoder factory will be created\n     * as an anonymous class, using the two parameters (encoder and decoder), which are class names. Instances for those\n     * classes will be created in this constructor.\n     * \n     * @param encoderClass The class responsible for encoding the message\n     * @param decoderClass The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(Class<? extends ProtocolEncoder<MESSAGE, ENCODED>> encoderClass,\n            Class<? extends ProtocolDecoder<ENCODED, MESSAGE>> decoderClass) {\n        Assert.assertNotNull(encoderClass, \"Encoder Class\");\n        Assert.assertNotNull(decoderClass, \"Decoder Class\");\n\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\"encoderClass doesn't have a public default constructor.\");\n        }\n\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\"decoderClass doesn't have a public default constructor.\");\n        }\n\n        final ProtocolEncoder<MESSAGE, ENCODED> encoder;\n\n        try {\n            encoder = encoderClass.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"encoderClass cannot be initialized\");\n        }\n\n        final ProtocolDecoder<ENCODED, MESSAGE> decoder;\n\n        try {\n            decoder = decoderClass.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"decoderClass cannot be initialized\");\n        }\n\n        // Create the inner factory based on the two parameters.\n        this.factory = new ProtocolCodecFactory<MESSAGE, ENCODED>() {\n            @Override\n            public ProtocolEncoder<MESSAGE, ENCODED> getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            @Override\n            public ProtocolDecoder<ENCODED, MESSAGE> getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Get the encoder instance from a given session.\n     * \n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder<MESSAGE, ENCODED> getEncoder(IoSession session) {\n        return factory.getEncoder(session);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     * \n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance, if any\n     */\n    public ProtocolDecoder<ENCODED, MESSAGE> getDecoder(IoSession session) {\n        return factory.getDecoder(session);\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming buffer might contains more than one\n     * messages, we have to loop until the decoder throws an exception. <code>\n     *  while ( buffer not empty )\n     *    try\n     *      decode ( buffer )\n     *    catch\n     *      break;\n     * <\/code>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageReceived(IoSession session, Object in, ReadFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_RECEIVED for session {}\", session);\n\n        ProtocolDecoder<ENCODED, MESSAGE> decoder = getDecoder(session);\n\n        // Loop until the codec cannot decode more\n        MESSAGE[] msg;\n        try {\n            while ((msg = decoder.decode((ENCODED) in)) != null) {\n                for (MESSAGE m : msg) {\n                    controller.callReadNextFilter(m);\n                }\n            }\n        } catch (ProtocolDecoderException e) {\n            LOGGER.debug(\"decoding exception : \", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageWriting(IoSession session, WriteRequest message, WriteFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_WRITTING for session {}\", session);\n\n        ProtocolEncoder<MESSAGE, ENCODED> encoder = getEncoder(session);\n        ENCODED encoded = encoder.encode((MESSAGE) message.getMessage());\n        message.setMessage(encoded);\n\n        controller.callWriteNextFilter(message);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionOpened(IoSession session) {\n        // Initialize the encoder and decoder if we use a factory\n        if (factory != null) {\n            ProtocolEncoder<MESSAGE, ENCODED> encoder = factory.getEncoder(session);\n            session.setAttribute(ENCODER, encoder);\n            ProtocolDecoder<ENCODED, MESSAGE> decoder = factory.getDecoder(session);\n            session.setAttribute(DECODER, decoder);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(IoSession session) {\n        disposeCodec(session);\n    }\n\n    // ----------- Helper methods ---------------------------------------------\n    /**\n     * Dispose the encoder, decoder, and the callback for the decoded messages.\n     */\n    private void disposeCodec(IoSession session) {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(session);\n        disposeDecoder(session);\n    }\n\n    /**\n     * Dispose the encoder, removing its instance from the session's attributes, and calling the associated dispose\n     * method.\n     */\n    private void disposeEncoder(IoSession session) {\n        session.removeAttribute(ENCODER);\n    }\n\n    /**\n     * Dispose the decoder, removing its instance from the session's attributes, and calling the associated dispose\n     * method.\n     */\n    private void disposeDecoder(IoSession session) {\n        @SuppressWarnings(\"unchecked\")\n        ProtocolDecoder<ENCODED, MESSAGE> decoder = session.removeAttribute(DECODER);\n        try {\n            decoder.finishDecode();\n        } catch (Throwable t) {\n            LOGGER.warn(\"Failed to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport org.apache.mina.api.AbstractIoFilter;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.codec.ProtocolDecoder;\nimport org.apache.mina.codec.ProtocolDecoderException;\nimport org.apache.mina.codec.ProtocolEncoder;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.session.AttributeKey;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.util.Assert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into message objects and vice versa using\n * {@link ProtocolCodecFactory}, {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ProtocolCodecFilter<MESSAGE, ENCODED, ENCODING_STATE, DECODING_STATE> extends AbstractIoFilter {\n    /** A logger for this class */\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolCodecFilter.class);\n\n    /** the immutable encoder */\n    private final ProtocolEncoder<MESSAGE, ENCODED, ENCODING_STATE> encoder;\n\n    /** the immutable decoder */\n    private final ProtocolDecoder<ENCODED, MESSAGE, DECODING_STATE> decoder;\n\n    /** key for session attribute holding the encoder */\n    private final AttributeKey<Object> ENCODER = new AttributeKey<Object>(Object.class, \"internal_encoder\");\n\n    /** key for session attribute holding the decoder */\n    private final AttributeKey<Object> DECODER = new AttributeKey<Object>(Object.class, \"internal_decoder\");\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, with the specified encoder and decoder.\n     * \n     */\n    public ProtocolCodecFilter(ProtocolEncoder<MESSAGE, ENCODED, ENCODING_STATE> encoder,\n            ProtocolDecoder<ENCODED, MESSAGE, DECODING_STATE> decoder) {\n        Assert.assertNotNull(encoder, \"encoder\");\n        Assert.assertNotNull(decoder, \"decoder\");\n        this.encoder = encoder;\n        this.decoder = decoder;\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming buffer might contains more than one\n     * messages, we have to loop until the decoder throws an exception. <code>\n     *  while ( buffer not empty )\n     *    try\n     *      decode ( buffer )\n     *    catch\n     *      break;\n     * <\/code>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageReceived(IoSession session, Object in, ReadFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_RECEIVED for session {}\", session);\n\n        DECODING_STATE state = getDecodingState(session);\n\n        // Loop until the decoder cannot decode more\n        MESSAGE[] msg;\n        try {\n            while ((msg = decoder.decode((ENCODED) in, state)) != null) {\n                for (MESSAGE m : msg) {\n                    controller.callReadNextFilter(m);\n                }\n            }\n        } catch (ProtocolDecoderException e) {\n            LOGGER.debug(\"decoding exception : \", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageWriting(IoSession session, WriteRequest message, WriteFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_WRITTING for session {}\", session);\n\n        ENCODED encoded = encoder.encode((MESSAGE) message.getMessage(), getEncodingState(session));\n        message.setMessage(encoded);\n\n        controller.callWriteNextFilter(message);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionOpened(IoSession session) {\n        // Initialize the encoder and decoder state\n\n        ENCODING_STATE encodingState = encoder.createEncoderState();\n        session.setAttribute(ENCODER, encodingState);\n\n        DECODING_STATE decodingState = decoder.createDecoderState();\n        session.setAttribute(DECODER, decodingState);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(IoSession session) {\n        decoder.finishDecode(getDecodingState(session));\n\n    }\n\n    // ----------- Helper methods ---------------------------------------------\n\n    @SuppressWarnings(\"unchecked\")\n    private DECODING_STATE getDecodingState(IoSession session) {\n        return (DECODING_STATE) session.getAttribute(DECODER);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ENCODING_STATE getEncodingState(IoSession session) {\n        return (ENCODING_STATE) session.getAttribute(ENCODER);\n    }\n\n}\n","lineNo":121}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport org.apache.mina.api.AbstractIoFilter;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.codec.ProtocolDecoder;\nimport org.apache.mina.codec.ProtocolDecoderException;\nimport org.apache.mina.codec.ProtocolEncoder;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.session.AttributeKey;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.util.Assert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into message objects and vice versa using\n * {@link ProtocolCodecFactory}, {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ProtocolCodecFilter<MESSAGE, ENCODED> extends AbstractIoFilter {\n    /** A logger for this class */\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolCodecFilter.class);\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n\n    /** key for session attribute holding the encoder */\n    @SuppressWarnings(\"rawtypes\")\n    private final AttributeKey<ProtocolEncoder> ENCODER = new AttributeKey<ProtocolEncoder>(ProtocolEncoder.class,\n            \"internal_encoder\");\n\n    /** key for session attribute holding the decoder */\n    @SuppressWarnings(\"rawtypes\")\n    private final AttributeKey<ProtocolDecoder> DECODER = new AttributeKey<ProtocolDecoder>(ProtocolDecoder.class,\n            \"internal_decoder\");\n\n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory<MESSAGE, ENCODED> factory;\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory for the creation of the encoder and decoder.\n     * \n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory<MESSAGE, ENCODED> factory) {\n        if (factory == null) {\n            throw new IllegalArgumentException(\"factory\");\n        }\n\n        this.factory = factory;\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory. The encoder/decoder factory will be created\n     * as an anonymous class, using the two parameters (encoder and decoder), which are class names. Instances for those\n     * classes will be created in this constructor.\n     * \n     * @param encoderClass The class responsible for encoding the message\n     * @param decoderClass The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(Class<? extends ProtocolEncoder<MESSAGE, ENCODED>> encoderClass,\n            Class<? extends ProtocolDecoder<ENCODED, MESSAGE>> decoderClass) {\n        Assert.assertNotNull(encoderClass, \"Encoder Class\");\n        Assert.assertNotNull(decoderClass, \"Decoder Class\");\n\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\"encoderClass doesn't have a public default constructor.\");\n        }\n\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\"decoderClass doesn't have a public default constructor.\");\n        }\n\n        final ProtocolEncoder<MESSAGE, ENCODED> encoder;\n\n        try {\n            encoder = encoderClass.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"encoderClass cannot be initialized\");\n        }\n\n        final ProtocolDecoder<ENCODED, MESSAGE> decoder;\n\n        try {\n            decoder = decoderClass.newInstance();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"decoderClass cannot be initialized\");\n        }\n\n        // Create the inner factory based on the two parameters.\n        this.factory = new ProtocolCodecFactory<MESSAGE, ENCODED>() {\n            @Override\n            public ProtocolEncoder<MESSAGE, ENCODED> getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            @Override\n            public ProtocolDecoder<ENCODED, MESSAGE> getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Get the encoder instance from a given session.\n     * \n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder<MESSAGE, ENCODED> getEncoder(IoSession session) {\n        return factory.getEncoder(session);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     * \n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance, if any\n     */\n    public ProtocolDecoder<ENCODED, MESSAGE> getDecoder(IoSession session) {\n        return factory.getDecoder(session);\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming buffer might contains more than one\n     * messages, we have to loop until the decoder throws an exception. <code>\n     *  while ( buffer not empty )\n     *    try\n     *      decode ( buffer )\n     *    catch\n     *      break;\n     * <\/code>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageReceived(IoSession session, Object in, ReadFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_RECEIVED for session {}\", session);\n\n        ProtocolDecoder<ENCODED, MESSAGE> decoder = getDecoder(session);\n\n        // Loop until the codec cannot decode more\n        MESSAGE[] msg;\n        try {\n            while ((msg = decoder.decode((ENCODED) in)) != null) {\n                for (MESSAGE m : msg) {\n                    controller.callReadNextFilter(m);\n                }\n            }\n        } catch (ProtocolDecoderException e) {\n            LOGGER.debug(\"decoding exception : \", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageWriting(IoSession session, WriteRequest message, WriteFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_WRITTING for session {}\", session);\n\n        ProtocolEncoder<MESSAGE, ENCODED> encoder = getEncoder(session);\n        ENCODED encoded = encoder.encode((MESSAGE) message.getMessage());\n        message.setMessage(encoded);\n\n        controller.callWriteNextFilter(message);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionOpened(IoSession session) {\n        // Initialize the encoder and decoder if we use a factory\n        if (factory != null) {\n            ProtocolEncoder<MESSAGE, ENCODED> encoder = factory.getEncoder(session);\n            session.setAttribute(ENCODER, encoder);\n            ProtocolDecoder<ENCODED, MESSAGE> decoder = factory.getDecoder(session);\n            session.setAttribute(DECODER, decoder);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(IoSession session) {\n        disposeCodec(session);\n    }\n\n    // ----------- Helper methods ---------------------------------------------\n    /**\n     * Dispose the encoder, decoder, and the callback for the decoded messages.\n     */\n    private void disposeCodec(IoSession session) {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(session);\n        disposeDecoder(session);\n    }\n\n    /**\n     * Dispose the encoder, removing its instance from the session's attributes, and calling the associated dispose\n     * method.\n     */\n    private void disposeEncoder(IoSession session) {\n        session.removeAttribute(ENCODER);\n    }\n\n    /**\n     * Dispose the decoder, removing its instance from the session's attributes, and calling the associated dispose\n     * method.\n     */\n    private void disposeDecoder(IoSession session) {\n        @SuppressWarnings(\"unchecked\")\n        ProtocolDecoder<ENCODED, MESSAGE> decoder = session.removeAttribute(DECODER);\n        try {\n            decoder.finishDecode();\n        } catch (Throwable t) {\n            LOGGER.warn(\"Failed to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport org.apache.mina.api.AbstractIoFilter;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.codec.ProtocolDecoder;\nimport org.apache.mina.codec.ProtocolDecoderException;\nimport org.apache.mina.codec.ProtocolEncoder;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.session.AttributeKey;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.util.Assert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into message objects and vice versa using\n * {@link ProtocolCodecFactory}, {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ProtocolCodecFilter<MESSAGE, ENCODED, ENCODING_STATE, DECODING_STATE> extends AbstractIoFilter {\n    /** A logger for this class */\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolCodecFilter.class);\n\n    /** the immutable encoder */\n    private final ProtocolEncoder<MESSAGE, ENCODED, ENCODING_STATE> encoder;\n\n    /** the immutable decoder */\n    private final ProtocolDecoder<ENCODED, MESSAGE, DECODING_STATE> decoder;\n\n    /** key for session attribute holding the encoder */\n    private final AttributeKey<Object> ENCODER = new AttributeKey<Object>(Object.class, \"internal_encoder\");\n\n    /** key for session attribute holding the decoder */\n    private final AttributeKey<Object> DECODER = new AttributeKey<Object>(Object.class, \"internal_decoder\");\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, with the specified encoder and decoder.\n     * \n     */\n    public ProtocolCodecFilter(ProtocolEncoder<MESSAGE, ENCODED, ENCODING_STATE> encoder,\n            ProtocolDecoder<ENCODED, MESSAGE, DECODING_STATE> decoder) {\n        Assert.assertNotNull(encoder, \"encoder\");\n        Assert.assertNotNull(decoder, \"decoder\");\n        this.encoder = encoder;\n        this.decoder = decoder;\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming buffer might contains more than one\n     * messages, we have to loop until the decoder throws an exception. <code>\n     *  while ( buffer not empty )\n     *    try\n     *      decode ( buffer )\n     *    catch\n     *      break;\n     * <\/code>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageReceived(IoSession session, Object in, ReadFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_RECEIVED for session {}\", session);\n\n        DECODING_STATE state = getDecodingState(session);\n\n        // Loop until the decoder cannot decode more\n        MESSAGE[] msg;\n        try {\n            while ((msg = decoder.decode((ENCODED) in, state)) != null) {\n                for (MESSAGE m : msg) {\n                    controller.callReadNextFilter(m);\n                }\n            }\n        } catch (ProtocolDecoderException e) {\n            LOGGER.debug(\"decoding exception : \", e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void messageWriting(IoSession session, WriteRequest message, WriteFilterChainController controller) {\n        LOGGER.debug(\"Processing a MESSAGE_WRITTING for session {}\", session);\n\n        ENCODED encoded = encoder.encode((MESSAGE) message.getMessage(), getEncodingState(session));\n        message.setMessage(encoded);\n\n        controller.callWriteNextFilter(message);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionOpened(IoSession session) {\n        // Initialize the encoder and decoder state\n\n        ENCODING_STATE encodingState = encoder.createEncoderState();\n        session.setAttribute(ENCODER, encodingState);\n\n        DECODING_STATE decodingState = decoder.createDecoderState();\n        session.setAttribute(DECODER, decodingState);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(IoSession session) {\n        decoder.finishDecode(getDecodingState(session));\n\n    }\n\n    // ----------- Helper methods ---------------------------------------------\n\n    @SuppressWarnings(\"unchecked\")\n    private DECODING_STATE getDecodingState(IoSession session) {\n        return (DECODING_STATE) session.getAttribute(DECODER);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ENCODING_STATE getEncodingState(IoSession session) {\n        return (ENCODING_STATE) session.getAttribute(ENCODER);\n    }\n\n}\n","lineNo":124}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLException;\n\nimport org.apache.mina.api.IdleStatus;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoHandler;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.service.executor.CloseEvent;\nimport org.apache.mina.service.executor.IdleEvent;\nimport org.apache.mina.service.executor.IoHandlerExecutor;\nimport org.apache.mina.service.executor.OpenEvent;\nimport org.apache.mina.service.executor.ReceiveEvent;\nimport org.apache.mina.service.executor.SentEvent;\nimport org.apache.mina.service.idlechecker.IdleChecker;\nimport org.apache.mina.transport.nio.SelectorLoop;\nimport org.apache.mina.util.AbstractIoFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession, ReadFilterChainController, WriteFilterChainController {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** unique identifier generator */\n    private static final AtomicInteger NEXT_ID = new AtomicInteger(0);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** attributes map */\n    private final AttributeContainer attributes = new DefaultAttributeContainer();\n\n    /** the {@link IdleChecker} in charge of detecting idle event for this session */\n    protected final IdleChecker idleChecker;\n\n    // ------------------------------------------------------------------------\n    // Basic statistics\n    // ------------------------------------------------------------------------\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    // ------------------------------------------------------------------------\n    // Session state\n    // ------------------------------------------------------------------------\n\n    /** The session's state : one of CREATED, CONNECTED, CLOSING, CLOSED, SECURING, CONNECTED_SECURED */\n    protected volatile SessionState state;\n\n    /** A lock to protect the access to the session's state */\n    private final ReadWriteLock stateLock = new ReentrantReadWriteLock();\n\n    /** A Read lock on the reentrant session's state lock */\n    private final Lock stateReadLock = stateLock.readLock();\n\n    /** A Write lock on the reentrant session's state lock */\n    private final Lock stateWriteLock = stateLock.writeLock();\n\n    /** Tells if the session is secured or not */\n    protected volatile boolean secured;\n\n    /** is this session registered for being polled for write ready events */\n    private final AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    // ------------------------------------------------------------------------\n    // Write queue\n    // ------------------------------------------------------------------------\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorLoop} */\n    private final Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    // ------------------------------------------------------------------------\n    // Filter chain\n    // ------------------------------------------------------------------------\n\n    /** The list of {@link IoFilter} implementing this chain. */\n    private final IoFilter[] chain;\n\n    /** the current position in the write chain for this thread */\n    private int writeChainPosition;\n\n    /** the current position in the read chain for this thread */\n    private int readChainPosition;\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private WriteRequest lastWriteRequest;\n\n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param selectorLoop the selector loop in charge of processing this session read/write events\n     */\n    public AbstractIoSession(final IoService service, final IdleChecker idleChecker) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.chain = service.getFilters();\n        this.idleChecker = idleChecker;\n\n        LOG.debug(\"Created new session with id : {}\", id);\n\n        this.state = SessionState.CREATED;\n    }\n\n    // ------------------------------------------------------------------------\n    // Session State management\n    // ------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CLOSED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosing() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CLOSING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnected() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CONNECTED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCreated() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CREATED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecuring() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.SECURING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnectedSecured() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.SECURED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void changeState(final SessionState to) throws IllegalStateException {\n        try {\n            stateWriteLock.lock();\n\n            switch (state) {\n            case CREATED:\n                switch (to) {\n                case CONNECTED:\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case CONNECTED:\n                switch (to) {\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case SECURING:\n                switch (to) {\n                case SECURED:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case SECURED:\n                switch (to) {\n                case CONNECTED:\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n            case CLOSING:\n                if (to != SessionState.CLOSED) {\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                state = to;\n\n                break;\n\n            case CLOSED:\n                throw new IllegalStateException(\"The session is already closed. cannot switch to \" + to);\n            }\n        } finally {\n            stateWriteLock.unlock();\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // SSL/TLS session state management\n    // ------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecured() {\n        return secured;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setSecured(final boolean secured) {\n        this.secured = secured;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initSecure(final SSLContext sslContext) throws SSLException {\n        final SslHelper sslHelper = new SslHelper(this, sslContext);\n        sslHelper.init();\n\n        attributes.setAttribute(SSL_HELPER, sslHelper);\n        setSecured(true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * To be called by the internal plumber when some bytes are written on the socket\n     * \n     * @param bytesCount number of extra bytes written\n     */\n    public void incrementWrittenBytes(final int bytesCount) {\n        writtenBytes += bytesCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     * @see #setAttribute(AttributeKey, Object)\n     */\n    @Override\n    public final <T> T getAttribute(final AttributeKey<T> key, final T defaultValue) {\n        return attributes.getAttribute(key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     * @see #setAttribute(AttributeKey, Object)\n     */\n    @Override\n    public final <T> T getAttribute(final AttributeKey<T> key) {\n        return attributes.getAttribute(key);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException <ul>\n     *            <li>\n     *            if <code>key==null<\/code><\/li>\n     *            <li>\n     *            if <code>value<\/code> is not <code>null<\/code> and not an instance of type that is specified in by the\n     *            given <code>key<\/code> (see {@link AttributeKey#getType()})<\/li>\n     *            <\/ul>\n     * \n     * @see #getAttribute(AttributeKey)\n     */\n    @Override\n    public final <T> T setAttribute(final AttributeKey<? extends T> key, final T value) {\n        return attributes.setAttribute(key, value);\n    };\n\n    /**\n     * {@inheritDoc}\n     * \n     * @see Collections#unmodifiableSet(Set)\n     */\n    @Override\n    public Set<AttributeKey<?>> getAttributeKeys() {\n        return attributes.getAttributeKeys();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     */\n    @Override\n    public <T> T removeAttribute(final AttributeKey<T> key) {\n        return attributes.removeAttribute(key);\n    }\n\n    // ----------------------------------------------------\n    // Write management\n    // ----------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(final Object message) {\n        doWriteWithFuture(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(final Object message) {\n        final IoFuture<Void> future = new DefaultWriteFuture();\n        doWriteWithFuture(message, future);\n        return future;\n    }\n\n    private void doWriteWithFuture(final Object message, final IoFuture<Void> future) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n\n        if ((state == SessionState.CLOSED) || (state == SessionState.CLOSING)) {\n            LOG.error(\"writing to closed or closing session, the message is discarded\");\n            return;\n        }\n\n        // process the queue\n        processMessageWriting(message, future);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public WriteRequest enqueueWriteRequest(final Object message) {\n        WriteRequest request = null;\n\n        if (isConnectedSecured()) {\n            // SSL/TLS : we have to encrypt the message\n            final SslHelper sslHelper = getAttribute(SSL_HELPER, null);\n\n            if (sslHelper == null) {\n                throw new IllegalStateException();\n            }\n\n            request = sslHelper.processWrite(this, message, writeQueue);\n        } else {\n            // Plain message\n            request = new DefaultWriteRequest(message);\n        }\n\n        synchronized (writeQueue) {\n            writeQueue.add(request);\n\n            // If it wasn't, we register this session as interested to write.\n            // It's done in atomic fashion for avoiding two concurrent registering.\n            if (!registeredForWrite.getAndSet(true)) {\n                flushWriteQueue();\n            }\n        }\n\n        // Always wake-up the selector here!\n        // TODO : wake up the selector.\n\n        return request;\n    }\n\n    public abstract void flushWriteQueue();\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> getWriteQueue() {\n        return writeQueue;\n    }\n\n    // ------------------------------------------------------------------------\n    // Close session management\n    // ------------------------------------------------------------------------\n\n    /** we pre-allocate a close future for lock-less {@link #close(boolean)} */\n    private final IoFuture<Void> closeFuture = new AbstractIoFuture<Void>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean cancelOwner(final boolean mayInterruptIfRunning) {\n            // we don't cancel close\n            return false;\n        }\n    };\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> close(final boolean immediately) {\n        switch (state) {\n        case CREATED:\n            LOG.error(\"Session {} not opened\", this);\n            throw new IllegalStateException(\"cannot close an not opened session\");\n        case CONNECTED:\n            state = SessionState.CLOSING;\n            if (immediately) {\n                channelClose();\n                processSessionClosed();\n            } else {\n                // flush this session the flushing code will close the session\n                flushWriteQueue();\n            }\n            break;\n        case CLOSING:\n            // return the same future\n            LOG.warn(\"Already closing session {}\", this);\n            break;\n        case CLOSED:\n            LOG.warn(\"Already closed session {}\", this);\n            break;\n        default:\n            throw new IllegalStateException(\"not implemented session state : \" + state);\n        }\n\n        return closeFuture;\n    }\n\n    /**\n     * Close the inner socket channel\n     */\n    protected abstract void channelClose();\n\n    // ------------------------------------------------------------------------\n    // Event processing using the filter chain\n    // ------------------------------------------------------------------------\n\n    /** send a caught exception to the {@link IoHandler} (if any) */\n    protected void processException(final Throwable t) {\n        LOG.debug(\"caught session exception \", t);\n        final IoHandler handler = getService().getIoHandler();\n        if (handler != null) {\n            handler.exceptionCaught(this, t);\n        }\n    }\n\n    /**\n     * process session open event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionOpen() {\n        LOG.debug(\"processing session open event\");\n\n        try {\n\n            for (final IoFilter filter : chain) {\n                filter.sessionOpened(this);\n            }\n\n            final IoHandler handler = getService().getIoHandler();\n\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new OpenEvent(this));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionOpened(this);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /**\n     * process session closed event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionClosed() {\n        LOG.debug(\"processing session closed event\");\n        try {\n            for (final IoFilter filter : chain) {\n                filter.sessionClosed(this);\n            }\n\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new CloseEvent(this));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionClosed(this);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /**\n     * process session idle event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionIdle(final IdleStatus status) {\n        LOG.debug(\"processing session idle {} event for session {}\", status, this);\n\n        try {\n            for (final IoFilter filter : chain) {\n                filter.sessionIdle(this, status);\n            }\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new IdleEvent(this, status));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionIdle(this, status);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /** for knowing if the message buffer is the selector loop one */\n    static ThreadLocal<ByteBuffer> tl = new ThreadLocal<ByteBuffer>() {\n        @Override\n        protected ByteBuffer initialValue() {\n            return null;\n        }\n    };\n\n    /**\n     * process session message received event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the received message\n     */\n    public void processMessageReceived(final ByteBuffer message) {\n        LOG.debug(\"processing message '{}' received event for session {}\", message, this);\n\n        tl.set(message);\n        try {\n            // save basic statistics\n            readBytes += message.remaining();\n            lastReadTime = System.currentTimeMillis();\n\n            if (chain.length < 1) {\n                LOG.debug(\"Nothing to do, the chain is empty\");\n                final IoHandler handler = getService().getIoHandler();\n                if (handler != null) {\n                    IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                    if (executor != null) {\n                        // asynchronous event\n                        // copy the bytebuffer\n                        LOG.debug(\"copying bytebuffer before pushing to the executor\");\n                        ByteBuffer original = message;\n                        ByteBuffer clone = ByteBuffer.allocate(original.capacity());\n                        original.rewind();// copy from the beginning\n                        clone.put(original);\n                        original.rewind();\n                        clone.flip();\n                        executor.execute(new ReceiveEvent(this, clone));\n                    } else {\n                        // synchronous call (in the I/O loop)\n                        handler.messageReceived(this, message);\n                    }\n                }\n\n            } else {\n                readChainPosition = 0;\n                // we call the first filter, it's supposed to call the next ones using the filter chain controller\n                chain[readChainPosition].messageReceived(this, message, this);\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    /**\n     * process session message writing event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the wrote message, should be transformed into ByteBuffer at the end of the filter chain\n     */\n    public void processMessageWriting(final Object message, final IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event for session {}\", message, this);\n\n        try {\n            lastWriteRequest = null;\n\n            if (chain.length < 1) {\n                enqueueFinalWriteMessage(message);\n            } else {\n                writeChainPosition = chain.length - 1;\n                // we call the first filter, it's supposed to call the next ones using the filter chain controller\n                final int position = writeChainPosition;\n                final IoFilter nextFilter = chain[position];\n                nextFilter.messageWriting(this, message, this);\n            }\n\n            // put the future in the last write request\n\n            final WriteRequest request = lastWriteRequest;\n            if (request != null) {\n                if (future != null) {\n                    ((DefaultWriteRequest) request).setFuture(future);\n                }\n                ((DefaultWriteRequest) request).setHighLevelMessage(message);\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    public void processMessageSent(final Object highLevelMessage) {\n        LOG.debug(\"processing message '{}' sent event for session {}\", highLevelMessage, this);\n\n        try {\n            final int size = chain.length;\n            for (int i = size - 1; i >= 0; i--) {\n                chain[i].messageSent(this, highLevelMessage);\n            }\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new SentEvent(this, highLevelMessage));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.messageSent(this, highLevelMessage);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    /**\n     * process session message received event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the received message\n     */\n    @Override\n    public void callWriteNextFilter(final Object message) {\n        LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message, writeChainPosition);\n\n        writeChainPosition--;\n\n        if (writeChainPosition < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(message);\n        } else {\n            chain[writeChainPosition].messageWriting(this, message, this);\n        }\n\n        writeChainPosition++;\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(final Object message) {\n        LOG.debug(\"end of write chain we enqueue the message in the session : {}\", message);\n        lastWriteRequest = enqueueWriteRequest(message);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(final Object message) {\n        readChainPosition++;\n\n        if (readChainPosition >= chain.length) {\n            // end of chain processing\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    if (message == tl.get()) {\n                        // copy the bytebuffer\n                        LOG.debug(\"copying bytebuffer before pushing to the executor\");\n                        ByteBuffer original = (ByteBuffer) message;\n                        ByteBuffer clone = ByteBuffer.allocate(original.capacity());\n                        original.rewind();// copy from the beginning\n                        clone.put(original);\n                        original.rewind();\n                        clone.flip();\n                        executor.execute(new ReceiveEvent(this, clone));\n                    } else {\n                        executor.execute(new ReceiveEvent(this, message));\n                    }\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.messageReceived(this, message);\n                }\n            }\n        } else {\n            chain[readChainPosition].messageReceived(this, message, this);\n        }\n\n        readChainPosition--;\n    }\n\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLException;\n\nimport org.apache.mina.api.IdleStatus;\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoHandler;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.ReadFilterChainController;\nimport org.apache.mina.filterchain.WriteFilterChainController;\nimport org.apache.mina.service.executor.CloseEvent;\nimport org.apache.mina.service.executor.IdleEvent;\nimport org.apache.mina.service.executor.IoHandlerExecutor;\nimport org.apache.mina.service.executor.OpenEvent;\nimport org.apache.mina.service.executor.ReceiveEvent;\nimport org.apache.mina.service.executor.SentEvent;\nimport org.apache.mina.service.idlechecker.IdleChecker;\nimport org.apache.mina.transport.nio.SelectorLoop;\nimport org.apache.mina.util.AbstractIoFuture;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession, ReadFilterChainController, WriteFilterChainController {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** unique identifier generator */\n    private static final AtomicInteger NEXT_ID = new AtomicInteger(0);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** attributes map */\n    private final AttributeContainer attributes = new DefaultAttributeContainer();\n\n    /** the {@link IdleChecker} in charge of detecting idle event for this session */\n    protected final IdleChecker idleChecker;\n\n    // ------------------------------------------------------------------------\n    // Basic statistics\n    // ------------------------------------------------------------------------\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    // ------------------------------------------------------------------------\n    // Session state\n    // ------------------------------------------------------------------------\n\n    /** The session's state : one of CREATED, CONNECTED, CLOSING, CLOSED, SECURING, CONNECTED_SECURED */\n    protected volatile SessionState state;\n\n    /** A lock to protect the access to the session's state */\n    private final ReadWriteLock stateLock = new ReentrantReadWriteLock();\n\n    /** A Read lock on the reentrant session's state lock */\n    private final Lock stateReadLock = stateLock.readLock();\n\n    /** A Write lock on the reentrant session's state lock */\n    private final Lock stateWriteLock = stateLock.writeLock();\n\n    /** Tells if the session is secured or not */\n    protected volatile boolean secured;\n\n    /** is this session registered for being polled for write ready events */\n    private final AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    // ------------------------------------------------------------------------\n    // Write queue\n    // ------------------------------------------------------------------------\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorLoop} */\n    private final Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    // ------------------------------------------------------------------------\n    // Filter chain\n    // ------------------------------------------------------------------------\n\n    /** The list of {@link IoFilter} implementing this chain. */\n    private final IoFilter[] chain;\n\n    /** the current position in the write chain for this thread */\n    private int writeChainPosition;\n\n    /** the current position in the read chain for this thread */\n    private int readChainPosition;\n\n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param selectorLoop the selector loop in charge of processing this session read/write events\n     */\n    public AbstractIoSession(final IoService service, final IdleChecker idleChecker) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.chain = service.getFilters();\n        this.idleChecker = idleChecker;\n\n        LOG.debug(\"Created new session with id : {}\", id);\n\n        this.state = SessionState.CREATED;\n    }\n\n    // ------------------------------------------------------------------------\n    // Session State management\n    // ------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CLOSED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosing() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CLOSING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnected() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CONNECTED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCreated() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.CREATED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecuring() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.SECURING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnectedSecured() {\n        try {\n            stateReadLock.lock();\n\n            return state == SessionState.SECURED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void changeState(final SessionState to) throws IllegalStateException {\n        try {\n            stateWriteLock.lock();\n\n            switch (state) {\n            case CREATED:\n                switch (to) {\n                case CONNECTED:\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case CONNECTED:\n                switch (to) {\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case SECURING:\n                switch (to) {\n                case SECURED:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n\n            case SECURED:\n                switch (to) {\n                case CONNECTED:\n                case SECURING:\n                case CLOSING:\n                    state = to;\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                break;\n            case CLOSING:\n                if (to != SessionState.CLOSED) {\n                    throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to);\n                }\n\n                state = to;\n\n                break;\n\n            case CLOSED:\n                throw new IllegalStateException(\"The session is already closed. cannot switch to \" + to);\n            }\n        } finally {\n            stateWriteLock.unlock();\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // SSL/TLS session state management\n    // ------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecured() {\n        return secured;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setSecured(final boolean secured) {\n        this.secured = secured;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initSecure(final SSLContext sslContext) throws SSLException {\n        final SslHelper sslHelper = new SslHelper(this, sslContext);\n        sslHelper.init();\n\n        attributes.setAttribute(SSL_HELPER, sslHelper);\n        setSecured(true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * To be called by the internal plumber when some bytes are written on the socket\n     * \n     * @param bytesCount number of extra bytes written\n     */\n    public void incrementWrittenBytes(final int bytesCount) {\n        writtenBytes += bytesCount;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     * @see #setAttribute(AttributeKey, Object)\n     */\n    @Override\n    public final <T> T getAttribute(final AttributeKey<T> key, final T defaultValue) {\n        return attributes.getAttribute(key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     * @see #setAttribute(AttributeKey, Object)\n     */\n    @Override\n    public final <T> T getAttribute(final AttributeKey<T> key) {\n        return attributes.getAttribute(key);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException <ul>\n     *            <li>\n     *            if <code>key==null<\/code><\/li>\n     *            <li>\n     *            if <code>value<\/code> is not <code>null<\/code> and not an instance of type that is specified in by the\n     *            given <code>key<\/code> (see {@link AttributeKey#getType()})<\/li>\n     *            <\/ul>\n     * \n     * @see #getAttribute(AttributeKey)\n     */\n    @Override\n    public final <T> T setAttribute(final AttributeKey<? extends T> key, final T value) {\n        return attributes.setAttribute(key, value);\n    };\n\n    /**\n     * {@inheritDoc}\n     * \n     * @see Collections#unmodifiableSet(Set)\n     */\n    @Override\n    public Set<AttributeKey<?>> getAttributeKeys() {\n        return attributes.getAttributeKeys();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @exception IllegalArgumentException if <code>key==null<\/code>\n     */\n    @Override\n    public <T> T removeAttribute(final AttributeKey<T> key) {\n        return attributes.removeAttribute(key);\n    }\n\n    // ----------------------------------------------------\n    // Write management\n    // ----------------------------------------------------\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(final Object message) {\n        doWriteWithFuture(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(final Object message) {\n        final IoFuture<Void> future = new DefaultWriteFuture();\n        doWriteWithFuture(message, future);\n        return future;\n    }\n\n    private void doWriteWithFuture(final Object message, final IoFuture<Void> future) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n\n        if ((state == SessionState.CLOSED) || (state == SessionState.CLOSING)) {\n            LOG.error(\"writing to closed or closing session, the message is discarded\");\n            return;\n        }\n\n        WriteRequest writeRequest = new DefaultWriteRequest(message);\n\n        // process the queue\n        processMessageWriting(writeRequest, future);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int writeDirect(Object message) {\n        // Default to 0 : this method should be overwritten if needed\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public WriteRequest enqueueWriteRequest(WriteRequest writeRequest) {\n        if (isConnectedSecured()) {\n            // SSL/TLS : we have to encrypt the message\n            final SslHelper sslHelper = getAttribute(SSL_HELPER, null);\n\n            if (sslHelper == null) {\n                throw new IllegalStateException();\n            }\n\n            writeRequest = sslHelper.processWrite(this, writeRequest, writeQueue);\n        }\n\n        synchronized (writeQueue) {\n            if (writeQueue.isEmpty()) {\n                ByteBuffer message = (ByteBuffer) writeRequest.getMessage();\n\n                // We don't have anything in the writeQueue, let's try to write the\n                // data in the channel immediately if we can\n                int written = writeDirect(writeRequest.getMessage());\n\n                LOG.debug(\"wrote {} bytes to {}\", written, this);\n\n                if (written > 0) {\n                    incrementWrittenBytes(written);\n                }\n\n                // Update the idle status for this session\n                idleChecker.sessionWritten(this, System.currentTimeMillis());\n\n                if ((written < 0) || message.remaining() > 0) {\n                    // We have to push the request on the writeQueue\n                    writeQueue.add(writeRequest);\n\n                    // If it wasn't, we register this session as interested to write.\n                    // It's done in atomic fashion for avoiding two concurrent registering.\n                    if (!registeredForWrite.getAndSet(true)) {\n                        flushWriteQueue();\n                    }\n                } else {\n                    // The message has been fully written : update the stats, and signal the handler\n                    // generate the message sent event\n                    // complete the future if we have one (we should...)\n                    final DefaultWriteFuture future = (DefaultWriteFuture) writeRequest.getFuture();\n\n                    if (future != null) {\n                        future.complete();\n                    }\n\n                    final Object highLevel = ((DefaultWriteRequest) writeRequest).getOriginalMessage();\n\n                    if (highLevel != null) {\n                        processMessageSent(highLevel);\n                    }\n                }\n            }\n        }\n\n        return writeRequest;\n    }\n\n    public abstract void flushWriteQueue();\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    protected boolean isRegisteredForWrite() {\n        return registeredForWrite.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> getWriteQueue() {\n        return writeQueue;\n    }\n\n    // ------------------------------------------------------------------------\n    // Close session management\n    // ------------------------------------------------------------------------\n\n    /** we pre-allocate a close future for lock-less {@link #close(boolean)} */\n    private final IoFuture<Void> closeFuture = new AbstractIoFuture<Void>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected boolean cancelOwner(final boolean mayInterruptIfRunning) {\n            // we don't cancel close\n            return false;\n        }\n    };\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> close(final boolean immediately) {\n        switch (state) {\n        case CREATED:\n            LOG.error(\"Session {} not opened\", this);\n            throw new IllegalStateException(\"cannot close an not opened session\");\n        case CONNECTED:\n            state = SessionState.CLOSING;\n            if (immediately) {\n                channelClose();\n                processSessionClosed();\n            } else {\n                // flush this session the flushing code will close the session\n                flushWriteQueue();\n            }\n            break;\n        case CLOSING:\n            // return the same future\n            LOG.warn(\"Already closing session {}\", this);\n            break;\n        case CLOSED:\n            LOG.warn(\"Already closed session {}\", this);\n            break;\n        default:\n            throw new IllegalStateException(\"not implemented session state : \" + state);\n        }\n\n        return closeFuture;\n    }\n\n    /**\n     * Close the inner socket channel\n     */\n    protected abstract void channelClose();\n\n    // ------------------------------------------------------------------------\n    // Event processing using the filter chain\n    // ------------------------------------------------------------------------\n\n    /** send a caught exception to the {@link IoHandler} (if any) */\n    protected void processException(final Throwable t) {\n        LOG.debug(\"caught session exception \", t);\n        final IoHandler handler = getService().getIoHandler();\n        if (handler != null) {\n            handler.exceptionCaught(this, t);\n        }\n    }\n\n    /**\n     * process session open event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionOpen() {\n        LOG.debug(\"processing session open event\");\n\n        try {\n\n            for (final IoFilter filter : chain) {\n                filter.sessionOpened(this);\n            }\n\n            final IoHandler handler = getService().getIoHandler();\n\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new OpenEvent(this));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionOpened(this);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /**\n     * process session closed event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionClosed() {\n        LOG.debug(\"processing session closed event\");\n        try {\n            for (final IoFilter filter : chain) {\n                filter.sessionClosed(this);\n            }\n\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new CloseEvent(this));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionClosed(this);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /**\n     * process session idle event using the filter chain. To be called by the session {@link SelectorLoop} .\n     */\n    public void processSessionIdle(final IdleStatus status) {\n        LOG.debug(\"processing session idle {} event for session {}\", status, this);\n\n        try {\n            for (final IoFilter filter : chain) {\n                filter.sessionIdle(this, status);\n            }\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new IdleEvent(this, status));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.sessionIdle(this, status);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n    }\n\n    /** for knowing if the message buffer is the selector loop one */\n    static ThreadLocal<ByteBuffer> tl = new ThreadLocal<ByteBuffer>() {\n        @Override\n        protected ByteBuffer initialValue() {\n            return null;\n        }\n    };\n\n    /**\n     * process session message received event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the received message\n     */\n    public void processMessageReceived(final ByteBuffer message) {\n        LOG.debug(\"processing message '{}' received event for session {}\", message, this);\n\n        tl.set(message);\n        try {\n            // save basic statistics\n            readBytes += message.remaining();\n            lastReadTime = System.currentTimeMillis();\n\n            if (chain.length < 1) {\n                LOG.debug(\"Nothing to do, the chain is empty\");\n                final IoHandler handler = getService().getIoHandler();\n                if (handler != null) {\n                    IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                    if (executor != null) {\n                        // asynchronous event\n                        // copy the bytebuffer\n                        LOG.debug(\"copying bytebuffer before pushing to the executor\");\n                        ByteBuffer original = message;\n                        ByteBuffer clone = ByteBuffer.allocate(original.capacity());\n                        original.rewind();// copy from the beginning\n                        clone.put(original);\n                        original.rewind();\n                        clone.flip();\n                        executor.execute(new ReceiveEvent(this, clone));\n                    } else {\n                        // synchronous call (in the I/O loop)\n                        handler.messageReceived(this, message);\n                    }\n                }\n\n            } else {\n                readChainPosition = 0;\n                // we call the first filter, it's supposed to call the next ones using the filter chain controller\n                chain[readChainPosition].messageReceived(this, message, this);\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    /**\n     * process session message writing event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the wrote message, should be transformed into ByteBuffer at the end of the filter chain\n     */\n    public void processMessageWriting(WriteRequest writeRequest, final IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event for session {}\", writeRequest, this);\n\n        try {\n            //lastWriteRequest = null;\n\n            if (chain.length < 1) {\n                enqueueWriteRequest(writeRequest);\n            } else {\n                writeChainPosition = chain.length - 1;\n                // we call the first filter, it's supposed to call the next ones using the filter chain controller\n                final int position = writeChainPosition;\n                final IoFilter nextFilter = chain[position];\n                nextFilter.messageWriting(this, writeRequest, this);\n            }\n\n            // put the future in the last write request\n            if (future != null) {\n                writeRequest.setFuture(future);\n            }\n            /*\n            final WriteRequest request = lastWriteRequest;\n            if (request != null) {\n                if (future != null) {\n                    ((DefaultWriteRequest) request).setFuture(future);\n                }\n                ((DefaultWriteRequest) request).setHighLevelMessage(message);\n            }\n                */\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    public void processMessageSent(final Object highLevelMessage) {\n        LOG.debug(\"processing message '{}' sent event for session {}\", highLevelMessage, this);\n\n        try {\n            final int size = chain.length;\n            for (int i = size - 1; i >= 0; i--) {\n                chain[i].messageSent(this, highLevelMessage);\n            }\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    executor.execute(new SentEvent(this, highLevelMessage));\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.messageSent(this, highLevelMessage);\n                }\n            }\n        } catch (final RuntimeException e) {\n            processException(e);\n        }\n\n    }\n\n    /**\n     * process session message received event using the filter chain. To be called by the session {@link SelectorLoop} .\n     * \n     * @param message the received message\n     */\n    @Override\n    public void callWriteNextFilter(WriteRequest message) {\n        LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message, writeChainPosition);\n\n        writeChainPosition--;\n\n        if (writeChainPosition < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueWriteRequest(message);\n        } else {\n            chain[writeChainPosition].messageWriting(this, message, this);\n        }\n\n        writeChainPosition++;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(final Object message) {\n        readChainPosition++;\n\n        if (readChainPosition >= chain.length) {\n            // end of chain processing\n            final IoHandler handler = getService().getIoHandler();\n            if (handler != null) {\n                IoHandlerExecutor executor = getService().getIoHandlerExecutor();\n                if (executor != null) {\n                    // asynchronous event\n                    if (message == tl.get()) {\n                        // copy the bytebuffer\n                        LOG.debug(\"copying bytebuffer before pushing to the executor\");\n                        ByteBuffer original = (ByteBuffer) message;\n                        ByteBuffer clone = ByteBuffer.allocate(original.capacity());\n                        original.rewind();// copy from the beginning\n                        clone.put(original);\n                        original.rewind();\n                        clone.flip();\n                        executor.execute(new ReceiveEvent(this, clone));\n                    } else {\n                        executor.execute(new ReceiveEvent(this, message));\n                    }\n                } else {\n                    // synchronous call (in the I/O loop)\n                    handler.messageReceived(this, message);\n                }\n            }\n        } else {\n            chain[readChainPosition].messageReceived(this, message, this);\n        }\n\n        readChainPosition--;\n    }\n\n}\n","lineNo":519}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport static org.apache.mina.session.AttributeKey.createKey;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLSession;\n\nimport org.apache.mina.api.IoClient;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.IoSession.SessionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An helper class used to manage everything related to SSL/TLS establishment\n * and management.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class SslHelper {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHelper.class);\n\n    /** The SSL engine instance */\n    private SSLEngine sslEngine;\n\n    /** The SSLContext instance */\n    private final SSLContext sslContext;\n\n    /** The current session */\n    private final IoSession session;\n\n    /**\n     * A session attribute key that should be set to an {@link InetSocketAddress}.\n     * Setting this attribute causes\n     * {@link SSLContext#createSSLEngine(String, int)} to be called passing the\n     * hostname and port of the {@link InetSocketAddress} to get an\n     * {@link SSLEngine} instance. If not set {@link SSLContext#createSSLEngine()}\n     * will be called.<br/>\n     * Using this feature {@link SSLSession} objects may be cached and reused\n     * when in client mode.\n     *\n     * @see SSLContext#createSSLEngine(String, int)\n     */\n    public static final AttributeKey<InetSocketAddress> PEER_ADDRESS = createKey(InetSocketAddress.class,\n            \"internal_peerAddress\");\n\n    public static final AttributeKey<Boolean> WANT_CLIENT_AUTH = createKey(Boolean.class, \"internal_wantClientAuth\");\n\n    public static final AttributeKey<Boolean> NEED_CLIENT_AUTH = createKey(Boolean.class, \"internal_needClientAuth\");\n\n    /** Incoming buffer accumulating bytes read from the channel */\n    private ByteBuffer accBuffer;\n\n    /** An empty buffer used during the handshake phase */\n    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\n\n    /** An empty buffer used during the handshake phase */\n    private static final ByteBuffer HANDSHAKE_BUFFER = ByteBuffer.allocate(1024);\n\n    /**\n     * Create a new SSL Handler.\n     *\n     * @param session The associated session\n     */\n    public SslHelper(IoSession session, SSLContext sslContext) {\n        this.session = session;\n        this.sslContext = sslContext;\n    }\n\n    /**\n     * @return The associated session\n     */\n    /* no qualifier */IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * @return The associated SSLEngine\n     */\n    /* no qualifier */SSLEngine getEngine() {\n        return sslEngine;\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException If the underlying SSLEngine handshake initialization failed\n     */\n    /* no qualifier */void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        LOGGER.debug(\"{} Initializing the SSL Helper\", session);\n\n        InetSocketAddress peer = session.getAttribute(PEER_ADDRESS, null);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(session.getService() instanceof IoClient);\n\n        // Initialize the different SslEngine modes\n        if (!sslEngine.getUseClientMode()) {\n            // Those parameters are only valid when in server mode\n            boolean needClientAuth = session.getAttribute(NEED_CLIENT_AUTH, false);\n            boolean wantClientAuth = session.getAttribute(WANT_CLIENT_AUTH, false);\n\n            // The WantClientAuth supersede the NeedClientAuth, if set.\n            if (needClientAuth) {\n                sslEngine.setNeedClientAuth(true);\n            }\n\n            if (wantClientAuth) {\n                sslEngine.setWantClientAuth(true);\n            }\n        }\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"{} SSL Handler Initialization done.\", session);\n        }\n    }\n\n    /**\n     * A helper method used to accumulate some ByteBuffer in the inner buffer.\n     * \n     * @param buffer The buffer to add.\n     */\n    private void addInBuffer(ByteBuffer buffer) {\n        if (accBuffer.capacity() - accBuffer.limit() < buffer.remaining()) {\n            // Increase the internal buffer\n            ByteBuffer newBuffer = ByteBuffer.allocate(accBuffer.capacity() + buffer.remaining());\n\n            // Copy the two buffers\n            newBuffer.put(accBuffer);\n            newBuffer.put(buffer);\n\n            // And reset the position to the original position\n            newBuffer.flip();\n\n            accBuffer = newBuffer;\n        } else {\n            accBuffer.put(buffer);\n            accBuffer.flip();\n        }\n    }\n\n    /**\n     * Process the NEED_TASK action.\n     * \n     * @param engine The SSLEngine instance\n     * @return The resulting HandshakeStatus\n     * @throws SSLException If we've got an error while processing the tasks\n     */\n    private HandshakeStatus processTasks(SSLEngine engine) throws SSLException {\n        Runnable runnable;\n\n        while ((runnable = engine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n\n        HandshakeStatus hsStatus = engine.getHandshakeStatus();\n\n        return hsStatus;\n    }\n\n    /**\n     * Process the NEED_UNWRAP action. We have to read the incoming buffer, and to feed\n     * the application buffer.\n     */\n    private SSLEngineResult unwrap(ByteBuffer inBuffer, ByteBuffer appBuffer) throws SSLException {\n        ByteBuffer tempBuffer = null;\n\n        // First work with either the new incoming buffer, or the accumulating buffer\n        if ((accBuffer != null) && (accBuffer.remaining() > 0)) {\n            // Add the new incoming data into the local buffer\n            addInBuffer(inBuffer);\n            tempBuffer = this.accBuffer;\n        } else {\n            tempBuffer = inBuffer;\n        }\n\n        // Loop until we have processed the entire incoming buffer,\n        // or until we have to stop\n        while (true) {\n            // Do the unwrapping\n            SSLEngineResult result = sslEngine.unwrap(tempBuffer, appBuffer);\n\n            switch (result.getStatus()) {\n            case OK:\n                // Ok, we have unwrapped a message, return.\n                accBuffer = null;\n\n                return result;\n\n            case BUFFER_UNDERFLOW:\n                // We need to read some more data from the channel.\n                if (this.accBuffer == null) {\n                    this.accBuffer = ByteBuffer.allocate(tempBuffer.capacity() + 4096);\n                    this.accBuffer.put(inBuffer);\n                }\n\n                inBuffer.clear();\n\n                return result;\n\n            case CLOSED:\n                accBuffer = null;\n\n                // We have received a Close message, we can exit now\n                if (session.isConnectedSecured()) {\n                    return result;\n                } else {\n                    throw new IllegalStateException();\n                }\n\n            case BUFFER_OVERFLOW:\n                // We have to increase the appBuffer size. In any case\n                // we aren't processing an handshake here. Read again.\n                appBuffer = ByteBuffer.allocate(appBuffer.capacity() + 4096);\n            }\n        }\n    }\n\n    /**\n     * Process a read ByteBuffer over a secured connection, or during the SSL/TLS\n     * Handshake.\n     * \n     * @param session The session we are processing a read for\n     * @param readBuffer The data we get from the channel\n     * @throws SSLException If the unwrapping or handshaking failed\n     */\n    public void processRead(AbstractIoSession session, ByteBuffer readBuffer) throws SSLException {\n        if (session.isConnectedSecured()) {\n            // Unwrap the incoming data\n            processUnwrap(session, readBuffer);\n        } else {\n            // Process the SSL handshake now\n            processHandShake(session, readBuffer);\n        }\n    }\n\n    /**\n     * Unwrap a SSL/TLS message. The message might not be encrypted (if we are processing\n     * a Handshake message or an Alert message).\n     */\n    private void processUnwrap(AbstractIoSession session, ByteBuffer inBuffer) throws SSLException {\n        // Blind guess : once uncompressed, the resulting buffer will be 3 times bigger\n        ByteBuffer appBuffer = ByteBuffer.allocate(inBuffer.limit() * 3);\n        SSLEngineResult result = unwrap(inBuffer, appBuffer);\n\n        switch (result.getStatus()) {\n        case OK:\n            // Ok, go through the chain now\n            appBuffer.flip();\n            session.processMessageReceived(appBuffer);\n            break;\n\n        case CLOSED:\n            // This was a Alert Closure message. Process it\n            processClosed(result);\n\n            break;\n        }\n    }\n\n    /**\n     * Process the SSL/TLS Alert Closure message\n     */\n    private void processClosed(SSLEngineResult result) throws SSLException {\n        // We have received a Alert_CLosure message, we will have to do a wrap\n        HandshakeStatus hsStatus = result.getHandshakeStatus();\n\n        if (hsStatus == HandshakeStatus.NEED_WRAP) {\n            // We need to send back the Alert Closure message\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"{} processing the NEED_WRAP state\", session);\n            }\n\n            int capacity = sslEngine.getSession().getPacketBufferSize();\n            ByteBuffer outBuffer = ByteBuffer.allocate(capacity);\n            session.changeState(SessionState.CONNECTED);\n\n            // Loop until the SSLEngine has nothing more to produce\n            while (!sslEngine.isOutboundDone()) {\n                sslEngine.wrap(EMPTY_BUFFER, outBuffer);\n                outBuffer.flip();\n\n                // Get out of the Connected state\n                session.enqueueWriteRequest(outBuffer);\n            }\n        }\n    }\n\n    /**\n     * Process the SLL/TLS Handshake. We may enter in this method more than once,\n     * as the handshake is a dialogue between the client and the server.\n     */\n    private void processHandShake(IoSession session, ByteBuffer inBuffer) throws SSLException {\n        // Start the Handshake if we aren't already processing a HandShake\n        // and switch to the SECURING state\n        HandshakeStatus hsStatus = sslEngine.getHandshakeStatus();\n\n        // Initilize the session status when we enter into the Handshake process.\n        // Not that we don't call the SSLEngine.beginHandshake() method  :\n        // It's implicitely done internally by the unwrap() method.\n        if (hsStatus == HandshakeStatus.NOT_HANDSHAKING) {\n            session.changeState(SessionState.SECURING);\n        }\n\n        SSLEngineResult result = null;\n\n        // If the SSLEngine has not be started, then the status will be NOT_HANDSHAKING\n        // We loop until we reach the FINISHED state\n        while (hsStatus != HandshakeStatus.FINISHED) {\n            if (hsStatus == HandshakeStatus.NEED_TASK) {\n                hsStatus = processTasks(sslEngine);\n            } else if (hsStatus == HandshakeStatus.NEED_WRAP) {\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(\"{} processing the NEED_WRAP state\", session);\n                }\n\n                // Create an insanely wide buffer, as the SSLEngine requires it\n                int capacity = sslEngine.getSession().getPacketBufferSize();\n                ByteBuffer outBuffer = ByteBuffer.allocate(capacity);\n\n                boolean completed = false;\n\n                // Loop until we are able to wrap the message (we may have\n                // to increase the buffer size more than once.\n                while (!completed) {\n                    result = sslEngine.wrap(EMPTY_BUFFER, outBuffer);\n\n                    switch (result.getStatus()) {\n                    case OK:\n                    case CLOSED:\n                        completed = true;\n                        break;\n\n                    case BUFFER_OVERFLOW:\n                        // Increase the target buffer size\n                        outBuffer = ByteBuffer.allocate(outBuffer.capacity() + 4096);\n                        break;\n                    }\n                }\n\n                // Done. We can now push this buffer into the write queue.\n                outBuffer.flip();\n                session.enqueueWriteRequest(outBuffer);\n                hsStatus = result.getHandshakeStatus();\n\n                // Nothing more to wrap : get out.\n                // Note to self : we can probably use only one ByteBuffer for the\n                // multiple wrapped messages. (see https://issues.apache.org/jira/browse/DIRMINA-878)\n                if (hsStatus != HandshakeStatus.NEED_WRAP) {\n                    break;\n                }\n            } else if ((hsStatus == HandshakeStatus.NEED_UNWRAP) || (hsStatus == HandshakeStatus.NOT_HANDSHAKING)) {\n                // We cover the ongoing handshake (NEED_UNWRAP) and\n                // the initial call to the handshake (NOT_HANDSHAKING)\n                result = unwrap(inBuffer, HANDSHAKE_BUFFER);\n\n                if (result.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    // Read more data\n                    break;\n                } else {\n                    hsStatus = result.getHandshakeStatus();\n                }\n            }\n        }\n\n        if (hsStatus == HandshakeStatus.FINISHED) {\n            // The handshake has been completed. We can change the session's state.\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"{} processing the FINISHED state\", session);\n            }\n\n            session.changeState(SessionState.SECURED);\n        }\n    }\n\n    /**\n     * Process the application data encryption for a session.\n     * @param session The session sending encrypted data to the peer.\n     * @param message The message to encrypt\n     * @param writeQueue The queue in which the encrypted buffer will be written\n     * @return The written WriteRequest\n     */\n    /** No qualifier */\n    WriteRequest processWrite(IoSession session, Object message, Queue<WriteRequest> writeQueue) {\n        ByteBuffer buf = (ByteBuffer) message;\n        ByteBuffer appBuffer = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n\n        try {\n            while (true) {\n                // Encypt the message\n                SSLEngineResult result = sslEngine.wrap(buf, appBuffer);\n\n                switch (result.getStatus()) {\n                case BUFFER_OVERFLOW:\n                    // Increase the buffer size as needed\n                    appBuffer = ByteBuffer.allocate(appBuffer.capacity() + 4096);\n                    break;\n\n                case BUFFER_UNDERFLOW:\n                case CLOSED:\n                    break;\n\n                case OK:\n                    // We are done. Flip the buffer and push it to the write queue.\n                    appBuffer.flip();\n                    WriteRequest request = new DefaultWriteRequest(appBuffer);\n\n                    return request;\n                }\n            }\n        } catch (SSLException se) {\n            throw new IllegalStateException(se.getMessage());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport static org.apache.mina.session.AttributeKey.createKey;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLSession;\n\nimport org.apache.mina.api.IoClient;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.IoSession.SessionState;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An helper class used to manage everything related to SSL/TLS establishment\n * and management.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class SslHelper {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHelper.class);\n\n    /** The SSL engine instance */\n    private SSLEngine sslEngine;\n\n    /** The SSLContext instance */\n    private final SSLContext sslContext;\n\n    /** The current session */\n    private final IoSession session;\n\n    /**\n     * A session attribute key that should be set to an {@link InetSocketAddress}.\n     * Setting this attribute causes\n     * {@link SSLContext#createSSLEngine(String, int)} to be called passing the\n     * hostname and port of the {@link InetSocketAddress} to get an\n     * {@link SSLEngine} instance. If not set {@link SSLContext#createSSLEngine()}\n     * will be called.<br/>\n     * Using this feature {@link SSLSession} objects may be cached and reused\n     * when in client mode.\n     *\n     * @see SSLContext#createSSLEngine(String, int)\n     */\n    public static final AttributeKey<InetSocketAddress> PEER_ADDRESS = createKey(InetSocketAddress.class,\n            \"internal_peerAddress\");\n\n    public static final AttributeKey<Boolean> WANT_CLIENT_AUTH = createKey(Boolean.class, \"internal_wantClientAuth\");\n\n    public static final AttributeKey<Boolean> NEED_CLIENT_AUTH = createKey(Boolean.class, \"internal_needClientAuth\");\n\n    /** Incoming buffer accumulating bytes read from the channel */\n    private ByteBuffer accBuffer;\n\n    /** An empty buffer used during the handshake phase */\n    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\n\n    /** An empty buffer used during the handshake phase */\n    private static final ByteBuffer HANDSHAKE_BUFFER = ByteBuffer.allocate(1024);\n\n    /**\n     * Create a new SSL Handler.\n     *\n     * @param session The associated session\n     */\n    public SslHelper(IoSession session, SSLContext sslContext) {\n        this.session = session;\n        this.sslContext = sslContext;\n    }\n\n    /**\n     * @return The associated session\n     */\n    /* no qualifier */IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * @return The associated SSLEngine\n     */\n    /* no qualifier */SSLEngine getEngine() {\n        return sslEngine;\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException If the underlying SSLEngine handshake initialization failed\n     */\n    /* no qualifier */void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        LOGGER.debug(\"{} Initializing the SSL Helper\", session);\n\n        InetSocketAddress peer = session.getAttribute(PEER_ADDRESS, null);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(session.getService() instanceof IoClient);\n\n        // Initialize the different SslEngine modes\n        if (!sslEngine.getUseClientMode()) {\n            // Those parameters are only valid when in server mode\n            boolean needClientAuth = session.getAttribute(NEED_CLIENT_AUTH, false);\n            boolean wantClientAuth = session.getAttribute(WANT_CLIENT_AUTH, false);\n\n            // The WantClientAuth supersede the NeedClientAuth, if set.\n            if (needClientAuth) {\n                sslEngine.setNeedClientAuth(true);\n            }\n\n            if (wantClientAuth) {\n                sslEngine.setWantClientAuth(true);\n            }\n        }\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"{} SSL Handler Initialization done.\", session);\n        }\n    }\n\n    /**\n     * A helper method used to accumulate some ByteBuffer in the inner buffer.\n     * \n     * @param buffer The buffer to add.\n     */\n    private void addInBuffer(ByteBuffer buffer) {\n        if (accBuffer.capacity() - accBuffer.limit() < buffer.remaining()) {\n            // Increase the internal buffer\n            ByteBuffer newBuffer = ByteBuffer.allocate(accBuffer.capacity() + buffer.remaining());\n\n            // Copy the two buffers\n            newBuffer.put(accBuffer);\n            newBuffer.put(buffer);\n\n            // And reset the position to the original position\n            newBuffer.flip();\n\n            accBuffer = newBuffer;\n        } else {\n            accBuffer.put(buffer);\n            accBuffer.flip();\n        }\n    }\n\n    /**\n     * Process the NEED_TASK action.\n     * \n     * @param engine The SSLEngine instance\n     * @return The resulting HandshakeStatus\n     * @throws SSLException If we've got an error while processing the tasks\n     */\n    private HandshakeStatus processTasks(SSLEngine engine) throws SSLException {\n        Runnable runnable;\n\n        while ((runnable = engine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n\n        HandshakeStatus hsStatus = engine.getHandshakeStatus();\n\n        return hsStatus;\n    }\n\n    /**\n     * Process the NEED_UNWRAP action. We have to read the incoming buffer, and to feed\n     * the application buffer.\n     */\n    private SSLEngineResult unwrap(ByteBuffer inBuffer, ByteBuffer appBuffer) throws SSLException {\n        ByteBuffer tempBuffer = null;\n\n        // First work with either the new incoming buffer, or the accumulating buffer\n        if ((accBuffer != null) && (accBuffer.remaining() > 0)) {\n            // Add the new incoming data into the local buffer\n            addInBuffer(inBuffer);\n            tempBuffer = this.accBuffer;\n        } else {\n            tempBuffer = inBuffer;\n        }\n\n        // Loop until we have processed the entire incoming buffer,\n        // or until we have to stop\n        while (true) {\n            // Do the unwrapping\n            SSLEngineResult result = sslEngine.unwrap(tempBuffer, appBuffer);\n\n            switch (result.getStatus()) {\n            case OK:\n                // Ok, we have unwrapped a message, return.\n                accBuffer = null;\n\n                return result;\n\n            case BUFFER_UNDERFLOW:\n                // We need to read some more data from the channel.\n                if (this.accBuffer == null) {\n                    this.accBuffer = ByteBuffer.allocate(tempBuffer.capacity() + 4096);\n                    this.accBuffer.put(inBuffer);\n                }\n\n                inBuffer.clear();\n\n                return result;\n\n            case CLOSED:\n                accBuffer = null;\n\n                // We have received a Close message, we can exit now\n                if (session.isConnectedSecured()) {\n                    return result;\n                } else {\n                    throw new IllegalStateException();\n                }\n\n            case BUFFER_OVERFLOW:\n                // We have to increase the appBuffer size. In any case\n                // we aren't processing an handshake here. Read again.\n                appBuffer = ByteBuffer.allocate(appBuffer.capacity() + 4096);\n            }\n        }\n    }\n\n    /**\n     * Process a read ByteBuffer over a secured connection, or during the SSL/TLS\n     * Handshake.\n     * \n     * @param session The session we are processing a read for\n     * @param readBuffer The data we get from the channel\n     * @throws SSLException If the unwrapping or handshaking failed\n     */\n    public void processRead(AbstractIoSession session, ByteBuffer readBuffer) throws SSLException {\n        if (session.isConnectedSecured()) {\n            // Unwrap the incoming data\n            processUnwrap(session, readBuffer);\n        } else {\n            // Process the SSL handshake now\n            processHandShake(session, readBuffer);\n        }\n    }\n\n    /**\n     * Unwrap a SSL/TLS message. The message might not be encrypted (if we are processing\n     * a Handshake message or an Alert message).\n     */\n    private void processUnwrap(AbstractIoSession session, ByteBuffer inBuffer) throws SSLException {\n        // Blind guess : once uncompressed, the resulting buffer will be 3 times bigger\n        ByteBuffer appBuffer = ByteBuffer.allocate(inBuffer.limit() * 3);\n        SSLEngineResult result = unwrap(inBuffer, appBuffer);\n\n        switch (result.getStatus()) {\n        case OK:\n            // Ok, go through the chain now\n            appBuffer.flip();\n            session.processMessageReceived(appBuffer);\n            break;\n\n        case CLOSED:\n            // This was a Alert Closure message. Process it\n            processClosed(result);\n\n            break;\n        }\n    }\n\n    /**\n     * Process the SSL/TLS Alert Closure message\n     */\n    private void processClosed(SSLEngineResult result) throws SSLException {\n        // We have received a Alert_CLosure message, we will have to do a wrap\n        HandshakeStatus hsStatus = result.getHandshakeStatus();\n\n        if (hsStatus == HandshakeStatus.NEED_WRAP) {\n            // We need to send back the Alert Closure message\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"{} processing the NEED_WRAP state\", session);\n            }\n\n            int capacity = sslEngine.getSession().getPacketBufferSize();\n            ByteBuffer outBuffer = ByteBuffer.allocate(capacity);\n            session.changeState(SessionState.CONNECTED);\n\n            // Loop until the SSLEngine has nothing more to produce\n            while (!sslEngine.isOutboundDone()) {\n                sslEngine.wrap(EMPTY_BUFFER, outBuffer);\n                outBuffer.flip();\n\n                // Get out of the Connected state\n                WriteRequest writeRequest = new DefaultWriteRequest(outBuffer);\n                session.enqueueWriteRequest(writeRequest);\n            }\n        }\n    }\n\n    /**\n     * Process the SLL/TLS Handshake. We may enter in this method more than once,\n     * as the handshake is a dialogue between the client and the server.\n     */\n    private void processHandShake(IoSession session, ByteBuffer inBuffer) throws SSLException {\n        // Start the Handshake if we aren't already processing a HandShake\n        // and switch to the SECURING state\n        HandshakeStatus hsStatus = sslEngine.getHandshakeStatus();\n\n        // Initilize the session status when we enter into the Handshake process.\n        // Not that we don't call the SSLEngine.beginHandshake() method  :\n        // It's implicitely done internally by the unwrap() method.\n        if (hsStatus == HandshakeStatus.NOT_HANDSHAKING) {\n            session.changeState(SessionState.SECURING);\n        }\n\n        SSLEngineResult result = null;\n\n        // If the SSLEngine has not be started, then the status will be NOT_HANDSHAKING\n        // We loop until we reach the FINISHED state\n        while (hsStatus != HandshakeStatus.FINISHED) {\n            if (hsStatus == HandshakeStatus.NEED_TASK) {\n                hsStatus = processTasks(sslEngine);\n            } else if (hsStatus == HandshakeStatus.NEED_WRAP) {\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(\"{} processing the NEED_WRAP state\", session);\n                }\n\n                // Create an insanely wide buffer, as the SSLEngine requires it\n                int capacity = sslEngine.getSession().getPacketBufferSize();\n                ByteBuffer outBuffer = ByteBuffer.allocate(capacity);\n\n                boolean completed = false;\n\n                // Loop until we are able to wrap the message (we may have\n                // to increase the buffer size more than once.\n                while (!completed) {\n                    result = sslEngine.wrap(EMPTY_BUFFER, outBuffer);\n\n                    switch (result.getStatus()) {\n                    case OK:\n                    case CLOSED:\n                        completed = true;\n                        break;\n\n                    case BUFFER_OVERFLOW:\n                        // Increase the target buffer size\n                        outBuffer = ByteBuffer.allocate(outBuffer.capacity() + 4096);\n                        break;\n                    }\n                }\n\n                // Done. We can now push this buffer into the write queue.\n                outBuffer.flip();\n                WriteRequest writeRequest = new DefaultWriteRequest(inBuffer);\n                writeRequest.setMessage(outBuffer);\n                session.enqueueWriteRequest(writeRequest);\n                hsStatus = result.getHandshakeStatus();\n\n                // Nothing more to wrap : get out.\n                // Note to self : we can probably use only one ByteBuffer for the\n                // multiple wrapped messages. (see https://issues.apache.org/jira/browse/DIRMINA-878)\n                if (hsStatus != HandshakeStatus.NEED_WRAP) {\n                    break;\n                }\n            } else if ((hsStatus == HandshakeStatus.NEED_UNWRAP) || (hsStatus == HandshakeStatus.NOT_HANDSHAKING)) {\n                // We cover the ongoing handshake (NEED_UNWRAP) and\n                // the initial call to the handshake (NOT_HANDSHAKING)\n                result = unwrap(inBuffer, HANDSHAKE_BUFFER);\n\n                if (result.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    // Read more data\n                    break;\n                } else {\n                    hsStatus = result.getHandshakeStatus();\n                }\n            }\n        }\n\n        if (hsStatus == HandshakeStatus.FINISHED) {\n            // The handshake has been completed. We can change the session's state.\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"{} processing the FINISHED state\", session);\n            }\n\n            session.changeState(SessionState.SECURED);\n        }\n    }\n\n    /**\n     * Process the application data encryption for a session.\n     * @param session The session sending encrypted data to the peer.\n     * @param message The message to encrypt\n     * @param writeQueue The queue in which the encrypted buffer will be written\n     * @return The written WriteRequest\n     */\n    /** No qualifier */\n    WriteRequest processWrite(IoSession session, Object message, Queue<WriteRequest> writeQueue) {\n        ByteBuffer buf = (ByteBuffer) message;\n        ByteBuffer appBuffer = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());\n\n        try {\n            while (true) {\n                // Encypt the message\n                SSLEngineResult result = sslEngine.wrap(buf, appBuffer);\n\n                switch (result.getStatus()) {\n                case BUFFER_OVERFLOW:\n                    // Increase the buffer size as needed\n                    appBuffer = ByteBuffer.allocate(appBuffer.capacity() + 4096);\n                    break;\n\n                case BUFFER_UNDERFLOW:\n                case CLOSED:\n                    break;\n\n                case OK:\n                    // We are done. Flip the buffer and push it to the write queue.\n                    appBuffer.flip();\n                    WriteRequest request = new DefaultWriteRequest(appBuffer);\n\n                    return request;\n                }\n            }\n        } catch (SSLException se) {\n            throw new IllegalStateException(se.getMessage());\n        }\n    }\n}\n","lineNo":327}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        listener.ready(key.isAcceptable(), key.isConnectable(), key.isReadable(),\n                                key.isReadable() ? readBuffer : null, key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        boolean isAcceptable = key.isAcceptable();\n                        boolean isConnectable = key.isConnectable();\n                        boolean isReadable = key.isReadable();\n                        boolean isWritable = key.isWritable();\n                        listener.ready(isAcceptable, isConnectable, isReadable, isReadable ? readBuffer : null,\n                                isWritable);\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"Registration : [\");\n\n            boolean hasOp = false;\n\n            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                sb.append(\"OP_READ\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_WRITE\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_ACCEPT\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_CONNECT\");\n                hasOp = true;\n            }\n\n            if (channel != null) {\n                sb.append(\", \").append(channel);\n            }\n\n            return sb.toString();\n        }\n    }\n}\n","lineNo":205}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        listener.ready(key.isAcceptable(), key.isConnectable(), key.isReadable(),\n                                key.isReadable() ? readBuffer : null, key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        boolean isAcceptable = key.isAcceptable();\n                        boolean isConnectable = key.isConnectable();\n                        boolean isReadable = key.isReadable();\n                        boolean isWritable = key.isWritable();\n                        listener.ready(isAcceptable, isConnectable, isReadable, isReadable ? readBuffer : null,\n                                isWritable);\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"Registration : [\");\n\n            boolean hasOp = false;\n\n            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                sb.append(\"OP_READ\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_WRITE\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_ACCEPT\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_CONNECT\");\n                hasOp = true;\n            }\n\n            if (channel != null) {\n                sb.append(\", \").append(channel);\n            }\n\n            return sb.toString();\n        }\n    }\n}\n","lineNo":206}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        listener.ready(key.isAcceptable(), key.isConnectable(), key.isReadable(),\n                                key.isReadable() ? readBuffer : null, key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        boolean isAcceptable = key.isAcceptable();\n                        boolean isConnectable = key.isConnectable();\n                        boolean isReadable = key.isReadable();\n                        boolean isWritable = key.isWritable();\n                        listener.ready(isAcceptable, isConnectable, isReadable, isReadable ? readBuffer : null,\n                                isWritable);\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"Registration : [\");\n\n            boolean hasOp = false;\n\n            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                sb.append(\"OP_READ\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_WRITE\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_ACCEPT\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_CONNECT\");\n                hasOp = true;\n            }\n\n            if (channel != null) {\n                sb.append(\", \").append(channel);\n            }\n\n            return sb.toString();\n        }\n    }\n}\n","lineNo":207}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        listener.ready(key.isAcceptable(), key.isConnectable(), key.isReadable(),\n                                key.isReadable() ? readBuffer : null, key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new IllegalStateException(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\",\n                    ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean connect, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel, RegistrationCallback callback) {\n        logger.debug(\"registering : {} for accept : {}, connect: {}, read : {}, write : {}, channel : {}\",\n                new Object[] { listener, accept, connect, read, write, channel });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (connect) {\n            ops |= SelectionKey.OP_CONNECT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener, callback));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}, channel : {}\", new Object[] {\n                listener, accept, read, write, channel });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n\n        // we need to wakeup for the registration to be modified (TODO : not needed if we are in the worker thread)\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        logger.debug(\"key : {}\", key);\n                        boolean isAcceptable = key.isAcceptable();\n                        boolean isConnectable = key.isConnectable();\n                        boolean isReadable = key.isReadable();\n                        boolean isWritable = key.isWritable();\n                        listener.ready(isAcceptable, isConnectable, isReadable, isReadable ? readBuffer : null,\n                                isWritable);\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        logger.debug(\"remove\");\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            if (reg.getCallback() != null) {\n                                reg.getCallback().done(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class Registration {\n\n        public Registration(int ops, SelectableChannel channel, SelectorListener listener, RegistrationCallback callback) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.callback = callback;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final RegistrationCallback callback;\n\n        public RegistrationCallback getCallback() {\n            return callback;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n\n            sb.append(\"Registration : [\");\n\n            boolean hasOp = false;\n\n            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\n                sb.append(\"OP_READ\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_WRITE\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_ACCEPT\");\n                hasOp = true;\n            }\n\n            if ((ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT) {\n                if (hasOp) {\n                    sb.append(\"|\");\n                }\n\n                sb.append(\"OP_CONNECT\");\n                hasOp = true;\n            }\n\n            if (channel != null) {\n                sb.append(\", \").append(channel);\n            }\n\n            return sb.toString();\n        }\n    }\n}\n","lineNo":208}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.apache.mina.api.RuntimeIoException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        logger = LoggerFactory.getLogger(NioSelectorLoop.class.getName() + \":\" + prefix + \"-\" + index);\n        worker = new SelectorWorker(prefix, index);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new RuntimeIoException(ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"registering : {} for accept : {}, read : {}, write : {}\", new Object[] { listener, accept, read,\n                                write });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(ops, channel, listener));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}\", new Object[] { listener,\n                                accept, read, write });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(final String prefix, final int index) {\n            super(\"SelectorWorker \" + prefix + \"-\" + index);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        listener.ready(key.isAcceptable(), key.isReadable(), key.isReadable() ? readBuffer : null,\n                                key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            reg.channel.register(selector, reg.ops, reg.listener);\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class Registration {\n\n        public Registration(final int ops, final SelectableChannel channel, final SelectorListener listener) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.mina.transport.nio;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.RuntimeIoException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class holds a Selector and handle all the incoming events for the sessions registered on this selector.ALl the\n * events will be processed by some dedicated thread, taken from a pool. It will loop forever, untill the instance is\n * stopped.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class NioSelectorLoop implements SelectorLoop {\n    /** The logger for this class */\n    private final Logger logger;\n\n    /** the selector managed by this class */\n    private Selector selector;\n\n    /** the worker thread in charge of processing the events */\n    private final SelectorWorker worker;\n\n    /** Read buffer for all the incoming bytes (default to 64Kb) */\n    private final ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    /** The queue containing the channels to register on the selector */\n    private final Queue<Registration> registrationQueue = new ConcurrentLinkedQueue<Registration>();\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix) {\n        this(prefix, -1);\n    }\n\n    /**\n     * Creates an instance of the SelectorLoop.\n     * \n     * @param prefix\n     * @param index\n     */\n    public NioSelectorLoop(final String prefix, final int index) {\n        String name = NioSelectorLoop.class.getName() + \":\" + prefix;\n        String workerName = \"SelectorWorker \" + prefix;\n\n        if (index >= 0) {\n            name += \"-\" + index;\n            workerName += \"-\" + index;\n        }\n\n        logger = LoggerFactory.getLogger(name);\n        worker = new SelectorWorker(workerName);\n\n        try {\n            logger.debug(\"open a selector\");\n            selector = Selector.open();\n        } catch (final IOException ioe) {\n            logger.error(\"Impossible to open a new NIO selector, O/S is out of file descriptor ?\");\n            throw new RuntimeIoException(ioe);\n        }\n        logger.debug(\"starting worker thread\");\n        worker.start();\n\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(boolean accept, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel) {\n        register(null, accept, read, write, listener, channel);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void register(IoSession session, boolean accept, boolean read, boolean write, SelectorListener listener,\n            SelectableChannel channel) {\n        logger.debug(\"registering : {} for accept : {}, read : {}, write : {}\", new Object[] { listener, accept, read,\n                write });\n        int ops = 0;\n\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n\n        // TODO : if it's the same selector/worker, we don't need to do that we could directly enqueue\n        registrationQueue.add(new Registration(session, ops, channel, listener));\n\n        // Now, wakeup the selector in order to let it update the selectionKey status\n        selector.wakeup();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void modifyRegistration(final boolean accept, final boolean read, final boolean write,\n            final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"modifying registration : {} for accept : {}, read : {}, write : {}\", new Object[] { listener,\n                accept, read, write });\n\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n\n        int ops = 0;\n        if (accept) {\n            ops |= SelectionKey.OP_ACCEPT;\n        }\n        if (read) {\n            ops |= SelectionKey.OP_READ;\n        }\n        if (write) {\n            ops |= SelectionKey.OP_WRITE;\n        }\n        key.interestOps(ops);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unregister(final SelectorListener listener, final SelectableChannel channel) {\n        logger.debug(\"unregistering : {}\", listener);\n        final SelectionKey key = channel.keyFor(selector);\n        if (key == null) {\n            logger.error(\"Trying to modify the registration of a not registered channel\");\n            return;\n        }\n        key.cancel();\n        key.attach(null);\n        logger.debug(\"unregistering : {} done !\", listener);\n\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads. It will\n     * also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n\n        public SelectorWorker(String name) {\n            super(name);\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n\n            for (;;) {\n                try {\n                    logger.debug(\"selecting...\");\n                    final int readyCount = selector.select();\n                    logger.debug(\"... done selecting : {} events\", readyCount);\n                    final Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n                    while (it.hasNext()) {\n                        final SelectionKey key = it.next();\n                        final SelectorListener listener = (SelectorListener) key.attachment();\n                        listener.ready(key.isAcceptable(), key.isReadable(), key.isReadable() ? readBuffer : null,\n                                key.isWritable());\n                        // if you don't remove the event of the set, the selector will present you this event again and\n                        // again\n                        it.remove();\n                    }\n\n                    // new registration\n                    while (!registrationQueue.isEmpty()) {\n                        final Registration reg = registrationQueue.poll();\n\n                        try {\n                            SelectionKey selectionKey = reg.channel.register(selector, reg.ops, reg.listener);\n\n                            IoSession session = reg.getSession();\n\n                            if (session != null) {\n                                ((NioSession) session).setSelectionKey(selectionKey);\n                            }\n                        } catch (final ClosedChannelException ex) {\n                            // dead session..\n                            logger.error(\"socket is already dead\", ex);\n                        }\n                    }\n                } catch (final Exception e) {\n                    logger.error(\"Unexpected exception : \", e);\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class Registration {\n\n        public Registration(IoSession session, int ops, SelectableChannel channel, SelectorListener listener) {\n            this.ops = ops;\n            this.channel = channel;\n            this.listener = listener;\n            this.session = session;\n        }\n\n        private final int ops;\n\n        private final SelectableChannel channel;\n\n        private final SelectorListener listener;\n\n        private final IoSession session;\n\n        public IoSession getSession() {\n            return session;\n        }\n    }\n\n    @Override\n    public void wakeup() {\n        selector.wakeup();\n    }\n}\n","lineNo":77}
{"Smelly Sample":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.session;\n\nimport static org.mockito.Mockito.*;\n\nimport java.net.SocketAddress;\n\nimport junit.framework.Assert;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSessionConfig;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class AbstractIoSessionTest {\n\n    private static final class DummySession extends AbstractIoSession {\n        private DummySession(IoService service) {\n            super(service, null);\n        }\n\n        @Override\n        public IoFuture<Void> close(boolean immediately) {\n            return null;\n        }\n\n        @Override\n        public IoSessionConfig getConfig() {\n            return null;\n        }\n\n        @Override\n        public SocketAddress getLocalAddress() {\n            return null;\n        }\n\n        @Override\n        public SocketAddress getRemoteAddress() {\n            return null;\n        }\n\n        @Override\n        public boolean isConnected() {\n            return false;\n        }\n\n        @Override\n        public boolean isReadSuspended() {\n            return false;\n        }\n\n        @Override\n        public boolean isWriteSuspended() {\n            return false;\n        }\n\n        @Override\n        public void resumeRead() {\n        }\n\n        @Override\n        public void resumeWrite() {\n        }\n\n        @Override\n        public void suspendRead() {\n        }\n\n        @Override\n        public void suspendWrite() {\n        }\n\n        @Override\n        public boolean isSecuring() {\n            return false;\n        }\n\n        @Override\n        public boolean isSecured() {\n            return false;\n        }\n\n        @Override\n        public boolean isClosed() {\n            // TODO Auto-generated method stub\n            return false;\n        }\n    }\n\n    private IoService service = null;\n\n    @Before\n    public void setup() {\n        service = mock(IoService.class);\n        when(service.getFilters()).thenReturn(new IoFilter[] {});\n    }\n\n    @Test\n    public void testGetId() {\n\n        Assert.assertNotSame((new DummySession(service)).getId(), (new DummySession(service)).getId());\n\n    }\n\n    @Test\n    public void testCreationTime() {\n        long before = System.currentTimeMillis();\n        long creation = (new DummySession(service)).getCreationTime();\n        long after = System.currentTimeMillis();\n        Assert.assertTrue(creation <= after);\n        Assert.assertTrue(creation >= before);\n    }\n\n    @Test\n    public void testAttachment() {\n        AbstractIoSession aio = new DummySession(service);\n        String value = \"value\";\n        Assert.assertNull(aio.getAttribute(\"test\"));\n        Assert.assertEquals(null, aio.setAttribute(\"test\", value));\n        Assert.assertTrue(aio.containsAttribute(\"test\"));\n        Assert.assertEquals(aio.getAttributeNames().size(), 1);\n        Assert.assertEquals(value, aio.setAttribute(\"test\", value));\n        Assert.assertEquals(aio.getAttributeNames().size(), 1);\n        Assert.assertTrue(aio.containsAttribute(\"test\"));\n        Assert.assertEquals(value, aio.getAttribute(\"test\"));\n        Assert.assertEquals(value, aio.removeAttribute(\"test\"));\n        Assert.assertEquals(aio.getAttributeNames().size(), 0);\n        Assert.assertFalse(aio.containsAttribute(\"test\"));\n\n        Assert.assertEquals(null, aio.getAttribute(\"test\"));\n        Assert.assertNotNull(aio.getService());\n    }\n\n}\n","Method after Refactoring":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.session;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNotNull;\nimport static junit.framework.Assert.assertNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.net.SocketAddress;\n\nimport junit.framework.Assert;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSessionConfig;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * A test class for IoSession\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class AbstractIoSessionTest {\n\n    private static final class DummySession extends AbstractIoSession {\n        private DummySession(IoService service) {\n            super(service, null);\n        }\n\n        @Override\n        public IoFuture<Void> close(boolean immediately) {\n            return null;\n        }\n\n        @Override\n        public IoSessionConfig getConfig() {\n            return null;\n        }\n\n        @Override\n        public SocketAddress getLocalAddress() {\n            return null;\n        }\n\n        @Override\n        public SocketAddress getRemoteAddress() {\n            return null;\n        }\n\n        @Override\n        public boolean isConnected() {\n            return false;\n        }\n\n        @Override\n        public boolean isReadSuspended() {\n            return false;\n        }\n\n        @Override\n        public boolean isWriteSuspended() {\n            return false;\n        }\n\n        @Override\n        public void resumeRead() {\n        }\n\n        @Override\n        public void resumeWrite() {\n        }\n\n        @Override\n        public void suspendRead() {\n        }\n\n        @Override\n        public void suspendWrite() {\n        }\n\n        @Override\n        public boolean isSecuring() {\n            return false;\n        }\n\n        @Override\n        public boolean isSecured() {\n            return false;\n        }\n\n        @Override\n        public boolean isClosed() {\n            // TODO Auto-generated method stub\n            return false;\n        }\n    }\n\n    private IoService service = null;\n\n    @Before\n    public void setup() {\n        service = mock(IoService.class);\n        when(service.getFilters()).thenReturn(new IoFilter[] {});\n    }\n\n    @Test\n    public void testGetId() {\n\n        Assert.assertNotSame((new DummySession(service)).getId(), (new DummySession(service)).getId());\n\n    }\n\n    @Test\n    public void testCreationTime() {\n        long before = System.currentTimeMillis();\n        long creation = (new DummySession(service)).getCreationTime();\n        long after = System.currentTimeMillis();\n        Assert.assertTrue(creation <= after);\n        Assert.assertTrue(creation >= before);\n    }\n\n    @Test\n    public void testAttachment() {\n        AbstractIoSession aio = new DummySession(service);\n        String value = \"value\";\n        AttributeKey<String> key = new AttributeKey<String>(String.class, \"test\");\n        assertNull(aio.getAttribute(key, null));\n        assertEquals(null, aio.setAttribute(key, value));\n\n        assertEquals(aio.getAttributeKeys().size(), 1);\n        assertEquals(value, aio.setAttribute(key, value));\n        assertEquals(aio.getAttributeKeys().size(), 1);\n        assertEquals(value, aio.getAttribute(key, null));\n        assertEquals(value, aio.removeAttribute(key));\n        assertEquals(aio.getAttributeKeys().size(), 0);\n\n        assertEquals(null, aio.getAttribute(key, null));\n        assertNotNull(aio.getService());\n    }\n}\n","lineNo":146}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        \n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        \n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            \n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        int position = writeChainPosition.get();\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    position);\n        }\n        \n        writeChainPosition.set(position - 1);\n        \n        if ((position< 0) || (chain.length == 0)) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        \n        writeChainPosition.set(position + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        int position = readChainPosition.get();\n        \n        readChainPosition.set(position + 1);\n        \n        if (position >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[position].messageReceived(session, message, this);\n        }\n        \n        readChainPosition.set(position - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        \n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        \n        return bldr.append(\"}\").toString();\n    }\n}\n","lineNo":153}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        \n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        \n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            \n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        int position = writeChainPosition.get();\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    position);\n        }\n        \n        writeChainPosition.set(position - 1);\n        \n        if ((position< 0) || (chain.length == 0)) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        \n        writeChainPosition.set(position + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        int position = readChainPosition.get();\n        \n        readChainPosition.set(position + 1);\n        \n        if (position >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[position].messageReceived(session, message, this);\n        }\n        \n        readChainPosition.set(position - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        \n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        \n        return bldr.append(\"}\").toString();\n    }\n}\n","lineNo":166}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        \n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        \n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        \n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            \n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        int position = writeChainPosition.get();\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    position);\n        }\n        \n        writeChainPosition.set(position - 1);\n        \n        if ((position< 0) || (chain.length == 0)) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        \n        writeChainPosition.set(position + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        int position = readChainPosition.get();\n        \n        readChainPosition.set(position + 1);\n        \n        if (position >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[position].messageReceived(session, message, this);\n        }\n        \n        readChainPosition.set(position - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        \n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        \n        return bldr.append(\"}\").toString();\n    }\n}\n","lineNo":186}
{"Smelly Sample":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.util;\n\nimport java.nio.ByteBuffer;\n\n/**\n * Utility class for smart dumping {@link ByteBuffer}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ByteBufferDumper {\n\n    /**\n     * The high digits lookup table.\n    */\n    private static final byte[] highDigits;\n\n    /**\n     * The low digits lookup table.\n     */\n    private static final byte[] lowDigits;\n\n    /**\n     * Initialize lookup tables.\n     */\n    static {\n        final byte[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\n        int i;\n        byte[] high = new byte[256];\n        byte[] low = new byte[256];\n\n        for (i = 0; i < 256; i++) {\n            high[i] = digits[i >>> 4];\n            low[i] = digits[i & 0x0F];\n        }\n\n        highDigits = high;\n        lowDigits = low;\n    }\n    \n    public static String dump(IoBuffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        \n        boolean isFirst = true;\n        \n        for (int i = 0; i < buffer.limit(); i++) {\n            int byteValue = buffer.get(i) & 0xFF;\n            \n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(' ');\n            }\n            \n            sb.append(\"0x\");\n            sb.append((char) highDigits[byteValue]);\n            sb.append((char) lowDigits[byteValue]);\n        }\n            \n        return sb.toString();\n    }\n\n    public static String dump(ByteBuffer buffer) {\n        byte[] data = buffer.array();\n        int start = buffer.position();\n        int size = buffer.remaining();\n        \n        // is not ASCII printable ?\n        boolean binaryContent = false;\n        \n        for (int i = start; i < size; i++) {\n            byte b = data[i];\n            \n            if ((b < 32 || b > 126) && b != 13 && b != 10) {\n                binaryContent = true;\n                break;\n            }\n        }\n\n        if (binaryContent) {\n            StringBuilder out = new StringBuilder(size * 3 + 24);\n            out.append(\"ByteBuffer[len=\").append(size).append(\",bytes='\\n\");\n\n            // fill the first\n            int byteValue = data[start] & 0xFF;\n            out.append((char) highDigits[byteValue]);\n            out.append((char) lowDigits[byteValue]);\n\n            // and the others, too\n            for (int i = start + 1; i < size; i++) {\n                if (i%16 == 0) {\n                    out.append('\\n');\n                } else {\n                    out.append(' ');\n                }\n                \n                byteValue = data[i] & 0xFF;\n                out.append((char) highDigits[byteValue]);\n                out.append((char) lowDigits[byteValue]);\n            }\n            \n            out.append(\"']\");\n            \n            return out.toString();\n\n        } else {\n            StringBuilder sb = new StringBuilder(size);\n            sb.append(\"ByteBuffer[len=\")\n                .append(buffer.remaining())\n                .append(\",str='\")\n                .append(new String(data, start, size))\n                .append(\"']\");\n            \n            return sb.toString();\n        }\n    }\n\n}\n","Method after Refactoring":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.util;\n\nimport java.nio.ByteBuffer;\n\n/**\n * Utility class for smart dumping {@link ByteBuffer}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ByteBufferDumper {\n    /** Hex chars */\n    private static final byte[] HEX_CHAR = new byte[]\n        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n    \n    /**\n     * Dump the content of a IoBuffer\n     * \n     * @param buffer The IoBuffer to dump\n     * @return A string representing the IoBuffer content\n     */\n    public static String dump(IoBuffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        \n        boolean isFirst = true;\n        \n        for (int i = 0; i < buffer.limit(); i++) {\n            byte byteValue = buffer.get(i);\n            \n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(' ');\n            }\n            \n            sb.append( new String( new byte[]\n                { '0', 'x', HEX_CHAR[( byteValue & 0x00F0 ) >> 4], HEX_CHAR[byteValue & 0x000F] } ));\n        }\n            \n        return sb.toString();\n    }\n    \n    /**\n     * Dump the content of the given ByteBuffer, up to a number of bytes. If the\n     * toAscii flag is set to <code>true<\/code>, this method will try to convert\n     * the bytes to a String\n     * \n     * @param buffer The buffer to dump\n     * @param nbBytes The number of bytes to dump (-1 for all of them)\n     * @param toAscii If we want to write the message as a String\n     * @return A dump of this ByteBuffer\n     */\n    public static String dump(ByteBuffer buffer, int nbBytes, boolean toAscii) {\n        byte[] data = buffer.array();\n        int start = buffer.position();\n        int size = Math.min(buffer.remaining(), nbBytes >= 0?nbBytes : Integer.MAX_VALUE);\n        int length = buffer.remaining();\n        \n        // is not ASCII printable ?\n        boolean binaryContent = false;\n        \n        if (toAscii) {\n            for (int i = start; i < size; i++) {\n                byte b = data[i];\n                \n                if (((b < 32) || (b > 126)) && (b != 13) && (b != 10)) {\n                    binaryContent = true;\n                    break;\n                }\n            }\n        }\n\n        if (!toAscii || binaryContent) {\n            StringBuilder out = new StringBuilder(size * 3 + 30);\n            out.append(\"ByteBuffer[len=\").append(length).append(\",bytes='\");\n\n            // fill the first\n            int byteValue = data[start] & 0xFF;\n            boolean isFirst = true;\n\n            // and the others, too\n            for (int i = start; i < size; i++) {\n                if (isFirst) {\n                    isFirst = false;\n                } else {\n                    out.append(' ');\n                }\n                \n                byteValue = data[i] & 0xFF;\n                out.append( new String( new byte[]\n                    { '0', 'x', HEX_CHAR[( byteValue & 0x00F0 ) >> 4], HEX_CHAR[byteValue & 0x000F] } ));\n            }\n            \n            out.append(\"']\");\n            \n            return out.toString();\n\n        } else {\n            StringBuilder sb = new StringBuilder(size);\n            sb.append(\"ByteBuffer[len=\")\n                .append(length)\n                .append(\",str='\")\n                .append(new String(data, start, size))\n                .append(\"']\");\n            \n            return sb.toString();\n        }\n    }\n\n    /**\n     * Dumps the given buffer. If the buffer contains only ascii, it will write\n     * the buffer content as a String.\n     * \n     * @param buffer The buffer to dump\n     * @return A string representing the buffer content\n     */\n    public static String dump(ByteBuffer buffer) {\n        return dump(buffer, -1, true);\n    }\n}\n","lineNo":74}
{"Smelly Sample":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.util;\n\nimport java.nio.ByteBuffer;\n\n/**\n * Utility class for smart dumping {@link ByteBuffer}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ByteBufferDumper {\n\n    /**\n     * The high digits lookup table.\n    */\n    private static final byte[] highDigits;\n\n    /**\n     * The low digits lookup table.\n     */\n    private static final byte[] lowDigits;\n\n    /**\n     * Initialize lookup tables.\n     */\n    static {\n        final byte[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\n        int i;\n        byte[] high = new byte[256];\n        byte[] low = new byte[256];\n\n        for (i = 0; i < 256; i++) {\n            high[i] = digits[i >>> 4];\n            low[i] = digits[i & 0x0F];\n        }\n\n        highDigits = high;\n        lowDigits = low;\n    }\n    \n    public static String dump(IoBuffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        \n        boolean isFirst = true;\n        \n        for (int i = 0; i < buffer.limit(); i++) {\n            int byteValue = buffer.get(i) & 0xFF;\n            \n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(' ');\n            }\n            \n            sb.append(\"0x\");\n            sb.append((char) highDigits[byteValue]);\n            sb.append((char) lowDigits[byteValue]);\n        }\n            \n        return sb.toString();\n    }\n\n    public static String dump(ByteBuffer buffer) {\n        byte[] data = buffer.array();\n        int start = buffer.position();\n        int size = buffer.remaining();\n        \n        // is not ASCII printable ?\n        boolean binaryContent = false;\n        \n        for (int i = start; i < size; i++) {\n            byte b = data[i];\n            \n            if ((b < 32 || b > 126) && b != 13 && b != 10) {\n                binaryContent = true;\n                break;\n            }\n        }\n\n        if (binaryContent) {\n            StringBuilder out = new StringBuilder(size * 3 + 24);\n            out.append(\"ByteBuffer[len=\").append(size).append(\",bytes='\\n\");\n\n            // fill the first\n            int byteValue = data[start] & 0xFF;\n            out.append((char) highDigits[byteValue]);\n            out.append((char) lowDigits[byteValue]);\n\n            // and the others, too\n            for (int i = start + 1; i < size; i++) {\n                if (i%16 == 0) {\n                    out.append('\\n');\n                } else {\n                    out.append(' ');\n                }\n                \n                byteValue = data[i] & 0xFF;\n                out.append((char) highDigits[byteValue]);\n                out.append((char) lowDigits[byteValue]);\n            }\n            \n            out.append(\"']\");\n            \n            return out.toString();\n\n        } else {\n            StringBuilder sb = new StringBuilder(size);\n            sb.append(\"ByteBuffer[len=\")\n                .append(buffer.remaining())\n                .append(\",str='\")\n                .append(new String(data, start, size))\n                .append(\"']\");\n            \n            return sb.toString();\n        }\n    }\n\n}\n","Method after Refactoring":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mina.util;\n\nimport java.nio.ByteBuffer;\n\n/**\n * Utility class for smart dumping {@link ByteBuffer}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class ByteBufferDumper {\n    /** Hex chars */\n    private static final byte[] HEX_CHAR = new byte[]\n        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n    \n    /**\n     * Dump the content of a IoBuffer\n     * \n     * @param buffer The IoBuffer to dump\n     * @return A string representing the IoBuffer content\n     */\n    public static String dump(IoBuffer buffer) {\n        StringBuilder sb = new StringBuilder();\n        \n        boolean isFirst = true;\n        \n        for (int i = 0; i < buffer.limit(); i++) {\n            byte byteValue = buffer.get(i);\n            \n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(' ');\n            }\n            \n            sb.append( new String( new byte[]\n                { '0', 'x', HEX_CHAR[( byteValue & 0x00F0 ) >> 4], HEX_CHAR[byteValue & 0x000F] } ));\n        }\n            \n        return sb.toString();\n    }\n    \n    /**\n     * Dump the content of the given ByteBuffer, up to a number of bytes. If the\n     * toAscii flag is set to <code>true<\/code>, this method will try to convert\n     * the bytes to a String\n     * \n     * @param buffer The buffer to dump\n     * @param nbBytes The number of bytes to dump (-1 for all of them)\n     * @param toAscii If we want to write the message as a String\n     * @return A dump of this ByteBuffer\n     */\n    public static String dump(ByteBuffer buffer, int nbBytes, boolean toAscii) {\n        byte[] data = buffer.array();\n        int start = buffer.position();\n        int size = Math.min(buffer.remaining(), nbBytes >= 0?nbBytes : Integer.MAX_VALUE);\n        int length = buffer.remaining();\n        \n        // is not ASCII printable ?\n        boolean binaryContent = false;\n        \n        if (toAscii) {\n            for (int i = start; i < size; i++) {\n                byte b = data[i];\n                \n                if (((b < 32) || (b > 126)) && (b != 13) && (b != 10)) {\n                    binaryContent = true;\n                    break;\n                }\n            }\n        }\n\n        if (!toAscii || binaryContent) {\n            StringBuilder out = new StringBuilder(size * 3 + 30);\n            out.append(\"ByteBuffer[len=\").append(length).append(\",bytes='\");\n\n            // fill the first\n            int byteValue = data[start] & 0xFF;\n            boolean isFirst = true;\n\n            // and the others, too\n            for (int i = start; i < size; i++) {\n                if (isFirst) {\n                    isFirst = false;\n                } else {\n                    out.append(' ');\n                }\n                \n                byteValue = data[i] & 0xFF;\n                out.append( new String( new byte[]\n                    { '0', 'x', HEX_CHAR[( byteValue & 0x00F0 ) >> 4], HEX_CHAR[byteValue & 0x000F] } ));\n            }\n            \n            out.append(\"']\");\n            \n            return out.toString();\n\n        } else {\n            StringBuilder sb = new StringBuilder(size);\n            sb.append(\"ByteBuffer[len=\")\n                .append(length)\n                .append(\",str='\")\n                .append(new String(data, start, size))\n                .append(\"']\");\n            \n            return sb.toString();\n        }\n    }\n\n    /**\n     * Dumps the given buffer. If the buffer contains only ascii, it will write\n     * the buffer content as a String.\n     * \n     * @param buffer The buffer to dump\n     * @return A string representing the buffer content\n     */\n    public static String dump(ByteBuffer buffer) {\n        return dump(buffer, -1, true);\n    }\n}\n","lineNo":45}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session \n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","lineNo":130}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session \n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filterchain;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.mina.api.IoFilter;\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.session.DefaultWriteRequest;\nimport org.apache.mina.session.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default implementation of the {@link IoFilterController}\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic class DefaultIoFilterController implements IoFilterController, ReadFilterChainController,\n        WriteFilterChainController {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultIoFilterController.class);\n\n    /**\n     * The list of {@link IoFilter} implementing this chain.\n     */\n    private final IoFilter[] chain;\n\n    /**\n     * The instance of {@link DefaultIoFilterController} with the {@link IoService} chain.\n     */\n    public DefaultIoFilterController(IoFilter[] chain) {\n        if (chain == null) {\n            throw new IllegalArgumentException(\"chain\");\n        }\n        this.chain = chain;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionCreated(IoSession session) {\n        LOG.debug(\"processing session created event for session {}\", session);\n        for (IoFilter filter : chain) {\n            filter.sessionCreated(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionOpened(IoSession session) {\n        LOG.debug(\"processing session open event\");\n        for (IoFilter filter : chain) {\n            filter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processSessionClosed(IoSession session) {\n        LOG.debug(\"processing session closed event\");\n        for (IoFilter filter : chain) {\n            filter.sessionClosed(session);\n        }\n    }\n\n    /** the current position in the read chain for this thread */\n    private static final ThreadLocal<Integer> readChainPosition = new ThreadLocal<Integer>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageReceived(IoSession session, Object message) {\n        LOG.debug(\"processing message '{}' received event \", message);\n        if (chain.length < 1) {\n            LOG.debug(\"Nothing to do, the chain is empty\");\n        } else {\n            readChainPosition.set(0);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n    }\n\n    /** the current position n the write chain for this thread */\n    private static final ThreadLocal<Integer> writeChainPosition = new ThreadLocal<Integer>();\n\n    /** hold the last WriteRequest created for the high level message currently written (can be null) */\n    private static final ThreadLocal<WriteRequest> lastWriteRequest = new ThreadLocal<WriteRequest>();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void processMessageWriting(IoSession session, Object message, IoFuture<Void> future) {\n        LOG.debug(\"processing message '{}' writing event \", message);\n\n        lastWriteRequest.set(null);\n\n        if (chain.length < 1) {\n            enqueueFinalWriteMessage(session, message);\n        } else {\n\n            writeChainPosition.set(chain.length - 1);\n            // we call the first filter, it's supposed to call the next ones using the filter chain controller\n            int position = writeChainPosition.get();\n            IoFilter nextFilter = chain[position];\n            nextFilter.messageWriting(session, message, this);\n        }\n        // put the future in the last write request\n        if (future != null) {\n            WriteRequest request = lastWriteRequest.get();\n            if (request != null) {\n                ((DefaultWriteRequest) request).setFuture(future);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callWriteNextFilter(IoSession session, Object message) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"calling next filter for writing for message '{}' position : {}\", message,\n                    writeChainPosition.get());\n        }\n        writeChainPosition.set(writeChainPosition.get() - 1);\n        if (writeChainPosition.get() < 0 || chain.length == 0) {\n            // end of chain processing\n            enqueueFinalWriteMessage(session, message);\n        } else {\n            chain[writeChainPosition.get()].messageWriting(session, message, this);\n        }\n        writeChainPosition.set(writeChainPosition.get() + 1);\n    }\n\n    /**\n     * At the end of write chain processing, enqueue final encoded {@link ByteBuffer} message in the session\n     */\n    private void enqueueFinalWriteMessage(IoSession session, Object message) {\n        LOG.debug(\"end of write chan we enqueue the message in the session : {}\", message);\n        lastWriteRequest.set(session.enqueueWriteRequest(message));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void callReadNextFilter(IoSession session, Object message) {\n        readChainPosition.set(readChainPosition.get() + 1);\n        if (readChainPosition.get() >= chain.length) {\n            // end of chain processing\n        } else {\n            chain[readChainPosition.get()].messageReceived(session, message, this);\n        }\n        readChainPosition.set(readChainPosition.get() - 1);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        StringBuilder bldr = new StringBuilder(\"IoFilterChain {\");\n        int index = 0;\n        for (IoFilter filter : chain) {\n            bldr.append(index).append(\":\").append(filter).append(\", \");\n        }\n        return bldr.append(\"}\").toString();\n    }\n}\n","lineNo":131}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLException;\n\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.DefaultIoFilterController;\nimport org.apache.mina.filterchain.IoFilterController;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** The {@link SelectorProcessor} used for handling this session writing */\n    protected SelectorProcessor writeProcessor;\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    /** attributes map */\n    private final Map<String, Object> attributes = new ConcurrentHashMap<String, Object>(4);\n\n    /** unique identifier generator */\n    private static final AtomicLong NEXT_ID = new AtomicLong(0);\n\n    protected final Object stateMonitor = new Object();\n\n    /** The session's state : one of CREATED, CONNECTED, CLOSING, CLOSED, SECURING, CONNECTED_SECURED */\n    protected volatile SessionState state;\n    \n    /** A lock to protect the access to the session's state */\n    private final ReadWriteLock stateLock = new ReentrantReadWriteLock();\n    \n    /** A Read lock on the reentrant session's state lock */\n    private final Lock stateReadLock = stateLock.readLock();\n\n    /** A Write lock on the reentrant session's state lock */\n    private final Lock stateWriteLock = stateLock.writeLock();\n\n\n    /** Tells if the session is secured or not */\n    protected volatile boolean secured;\n\n    /** is this session registered for being polled for write ready events */\n    private AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorProcessor} */\n    private Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    /** A lock to protect the access to the write queue */\n    private final ReadWriteLock writeQueueLock = new ReentrantReadWriteLock();\n    \n    /** A Read lock on the reentrant writeQueue lock */\n    private final Lock writeQueueReadLock = writeQueueLock.readLock();\n\n    /** A Write lock on the reentrant writeQueue lock */\n    private final Lock writeQueueWriteLock = writeQueueLock.writeLock();\n\n    private IoFilterController filterProcessor;\n    \n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param writeProcessor the processor in charge of processing this session write queue\n     */\n    public AbstractIoSession(IoService service, SelectorProcessor writeProcessor) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.writeProcessor = writeProcessor;\n        this.filterProcessor = new DefaultIoFilterController(service.getFilters());\n\n        LOG.debug(\"Created new session with id : {}\", id);\n\n        this.state = SessionState.CREATED;\n    }\n\n    //------------------------------------------------------------------------\n    // Session State management\n    //------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CLOSED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosing() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CLOSING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnected() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CONNECTED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCreated() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CREATED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecuring() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.SECURING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnectedSecured() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.SECURED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void changeState(SessionState to) throws IllegalStateException {\n        try {\n            stateWriteLock.lock();\n            \n            switch (state) {\n                case CREATED :\n                    switch (to) {\n                        case CONNECTED :\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                case CONNECTED :\n                    switch (to) {\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                case SECURING :\n                    switch (to) {\n                        case SECURED :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                    \n                case SECURED :\n                    switch (to) {\n                        case CONNECTED :\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                case CLOSING :\n                    if (to != SessionState.CLOSED) {\n                        throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n\n                    state = to;\n                    \n                    break;\n                    \n                case CLOSED :\n                    throw new IllegalStateException(\"The session is already closed. cannot switch to \" + to );\n            }\n        } finally {\n            stateWriteLock.unlock();\n        }\n    }\n\n    //------------------------------------------------------------------------\n    // SSL/TLS session state management\n    //------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecured() {\n        return secured;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void setSecured(boolean secured) {\n        this.secured = secured;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void initSecure(SSLContext sslContext) throws SSLException {\n        SslHelper sslHelper = new SslHelper(this, sslContext);\n        sslHelper.init();\n        \n        attributes.put(SSL_HELPER, sslHelper);\n        setSecured(true);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T getAttribute(String name) {\n        return (T) attributes.get(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T setAttribute(String name, T value) {\n        return (T) attributes.put(name, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsAttribute(String name) {\n        return attributes.containsKey(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Object removeAttribute(String name) {\n        return attributes.remove(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<String> getAttributeNames() {\n        return attributes.keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(Object message) {\n        doWriteWithFuture(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(Object message) {\n        IoFuture<Void> future = new DefaultWriteFuture();\n        doWriteWithFuture(message, future);\n        return future;\n    }\n\n    private void doWriteWithFuture(Object message, IoFuture<Void> future) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n        \n        if ((state == SessionState.CLOSED) || (state == SessionState.CLOSING)) {\n            LOG.error(\"writing to closed or closing session, the message is discarded\");\n            return;\n        }\n\n        // process the queue\n        getFilterChain().processMessageWriting(this, message, future);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteRequest enqueueWriteRequest(Object message) {\n        DefaultWriteRequest request = null;\n        \n        try {\n            writeQueueReadLock.lock();\n            \n            if ( isConnectedSecured()) {\n                SslHelper sslHelper = getAttribute( IoSession.SSL_HELPER );\n                \n                if (sslHelper == null) {\n                    throw new IllegalStateException();\n                }\n                \n                request = sslHelper.processWrite(this, message, writeQueue);\n            } else {\n                request = new DefaultWriteRequest(message);\n                \n                writeQueue.add(request);\n            }\n        } finally {\n            writeQueueReadLock.unlock();\n        }\n\n        // If it wasn't, we register this session as interested to write.\n        // It's done in atomic fashion for avoiding two concurrent registering.\n        if (!registeredForWrite.getAndSet(true)) {\n            writeProcessor.flush(this);\n        }\n\n        return request;\n    }\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> acquireWriteQueue() {\n        writeQueueWriteLock.lock();\n        return writeQueue;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void releaseWriteQueue() {\n        writeQueueWriteLock.unlock();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFilterController getFilterChain() {\n        return filterProcessor;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLException;\n\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.DefaultIoFilterController;\nimport org.apache.mina.filterchain.IoFilterController;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** The {@link SelectorProcessor} used for handling this session writing */\n    protected SelectorProcessor writeProcessor;\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    /** attributes map */\n    private final Map<String, Object> attributes = new ConcurrentHashMap<String, Object>(4);\n\n    /** unique identifier generator */\n    private static final AtomicLong NEXT_ID = new AtomicLong(0);\n\n    protected final Object stateMonitor = new Object();\n\n    /** The session's state : one of CREATED, CONNECTED, CLOSING, CLOSED, SECURING, CONNECTED_SECURED */\n    protected volatile SessionState state;\n    \n    /** A lock to protect the access to the session's state */\n    private final ReadWriteLock stateLock = new ReentrantReadWriteLock();\n    \n    /** A Read lock on the reentrant session's state lock */\n    private final Lock stateReadLock = stateLock.readLock();\n\n    /** A Write lock on the reentrant session's state lock */\n    private final Lock stateWriteLock = stateLock.writeLock();\n\n\n    /** Tells if the session is secured or not */\n    protected volatile boolean secured;\n\n    /** is this session registered for being polled for write ready events */\n    private AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorProcessor} */\n    private Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    /** A lock to protect the access to the write queue */\n    private final ReadWriteLock writeQueueLock = new ReentrantReadWriteLock();\n    \n    /** A Read lock on the reentrant writeQueue lock */\n    private final Lock writeQueueReadLock = writeQueueLock.readLock();\n\n    /** A Write lock on the reentrant writeQueue lock */\n    private final Lock writeQueueWriteLock = writeQueueLock.writeLock();\n\n    private IoFilterController filterProcessor;\n    \n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param writeProcessor the processor in charge of processing this session write queue\n     */\n    public AbstractIoSession(IoService service, SelectorProcessor writeProcessor) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.writeProcessor = writeProcessor;\n        this.filterProcessor = new DefaultIoFilterController(service.getFilters());\n\n        LOG.debug(\"Created new session with id : {}\", id);\n\n        this.state = SessionState.CREATED;\n    }\n\n    //------------------------------------------------------------------------\n    // Session State management\n    //------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CLOSED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosing() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CLOSING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnected() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CONNECTED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isCreated() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.CREATED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecuring() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.SECURING;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnectedSecured() {\n        try {\n            stateReadLock.lock();\n            \n            return state == SessionState.SECURED;\n        } finally {\n            stateReadLock.unlock();\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void changeState(SessionState to) throws IllegalStateException {\n        try {\n            stateWriteLock.lock();\n            \n            switch (state) {\n                case CREATED :\n                    switch (to) {\n                        case CONNECTED :\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                case CONNECTED :\n                    switch (to) {\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                case SECURING :\n                    switch (to) {\n                        case SECURED :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                    \n                    \n                case SECURED :\n                    switch (to) {\n                        case CONNECTED :\n                        case SECURING :\n                        case CLOSING :\n                            state = to;\n                            break;\n                            \n                        default :\n                            throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n                    \n                    break;\n                case CLOSING :\n                    if (to != SessionState.CLOSED) {\n                        throw new IllegalStateException(\"Cannot transit from \" + state + \" to \" + to );\n                    }\n\n                    state = to;\n                    \n                    break;\n                    \n                case CLOSED :\n                    throw new IllegalStateException(\"The session is already closed. cannot switch to \" + to );\n            }\n        } finally {\n            stateWriteLock.unlock();\n        }\n    }\n\n    //------------------------------------------------------------------------\n    // SSL/TLS session state management\n    //------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSecured() {\n        return secured;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void setSecured(boolean secured) {\n        this.secured = secured;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void initSecure(SSLContext sslContext) throws SSLException {\n        SslHelper sslHelper = new SslHelper(this, sslContext);\n        sslHelper.init();\n        \n        attributes.put(SSL_HELPER, sslHelper);\n        setSecured(true);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T getAttribute(String name) {\n        return (T) attributes.get(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T setAttribute(String name, T value) {\n        return (T) attributes.put(name, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsAttribute(String name) {\n        return attributes.containsKey(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Object removeAttribute(String name) {\n        return attributes.remove(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<String> getAttributeNames() {\n        return attributes.keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(Object message) {\n        doWriteWithFuture(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(Object message) {\n        IoFuture<Void> future = new DefaultWriteFuture();\n        doWriteWithFuture(message, future);\n        return future;\n    }\n\n    private void doWriteWithFuture(Object message, IoFuture<Void> future) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n        \n        if ((state == SessionState.CLOSED) || (state == SessionState.CLOSING)) {\n            LOG.error(\"writing to closed or closing session, the message is discarded\");\n            return;\n        }\n\n        // process the queue\n        IoFilterController chain = getFilterChain();\n        chain.processMessageWriting(this, message, future);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteRequest enqueueWriteRequest(Object message) {\n        DefaultWriteRequest request = null;\n        \n        try {\n            writeQueueReadLock.lock();\n            \n            if ( isConnectedSecured()) {\n                SslHelper sslHelper = getAttribute( IoSession.SSL_HELPER );\n                \n                if (sslHelper == null) {\n                    throw new IllegalStateException();\n                }\n                \n                request = sslHelper.processWrite(this, message, writeQueue);\n            } else {\n                request = new DefaultWriteRequest(message);\n                \n                writeQueue.add(request);\n            }\n        } finally {\n            writeQueueReadLock.unlock();\n        }\n\n        // If it wasn't, we register this session as interested to write.\n        // It's done in atomic fashion for avoiding two concurrent registering.\n        if (!registeredForWrite.getAndSet(true)) {\n            writeProcessor.flush(this);\n        }\n\n        return request;\n    }\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> acquireWriteQueue() {\n        writeQueueWriteLock.lock();\n        return writeQueue;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void releaseWriteQueue() {\n        writeQueueWriteLock.unlock();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFilterController getFilterChain() {\n        return filterProcessor;\n    }\n}\n","lineNo":467}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\n\npackage org.apache.mina.transport.tcp;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.mina.api.IoServer;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.RuntimeIoException;\nimport org.apache.mina.service.AbstractIoService;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.apache.mina.service.SelectorStrategy;\nimport org.apache.mina.session.DefaultWriteFuture;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.transport.tcp.nio.NioTcpServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * \n * A {@link SelectorProcessor} for processing NIO based {@link IoSession}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n */\npublic class NioSelectorProcessor implements SelectorProcessor {\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    private SelectorStrategy strategy;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NioSelectorProcessor.class);\n\n    private Map<SocketAddress, ServerSocketChannel> serverSocketChannels = new ConcurrentHashMap<SocketAddress, ServerSocketChannel>();\n\n    // read buffer for all the incoming bytes\n    private ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    // the thread polling and processing the I/O events\n    private SelectorWorker worker = null;\n\n    /**\n     * new binded server to add to the selector {ServerSocketChannel, IoServer}\n     * jvermillard : FIXME the typing is ugly !!!\n     */\n    private final Queue<Object[]> serversToAdd = new ConcurrentLinkedQueue<Object[]>();\n\n    /** server to remove of the selector */\n    private final Queue<ServerSocketChannel> serversToRemove = new ConcurrentLinkedQueue<ServerSocketChannel>();\n\n    /**\n     * new session freshly accepted, placed here for being added to the selector\n     */\n    private final Queue<NioTcpSession> sessionsToConnect = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** session to be removed of the selector */\n    private final Queue<NioTcpSession> sessionsToClose = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<NioTcpSession> flushingSessions = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    private Selector selector;\n\n    // Lock for Selector worker, using default. can look into fairness later.\n    // We need to think about a lock less mechanism here.\n    private Lock workerLock = new ReentrantLock();\n\n    public NioSelectorProcessor(String name, SelectorStrategy strategy) {\n        this.strategy = strategy;\n\n        // FIXME : configurable parameter\n        readBuffer = ByteBuffer.allocate(1024);\n    }\n\n    /**\n     * Add a bound server channel for starting accepting new client connections.\n     * \n     * @param serverChannel\n     */\n    private void add(ServerSocketChannel serverChannel, IoServer server) {\n        LOGGER.debug(\"adding a server channel {} for server {}\", serverChannel, server);\n        serversToAdd.add(new Object[] { serverChannel, server });\n        wakeupWorker();\n    }\n\n    /**\n     * Wake the I/O worker thread and if none exists, create a new one\n     * FIXME : too much locking there ?\n     */\n    private void wakeupWorker() {\n        workerLock.lock();\n        try {\n            if (worker == null) {\n                worker = new SelectorWorker();\n                worker.start();\n            }\n        } finally {\n            workerLock.unlock();\n        }\n\n        if (selector != null) {\n            selector.wakeup();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bindAndAcceptAddress(IoServer server, SocketAddress address) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // FIXME : should be \"genericified\"\n        if (server instanceof AbstractTcpServer) {\n            serverSocketChannel.socket().setReuseAddress(((AbstractTcpServer) server).isReuseAddress());\n        }\n        serverSocketChannel.socket().bind(address);\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannels.put(address, serverSocketChannel);\n        add(serverSocketChannel, server);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unbind(SocketAddress address) throws IOException {\n        ServerSocketChannel channel = serverSocketChannels.get(address);\n        channel.socket().close();\n        channel.close();\n        if (serverSocketChannels.remove(address) == null) {\n            LOGGER.warn(\"The server channel for address {} was already unbound\", address);\n        }\n        LOGGER.debug(\"Removing a server channel {}\", channel);\n        serversToRemove.add(channel);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void createSession(IoService service, Object clientSocket) {\n        LOGGER.debug(\"create session\");\n        final SocketChannel socketChannel = (SocketChannel) clientSocket;\n        final SocketSessionConfig defaultConfig = (SocketSessionConfig) service.getSessionConfig();\n        final NioTcpSession session = new NioTcpSession((NioTcpServer) service, socketChannel,\n                strategy.getSelectorForNewSession(this));\n\n        try {\n            socketChannel.configureBlocking(false);\n        } catch (IOException e) {\n            LOGGER.error(\"Unexpected exception, while configuring socket as non blocking\", e);\n            throw new RuntimeIoException(\"cannot configure socket as non-blocking\", e);\n        }\n\n        // apply the default service socket configuration\n        Boolean keepAlive = defaultConfig.isKeepAlive();\n        \n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = defaultConfig.isOobInline();\n        \n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = defaultConfig.isReuseAddress();\n        \n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = defaultConfig.isTcpNoDelay();\n        \n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = defaultConfig.getReceiveBufferSize();\n        \n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = defaultConfig.getSendBufferSize();\n        \n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = defaultConfig.getTrafficClass();\n        \n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = defaultConfig.getSoLinger();\n        \n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n        \n        // Set the secured fag if the service is to be used over SSL/TLS\n        if (service.isSecured()) {\n            session.setSecured(true);\n        }\n\n        // event session created\n        session.getFilterChain().processSessionCreated(session);\n\n        // add the session to the queue for being added to the selector\n        sessionsToConnect.add(session);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void flush(IoSession session) {\n        LOGGER.debug(\"scheduling session {} for writing\", session);\n        // add the session to the list of session to be registered for writing\n        flushingSessions.add((NioTcpSession) session);\n        // wake the selector for unlocking the I/O thread\n        wakeupWorker();\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads.\n     * It will also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n        // map for finding the keys associated with a given server\n        private Map<ServerSocketChannel, SelectionKey> serverKey = new HashMap<ServerSocketChannel, SelectionKey>();\n\n        // map for finding read keys associated with a given session\n        private Map<NioTcpSession, SelectionKey> sessionReadKey = new HashMap<NioTcpSession, SelectionKey>();\n\n        @Override\n        public void run() {\n            if (selector == null) {\n                LOGGER.debug(\"opening a new selector\");\n\n                try {\n                    selector = Selector.open();\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while opening a new Selector\", e);\n                }\n            }\n\n            for (;;) {\n                try {\n                    // pop server sockets for removing\n                    if (serversToRemove.size() > 0) {\n                        while (!serversToRemove.isEmpty()) {\n                            ServerSocketChannel channel = serversToRemove.poll();\n                            SelectionKey key = serverKey.remove(channel);\n\n                            if (key == null) {\n                                LOGGER.error(\"The server socket was already removed of the selector\");\n                            } else {\n                                key.cancel();\n                            }\n                        }\n                    }\n\n                    // pop new server sockets for accepting\n                    if (serversToAdd.size() > 0) {\n                        while (!serversToAdd.isEmpty()) {\n                            Object[] tmp = serversToAdd.poll();\n                            ServerSocketChannel channel = (ServerSocketChannel) tmp[0];\n                            SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT);\n                            key.attach(tmp);\n                        }\n                    }\n\n                    // pop new session for starting read/write\n                    if (sessionsToConnect.size() > 0) {\n                        while (!sessionsToConnect.isEmpty()) {\n                            NioTcpSession session = sessionsToConnect.poll();\n                            SelectionKey key = session.getSocketChannel().register(selector, SelectionKey.OP_READ);\n                            key.attach(session);\n                            sessionReadKey.put(session, key);\n\n                            // Switch to CONNECTED, only if the session is not secured, as the SSL Handshake\n                            // will occur later.\n                            if (!session.isSecured()) {\n                                session.setConnected();\n                                \n                                // fire the event\n                                ((AbstractIoService) session.getService()).fireSessionCreated(session);\n                                session.getFilterChain().processSessionOpened(session);\n                            }\n                        }\n                    }\n\n                    // pop session for close\n                    if (sessionsToClose.size() > 0) {\n                        while (!sessionsToClose.isEmpty()) {\n                            NioTcpSession session = sessionsToClose.poll();\n\n                            SelectionKey key = sessionReadKey.remove(session);\n                            key.cancel();\n\n                            // closing underlying socket\n                            session.getSocketChannel().close();\n                            // fire the event\n                            session.getFilterChain().processSessionClosed(session);\n                            ((AbstractIoService) session.getService()).fireSessionDestroyed(session);\n\n                        }\n                    }\n\n                    LOGGER.debug(\"selecting...\");\n                    int readyCount = selector.select(SELECT_TIMEOUT);\n                    LOGGER.debug(\"... done selecting : {}\", readyCount);\n\n                    if (readyCount > 0) {\n                        // process selected keys\n                        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n\n                        while (selectedKeys.hasNext()) {\n                            SelectionKey key = selectedKeys.next();\n                            selectedKeys.remove();\n\n                            if (!key.isValid()) {\n                                continue;\n                            }\n\n                            selector.selectedKeys().remove(key);\n\n                            if (key.isReadable()) {\n                                LOGGER.debug(\"readable client {}\", key);\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                SocketChannel channel = session.getSocketChannel();\n                                readBuffer.rewind();\n                                int readCount = channel.read(readBuffer);\n                                LOGGER.debug(\"read {} bytes\", readCount);\n\n                                if (readCount < 0) {\n                                    // session closed by the remote peer\n                                    LOGGER.debug(\"session closed by the remote peer\");\n                                    sessionsToClose.add(session);\n                                } else {\n                                    // we have read some data\n                                    // limit at the current position & rewind buffer back to start & push to the chain\n                                    readBuffer.flip();\n                                    \n                                    if (session.isSecured() && !session.isConnectedSecured()) {\n                                            // Process the SSL handshake now\n                                    } else {\n                                        session.getFilterChain().processMessageReceived(session, readBuffer);\n                                    }\n                                }\n                            }\n\n                            if (key.isWritable()) {\n                                if (LOGGER.isDebugEnabled()) {\n                                    LOGGER.debug(\"writable session : {}\", key.attachment());\n                                }\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                session.setNotRegisteredForWrite();\n                                // write from the session write queue\n                                Queue<WriteRequest> queue = session.getWriteQueue();\n\n                                do {\n                                    // get a write request from the queue\n                                    WriteRequest wreq = queue.peek();\n                                    if (wreq == null) {\n                                        break;\n                                    }\n                                    ByteBuffer buf = (ByteBuffer) wreq.getMessage();\n\n                                    int wrote = session.getSocketChannel().write(buf);\n                                    if (LOGGER.isDebugEnabled()) {\n                                        LOGGER.debug(\"wrote {} bytes to {}\", wrote, session);\n                                    }\n\n                                    if (buf.remaining() == 0) {\n                                        // completed write request, let's remove\n                                        // it\n                                        queue.remove();\n                                        // complete the future\n                                        DefaultWriteFuture future = (DefaultWriteFuture) wreq.getFuture();\n                                        if (future != null) {\n                                            future.complete();\n                                        }\n                                    } else {\n                                        // output socket buffer is full, we need\n                                        // to give up until next selection for\n                                        // writing\n                                        break;\n                                    }\n\n                                } while (!queue.isEmpty());\n\n                                // if the session is no more interested in writing, we need\n                                // to stop listening for OP_WRITE events\n                                if (queue.isEmpty()) {\n                                    // a key registered for read ? (because we can have a\n                                    // Selector for reads and another for the writes\n                                    SelectionKey readKey = sessionReadKey.get(session);\n                                    if (readKey != null) {\n                                        LOGGER.debug(\"registering key for only reading\");\n                                        SelectionKey mykey = session.getSocketChannel().register(selector,\n                                                SelectionKey.OP_READ, session);\n                                        sessionReadKey.put(session, mykey);\n                                    } else {\n                                        LOGGER.debug(\"cancel key for writing\");\n                                        session.getSocketChannel().keyFor(selector).cancel();\n                                    }\n                                }\n\n                            }\n\n                            if (key.isAcceptable()) {\n                                LOGGER.debug(\"acceptable new client {}\", key);\n                                ServerSocketChannel serverSocket = (ServerSocketChannel) ((Object[]) key.attachment())[0];\n                                IoServer server = (IoServer) (((Object[]) key.attachment())[1]);\n                                // accepted connection\n                                SocketChannel newClientChannel = serverSocket.accept();\n                                LOGGER.debug(\"client accepted\");\n                                // and give it's to the strategy\n                                strategy.getSelectorForNewSession(NioSelectorProcessor.this).createSession(server,\n                                        newClientChannel);\n                            }\n\n                        }\n                    }\n\n                    // registering session with data in the write queue for\n                    // writing\n                    while (!flushingSessions.isEmpty()) {\n                        NioTcpSession session = flushingSessions.poll();\n                        // a key registered for read ? (because we can have a\n                        // Selector for reads and another for the writes\n                        SelectionKey readKey = sessionReadKey.get(session);\n                        if (readKey != null) {\n                            // register for read/write\n                            SelectionKey key = session.getSocketChannel().register(selector,\n                                    SelectionKey.OP_READ | SelectionKey.OP_WRITE, session);\n\n                            sessionReadKey.put(session, key);\n\n                        } else {\n                            session.getSocketChannel().register(selector, SelectionKey.OP_WRITE, session);\n                        }\n                    }\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while selecting selector\", e);\n                }\n\n                // stop the worker if needed\n                workerLock.lock();\n                try {\n                    if (selector.keys().isEmpty()) {\n                        worker = null;\n                        break;\n                    }\n                } finally {\n                    workerLock.unlock();\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\n\npackage org.apache.mina.transport.tcp;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.mina.api.IoServer;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.RuntimeIoException;\nimport org.apache.mina.service.AbstractIoService;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.apache.mina.service.SelectorStrategy;\nimport org.apache.mina.session.DefaultWriteFuture;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.transport.tcp.nio.NioTcpServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * \n * A {@link SelectorProcessor} for processing NIO based {@link IoSession}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n */\npublic class NioSelectorProcessor implements SelectorProcessor {\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    private SelectorStrategy strategy;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NioSelectorProcessor.class);\n\n    private Map<SocketAddress, ServerSocketChannel> serverSocketChannels = new ConcurrentHashMap<SocketAddress, ServerSocketChannel>();\n\n    // read buffer for all the incoming bytes\n    private ByteBuffer readBuffer = ByteBuffer.allocate(64 * 1024);\n\n    // the thread polling and processing the I/O events\n    private SelectorWorker worker = null;\n\n    /**\n     * new binded server to add to the selector {ServerSocketChannel, IoServer}\n     * jvermillard : FIXME the typing is ugly !!!\n     */\n    private final Queue<Object[]> serversToAdd = new ConcurrentLinkedQueue<Object[]>();\n\n    /** server to remove of the selector */\n    private final Queue<ServerSocketChannel> serversToRemove = new ConcurrentLinkedQueue<ServerSocketChannel>();\n\n    /**\n     * new session freshly accepted, placed here for being added to the selector\n     */\n    private final Queue<NioTcpSession> sessionsToConnect = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** session to be removed of the selector */\n    private final Queue<NioTcpSession> sessionsToClose = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<NioTcpSession> flushingSessions = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    private Selector selector;\n\n    // Lock for Selector worker, using default. can look into fairness later.\n    // We need to think about a lock less mechanism here.\n    private Lock workerLock = new ReentrantLock();\n\n    public NioSelectorProcessor(String name, SelectorStrategy strategy) {\n        this.strategy = strategy;\n\n        // FIXME : configurable parameter\n        readBuffer = ByteBuffer.allocate(1024);\n    }\n\n    /**\n     * Add a bound server channel for starting accepting new client connections.\n     * \n     * @param serverChannel\n     */\n    private void add(ServerSocketChannel serverChannel, IoServer server) {\n        LOGGER.debug(\"adding a server channel {} for server {}\", serverChannel, server);\n        serversToAdd.add(new Object[] { serverChannel, server });\n        wakeupWorker();\n    }\n\n    /**\n     * Wake the I/O worker thread and if none exists, create a new one\n     * FIXME : too much locking there ?\n     */\n    private void wakeupWorker() {\n        workerLock.lock();\n        try {\n            if (worker == null) {\n                worker = new SelectorWorker();\n                worker.start();\n            }\n        } finally {\n            workerLock.unlock();\n        }\n\n        if (selector != null) {\n            selector.wakeup();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bindAndAcceptAddress(IoServer server, SocketAddress address) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // FIXME : should be \"genericified\"\n        if (server instanceof AbstractTcpServer) {\n            serverSocketChannel.socket().setReuseAddress(((AbstractTcpServer) server).isReuseAddress());\n        }\n        serverSocketChannel.socket().bind(address);\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannels.put(address, serverSocketChannel);\n        add(serverSocketChannel, server);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unbind(SocketAddress address) throws IOException {\n        ServerSocketChannel channel = serverSocketChannels.get(address);\n        channel.socket().close();\n        channel.close();\n        if (serverSocketChannels.remove(address) == null) {\n            LOGGER.warn(\"The server channel for address {} was already unbound\", address);\n        }\n        LOGGER.debug(\"Removing a server channel {}\", channel);\n        serversToRemove.add(channel);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void createSession(IoService service, Object clientSocket) {\n        LOGGER.debug(\"create session\");\n        final SocketChannel socketChannel = (SocketChannel) clientSocket;\n        final SocketSessionConfig defaultConfig = (SocketSessionConfig) service.getSessionConfig();\n        final NioTcpSession session = new NioTcpSession((NioTcpServer) service, socketChannel,\n                strategy.getSelectorForNewSession(this));\n\n        try {\n            socketChannel.configureBlocking(false);\n        } catch (IOException e) {\n            LOGGER.error(\"Unexpected exception, while configuring socket as non blocking\", e);\n            throw new RuntimeIoException(\"cannot configure socket as non-blocking\", e);\n        }\n\n        // apply the default service socket configuration\n        Boolean keepAlive = defaultConfig.isKeepAlive();\n        \n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = defaultConfig.isOobInline();\n        \n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = defaultConfig.isReuseAddress();\n        \n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = defaultConfig.isTcpNoDelay();\n        \n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = defaultConfig.getReceiveBufferSize();\n        \n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = defaultConfig.getSendBufferSize();\n        \n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = defaultConfig.getTrafficClass();\n        \n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = defaultConfig.getSoLinger();\n        \n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n        \n        // Set the secured fag if the service is to be used over SSL/TLS\n        if (service.isSecured()) {\n            session.setSecured(true);\n        }\n\n        // event session created\n        session.getFilterChain().processSessionCreated(session);\n\n        // add the session to the queue for being added to the selector\n        sessionsToConnect.add(session);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void flush(IoSession session) {\n        LOGGER.debug(\"scheduling session {} for writing\", session);\n        // add the session to the list of session to be registered for writing\n        flushingSessions.add((NioTcpSession) session);\n        // wake the selector for unlocking the I/O thread\n        wakeupWorker();\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads.\n     * It will also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n        // map for finding the keys associated with a given server\n        private Map<ServerSocketChannel, SelectionKey> serverKey = new HashMap<ServerSocketChannel, SelectionKey>();\n\n        // map for finding read keys associated with a given session\n        private Map<NioTcpSession, SelectionKey> sessionReadKey = new HashMap<NioTcpSession, SelectionKey>();\n\n        @Override\n        public void run() {\n            if (selector == null) {\n                LOGGER.debug(\"opening a new selector\");\n\n                try {\n                    selector = Selector.open();\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while opening a new Selector\", e);\n                }\n            }\n\n            for (;;) {\n                try {\n                    // pop server sockets for removing\n                    if (serversToRemove.size() > 0) {\n                        while (!serversToRemove.isEmpty()) {\n                            ServerSocketChannel channel = serversToRemove.poll();\n                            SelectionKey key = serverKey.remove(channel);\n\n                            if (key == null) {\n                                LOGGER.error(\"The server socket was already removed of the selector\");\n                            } else {\n                                key.cancel();\n                            }\n                        }\n                    }\n\n                    // pop new server sockets for accepting\n                    if (serversToAdd.size() > 0) {\n                        while (!serversToAdd.isEmpty()) {\n                            Object[] tmp = serversToAdd.poll();\n                            ServerSocketChannel channel = (ServerSocketChannel) tmp[0];\n                            SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT);\n                            key.attach(tmp);\n                        }\n                    }\n\n                    // pop new session for starting read/write\n                    if (sessionsToConnect.size() > 0) {\n                        while (!sessionsToConnect.isEmpty()) {\n                            NioTcpSession session = sessionsToConnect.poll();\n                            SelectionKey key = session.getSocketChannel().register(selector, SelectionKey.OP_READ);\n                            key.attach(session);\n                            sessionReadKey.put(session, key);\n\n                            // Switch to CONNECTED, only if the session is not secured, as the SSL Handshake\n                            // will occur later.\n                            if (!session.isSecured()) {\n                                session.setConnected();\n                                \n                                // fire the event\n                                ((AbstractIoService) session.getService()).fireSessionCreated(session);\n                                session.getFilterChain().processSessionOpened(session);\n                            }\n                        }\n                    }\n\n                    // pop session for close\n                    if (sessionsToClose.size() > 0) {\n                        while (!sessionsToClose.isEmpty()) {\n                            NioTcpSession session = sessionsToClose.poll();\n\n                            SelectionKey key = sessionReadKey.remove(session);\n                            key.cancel();\n\n                            // closing underlying socket\n                            session.getSocketChannel().close();\n                            // fire the event\n                            session.getFilterChain().processSessionClosed(session);\n                            ((AbstractIoService) session.getService()).fireSessionDestroyed(session);\n\n                        }\n                    }\n\n                    LOGGER.debug(\"selecting...\");\n                    int readyCount = selector.select(SELECT_TIMEOUT);\n                    LOGGER.debug(\"... done selecting : {}\", readyCount);\n\n                    if (readyCount > 0) {\n                        // process selected keys\n                        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n\n                        while (selectedKeys.hasNext()) {\n                            SelectionKey key = selectedKeys.next();\n                            selectedKeys.remove();\n\n                            if (!key.isValid()) {\n                                continue;\n                            }\n\n                            selector.selectedKeys().remove(key);\n\n                            if (key.isReadable()) {\n                                LOGGER.debug(\"readable client {}\", key);\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                SocketChannel channel = session.getSocketChannel();\n                                readBuffer.rewind();\n                                int readCount = channel.read(readBuffer);\n                                LOGGER.debug(\"read {} bytes\", readCount);\n\n                                if (readCount < 0) {\n                                    // session closed by the remote peer\n                                    LOGGER.debug(\"session closed by the remote peer\");\n                                    sessionsToClose.add(session);\n                                } else {\n                                    // we have read some data\n                                    // limit at the current position & rewind buffer back to start & push to the chain\n                                    readBuffer.flip();\n                                    \n                                    if (session.isSecured() && !session.isConnectedSecured()) {\n                                        // Process the SSL handshake now\n                                        //processHandShake(session, readBuffer);\n                                    } else {\n                                        session.getFilterChain().processMessageReceived(session, readBuffer);\n                                    }\n                                }\n                            }\n\n                            if (key.isWritable()) {\n                                if (LOGGER.isDebugEnabled()) {\n                                    LOGGER.debug(\"writable session : {}\", key.attachment());\n                                }\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                session.setNotRegisteredForWrite();\n\n                                // write from the session write queue\n                                boolean isEmpty = false;\n                                \n                                try {\n                                    Queue<WriteRequest> queue = session.acquireWriteQueue();\n    \n                                    do {\n                                        // get a write request from the queue\n                                        WriteRequest wreq = queue.peek();\n                                        \n                                        if (wreq == null) {\n                                            break;\n                                        }\n                                        \n                                        ByteBuffer buf = (ByteBuffer) wreq.getMessage();\n    \n                                        int wrote = session.getSocketChannel().write(buf);\n                                        \n                                        if (LOGGER.isDebugEnabled()) {\n                                            LOGGER.debug(\"wrote {} bytes to {}\", wrote, session);\n                                        }\n    \n                                        if (buf.remaining() == 0) {\n                                            // completed write request, let's remove\n                                            // it\n                                            queue.remove();\n                                            // complete the future\n                                            DefaultWriteFuture future = (DefaultWriteFuture) wreq.getFuture();\n                                            \n                                            if (future != null) {\n                                                future.complete();\n                                            }\n                                        } else {\n                                            // output socket buffer is full, we need\n                                            // to give up until next selection for\n                                            // writing\n                                            break;\n                                        }\n                                    } while (!queue.isEmpty());\n                                    \n                                    isEmpty = queue.isEmpty();\n                                } finally {\n                                    session.releaseWriteQueue();\n                                }\n\n                                // if the session is no more interested in writing, we need\n                                // to stop listening for OP_WRITE events\n                                if (isEmpty) {\n                                    // a key registered for read ? (because we can have a\n                                    // Selector for reads and another for the writes\n                                    SelectionKey readKey = sessionReadKey.get(session);\n                                    \n                                    if (readKey != null) {\n                                        LOGGER.debug(\"registering key for only reading\");\n                                        SelectionKey mykey = session.getSocketChannel().register(selector,\n                                                SelectionKey.OP_READ, session);\n                                        sessionReadKey.put(session, mykey);\n                                    } else {\n                                        LOGGER.debug(\"cancel key for writing\");\n                                        session.getSocketChannel().keyFor(selector).cancel();\n                                    }\n                                }\n                            }\n\n                            if (key.isAcceptable()) {\n                                LOGGER.debug(\"acceptable new client {}\", key);\n                                ServerSocketChannel serverSocket = (ServerSocketChannel) ((Object[]) key.attachment())[0];\n                                IoServer server = (IoServer) (((Object[]) key.attachment())[1]);\n                                // accepted connection\n                                SocketChannel newClientChannel = serverSocket.accept();\n                                LOGGER.debug(\"client accepted\");\n                                // and give it's to the strategy\n                                strategy.getSelectorForNewSession(NioSelectorProcessor.this).createSession(server,\n                                        newClientChannel);\n                            }\n\n                        }\n                    }\n\n                    // registering session with data in the write queue for\n                    // writing\n                    while (!flushingSessions.isEmpty()) {\n                        NioTcpSession session = flushingSessions.poll();\n                        // a key registered for read ? (because we can have a\n                        // Selector for reads and another for the writes\n                        SelectionKey readKey = sessionReadKey.get(session);\n                        if (readKey != null) {\n                            // register for read/write\n                            SelectionKey key = session.getSocketChannel().register(selector,\n                                    SelectionKey.OP_READ | SelectionKey.OP_WRITE, session);\n\n                            sessionReadKey.put(session, key);\n\n                        } else {\n                            session.getSocketChannel().register(selector, SelectionKey.OP_WRITE, session);\n                        }\n                    }\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while selecting selector\", e);\n                }\n\n                // stop the worker if needed\n                workerLock.lock();\n                try {\n                    if (selector.keys().isEmpty()) {\n                        worker = null;\n                        break;\n                    }\n                } finally {\n                    workerLock.unlock();\n                }\n            }\n        }\n    }\n}\n","lineNo":405}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\n\npackage org.apache.mina.transport.tcp;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.mina.api.IoServer;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.service.AbstractIoService;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.apache.mina.service.SelectorStrategy;\nimport org.apache.mina.session.DefaultWriteFuture;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.transport.tcp.nio.NioTcpServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * \n * A {@link SelectorProcessor} for processing NIO based {@link IoSession}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n */\npublic class NioSelectorProcessor implements SelectorProcessor {\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    private SelectorStrategy strategy;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NioSelectorProcessor.class);\n\n    private Map<SocketAddress, ServerSocketChannel> serverSocketChannels = new ConcurrentHashMap<SocketAddress, ServerSocketChannel>();\n\n    private ByteBuffer readBuffer;\n\n    /**\n     * new binded server to add to the selector {ServerSocketChannel, IoServer}\n     */\n    private final Queue<Object[]> serversToAdd = new ConcurrentLinkedQueue<Object[]>();\n\n    /** server to remove of the selector */\n    private final Queue<ServerSocketChannel> serversToRemove = new ConcurrentLinkedQueue<ServerSocketChannel>();\n\n    /**\n     * new session freshly accepted, placed here for being added to the selector\n     */\n    private final Queue<NioTcpSession> sessionsToConnect = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** session to be removed of the selector */\n    private final Queue<NioTcpSession> sessionsToClose = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<NioTcpSession> flushingSessions = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    private Selector selector;\n\n    // Lock for Selector worker, using default. can look into fairness later\n    private Lock workerLock = new ReentrantLock();\n\n    public NioSelectorProcessor(String name, SelectorStrategy strategy) {\n        this.strategy = strategy;\n\n        // TODO : configurable parameter\n        readBuffer = ByteBuffer.allocate(1024);\n    }\n\n    /**\n     * Add a bound server channel for starting accepting new client connections.\n     * \n     * @param serverChannel\n     */\n    private void add(ServerSocketChannel serverChannel, IoServer server) {\n        LOGGER.debug(\"adding a server channel {} for server {}\", serverChannel, server);\n        serversToAdd.add(new Object[] { serverChannel, server });\n        wakeupWorker();\n    }\n\n    private SelectorWorker worker = null;\n\n    private void wakeupWorker() {\n        workerLock.lock();\n        try {\n            if (worker == null) {\n                worker = new SelectorWorker();\n                worker.start();\n            }\n        } finally {\n            workerLock.unlock();\n        }\n\n        if (selector != null) {\n            selector.wakeup();\n        }\n    }\n\n    @Override\n    public void bindAndAcceptAddress(IoServer server, SocketAddress address) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        if (server instanceof AbstractTcpServer) {\n            serverSocketChannel.socket().setReuseAddress(((AbstractTcpServer) server).isReuseAddress());\n        }\n        serverSocketChannel.socket().bind(address);\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannels.put(address, serverSocketChannel);\n        add(serverSocketChannel, server);\n    }\n\n    @Override\n    public void unbind(SocketAddress address) throws IOException {\n        ServerSocketChannel channel = serverSocketChannels.get(address);\n        channel.socket().close();\n        channel.close();\n        if (serverSocketChannels.remove(address) == null) {\n            LOGGER.warn(\"The server channel for address {} was already unbound\", address);\n        }\n        LOGGER.debug(\"Removing a server channel {}\", channel);\n        serversToRemove.add(channel);\n        wakeupWorker();\n    }\n\n    @Override\n    public void createSession(IoService service, Object clientSocket) {\n        LOGGER.debug(\"create session\");\n        final SocketChannel socketChannel = (SocketChannel) clientSocket;\n        final SocketSessionConfig defaultConfig = (SocketSessionConfig) service.getSessionConfig();\n        final NioTcpSession session = new NioTcpSession((NioTcpServer) service, socketChannel,\n                strategy.getSelectorForNewSession(this));\n\n        try {\n            socketChannel.configureBlocking(false);\n        } catch (IOException e) {\n            LOGGER.error(\"Unexpected exception, while configuring socket as non blocking\", e);\n        }\n\n        // apply the default service socket configuration\n\n        Boolean keepAlive = defaultConfig.isKeepAlive();\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = defaultConfig.isOobInline();\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = defaultConfig.isReuseAddress();\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = defaultConfig.isTcpNoDelay();\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = defaultConfig.getReceiveBufferSize();\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = defaultConfig.getSendBufferSize();\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = defaultConfig.getTrafficClass();\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = defaultConfig.getSoLinger();\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        // event session created\n        session.getFilterChain().processSessionCreated(session);\n\n        // add the session to the queue for being added to the selector\n        sessionsToConnect.add(session);\n        wakeupWorker();\n    }\n\n    /**\n     * The worker processing incoming session creation and destruction requests.\n     * It will also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n        // map for finding the keys associated with a given server\n        private Map<ServerSocketChannel, SelectionKey> serverKey = new HashMap<ServerSocketChannel, SelectionKey>();\n\n        // map for finding read keys associated with a given session\n        private Map<NioTcpSession, SelectionKey> sessionReadKey = new HashMap<NioTcpSession, SelectionKey>();\n\n        @Override\n        public void run() {\n            if (selector == null) {\n                LOGGER.debug(\"opening a new selector\");\n\n                try {\n                    selector = Selector.open();\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while opening a new Selector\", e);\n                }\n            }\n\n            for (;;) {\n                try {\n                    // pop server sockets for removing\n                    if (serversToRemove.size() > 0) {\n                        while (!serversToRemove.isEmpty()) {\n                            ServerSocketChannel channel = serversToRemove.poll();\n                            SelectionKey key = serverKey.remove(channel);\n\n                            if (key == null) {\n                                LOGGER.error(\"The server socket was already removed of the selector\");\n                            } else {\n                                key.cancel();\n                            }\n                        }\n                    }\n\n                    // pop new server sockets for accepting\n                    if (serversToAdd.size() > 0) {\n                        while (!serversToAdd.isEmpty()) {\n                            Object[] tmp = serversToAdd.poll();\n                            ServerSocketChannel channel = (ServerSocketChannel) tmp[0];\n                            SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT);\n                            key.attach(tmp);\n                        }\n                    }\n\n                    // pop new session for starting read/write\n                    if (sessionsToConnect.size() > 0) {\n                        while (!sessionsToConnect.isEmpty()) {\n                            NioTcpSession session = sessionsToConnect.poll();\n                            SelectionKey key = session.getSocketChannel().register(selector, SelectionKey.OP_READ);\n                            key.attach(session);\n                            sessionReadKey.put(session, key);\n                            session.setConnected();\n                            // fire the event\n                            ((AbstractIoService) session.getService()).fireSessionCreated(session);\n                            session.getFilterChain().processSessionOpened(session);\n                        }\n                    }\n\n                    // pop session for close\n                    if (sessionsToClose.size() > 0) {\n                        while (!sessionsToClose.isEmpty()) {\n                            NioTcpSession session = sessionsToClose.poll();\n\n                            SelectionKey key = sessionReadKey.remove(session);\n                            key.cancel();\n\n                            // needed ?\n                            session.getSocketChannel().close();\n                            // fire the event\n                            session.getFilterChain().processSessionClosed(session);\n                            ((AbstractIoService) session.getService()).fireSessionDestroyed(session);\n\n                        }\n                    }\n\n                    LOGGER.debug(\"selecting...\");\n                    int readyCount = selector.select(SELECT_TIMEOUT);\n                    LOGGER.debug(\"... done selecting : {}\", readyCount);\n\n                    if (readyCount > 0) {\n\n                        // process selected keys\n                        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n\n                        while (selectedKeys.hasNext()) {\n                            SelectionKey key = selectedKeys.next();\n                            selectedKeys.remove();\n\n                            if (!key.isValid()) {\n                                continue;\n                            }\n                            selector.selectedKeys().remove(key);\n\n                            if (key.isReadable()) {\n                                LOGGER.debug(\"readable client {}\", key);\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                SocketChannel channel = session.getSocketChannel();\n                                readBuffer.rewind();\n                                int readCount = channel.read(readBuffer);\n                                LOGGER.debug(\"read {} bytes\", readCount);\n                                if (readCount < 0) {\n                                    // session closed by the remote peer\n                                    LOGGER.debug(\"session closed by the remote peer\");\n                                    sessionsToClose.add(session);\n                                } else {\n                                    // we have read some data\n                                    // limit at the current position & rewind buffer back to start & push to the chain\n                                    readBuffer.flip();\n                                    session.getFilterChain().processMessageReceived(session, readBuffer);\n                                }\n\n                            }\n                            if (key.isWritable()) {\n                                if (LOGGER.isDebugEnabled()) {\n                                    LOGGER.debug(\"writable session : {}\", key.attachment());\n                                }\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                session.setNotRegisteredForWrite();\n                                // write from the session write queue\n                                Queue<WriteRequest> queue = session.getWriteQueue();\n                                do {\n                                    // get a write request from the queue\n                                    WriteRequest wreq = queue.peek();\n                                    if (wreq == null) {\n                                        break;\n                                    }\n                                    ByteBuffer buf = (ByteBuffer) wreq.getMessage();\n\n                                    if (LOGGER.isDebugEnabled()) {\n                                        int wrote = session.getSocketChannel().write(buf);\n                                        LOGGER.debug(\"wrote {} bytes to {}\", wrote, session);\n                                    }\n\n                                    if (buf.remaining() == 0) {\n                                        // completed write request, let's remove\n                                        // it\n                                        queue.remove();\n                                        // complete the future\n                                        ((DefaultWriteFuture) wreq.getFuture()).complete();\n                                    } else {\n                                        // output socket buffer is full, we need\n                                        // to give up until next selection for\n                                        // writing\n                                        break;\n                                    }\n\n                                } while (!queue.isEmpty());\n\n                                // if the session is no more interested in writing, we need\n                                // to stop listening for OP_WRITE events\n                                if (queue.isEmpty()) {\n                                    // a key registered for read ? (because we can have a\n                                    // Selector for reads and another for the writes\n                                    SelectionKey readKey = sessionReadKey.get(session);\n                                    if (readKey != null) {\n                                        LOGGER.debug(\"registering key for only reading\");\n                                        SelectionKey mykey = session.getSocketChannel().register(selector,\n                                                SelectionKey.OP_READ, session);\n                                        sessionReadKey.put(session, mykey);\n                                    } else {\n                                        LOGGER.debug(\"cancel key for writing\");\n                                        session.getSocketChannel().keyFor(selector).cancel();\n                                    }\n                                }\n\n                            }\n\n                            if (key.isAcceptable()) {\n                                LOGGER.debug(\"acceptable new client {}\", key);\n                                ServerSocketChannel serverSocket = (ServerSocketChannel) ((Object[]) key.attachment())[0];\n                                IoServer server = (IoServer) (((Object[]) key.attachment())[1]);\n                                // accepted connection\n                                SocketChannel newClientChannel = serverSocket.accept();\n                                LOGGER.debug(\"client accepted\");\n                                // and give it's to the strategy\n                                strategy.getSelectorForNewSession(NioSelectorProcessor.this).createSession(server,\n                                        newClientChannel);\n                            }\n\n                        }\n                    }\n\n                    // registering session with data in the write queue for\n                    // writing\n                    while (!flushingSessions.isEmpty()) {\n                        NioTcpSession session = flushingSessions.poll();\n                        // a key registered for read ? (because we can have a\n                        // Selector for reads and another for the writes\n                        SelectionKey readKey = sessionReadKey.get(session);\n                        if (readKey != null) {\n                            // register for read/write\n                            SelectionKey key = session.getSocketChannel().register(selector,\n                                    SelectionKey.OP_READ | SelectionKey.OP_WRITE, session);\n\n                            sessionReadKey.put(session, key);\n\n                        } else {\n                            session.getSocketChannel().register(selector, SelectionKey.OP_WRITE, session);\n                        }\n                    }\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while selecting selector\", e);\n                }\n\n                // stop the worker if needed\n                workerLock.lock();\n                try {\n                    if (selector.keys().isEmpty()) {\n                        worker = null;\n                        break;\n                    }\n                } finally {\n                    workerLock.unlock();\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void flush(IoSession session) {\n        LOGGER.debug(\"scheduling session {} for writing\", session.toString());\n        // add the session to the list of session to be registered for writing\n        // wake the selector\n        flushingSessions.add((NioTcpSession) session);\n        wakeupWorker();\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\n\npackage org.apache.mina.transport.tcp;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.mina.api.IoServer;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.api.RuntimeIoException;\nimport org.apache.mina.service.AbstractIoService;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.apache.mina.service.SelectorStrategy;\nimport org.apache.mina.session.DefaultWriteFuture;\nimport org.apache.mina.session.WriteRequest;\nimport org.apache.mina.transport.tcp.nio.NioTcpServer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * \n * A {@link SelectorProcessor} for processing NIO based {@link IoSession}.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n */\npublic class NioSelectorProcessor implements SelectorProcessor {\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    private SelectorStrategy strategy;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NioSelectorProcessor.class);\n\n    private Map<SocketAddress, ServerSocketChannel> serverSocketChannels = new ConcurrentHashMap<SocketAddress, ServerSocketChannel>();\n\n    // read buffer for all the incoming bytes\n    private ByteBuffer readBuffer;\n\n    // the thread polling and processing the I/O events \n    private SelectorWorker worker = null;\n\n    /**\n     * new binded server to add to the selector {ServerSocketChannel, IoServer}\n     * jvermillard : FIXME the typing is ugly !!!\n     */\n    private final Queue<Object[]> serversToAdd = new ConcurrentLinkedQueue<Object[]>();\n\n    /** server to remove of the selector */\n    private final Queue<ServerSocketChannel> serversToRemove = new ConcurrentLinkedQueue<ServerSocketChannel>();\n\n    /**\n     * new session freshly accepted, placed here for being added to the selector\n     */\n    private final Queue<NioTcpSession> sessionsToConnect = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** session to be removed of the selector */\n    private final Queue<NioTcpSession> sessionsToClose = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<NioTcpSession> flushingSessions = new ConcurrentLinkedQueue<NioTcpSession>();\n\n    private Selector selector;\n\n    // Lock for Selector worker, using default. can look into fairness later.\n    // We need to think about a lock less mechanism here.\n    private Lock workerLock = new ReentrantLock();\n\n    public NioSelectorProcessor(String name, SelectorStrategy strategy) {\n        this.strategy = strategy;\n\n        // FIXME : configurable parameter\n        readBuffer = ByteBuffer.allocate(1024);\n    }\n\n    /**\n     * Add a bound server channel for starting accepting new client connections.\n     * \n     * @param serverChannel\n     */\n    private void add(ServerSocketChannel serverChannel, IoServer server) {\n        LOGGER.debug(\"adding a server channel {} for server {}\", serverChannel, server);\n        serversToAdd.add(new Object[] { serverChannel, server });\n        wakeupWorker();\n    }\n\n    /**\n     * Wake the I/O worker thread and if none exists, create a new one\n     * FIXME : too much locking there ?\n     */\n    private void wakeupWorker() {\n        workerLock.lock();\n        try {\n            if (worker == null) {\n                worker = new SelectorWorker();\n                worker.start();\n            }\n        } finally {\n            workerLock.unlock();\n        }\n\n        if (selector != null) {\n            selector.wakeup();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bindAndAcceptAddress(IoServer server, SocketAddress address) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n        // FIXME : should be \"genericified\"\n        if (server instanceof AbstractTcpServer) {\n            serverSocketChannel.socket().setReuseAddress(((AbstractTcpServer) server).isReuseAddress());\n        }\n        serverSocketChannel.socket().bind(address);\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannels.put(address, serverSocketChannel);\n        add(serverSocketChannel, server);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void unbind(SocketAddress address) throws IOException {\n        ServerSocketChannel channel = serverSocketChannels.get(address);\n        channel.socket().close();\n        channel.close();\n        if (serverSocketChannels.remove(address) == null) {\n            LOGGER.warn(\"The server channel for address {} was already unbound\", address);\n        }\n        LOGGER.debug(\"Removing a server channel {}\", channel);\n        serversToRemove.add(channel);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void createSession(IoService service, Object clientSocket) {\n        LOGGER.debug(\"create session\");\n        final SocketChannel socketChannel = (SocketChannel) clientSocket;\n        final SocketSessionConfig defaultConfig = (SocketSessionConfig) service.getSessionConfig();\n        final NioTcpSession session = new NioTcpSession((NioTcpServer) service, socketChannel,\n                strategy.getSelectorForNewSession(this));\n\n        try {\n            socketChannel.configureBlocking(false);\n        } catch (IOException e) {\n            LOGGER.error(\"Unexpected exception, while configuring socket as non blocking\", e);\n            throw new RuntimeIoException(\"cannot configure socket as non-blocking\", e);\n        }\n\n        // apply the default service socket configuration\n\n        Boolean keepAlive = defaultConfig.isKeepAlive();\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = defaultConfig.isOobInline();\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = defaultConfig.isReuseAddress();\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = defaultConfig.isTcpNoDelay();\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = defaultConfig.getReceiveBufferSize();\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = defaultConfig.getSendBufferSize();\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = defaultConfig.getTrafficClass();\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = defaultConfig.getSoLinger();\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        // event session created\n        session.getFilterChain().processSessionCreated(session);\n\n        // add the session to the queue for being added to the selector\n        sessionsToConnect.add(session);\n        wakeupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void flush(IoSession session) {\n        LOGGER.debug(\"scheduling session {} for writing\", session);\n        // add the session to the list of session to be registered for writing\n        flushingSessions.add((NioTcpSession) session);\n        // wake the selector for unlocking the I/O thread\n        wakeupWorker();\n    }\n\n    /** \n     * {@inheritDoc}\n     */\n    @Override\n    public void scheduleForClose(IoSession session) {\n        LOGGER.debug(\"scheduling session {} for close\", session);\n        // add the session in the list of session for close.\n        sessionsToClose.add((NioTcpSession) session);\n        // wake the selector for unlocking the I/O thread\n        wakeupWorker();\n    }\n\n    /**\n     * The worker processing incoming session creation, session destruction requests, session write and reads.\n     * It will also bind new servers.\n     */\n    private class SelectorWorker extends Thread {\n        // map for finding the keys associated with a given server\n        private Map<ServerSocketChannel, SelectionKey> serverKey = new HashMap<ServerSocketChannel, SelectionKey>();\n\n        // map for finding read keys associated with a given session\n        private Map<NioTcpSession, SelectionKey> sessionReadKey = new HashMap<NioTcpSession, SelectionKey>();\n\n        @Override\n        public void run() {\n            if (selector == null) {\n                LOGGER.debug(\"opening a new selector\");\n\n                try {\n                    selector = Selector.open();\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while opening a new Selector\", e);\n                }\n            }\n\n            for (;;) {\n                try {\n                    // pop server sockets for removing\n                    if (serversToRemove.size() > 0) {\n                        while (!serversToRemove.isEmpty()) {\n                            ServerSocketChannel channel = serversToRemove.poll();\n                            SelectionKey key = serverKey.remove(channel);\n\n                            if (key == null) {\n                                LOGGER.error(\"The server socket was already removed of the selector\");\n                            } else {\n                                key.cancel();\n                            }\n                        }\n                    }\n\n                    // pop new server sockets for accepting\n                    if (serversToAdd.size() > 0) {\n                        while (!serversToAdd.isEmpty()) {\n                            Object[] tmp = serversToAdd.poll();\n                            ServerSocketChannel channel = (ServerSocketChannel) tmp[0];\n                            SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT);\n                            key.attach(tmp);\n                        }\n                    }\n\n                    // pop new session for starting read/write\n                    if (sessionsToConnect.size() > 0) {\n                        while (!sessionsToConnect.isEmpty()) {\n                            NioTcpSession session = sessionsToConnect.poll();\n                            SelectionKey key = session.getSocketChannel().register(selector, SelectionKey.OP_READ);\n                            key.attach(session);\n                            sessionReadKey.put(session, key);\n                            session.setConnected();\n                            // fire the event\n                            ((AbstractIoService) session.getService()).fireSessionCreated(session);\n                            session.getFilterChain().processSessionOpened(session);\n                        }\n                    }\n\n                    // pop session for close\n                    if (sessionsToClose.size() > 0) {\n                        while (!sessionsToClose.isEmpty()) {\n                            NioTcpSession session = sessionsToClose.poll();\n\n                            SelectionKey key = sessionReadKey.remove(session);\n                            key.cancel();\n\n                            // closing underlying socket\n                            session.getSocketChannel().close();\n                            // fire the event\n                            session.getFilterChain().processSessionClosed(session);\n                            ((AbstractIoService) session.getService()).fireSessionDestroyed(session);\n\n                        }\n                    }\n\n                    LOGGER.debug(\"selecting...\");\n                    int readyCount = selector.select(SELECT_TIMEOUT);\n                    LOGGER.debug(\"... done selecting : {}\", readyCount);\n\n                    if (readyCount > 0) {\n\n                        // process selected keys\n                        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n\n                        while (selectedKeys.hasNext()) {\n                            SelectionKey key = selectedKeys.next();\n                            selectedKeys.remove();\n\n                            if (!key.isValid()) {\n                                continue;\n                            }\n                            selector.selectedKeys().remove(key);\n\n                            if (key.isReadable()) {\n                                LOGGER.debug(\"readable client {}\", key);\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                SocketChannel channel = session.getSocketChannel();\n                                readBuffer.rewind();\n                                int readCount = channel.read(readBuffer);\n                                LOGGER.debug(\"read {} bytes\", readCount);\n                                if (readCount < 0) {\n                                    // session closed by the remote peer\n                                    LOGGER.debug(\"session closed by the remote peer\");\n                                    sessionsToClose.add(session);\n                                } else {\n                                    // we have read some data\n                                    // limit at the current position & rewind buffer back to start & push to the chain\n                                    readBuffer.flip();\n                                    session.getFilterChain().processMessageReceived(session, readBuffer);\n                                }\n\n                            }\n                            if (key.isWritable()) {\n                                if (LOGGER.isDebugEnabled()) {\n                                    LOGGER.debug(\"writable session : {}\", key.attachment());\n                                }\n                                NioTcpSession session = (NioTcpSession) key.attachment();\n                                session.setNotRegisteredForWrite();\n                                // write from the session write queue\n                                Queue<WriteRequest> queue = session.getWriteQueue();\n                                do {\n                                    // get a write request from the queue\n                                    WriteRequest wreq = queue.peek();\n                                    if (wreq == null) {\n                                        break;\n                                    }\n                                    ByteBuffer buf = (ByteBuffer) wreq.getMessage();\n\n                                    if (LOGGER.isDebugEnabled()) {\n                                        int wrote = session.getSocketChannel().write(buf);\n                                        LOGGER.debug(\"wrote {} bytes to {}\", wrote, session);\n                                    }\n\n                                    if (buf.remaining() == 0) {\n                                        // completed write request, let's remove\n                                        // it\n                                        queue.remove();\n                                        // complete the future\n                                        DefaultWriteFuture future = (DefaultWriteFuture) wreq.getFuture();\n                                        if (future != null) {\n                                            future.complete();\n                                        }\n                                    } else {\n                                        // output socket buffer is full, we need\n                                        // to give up until next selection for\n                                        // writing\n                                        break;\n                                    }\n\n                                } while (!queue.isEmpty());\n\n                                // if the session is no more interested in writing, we need\n                                // to stop listening for OP_WRITE events\n                                if (queue.isEmpty()) {\n                                    // a key registered for read ? (because we can have a\n                                    // Selector for reads and another for the writes\n                                    SelectionKey readKey = sessionReadKey.get(session);\n                                    if (readKey != null) {\n                                        LOGGER.debug(\"registering key for only reading\");\n                                        SelectionKey mykey = session.getSocketChannel().register(selector,\n                                                SelectionKey.OP_READ, session);\n                                        sessionReadKey.put(session, mykey);\n                                    } else {\n                                        LOGGER.debug(\"cancel key for writing\");\n                                        session.getSocketChannel().keyFor(selector).cancel();\n                                    }\n                                }\n\n                            }\n\n                            if (key.isAcceptable()) {\n                                LOGGER.debug(\"acceptable new client {}\", key);\n                                ServerSocketChannel serverSocket = (ServerSocketChannel) ((Object[]) key.attachment())[0];\n                                IoServer server = (IoServer) (((Object[]) key.attachment())[1]);\n                                // accepted connection\n                                SocketChannel newClientChannel = serverSocket.accept();\n                                LOGGER.debug(\"client accepted\");\n                                // and give it's to the strategy\n                                strategy.getSelectorForNewSession(NioSelectorProcessor.this).createSession(server,\n                                        newClientChannel);\n                            }\n\n                        }\n                    }\n\n                    // registering session with data in the write queue for\n                    // writing\n                    while (!flushingSessions.isEmpty()) {\n                        NioTcpSession session = flushingSessions.poll();\n                        // a key registered for read ? (because we can have a\n                        // Selector for reads and another for the writes\n                        SelectionKey readKey = sessionReadKey.get(session);\n                        if (readKey != null) {\n                            // register for read/write\n                            SelectionKey key = session.getSocketChannel().register(selector,\n                                    SelectionKey.OP_READ | SelectionKey.OP_WRITE, session);\n\n                            sessionReadKey.put(session, key);\n\n                        } else {\n                            session.getSocketChannel().register(selector, SelectionKey.OP_WRITE, session);\n                        }\n                    }\n                } catch (IOException e) {\n                    LOGGER.error(\"IOException while selecting selector\", e);\n                }\n\n                // stop the worker if needed\n                workerLock.lock();\n                try {\n                    if (selector.keys().isEmpty()) {\n                        worker = null;\n                        break;\n                    }\n                } finally {\n                    workerLock.unlock();\n                }\n            }\n        }\n    }\n}\n","lineNo":410}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.DefaultIoFilterController;\nimport org.apache.mina.filterchain.IoFilterController;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** The {@link SelectorProcessor} used for handling this session writing */\n    private SelectorProcessor writeProcessor;\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    /** attributes map */\n    private final Map<Object, Object> attributes = new ConcurrentHashMap<Object, Object>(4);\n\n    /** unique identifier generator */\n    private static final AtomicLong NEXT_ID = new AtomicLong(0);\n\n    protected final Object stateMonitor = new Object();\n\n    protected SessionState state;\n\n    /** is this session registered for being polled for write ready events */\n    private AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorProcessor} */\n    private Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    private IoFilterController filterProcessor;\n\n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param writeProcessor the processor in charge of processing this session write queue\n     */\n    public AbstractIoSession(IoService service, SelectorProcessor writeProcessor) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.writeProcessor = writeProcessor;\n        this.filterProcessor = new DefaultIoFilterController(service.getFilters());\n\n        LOG.debug(\"Created new session with id : {}\", id);\n        synchronized (stateMonitor) {\n            this.state = SessionState.CREATED;\n        }\n    }\n\n    public SessionState getState() {\n        return state;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T getAttribute(String name) {\n        return (T) attributes.get(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T setAttribute(String name, T value) {\n        return (T) attributes.put(name, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsAttribute(Object name) {\n        return attributes.containsKey(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Object removeAttribute(Object name) {\n        return attributes.remove(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<Object> getAttributeNames() {\n        return attributes.keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(Object message) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n        if (state == SessionState.CLOSED || state == SessionState.CLOSING) {\n            // TODO actually we just just shallow the message if the session is closed/closing\n            LOG.error(\"writing to closed or closing session\");\n            return;\n        }\n\n        // process the queue\n        getFilterChain().processMessageWriting(this, message);\n\n    }\n\n    public void enqueueWriteRequest(Object message) {\n        writeQueue.add(new DefaultWriteRequest(message));\n\n        // If it wasn't, we register this session as interested to write.\n        // It's done in atomic fashion for avoiding two concurrent registering.\n        if (!registeredForWrite.getAndSet(true)) {\n            writeProcessor.flush(this);\n        }\n    }\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(Object message) {\n        write(message);\n        // TODO implements IoFuture\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> getWriteQueue() {\n        return writeQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFilterController getFilterChain() {\n        return filterProcessor;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.session;\n\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.api.IoFuture;\nimport org.apache.mina.api.IoService;\nimport org.apache.mina.api.IoSession;\nimport org.apache.mina.filterchain.DefaultIoFilterController;\nimport org.apache.mina.filterchain.IoFilterController;\nimport org.apache.mina.service.SelectorProcessor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Base implementation of {@link IoSession} shared with all the different transports.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n    /** The logger for this class */\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractIoSession.class);\n\n    /** The session's unique identifier */\n    private final long id;\n\n    /** The session's creation time */\n    private final long creationTime;\n\n    /** The service this session is associated with */\n    private final IoService service;\n\n    /** The {@link SelectorProcessor} used for handling this session writing */\n    private SelectorProcessor writeProcessor;\n\n    /** The number of bytes read since this session has been created */\n    private volatile long readBytes;\n\n    /** The number of bytes written since this session has been created */\n    private volatile long writtenBytes;\n\n    /** Last time something was read for this session */\n    private volatile long lastReadTime;\n\n    /** Last time something was written for this session */\n    private volatile long lastWriteTime;\n\n    /** attributes map */\n    private final Map<Object, Object> attributes = new ConcurrentHashMap<Object, Object>(4);\n\n    /** unique identifier generator */\n    private static final AtomicLong NEXT_ID = new AtomicLong(0);\n\n    protected final Object stateMonitor = new Object();\n\n    protected volatile SessionState state;\n\n    /** is this session registered for being polled for write ready events */\n    private AtomicBoolean registeredForWrite = new AtomicBoolean();\n\n    /** the queue of pending writes for the session, to be dequeued by the {@link SelectorProcessor} */\n    private Queue<WriteRequest> writeQueue = new DefaultWriteQueue();\n\n    private IoFilterController filterProcessor;\n\n    /**\n     * Create an {@link org.apache.mina.api.IoSession} with a unique identifier (\n     * {@link org.apache.mina.api.IoSession#getId()}) and an associated {@link IoService}\n     * \n     * @param service the service this session is associated with\n     * @param writeProcessor the processor in charge of processing this session write queue\n     */\n    public AbstractIoSession(IoService service, SelectorProcessor writeProcessor) {\n        // generated a unique id\n        id = NEXT_ID.getAndIncrement();\n        creationTime = System.currentTimeMillis();\n        this.service = service;\n        this.writeProcessor = writeProcessor;\n        this.filterProcessor = new DefaultIoFilterController(service.getFilters());\n\n        LOG.debug(\"Created new session with id : {}\", id);\n        synchronized (stateMonitor) {\n            this.state = SessionState.CREATED;\n        }\n    }\n\n    public SessionState getState() {\n        return state;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoService getService() {\n        return service;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T getAttribute(String name) {\n        return (T) attributes.get(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T setAttribute(String name, T value) {\n        return (T) attributes.put(name, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsAttribute(Object name) {\n        return attributes.containsKey(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Object removeAttribute(Object name) {\n        return attributes.remove(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<Object> getAttributeNames() {\n        return attributes.keySet();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(Object message) {\n        doWriteWithFuture(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFuture<Void> writeWithFuture(Object message) {\n        IoFuture<Void> future = new DefaultWriteFuture();\n        doWriteWithFuture(message, future);\n        return future;\n    }\n\n    private void doWriteWithFuture(Object message, IoFuture<Void> future) {\n        LOG.debug(\"writing message {} to session {}\", message, this);\n        if (state == SessionState.CLOSED || state == SessionState.CLOSING) {\n            LOG.error(\"writing to closed or closing session, the message is discarded\");\n            return;\n        }\n\n        // process the queue\n        getFilterChain().processMessageWriting(this, message, future);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteRequest enqueueWriteRequest(Object message) {\n        DefaultWriteRequest request = new DefaultWriteRequest(message);\n        writeQueue.add(request);\n\n        // If it wasn't, we register this session as interested to write.\n        // It's done in atomic fashion for avoiding two concurrent registering.\n        if (!registeredForWrite.getAndSet(true)) {\n            writeProcessor.flush(this);\n        }\n\n        return request;\n    }\n\n    public void setNotRegisteredForWrite() {\n        registeredForWrite.set(false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<WriteRequest> getWriteQueue() {\n        return writeQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoFilterController getFilterChain() {\n        return filterProcessor;\n    }\n}\n","lineNo":253}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChainBuilder;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoServiceListenerSupport;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory.getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new ConcurrentHashMap<Class<?>, AtomicInteger>();\n\n    /** A lock used to protect the processor creation */\n    private final Object lock = new Object();\n\n    /** This IoProcessor instance name */\n    private final String threadName;\n\n    /** The executor to use when we need to start the inner Processor */\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        // add the session to the queue if it's not already\n        // in the queue, then wake up the select()\n        if (session.setScheduledForFlush( true )) {\n            flushingSessions.add(session);\n            wakeup();\n        }\n    }\n\n    private void scheduleFlush(T session) {\n        // add the session to the queue if it's not already\n        // in the queue\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        trafficControllingSessions.add(session);\n        wakeup();\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (T session = newSessions.poll(); session != null; session = newSessions.poll()) {\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    /**\n     * Process a new session :\n     * - initialize it\n     * - create its chain\n     * - fire the CREATED listeners if any\n     *\n     * @param session The session to create\n     * @return true if the session has been registered\n     */\n    private boolean addNow(T session) {\n        boolean registered = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            IoFilterChainBuilder chainBuilder = session.getService().getFilterChainBuilder();\n            chainBuilder.buildFilterChain(session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            // Propagate the SESSION_CREATED event up to the chain\n            IoServiceListenerSupport listeners = ((AbstractIoService) session.getService()).getListeners();\n            listeners.fireSessionCreated(session);\n        } catch (Throwable e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            \n            try {\n                destroy(session);\n            } catch (Exception e1) {\n                ExceptionMonitor.getInstance().exceptionCaught(e1);\n            } finally {\n                registered = false;\n            }\n        }\n        \n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (T session = removingSessions.poll();session != null;session = removingSessions.poll()) {\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n                case OPENED:\n                    // Try to remove this session\n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if channel is already closed\n                    break;\n    \n                case OPENING:\n                    // Remove session from the newSessions queue and\n                    // remove it\n                    newSessions.remove(session);\n    \n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n                    \n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n        \n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object message = req.getMessage();\n            \n            if (message instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer)message;\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            \n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended()) {\n            // add the session to the queue, if it's not already there\n            if (session.setScheduledForFlush(true)) {\n                flushingSessions.add(session);\n            }       \n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        \n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    \n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class.isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config).isCloseOnPortUnreachable()) {\n                    scheduleRemove(session);\n                }\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    /**\n     * Write all the pending messages\n     */\n    private void flush(long currentTime) {\n        if (flushingSessions.isEmpty()) {\n            return;\n        }\n\n        do {\n            T session = flushingSessions.poll(); // the same one with firstSession\n            \n            if (session == null) {\n                // Just in case ... It should not happen.\n                break;\n            }\n\n            // Reset the Schedule for flush flag for this session,\n            // as we are flushing it now\n            session.unscheduledForFlush();\n            \n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    try {\n                        boolean flushedAll = flushNow(session, currentTime);\n                        \n                        if (flushedAll\n                                && !session.getWriteRequestQueue().isEmpty(session)\n                                && !session.isScheduledForFlush()) {\n                            scheduleFlush(session);\n                        }\n                    } catch (Exception e) {\n                        scheduleRemove(session);\n                        IoFilterChain filterChain = session.getFilterChain();\n                        filterChain.fireExceptionCaught(e);\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if the channel is already closed.\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.write() is called before addSession()\n                    // is processed)\n                    scheduleFlush(session);\n                    return;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n\n        } while (!flushingSessions.isEmpty());\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        \n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                \n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    \n                    if (req == null) {\n                        break;\n                    }\n                    \n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                \n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    \n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        \n        if (buf.hasRemaining()) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            \n            localWrittenBytes = write(session, buf, length);\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            int pos = buf.position();\n            buf.reset();\n            \n            fireMessageSent(session, req);\n            \n            // And set it back to its position\n            buf.position(pos);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        \n        if (region.getRemainingBytes() > 0) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            \n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    updateTrafficControl(session);\n\n                    break;\n    \n                case CLOSING:\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.suspend??() or session.resume??() is\n                    // called before addSession() is processed)\n                    // We just put back the session at the end of the queue.\n                    trafficControllingSessions.add(session);\n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n            \n            // As we have handled one session, decrement the number of\n            // remaining sessions. The OPENING session will be processed\n            // with the next select(), as the queue size has been decreased, even \n            // if the session has been pushed at the end of the queue\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * The main loop. This is the place in charge to poll the Selector, and to \n     * process the active sessions. It's done in \n     * - handle the newly created sessions\n     * - \n     */\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    if ((selected == 0) && !wakeupCalled.get() && (delta < 100)) {\n                        // Last chance : the select() may have been\n                        // interrupted because we have had an closed channel.\n                        if (isBrokenConnection()) {\n                            LOG.warn(\"Broken connection\");\n\n                            // we can reselect immediately\n                            // set back the flag to false\n                            wakeupCalled.getAndSet(false);\n\n                            continue;\n                        } else {\n                            LOG.warn(\"Create a new selector. Selected is 0, delta = \"\n                                            + (t1 - t0));\n                            // Ok, we are hit by the nasty epoll\n                            // spinning.\n                            // Basically, there is a race condition\n                            // which causes a closing file descriptor not to be\n                            // considered as available as a selected channel, but\n                            // it stopped the select. The next time we will\n                            // call select(), it will exit immediately for the same\n                            // reason, and do so forever, consuming 100%\n                            // CPU.\n                            // We have to destroy the selector, and\n                            // register all the socket on a new one.\n                            registerNewSelector();\n                        }\n\n                        // Set back the flag to false\n                        wakeupCalled.getAndSet(false);\n                        \n                        // and continue the loop\n                        continue;\n                    }\n\n                    // Manage newly created session first\n                    nSessions += handleNewSessions();\n                    \n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        //LOG.debug(\"Processing ...\"); // This log hurts one of the MDCFilter test...\n                        process();\n                    }\n\n                    // Write the pending requests\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    \n                    // And manage removed sessions\n                    nSessions -= removeSessions();\n                    \n                    // Last, not least, send Idle events to the idle sessions\n                    notifyIdleSessions(currentTime);\n\n                    // Get a chance to exit the infinite loop if there are no\n                    // more sessions on this Processor\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        \n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChainBuilder;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoServiceListenerSupport;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory.getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new ConcurrentHashMap<Class<?>, AtomicInteger>();\n\n    /** A lock used to protect the processor creation */\n    private final Object lock = new Object();\n\n    /** This IoProcessor instance name */\n    private final String threadName;\n\n    /** The executor to use when we need to start the inner Processor */\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        // add the session to the queue if it's not already\n        // in the queue, then wake up the select()\n        if (session.setScheduledForFlush( true )) {\n            flushingSessions.add(session);\n            wakeup();\n        }\n    }\n\n    private void scheduleFlush(T session) {\n        // add the session to the queue if it's not already\n        // in the queue\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        trafficControllingSessions.add(session);\n        wakeup();\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (T session = newSessions.poll(); session != null; session = newSessions.poll()) {\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    /**\n     * Process a new session :\n     * - initialize it\n     * - create its chain\n     * - fire the CREATED listeners if any\n     *\n     * @param session The session to create\n     * @return true if the session has been registered\n     */\n    private boolean addNow(T session) {\n        boolean registered = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            IoFilterChainBuilder chainBuilder = session.getService().getFilterChainBuilder();\n            chainBuilder.buildFilterChain(session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            // Propagate the SESSION_CREATED event up to the chain\n            IoServiceListenerSupport listeners = ((AbstractIoService) session.getService()).getListeners();\n            listeners.fireSessionCreated(session);\n        } catch (Throwable e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            \n            try {\n                destroy(session);\n            } catch (Exception e1) {\n                ExceptionMonitor.getInstance().exceptionCaught(e1);\n            } finally {\n                registered = false;\n            }\n        }\n        \n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (T session = removingSessions.poll();session != null;session = removingSessions.poll()) {\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n                case OPENED:\n                    // Try to remove this session\n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if channel is already closed\n                    break;\n    \n                case OPENING:\n                    // Remove session from the newSessions queue and\n                    // remove it\n                    newSessions.remove(session);\n    \n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n                    \n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n        \n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object message = req.getMessage();\n            \n            if (message instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer)message;\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            \n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended()) {\n            // add the session to the queue, if it's not already there\n            if (session.setScheduledForFlush(true)) {\n                flushingSessions.add(session);\n            }       \n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        int bufferSize = config.getReadBufferSize();\n        IoBuffer buf = IoBuffer.allocate(bufferSize);\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    \n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        \n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    \n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class.isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config).isCloseOnPortUnreachable()) {\n                    scheduleRemove(session);\n                }\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    /**\n     * Write all the pending messages\n     */\n    private void flush(long currentTime) {\n        if (flushingSessions.isEmpty()) {\n            return;\n        }\n\n        do {\n            T session = flushingSessions.poll(); // the same one with firstSession\n            \n            if (session == null) {\n                // Just in case ... It should not happen.\n                break;\n            }\n\n            // Reset the Schedule for flush flag for this session,\n            // as we are flushing it now\n            session.unscheduledForFlush();\n            \n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    try {\n                        boolean flushedAll = flushNow(session, currentTime);\n                        \n                        if (flushedAll\n                                && !session.getWriteRequestQueue().isEmpty(session)\n                                && !session.isScheduledForFlush()) {\n                            scheduleFlush(session);\n                        }\n                    } catch (Exception e) {\n                        scheduleRemove(session);\n                        IoFilterChain filterChain = session.getFilterChain();\n                        filterChain.fireExceptionCaught(e);\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if the channel is already closed.\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.write() is called before addSession()\n                    // is processed)\n                    scheduleFlush(session);\n                    return;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n\n        } while (!flushingSessions.isEmpty());\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        \n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                \n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    \n                    if (req == null) {\n                        break;\n                    }\n                    \n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                \n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    \n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        \n        if (buf.hasRemaining()) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            \n            localWrittenBytes = write(session, buf, length);\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            int pos = buf.position();\n            buf.reset();\n            \n            fireMessageSent(session, req);\n            \n            // And set it back to its position\n            buf.position(pos);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        \n        if (region.getRemainingBytes() > 0) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            \n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    updateTrafficControl(session);\n\n                    break;\n    \n                case CLOSING:\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.suspend??() or session.resume??() is\n                    // called before addSession() is processed)\n                    // We just put back the session at the end of the queue.\n                    trafficControllingSessions.add(session);\n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n            \n            // As we have handled one session, decrement the number of\n            // remaining sessions. The OPENING session will be processed\n            // with the next select(), as the queue size has been decreased, even \n            // if the session has been pushed at the end of the queue\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * The main loop. This is the place in charge to poll the Selector, and to \n     * process the active sessions. It's done in \n     * - handle the newly created sessions\n     * - \n     */\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    if ((selected == 0) && !wakeupCalled.get() && (delta < 100)) {\n                        // Last chance : the select() may have been\n                        // interrupted because we have had an closed channel.\n                        if (isBrokenConnection()) {\n                            LOG.warn(\"Broken connection\");\n\n                            // we can reselect immediately\n                            // set back the flag to false\n                            wakeupCalled.getAndSet(false);\n\n                            continue;\n                        } else {\n                            LOG.warn(\"Create a new selector. Selected is 0, delta = \"\n                                            + (t1 - t0));\n                            // Ok, we are hit by the nasty epoll\n                            // spinning.\n                            // Basically, there is a race condition\n                            // which causes a closing file descriptor not to be\n                            // considered as available as a selected channel, but\n                            // it stopped the select. The next time we will\n                            // call select(), it will exit immediately for the same\n                            // reason, and do so forever, consuming 100%\n                            // CPU.\n                            // We have to destroy the selector, and\n                            // register all the socket on a new one.\n                            registerNewSelector();\n                        }\n\n                        // Set back the flag to false\n                        wakeupCalled.getAndSet(false);\n                        \n                        // and continue the loop\n                        continue;\n                    }\n\n                    // Manage newly created session first\n                    nSessions += handleNewSessions();\n                    \n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        //LOG.debug(\"Processing ...\"); // This log hurts one of the MDCFilter test...\n                        process();\n                    }\n\n                    // Write the pending requests\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    \n                    // And manage removed sessions\n                    nSessions -= removeSessions();\n                    \n                    // Last, not least, send Idle events to the idle sessions\n                    notifyIdleSessions(currentTime);\n\n                    // Get a chance to exit the infinite loop if there are no\n                    // more sessions on this Processor\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        \n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","lineNo":682}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory\n            .getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n\n    private final String threadName;\n\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session\n     *            the {@link IoSession} to add to the polling\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        if (scheduleFlush(session)) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor,\n                        threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // All new sessions have been handled\n                break;\n            }\n\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n        boolean registered = false;\n        boolean notified = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (;;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                // No session to remove. Get out.\n                return removedSessions;\n            }\n\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n            case OPENED:\n                // Try to remove this session\n                if (removeNow(session)) {\n                    removedSessions++;\n                }\n\n                break;\n\n            case CLOSING:\n                // Skip if channel is already closed\n                break;\n\n            case OPENING:\n                // Remove session from the newSessions queue and\n                // remove it\n                newSessions.remove(session);\n\n                if (removeNow(session)) {\n                    removedSessions++;\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class\n                                .isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config)\n                                .isCloseOnPortUnreachable())\n\n                    scheduleRemove(session);\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n\n        for (;;) {\n            session.setScheduledForFlush(false);\n            SessionState state = getState(session);\n\n            switch (state) {\n            case OPENED:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll\n                            && !session.getWriteRequestQueue().isEmpty(session)\n                            && !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireExceptionCaught(e);\n                }\n\n                break;\n\n            case CLOSING:\n                // Skip if the channel is already closed.\n                break;\n\n            case OPENING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession()\n                // is processed)\n                scheduleFlush(session);\n                return;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i--) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session which has just been opened.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n            case OPENED:\n                updateTrafficControl(session);\n                break;\n\n            case CLOSING:\n                break;\n\n            case OPENING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                // We just put back the session at the end of the queue.\n                trafficControllingSessions.add(session);\n                break;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            // As we have handled one session, decrement the number of\n            // remaining sessions.\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    synchronized (wakeupCalled) {\n\n                        if (selected == 0) {\n                            if (!wakeupCalled.get()) {\n                                if (delta < 100) {\n                                    // Last chance : the select() may have been\n                                    // interrupted\n                                    // because we have had an closed channel.\n                                    if (isBrokenConnection()) {\n                                        // we can reselect immediately\n                                        continue;\n                                    } else {\n                                        LOG\n                                                .warn(\"Create a new selector. Selected is 0, delta = \"\n                                                        + (t1 - t0));\n                                        // Ok, we are hit by the nasty epoll\n                                        // spinning.\n                                        // Basically, there is a race condition\n                                        // which cause\n                                        // a closing file descriptor not to be\n                                        // considered as\n                                        // available as a selected channel, but\n                                        // it stopped\n                                        // the select. The next time we will\n                                        // call select(),\n                                        // it will exit immediately for the same\n                                        // reason,\n                                        // and do so forever, consuming 100%\n                                        // CPU.\n                                        // We have to destroy the selector, and\n                                        // register all\n                                        // the socket on a new one.\n                                        registerNewSelector();\n                                    }\n\n                                    // and continue the loop\n                                    continue;\n                                }\n                            } else {\n                                // System.out.println(\"Waited one second\");\n                            }\n                        } else {\n                            // System.out.println(\"Nb selected : \" + selected);\n                        }\n\n                        wakeupCalled.getAndSet(false);\n                    }\n\n                    nSessions += handleNewSessions();\n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        // System.out.println( \"Proccessing ...\");\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= removeSessions();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChainBuilder;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoServiceListenerSupport;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory.getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new HashMap<Class<?>, AtomicInteger>();\n\n    /** A lock used to protect the processor creation */\n    private final Object lock = new Object();\n\n    /** This IoProcessor instance name */\n    private final String threadName;\n\n    /** The executor to use when we need to start the inner Processor */\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            wakeup();\n        }\n    }\n\n    private void scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        trafficControllingSessions.add(session);\n        wakeup();\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (T session = newSessions.poll(); session != null; session = newSessions.poll()) {\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    /**\n     * Process a new session :\n     * - initialize it\n     * - create its chain\n     * - fire the CREATED listeners if any\n     *\n     * @param session The session to create\n     * @return true if the session has been registered\n     */\n    private boolean addNow(T session) {\n        boolean registered = false;\n        boolean notified = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            IoFilterChainBuilder chainBuilder = session.getService().getFilterChainBuilder();\n            chainBuilder.buildFilterChain(session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            // Propagate the SESSION_CREATED event up to the chain\n            IoServiceListenerSupport listeners = ((AbstractIoService) session.getService()).getListeners();\n            listeners.fireSessionCreated(session);\n            \n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                \n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        \n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (T session = removingSessions.poll();session != null;session = removingSessions.poll()) {\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n                case OPENED:\n                    // Try to remove this session\n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if channel is already closed\n                    break;\n    \n                case OPENING:\n                    // Remove session from the newSessions queue and\n                    // remove it\n                    newSessions.remove(session);\n    \n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n                    \n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n        \n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object message = req.getMessage();\n            \n            if (message instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer)message;\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            \n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended() && session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        \n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    \n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class.isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config).isCloseOnPortUnreachable()) {\n                    scheduleRemove(session);\n                }\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    /**\n     * Write all the pending messages\n     */\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        \n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n\n        for (;;) {\n            session.setScheduledForFlush(false);\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    try {\n                        boolean flushedAll = flushNow(session, currentTime);\n                        \n                        if (flushedAll\n                                && !session.getWriteRequestQueue().isEmpty(session)\n                                && !session.isScheduledForFlush()) {\n                            scheduleFlush(session);\n                        }\n                    } catch (Exception e) {\n                        scheduleRemove(session);\n                        IoFilterChain filterChain = session.getFilterChain();\n                        filterChain.fireExceptionCaught(e);\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if the channel is already closed.\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.write() is called before addSession()\n                    // is processed)\n                    scheduleFlush(session);\n                    return;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            \n            if ((session == null) || (session == firstSession)) {\n                break;\n            }\n            \n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        \n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                \n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    \n                    if (req == null) {\n                        break;\n                    }\n                    \n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                \n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    \n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        \n        if (buf.hasRemaining()) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            \n            for (int i = WRITE_SPIN_COUNT; i > 0; i--) {\n                localWrittenBytes = write(session, buf, length);\n                \n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        \n        if (region.getRemainingBytes() > 0) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            \n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    updateTrafficControl(session);\n\n                    break;\n    \n                case CLOSING:\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.suspend??() or session.resume??() is\n                    // called before addSession() is processed)\n                    // We just put back the session at the end of the queue.\n                    trafficControllingSessions.add(session);\n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n            \n            // As we have handled one session, decrement the number of\n            // remaining sessions. The OPENING session will be processed\n            // with the next select(), as the queue size has been decreased, even \n            // if the session has been pushed at the end of the queue\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * The main loop. This is the place in charge to poll the Selector, and to \n     * process the active sessions. It's done in \n     * - handle the newly created sessions\n     * - \n     */\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    synchronized (wakeupCalled) {\n\n                        if (selected == 0) {\n                            if (!wakeupCalled.get()) {\n                                if (delta < 100) {\n                                    // Last chance : the select() may have been\n                                    // interrupted\n                                    // because we have had an closed channel.\n                                    if (isBrokenConnection()) {\n                                        // we can reselect immediately\n                                        continue;\n                                    } else {\n                                        LOG.warn(\"Create a new selector. Selected is 0, delta = \"\n                                                        + (t1 - t0));\n                                        // Ok, we are hit by the nasty epoll\n                                        // spinning.\n                                        // Basically, there is a race condition\n                                        // which cause\n                                        // a closing file descriptor not to be\n                                        // considered as\n                                        // available as a selected channel, but\n                                        // it stopped\n                                        // the select. The next time we will\n                                        // call select(),\n                                        // it will exit immediately for the same\n                                        // reason,\n                                        // and do so forever, consuming 100%\n                                        // CPU.\n                                        // We have to destroy the selector, and\n                                        // register all\n                                        // the socket on a new one.\n                                        registerNewSelector();\n                                    }\n\n                                    // and continue the loop\n                                    continue;\n                                }\n                            } else {\n                                // System.out.println(\"Waited one second\");\n                            }\n                        } else {\n                            // System.out.println(\"Nb selected : \" + selected);\n                        }\n\n                        wakeupCalled.getAndSet(false);\n                    }\n\n                    // Manage newly created session first\n                    nSessions += handleNewSessions();\n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        //LOG.debug(\"Processing ...\"); // This log hurts one of the MDCFilter test...\n                        process();\n                    }\n\n                    // Write the pending requests\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    \n                    // And manage removed sessions\n                    nSessions -= removeSessions();\n                    \n                    // Last, not least, send Idle events to the idle sessions\n                    notifyIdleSessions(currentTime);\n\n                    // Get a chance to exit the infinite loop if there are no\n                    // more sessions on this Processor\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        \n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","lineNo":527}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory\n            .getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n\n    private final String threadName;\n\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session\n     *            the {@link IoSession} to add to the polling\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        if (scheduleFlush(session)) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor,\n                        threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // All new sessions have been handled\n                break;\n            }\n\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n        boolean registered = false;\n        boolean notified = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (;;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                // No session to remove. Get out.\n                return removedSessions;\n            }\n\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n            case OPENED:\n                // Try to remove this session\n                if (removeNow(session)) {\n                    removedSessions++;\n                }\n\n                break;\n\n            case CLOSING:\n                // Skip if channel is already closed\n                break;\n\n            case OPENING:\n                // Remove session from the newSessions queue and\n                // remove it\n                newSessions.remove(session);\n\n                if (removeNow(session)) {\n                    removedSessions++;\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class\n                                .isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config)\n                                .isCloseOnPortUnreachable())\n\n                    scheduleRemove(session);\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n\n        for (;;) {\n            session.setScheduledForFlush(false);\n            SessionState state = getState(session);\n\n            switch (state) {\n            case OPENED:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll\n                            && !session.getWriteRequestQueue().isEmpty(session)\n                            && !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireExceptionCaught(e);\n                }\n\n                break;\n\n            case CLOSING:\n                // Skip if the channel is already closed.\n                break;\n\n            case OPENING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession()\n                // is processed)\n                scheduleFlush(session);\n                return;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i--) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session which has just been opened.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n            case OPENED:\n                updateTrafficControl(session);\n                break;\n\n            case CLOSING:\n                break;\n\n            case OPENING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                // We just put back the session at the end of the queue.\n                trafficControllingSessions.add(session);\n                break;\n\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            // As we have handled one session, decrement the number of\n            // remaining sessions.\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    synchronized (wakeupCalled) {\n\n                        if (selected == 0) {\n                            if (!wakeupCalled.get()) {\n                                if (delta < 100) {\n                                    // Last chance : the select() may have been\n                                    // interrupted\n                                    // because we have had an closed channel.\n                                    if (isBrokenConnection()) {\n                                        // we can reselect immediately\n                                        continue;\n                                    } else {\n                                        LOG\n                                                .warn(\"Create a new selector. Selected is 0, delta = \"\n                                                        + (t1 - t0));\n                                        // Ok, we are hit by the nasty epoll\n                                        // spinning.\n                                        // Basically, there is a race condition\n                                        // which cause\n                                        // a closing file descriptor not to be\n                                        // considered as\n                                        // available as a selected channel, but\n                                        // it stopped\n                                        // the select. The next time we will\n                                        // call select(),\n                                        // it will exit immediately for the same\n                                        // reason,\n                                        // and do so forever, consuming 100%\n                                        // CPU.\n                                        // We have to destroy the selector, and\n                                        // register all\n                                        // the socket on a new one.\n                                        registerNewSelector();\n                                    }\n\n                                    // and continue the loop\n                                    continue;\n                                }\n                            } else {\n                                // System.out.println(\"Waited one second\");\n                            }\n                        } else {\n                            // System.out.println(\"Nb selected : \" + selected);\n                        }\n\n                        wakeupCalled.getAndSet(false);\n                    }\n\n                    nSessions += handleNewSessions();\n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        // System.out.println( \"Proccessing ...\");\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= removeSessions();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.net.PortUnreachableException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChainBuilder;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoServiceListenerSupport;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.SessionState;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.transport.socket.AbstractDatagramSessionConfig;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps transport\n * developers to write an {@link IoProcessor} easily. This class is in charge of\n * active polling a set of {@link IoSession} and trigger events when some I/O\n * operation is possible.\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession>\n        implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOG = LoggerFactory.getLogger(IoProcessor.class);\n\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming. It\n     * improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /**\n     * A timeout used for the select, as we need to get out to deal with idle\n     * sessions\n     */\n    private static final long SELECT_TIMEOUT = 1000L;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = new HashMap<Class<?>, AtomicInteger>();\n\n    /** A lock used to protect the processor creation */\n    private final Object lock = new Object();\n\n    /** This IoProcessor instance name */\n    private final String threadName;\n\n    /** The executor to use when we need to start the inner Processor */\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be removed */\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** A queue used to store the sessions to be flushed */\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n\n    /**\n     * A queue used to store the sessions which have a trafficControl to be\n     * updated\n     */\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n\n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    protected AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given\n     * {@link Executor} for handling I/Os events.\n     * \n     * @param executor\n     *            the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     * \n     * @return a name for the current thread, based on the class name and an\n     *         incremental value, starting at 1.\n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n\n        // We synchronize this block to avoid a concurrent access to\n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized (threadIds) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n\n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n\n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupProcessor();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling the\n     * client connections\n     * \n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * \n     * @param timeout\n     *            milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select(long timeout) throws Exception;\n\n    /**\n     * poll those sessions forever\n     * \n     * @return The number of session ready for read or for write\n     * @throws Exception\n     *             if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n\n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor}\n     * is empty\n     * \n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n\n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}\n     * \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n\n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n\n    /**\n     * Get the state of a session (preparing, open, closed)\n     * \n     * @param session\n     *            the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState getState(T session);\n\n    /**\n     * Is the session ready for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * \n     * @param session\n     *            the session registered\n     * @param isInterested\n     *            true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean isInterested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * \n     * @param session\n     *            the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process.\n     * \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n\n    /**\n     * Destroy the underlying client socket handle\n     * \n     * @param session\n     *            the {@link IoSession}\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n\n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given\n     * {@link IoBuffer}. Is called when the session was found ready for reading.\n     * \n     * @param session\n     *            the session to read\n     * @param buf\n     *            the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when\n     * a session was found ready for writing.\n     * \n     * @param session\n     *            the session to write\n     * @param buf\n     *            the buffer to write\n     * @param length\n     *            the number of bytes to write can be superior to the number of\n     *            bytes remaining in the buffer\n     * @return the number of byte written\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length)\n            throws Exception;\n\n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API\n     * isn't supporting system calls like sendfile(), you can throw a\n     * {@link UnsupportedOperationException} so the file will be send using\n     * usual {@link #write(AbstractIoSession, IoBuffer, int)} call.\n     * \n     * @param session\n     *            the session to write\n     * @param region\n     *            the file region to write\n     * @param length\n     *            the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception\n     *             any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length)\n            throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupProcessor();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupProcessor();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            wakeup();\n        }\n    }\n\n    private void scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        trafficControllingSessions.add(session);\n        wakeup();\n    }\n\n    /**\n     * Starts the inner Processor, asking the executor to pick a thread in its\n     * pool. The Runnable will be renamed\n     */\n    private void startupProcessor() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n\n        // Just stop the select() and start it again, so that the processor\n        // can be activated immediately.\n        wakeup();\n    }\n\n    /**\n     * In the case we are using the java select() method, this method is used to\n     * trash the buggy selector and create a new one, registring all the sockets\n     * on it.\n     * \n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected void registerNewSelector() throws IOException;\n\n    /**\n     * Check that the select() has not exited immediately just because of a\n     * broken connection. In this case, this is a standard case, and we just\n     * have to loop.\n     * \n     * @return true if a connection has been brutally closed.\n     * @throws IOException\n     *             If we got an exception\n     */\n    abstract protected boolean isBrokenConnection() throws IOException;\n\n    /**\n     * Loops over the new sessions blocking queue and returns the number of\n     * sessions which are effectively created\n     * \n     * @return The number of new sessions\n     */\n    private int handleNewSessions() {\n        int addedSessions = 0;\n\n        for (T session = newSessions.poll(); session != null; session = newSessions.poll()) {\n            if (addNow(session)) {\n                // A new session has been created\n                addedSessions++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    /**\n     * Process a new session :\n     * - initialize it\n     * - create its chain\n     * - fire the CREATED listeners if any\n     *\n     * @param session The session to create\n     * @return true if the session has been registered\n     */\n    private boolean addNow(T session) {\n        boolean registered = false;\n        boolean notified = false;\n\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            IoFilterChainBuilder chainBuilder = session.getService().getFilterChainBuilder();\n            chainBuilder.buildFilterChain(session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            // Propagate the SESSION_CREATED event up to the chain\n            IoServiceListenerSupport listeners = ((AbstractIoService) session.getService()).getListeners();\n            listeners.fireSessionCreated(session);\n            \n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                \n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        \n        return registered;\n    }\n\n    private int removeSessions() {\n        int removedSessions = 0;\n\n        for (T session = removingSessions.poll();session != null;session = removingSessions.poll()) {\n            SessionState state = getState(session);\n\n            // Now deal with the removal accordingly to the session's state\n            switch (state) {\n                case OPENED:\n                    // Try to remove this session\n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if channel is already closed\n                    break;\n    \n                case OPENING:\n                    // Remove session from the newSessions queue and\n                    // remove it\n                    newSessions.remove(session);\n    \n                    if (removeNow(session)) {\n                        removedSessions++;\n                    }\n                    \n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n        \n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners()\n                    .fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object message = req.getMessage();\n            \n            if (message instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer)message;\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain();\n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(\n                    failedRequests);\n            \n            for (WriteRequest r : failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            T session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    /**\n     * Deal with session ready for the read or write operations, or both.\n     */\n    private void process(T session) {\n        // Process Reads\n        if (isReadable(session) && !session.isReadSuspended()) {\n            read(session);\n        }\n\n        // Process writes\n        if (isWritable(session) && !session.isWriteSuspended() && session.setScheduledForFlush(true)) {\n            // add the session to the queue\n            flushingSessions.add(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        \n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    \n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain();\n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                if (!(e instanceof PortUnreachableException)\n                        || !AbstractDatagramSessionConfig.class.isAssignableFrom(config.getClass())\n                        || ((AbstractDatagramSessionConfig) config).isCloseOnPortUnreachable()) {\n                    scheduleRemove(session);\n                }\n            }\n\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= SELECT_TIMEOUT) {\n            lastIdleCheckTime = currentTime;\n            AbstractIoSession.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    /**\n     * Write all the pending messages\n     */\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        \n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n\n        for (;;) {\n            session.setScheduledForFlush(false);\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    try {\n                        boolean flushedAll = flushNow(session, currentTime);\n                        \n                        if (flushedAll\n                                && !session.getWriteRequestQueue().isEmpty(session)\n                                && !session.isScheduledForFlush()) {\n                            scheduleFlush(session);\n                        }\n                    } catch (Exception e) {\n                        scheduleRemove(session);\n                        IoFilterChain filterChain = session.getFilterChain();\n                        filterChain.fireExceptionCaught(e);\n                    }\n    \n                    break;\n    \n                case CLOSING:\n                    // Skip if the channel is already closed.\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.write() is called before addSession()\n                    // is processed)\n                    scheduleFlush(session);\n                    return;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            \n            if ((session == null) || (session == firstSession)) {\n                break;\n            }\n            \n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation = session.getTransportMetadata()\n                .hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session\n                .getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness. I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize()\n                + (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        WriteRequest req = null;\n        \n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                req = session.getCurrentWriteRequest();\n                \n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    \n                    if (req == null) {\n                        break;\n                    }\n                    \n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                \n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    \n                    if (localWrittenBytes > 0\n                            && ((IoBuffer) message).hasRemaining()) {\n                        // the buffer isn't empty, we re-interest it in writing\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(session, req,\n                            hasFragmentation, maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux\n                    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion,\n                    // return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0\n                            && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\n                            \"Don't know how to handle message of type '\"\n                                    + message.getClass().getName()\n                                    + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            if (req != null) {\n                req.getFuture().setException(e);\n            }\n            \n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        \n        if (buf.hasRemaining()) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            \n            for (int i = WRITE_SPIN_COUNT; i > 0; i--) {\n                localWrittenBytes = write(session, buf, length);\n                \n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() || !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime)\n            throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        \n        if (region.getRemainingBytes() > 0) {\n            int length;\n            \n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region\n                        .getRemainingBytes());\n            }\n            \n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 || !hasFragmentation\n                && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain();\n        filterChain.fireMessageSent(req);\n    }\n\n    /**\n     * Update the trafficControl for all the session.\n     */\n    private void updateTrafficMask() {\n        int queueSize = trafficControllingSessions.size();\n\n        while (queueSize > 0) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                // We are done with this queue.\n                return;\n            }\n\n            SessionState state = getState(session);\n\n            switch (state) {\n                case OPENED:\n                    updateTrafficControl(session);\n\n                    break;\n    \n                case CLOSING:\n                    break;\n    \n                case OPENING:\n                    // Retry later if session is not yet fully initialized.\n                    // (In case that Session.suspend??() or session.resume??() is\n                    // called before addSession() is processed)\n                    // We just put back the session at the end of the queue.\n                    trafficControllingSessions.add(session);\n                    break;\n    \n                default:\n                    throw new IllegalStateException(String.valueOf(state));\n            }\n            \n            // As we have handled one session, decrement the number of\n            // remaining sessions. The OPENING session will be processed\n            // with the next select(), as the queue size has been decreased, even \n            // if the session has been pushed at the end of the queue\n            queueSize--;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void updateTrafficControl(T session) {\n        // \n        try {\n            setInterestedInRead(session, !session.isReadSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n\n        try {\n            setInterestedInWrite(session, !session.getWriteRequestQueue()\n                    .isEmpty(session)\n                    && !session.isWriteSuspended());\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain();\n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * The main loop. This is the place in charge to poll the Selector, and to \n     * process the active sessions. It's done in \n     * - handle the newly created sessions\n     * - \n     */\n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    // This select has a timeout so that we can manage\n                    // idle session when we get out of the select every\n                    // second. (note : this is a hack to avoid creating\n                    // a dedicated thread).\n                    long t0 = System.currentTimeMillis();\n                    int selected = select(SELECT_TIMEOUT);\n                    long t1 = System.currentTimeMillis();\n                    long delta = (t1 - t0);\n\n                    synchronized (wakeupCalled) {\n\n                        if (selected == 0) {\n                            if (!wakeupCalled.get()) {\n                                if (delta < 100) {\n                                    // Last chance : the select() may have been\n                                    // interrupted\n                                    // because we have had an closed channel.\n                                    if (isBrokenConnection()) {\n                                        // we can reselect immediately\n                                        continue;\n                                    } else {\n                                        LOG.warn(\"Create a new selector. Selected is 0, delta = \"\n                                                        + (t1 - t0));\n                                        // Ok, we are hit by the nasty epoll\n                                        // spinning.\n                                        // Basically, there is a race condition\n                                        // which cause\n                                        // a closing file descriptor not to be\n                                        // considered as\n                                        // available as a selected channel, but\n                                        // it stopped\n                                        // the select. The next time we will\n                                        // call select(),\n                                        // it will exit immediately for the same\n                                        // reason,\n                                        // and do so forever, consuming 100%\n                                        // CPU.\n                                        // We have to destroy the selector, and\n                                        // register all\n                                        // the socket on a new one.\n                                        registerNewSelector();\n                                    }\n\n                                    // and continue the loop\n                                    continue;\n                                }\n                            } else {\n                                // System.out.println(\"Waited one second\");\n                            }\n                        } else {\n                            // System.out.println(\"Nb selected : \" + selected);\n                        }\n\n                        wakeupCalled.getAndSet(false);\n                    }\n\n                    // Manage newly created session first\n                    nSessions += handleNewSessions();\n                    updateTrafficMask();\n\n                    // Now, if we have had some incoming or outgoing events,\n                    // deal with them\n                    if (selected > 0) {\n                        //LOG.debug(\"Processing ...\"); // This log hurts one of the MDCFilter test...\n                        process();\n                    }\n\n                    // Write the pending requests\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    \n                    // And manage removed sessions\n                    nSessions -= removeSessions();\n                    \n                    // Last, not least, send Idle events to the idle sessions\n                    notifyIdleSessions(currentTime);\n\n                    // Get a chance to exit the infinite loop if there are no\n                    // more sessions on this Processor\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext();) {\n                            scheduleRemove(i.next());\n                        }\n                        \n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n}\n","lineNo":533}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.lang.reflect.Constructor;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoProcessor} pool that distributes {@link IoSession}s into one or more\n * {@link IoProcessor}s. Most current transport implementations use this pool internally\n * to perform better in a multi-core environment, and therefore, you won't need to \n * use this pool directly unless you are running multiple {@link IoService}s in the\n * same JVM.\n * <p>\n * If you are running multiple {@link IoService}s, you could want to share the pool\n * among all services.  To do so, you can create a new {@link SimpleIoProcessorPool}\n * instance by yourself and provide the pool as a constructor parameter when you\n * create the services.\n * <p>\n * This pool uses Java reflection API to create multiple {@link IoProcessor} instances.\n * It tries to instantiate the processor in the following order:\n * <ol>\n * <li>A public constructor with one {@link ExecutorService} parameter.<\/li>\n * <li>A public constructor with one {@link Executor} parameter.<\/li>\n * <li>A public default constructor<\/li>\n * <\/ol>\n * The following is an example for the NIO socket transport:\n * <pre><code>\n * // Create a shared pool.\n * SimpleIoProcessorPool&lt;NioSession&gt; pool = \n *         new SimpleIoProcessorPool&lt;NioSession&gt;(NioProcessor.class, 16);\n * \n * // Create two services that share the same pool.\n * SocketAcceptor acceptor = new NioSocketAcceptor(pool);\n * SocketConnector connector = new NioSocketConnector(pool);\n * \n * ...\n * \n * // Release related resources.\n * connector.dispose();\n * acceptor.dispose();\n * pool.dispose();\n * <\/code><\/pre>\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n * @param <T> the type of the {@link IoSession} to be managed by the specified\n *            {@link IoProcessor}.\n */\npublic class SimpleIoProcessorPool<T extends AbstractIoSession> implements\n        IoProcessor<T> {\n\n    private static final int DEFAULT_SIZE = Runtime.getRuntime()\n            .availableProcessors() + 1;\n\n    private static final AttributeKey PROCESSOR = new AttributeKey(\n            SimpleIoProcessorPool.class, \"processor\");\n\n    private final static Logger LOGGER = LoggerFactory\n            .getLogger(SimpleIoProcessorPool.class);\n\n    private final IoProcessor<T>[] pool;\n\n    private final AtomicInteger processorDistributor = new AtomicInteger();\n\n    private final Executor executor;\n\n    private final boolean createdExecutor;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType) {\n        this(processorType, null, DEFAULT_SIZE);\n    }\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            int size) {\n        this(processorType, null, size);\n    }\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            Executor executor) {\n        this(processorType, executor, DEFAULT_SIZE);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            Executor executor, int size) {\n        if (processorType == null) {\n            throw new NullPointerException(\"processorType\");\n        }\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"size: \" + size\n                    + \" (expected: positive integer)\");\n        }\n\n        if (executor == null) {\n            this.executor = executor = Executors.newCachedThreadPool();\n            this.createdExecutor = true;\n        } else {\n            this.executor = executor;\n            this.createdExecutor = false;\n        }\n\n        pool = new IoProcessor[size];\n\n        boolean success = false;\n        Constructor<? extends IoProcessor<T>> processorConstructor = null;\n        boolean usesExecutorArg = true;\n\n        try {\n            // We create at least one processor\n            try {\n                try {\n                    processorConstructor = processorType\n                            .getConstructor(ExecutorService.class);\n                    pool[0] = processorConstructor.newInstance(executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType\n                            .getConstructor(Executor.class);\n                    pool[0] = processorConstructor.newInstance(executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType.getConstructor();\n                    usesExecutorArg = false;\n                    pool[0] = processorConstructor.newInstance();\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new RuntimeIoException(\n                        \"Failed to create a new instance of \"\n                                + processorType.getName(), e);\n            }\n\n            if (processorConstructor == null) {\n                // Raise an exception if no proper constructor is found.\n                throw new IllegalArgumentException(String\n                        .valueOf(processorType)\n                        + \" must have a public constructor \"\n                        + \"with one \"\n                        + ExecutorService.class.getSimpleName()\n                        + \" parameter, \"\n                        + \"a public constructor with one \"\n                        + Executor.class.getSimpleName()\n                        + \" parameter or a public default constructor.\");\n            }\n\n            // Constructor found now use it for all subsequent instantiations\n            for (int i = 1; i < pool.length; i++) {\n                try {\n                    if (usesExecutorArg) {\n                        pool[i] = processorConstructor.newInstance(executor);\n                    } else {\n                        pool[i] = processorConstructor.newInstance();\n                    }\n                } catch (Exception e) {\n                    // Won't happen because it has been done previously\n                }\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                dispose();\n            }\n        }\n    }\n\n    public final void add(T session) {\n        getProcessor(session).add(session);\n    }\n\n    public final void flush(T session) {\n        getProcessor(session).flush(session);\n    }\n\n    public final void remove(T session) {\n        getProcessor(session).remove(session);\n    }\n\n    public final void updateTrafficControl(T session) {\n        getProcessor(session).updateTrafficControl(session);\n    }\n\n    public boolean isDisposed() {\n        return disposed;\n    }\n\n    public boolean isDisposing() {\n        return disposing;\n    }\n\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                for (int i = pool.length - 1; i >= 0; i--) {\n                    if (pool[i] == null || pool[i].isDisposing()) {\n                        continue;\n                    }\n\n                    try {\n                        pool[i].dispose();\n                    } catch (Exception e) {\n                        LOGGER.warn(\"Failed to dispose a \"\n                                + pool[i].getClass().getSimpleName()\n                                + \" at index \" + i + \".\", e);\n                    } finally {\n                        pool[i] = null;\n                    }\n                }\n\n                if (createdExecutor) {\n                    ((ExecutorService) executor).shutdown();\n                }\n            }\n        }\n\n        disposed = true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private IoProcessor<T> getProcessor(T session) {\n        IoProcessor<T> p = (IoProcessor<T>) session.getAttribute(PROCESSOR);\n        if (p == null) {\n            p = nextProcessor();\n            IoProcessor<T> oldp = (IoProcessor<T>) session\n                    .setAttributeIfAbsent(PROCESSOR, p);\n            if (oldp != null) {\n                p = oldp;\n            }\n        }\n\n        return p;\n    }\n\n    private IoProcessor<T> nextProcessor() {\n        if (disposed) {\n            throw new IllegalStateException(\n                    \"A disposed processor cannot be accessed.\");\n        }\n        return pool[Math.abs(processorDistributor.getAndIncrement())\n                % pool.length];\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.lang.reflect.Constructor;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoProcessor} pool that distributes {@link IoSession}s into one or more\n * {@link IoProcessor}s. Most current transport implementations use this pool internally\n * to perform better in a multi-core environment, and therefore, you won't need to \n * use this pool directly unless you are running multiple {@link IoService}s in the\n * same JVM.\n * <p>\n * If you are running multiple {@link IoService}s, you could want to share the pool\n * among all services.  To do so, you can create a new {@link SimpleIoProcessorPool}\n * instance by yourself and provide the pool as a constructor parameter when you\n * create the services.\n * <p>\n * This pool uses Java reflection API to create multiple {@link IoProcessor} instances.\n * It tries to instantiate the processor in the following order:\n * <ol>\n * <li>A public constructor with one {@link ExecutorService} parameter.<\/li>\n * <li>A public constructor with one {@link Executor} parameter.<\/li>\n * <li>A public default constructor<\/li>\n * <\/ol>\n * The following is an example for the NIO socket transport:\n * <pre><code>\n * // Create a shared pool.\n * SimpleIoProcessorPool&lt;NioSession&gt; pool = \n *         new SimpleIoProcessorPool&lt;NioSession&gt;(NioProcessor.class, 16);\n * \n * // Create two services that share the same pool.\n * SocketAcceptor acceptor = new NioSocketAcceptor(pool);\n * SocketConnector connector = new NioSocketConnector(pool);\n * \n * ...\n * \n * // Release related resources.\n * connector.dispose();\n * acceptor.dispose();\n * pool.dispose();\n * <\/code><\/pre>\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n * @param <T> the type of the {@link IoSession} to be managed by the specified\n *            {@link IoProcessor}.\n */\npublic class SimpleIoProcessorPool<T extends AbstractIoSession> implements IoProcessor<T> {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SimpleIoProcessorPool.class);\n\n    /** The default pool size, when no size is provided. */\n    private static final int DEFAULT_SIZE = Runtime.getRuntime().availableProcessors() + 1;\n\n    /** A key used to store the processor pool in the session's Attributes */\n    private static final AttributeKey PROCESSOR = new AttributeKey( SimpleIoProcessorPool.class, \"processor\");\n\n    /** The pool table */\n    private final IoProcessor<T>[] pool;\n\n    /** A protected counter used to loop on the pool when selecting a new one */\n    private final AtomicInteger processorDistributor = new AtomicInteger();\n\n    /** The contained  which is passed to the IoProcessor when they are created */\n    private final Executor executor;\n\n    /** A flag set to true if we had to create an executor */\n    private final boolean createdExecutor;\n\n    /** A lock to protect the disposal against concurrent calls */\n    private final Object disposalLock = new Object();\n\n    /** A flg set to true if the IoProcessor in the pool are being disposed */\n    private volatile boolean disposing;\n\n    /** A flag set to true if all the IoProcessor contained in the pool have been disposed */\n    private volatile boolean disposed;\n\n    /**\n     * Creates a new instance of SimpleIoProcessorPool with a default\n     * size of NbCPUs +1.\n     *\n     * @param processorType The type of IoProcessor to use\n     */\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType) {\n        this(processorType, null, DEFAULT_SIZE);\n    }\n\n    /**\n     * Creates a new instance of SimpleIoProcessorPool with a defined\n     * number of IoProcessors in the pool\n     *\n     * @param processorType The type of IoProcessor to use\n     * @param size The number of IoProcessor in the pool\n     */\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType, int size) {\n        this(processorType, null, size);\n    }\n\n    /**\n     * Creates a new instance of SimpleIoProcessorPool with an executor\n     *\n     * @param processorType The type of IoProcessor to use\n     * @param executor The {@link Executor}\n     */\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType, Executor executor) {\n        this(processorType, executor, DEFAULT_SIZE);\n    }\n\n    /**\n     * Creates a new instance of SimpleIoProcessorPool with an executor\n     *\n     * @param processorType The type of IoProcessor to use\n     * @param executor The {@link Executor}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            Executor executor, int size) {\n        if (processorType == null) {\n            throw new NullPointerException(\"processorType\");\n        }\n\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"size: \" + size\n                    + \" (expected: positive integer)\");\n        }\n\n        // Create the executor if none is provided\n        createdExecutor = (executor == null);\n        \n        if (createdExecutor) {\n            this.executor = Executors.newCachedThreadPool();\n        } else {\n            this.executor = executor;\n        }\n\n        pool = new IoProcessor[size];\n\n        boolean success = false;\n        Constructor<? extends IoProcessor<T>> processorConstructor = null;\n        boolean usesExecutorArg = true;\n\n        try {\n            // We create at least one processor\n            try {\n                try {\n                    processorConstructor = processorType.getConstructor(ExecutorService.class);\n                    pool[0] = processorConstructor.newInstance(this.executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType.getConstructor(Executor.class);\n                    pool[0] = processorConstructor.newInstance(this.executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType.getConstructor();\n                    usesExecutorArg = false;\n                    pool[0] = processorConstructor.newInstance();\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n            } catch (RuntimeException re) {\n                LOGGER.error(\"Cannot create an IoProcessor :{}\", re.getMessage());\n                throw re;\n            } catch (Exception e) {\n                String msg = \"Failed to create a new instance of \" + processorType.getName() + \":\" + e.getMessage();\n                LOGGER.error(msg, e);\n                throw new RuntimeIoException(msg , e);\n            }\n\n            if (processorConstructor == null) {\n                // Raise an exception if no proper constructor is found.\n                String msg = String.valueOf(processorType)\n                    + \" must have a public constructor with one \"\n                    + ExecutorService.class.getSimpleName()\n                    + \" parameter, a public constructor with one \"\n                    + Executor.class.getSimpleName()\n                    + \" parameter or a public default constructor.\";\n                LOGGER.error(msg);\n                throw new IllegalArgumentException(msg);\n            }\n\n            // Constructor found now use it for all subsequent instantiations\n            for (int i = 1; i < pool.length; i++) {\n                try {\n                    if (usesExecutorArg) {\n                        pool[i] = processorConstructor.newInstance(this.executor);\n                    } else {\n                        pool[i] = processorConstructor.newInstance();\n                    }\n                } catch (Exception e) {\n                    // Won't happen because it has been done previously\n                }\n            }\n            \n            success = true;\n        } finally {\n            if (!success) {\n                dispose();\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        getProcessor(session).add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        getProcessor(session).flush(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        getProcessor(session).remove(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficControl(T session) {\n        getProcessor(session).updateTrafficControl(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDisposed() {\n        return disposed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                \n                // Loop on all the IoProcessor and release them\n                for (int i = pool.length - 1; i >= 0; i--) {\n                    if ((pool[i] == null) || pool[i].isDisposing()) {\n                        // Already done\n                        continue;\n                    }\n\n                    try {\n                        pool[i].dispose();\n                    } catch (Exception e) {\n                        LOGGER.warn(\"Failed to dispose a \"\n                                + pool[i].getClass().getSimpleName()\n                                + \" at index \" + i + \".\", e);\n                    } finally {\n                        pool[i] = null;\n                    }\n                }\n\n                if (createdExecutor) {\n                    ((ExecutorService) executor).shutdown();\n                }\n            }\n        }\n\n        disposed = true;\n    }\n\n    /**\n     * Find the processor associated to a session. If it hasen't be stored into\n     * the session's attributes, pick a new processor and stores it.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private IoProcessor<T> getProcessor(T session) {\n        IoProcessor<T> processor = (IoProcessor<T>) session.getAttribute(PROCESSOR);\n        \n        if (processor == null) {\n            processor = nextProcessor();\n            session.setAttributeIfAbsent(PROCESSOR, processor);\n        }\n\n        return processor;\n    }\n\n    /**\n     * Get a new Processor in the pool, using a round-robin algorithm.\n     */\n    private IoProcessor<T> nextProcessor() {\n        if (disposed) {\n            throw new IllegalStateException(\n                    \"A disposed processor cannot be accessed.\");\n        }\n        \n        return pool[Math.abs(processorDistributor.getAndIncrement()) % pool.length];\n    }\n}\n","lineNo":200}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLSession;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\n\n/**\n * An SSL filter that encrypts and decrypts the data exchanged in the session.\n * Adding this filter triggers SSL handshake procedure immediately by sending\n * a SSL 'hello' message, so you don't need to call\n * {@link #startSsl(IoSession)} manually unless you are implementing StartTLS\n * (see below).  If you don't want the handshake procedure to start\n * immediately, please specify {@code false} as {@code autoStart} parameter in\n * the constructor.\n * <p>\n * This filter uses an {@link SSLEngine} which was introduced in Java 5, so\n * Java version 5 or above is mandatory to use this filter. And please note that\n * this filter only works for TCP/IP connections.\n * <p>\n *\n * <h2>Implementing StartTLS<\/h2>\n * <p>\n * You can use {@link #DISABLE_ENCRYPTION_ONCE} attribute to implement StartTLS:\n * <pre>\n * public void messageReceived(IoSession session, Object message) {\n *    if (message instanceof MyStartTLSRequest) {\n *        // Insert SSLFilter to get ready for handshaking\n *        session.getFilterChain().addFirst(sslFilter);\n *\n *        // Disable encryption temporarilly.\n *        // This attribute will be removed by SSLFilter\n *        // inside the Session.write() call below.\n *        session.setAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE, Boolean.TRUE);\n *\n *        // Write StartTLSResponse which won't be encrypted.\n *        session.write(new MyStartTLSResponse(OK));\n *\n *        // Now DISABLE_ENCRYPTION_ONCE attribute is cleared.\n *        assert session.getAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE) == null;\n *    }\n * }\n * <\/pre>\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * @org.apache.xbean.XBean\n */\npublic class SslFilter extends IoFilterAdapter {\n    /**\n     * A session attribute key that stores underlying {@link SSLSession}\n     * for each session.\n     */\n    public static final AttributeKey SSL_SESSION = new AttributeKey(SslFilter.class, \"session\");\n\n    /**\n     * A session attribute key that makes next one write request bypass\n     * this filter (not encrypting the data).  This is a marker attribute,\n     * which means that you can put whatever as its value. ({@link Boolean#TRUE}\n     * is preferred.)  The attribute is automatically removed from the session\n     * attribute map as soon as {@link IoSession#write(Object)} is invoked,\n     * and therefore should be put again if you want to make more messages\n     * bypass this filter.  This is especially useful when you implement\n     * StartTLS.\n     */\n    public static final AttributeKey DISABLE_ENCRYPTION_ONCE = new AttributeKey(SslFilter.class, \"disableOnce\");\n\n    /**\n     * A session attribute key that makes this filter to emit a\n     * {@link IoHandler#messageReceived(IoSession, Object)} event with a\n     * special message ({@link #SESSION_SECURED} or {@link #SESSION_UNSECURED}).\n     * This is a marker attribute, which means that you can put whatever as its\n     * value. ({@link Boolean#TRUE} is preferred.)  By default, this filter\n     * doesn't emit any events related with SSL session flow control.\n     */\n    public static final AttributeKey USE_NOTIFICATION = new AttributeKey(SslFilter.class, \"useNotification\");\n\n    /**\n     * A session attribute key that should be set to an {@link InetSocketAddress}.\n     * Setting this attribute causes\n     * {@link SSLContext#createSSLEngine(String, int)} to be called passing the\n     * hostname and port of the {@link InetSocketAddress} to get an\n     * {@link SSLEngine} instance. If not set {@link SSLContext#createSSLEngine()}\n     * will be called.<br/>\n     * Using this feature {@link SSLSession} objects may be cached and reused\n     * when in client mode.\n     *\n     * @see SSLContext#createSSLEngine(String, int)\n     */\n    public static final AttributeKey PEER_ADDRESS = new AttributeKey(SslFilter.class, \"peerAddress\");\n\n    /**\n     * A special message object which is emitted with a {@link IoHandler#messageReceived(IoSession, Object)}\n     * event when the session is secured and its {@link #USE_NOTIFICATION}\n     * attribute is set.\n     */\n    public static final SslFilterMessage SESSION_SECURED = new SslFilterMessage(\n            \"SESSION_SECURED\");\n\n    /**\n     * A special message object which is emitted with a {@link IoHandler#messageReceived(IoSession, Object)}\n     * event when the session is not secure anymore and its {@link #USE_NOTIFICATION}\n     * attribute is set.\n     */\n    public static final SslFilterMessage SESSION_UNSECURED = new SslFilterMessage(\n            \"SESSION_UNSECURED\");\n\n    private static final AttributeKey NEXT_FILTER = new AttributeKey(SslFilter.class, \"nextFilter\");\n    private static final AttributeKey SSL_HANDLER = new AttributeKey(SslFilter.class, \"handler\");\n\n    /** The SslContext used */\n    private final SSLContext sslContext;\n\n    /** A flag used to tell the filter to start the handshake immediately */\n    private final boolean autoStart;\n    \n    /** A flag used to determinate if the handshake should start immediately */\n    private static final boolean START_HANDSHAKE = true;\n\n    private boolean client;\n\n    private boolean needClientAuth;\n\n    private boolean wantClientAuth;\n\n    private String[] enabledCipherSuites;\n\n    private String[] enabledProtocols;\n\n    /**\n     * Creates a new SSL filter using the specified {@link SSLContext}.\n     * The handshake will start immediately.\n     */\n    public SslFilter(SSLContext sslContext) {\n        this(sslContext, START_HANDSHAKE);\n    }\n\n    /**\n     * Creates a new SSL filter using the specified {@link SSLContext}.\n     * If the <code>autostart<\/code> flag is set to <code>true<\/code>, the\n     * handshake will start immediately.\n     */\n    public SslFilter(SSLContext sslContext, boolean autoStart) {\n        if (sslContext == null) {\n            throw new NullPointerException(\"sslContext\");\n        }\n\n        this.sslContext = sslContext;\n        this.autoStart = autoStart;\n    }\n\n    /**\n     * Returns the underlying {@link SSLSession} for the specified session.\n     *\n     * @return <tt>null<\/tt> if no {@link SSLSession} is initialized yet.\n     */\n    public SSLSession getSslSession(IoSession session) {\n        return (SSLSession) session.getAttribute(SSL_SESSION);\n    }\n\n    /**\n     * (Re)starts SSL session for the specified <tt>session<\/tt> if not started yet.\n     * Please note that SSL session is automatically started by default, and therefore\n     * you don't need to call this method unless you've used TLS closure.\n     *\n     * @return <tt>true<\/tt> if the SSL session has been started, <tt>false<\/tt> if already started.\n     * @throws SSLException if failed to start the SSL session\n     */\n    public boolean startSsl(IoSession session) throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        boolean started;\n        synchronized (handler) {\n            if (handler.isOutboundDone()) {\n                NextFilter nextFilter = (NextFilter) session\n                        .getAttribute(NEXT_FILTER);\n                handler.destroy();\n                handler.init();\n                handler.handshake(nextFilter);\n                started = true;\n            } else {\n                started = false;\n            }\n        }\n\n        handler.flushScheduledEvents();\n        return started;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if and only if the specified <tt>session<\/tt> is\n     * encrypted/decrypted over SSL/TLS currently.  This method will start\n     * to return <tt>false<\/tt> after TLS <tt>close_notify<\/tt> message\n     * is sent and any messages written after then is not going to get encrypted.\n     */\n    public boolean isSslStarted(IoSession session) {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        \n        if (handler == null) {\n            return false;\n        }\n\n        synchronized (handler) {\n            return !handler.isOutboundDone();\n        }\n    }\n\n    /**\n     * Stops the SSL session by sending TLS <tt>close_notify<\/tt> message to\n     * initiate TLS closure.\n     *\n     * @param session the {@link IoSession} to initiate TLS closure\n     * @throws SSLException if failed to initiate TLS closure\n     * @throws IllegalArgumentException if this filter is not managing the specified session\n     */\n    public WriteFuture stopSsl(IoSession session) throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        NextFilter nextFilter = (NextFilter) session.getAttribute(NEXT_FILTER);\n        WriteFuture future;\n        synchronized (handler) {\n            future = initiateClosure(nextFilter, session);\n        }\n\n        handler.flushScheduledEvents();\n\n        return future;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine is set to use client mode\n     * when handshaking.\n     */\n    public boolean isUseClientMode() {\n        return client;\n    }\n\n    /**\n     * Configures the engine to use client (or server) mode when handshaking.\n     */\n    public void setUseClientMode(boolean clientMode) {\n        this.client = clientMode;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine will <em>require<\/em> client authentication.\n     * This option is only useful to engines in the server mode.\n     */\n    public boolean isNeedClientAuth() {\n        return needClientAuth;\n    }\n\n    /**\n     * Configures the engine to <em>require<\/em> client authentication.\n     * This option is only useful for engines in the server mode.\n     */\n    public void setNeedClientAuth(boolean needClientAuth) {\n        this.needClientAuth = needClientAuth;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine will <em>request<\/em> client authentication.\n     * This option is only useful to engines in the server mode.\n     */\n    public boolean isWantClientAuth() {\n        return wantClientAuth;\n    }\n\n    /**\n     * Configures the engine to <em>request<\/em> client authentication.\n     * This option is only useful for engines in the server mode.\n     */\n    public void setWantClientAuth(boolean wantClientAuth) {\n        this.wantClientAuth = wantClientAuth;\n    }\n\n    /**\n     * Returns the list of cipher suites to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @return <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public String[] getEnabledCipherSuites() {\n        return enabledCipherSuites;\n    }\n\n    /**\n     * Sets the list of cipher suites to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @param cipherSuites <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public void setEnabledCipherSuites(String[] cipherSuites) {\n        this.enabledCipherSuites = cipherSuites;\n    }\n\n    /**\n     * Returns the list of protocols to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @return <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public String[] getEnabledProtocols() {\n        return enabledProtocols;\n    }\n\n    /**\n     * Sets the list of protocols to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @param protocols <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public void setEnabledProtocols(String[] protocols) {\n        this.enabledProtocols = protocols;\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        if (parent.contains(SslFilter.class)) {\n            throw new IllegalStateException(\n                    \"Only one \" + SslFilter.class.getName() + \" is permitted.\");\n        }\n\n        IoSession session = parent.getSession();\n        session.setAttribute(NEXT_FILTER, nextFilter);\n\n        // Create an SSL handler and start handshake.\n        SslHandler handler = new SslHandler(this, sslContext, session);\n        session.setAttribute(SSL_HANDLER, handler);\n    }\n\n    @Override\n    public void onPostAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        if (autoStart == START_HANDSHAKE) {\n            initiateHandshake(nextFilter, parent.getSession());\n        }\n    }\n\n    @Override\n    public void onPreRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        IoSession session = parent.getSession();\n        stopSsl(session);\n        session.removeAttribute(NEXT_FILTER);\n        session.removeAttribute(SSL_HANDLER);\n    }\n\n    // IoFilter impl.\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        try {\n            synchronized (handler) {\n                // release resources\n                handler.destroy();\n            }\n\n            handler.flushScheduledEvents();\n        } finally {\n            // notify closed session\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        \n        synchronized (handler) {\n            if (!isSslStarted(session) && handler.isInboundDone()) {\n                handler.scheduleMessageReceived(nextFilter, message);\n            } else {\n                IoBuffer buf = (IoBuffer) message;\n                \n                try {\n                    // forward read encrypted data to SSL handler\n                    handler.messageReceived(nextFilter, buf.buf());\n\n                    // Handle data to be forwarded to application or written to net\n                    handleSslData(nextFilter, handler);\n\n                    if (handler.isInboundDone()) {\n                        if (handler.isOutboundDone()) {\n                            handler.destroy();\n                        } else {\n                            initiateClosure(nextFilter, session);\n                        }\n\n                        if (buf.hasRemaining()) {\n                            // Forward the data received after closure.\n                            handler.scheduleMessageReceived(nextFilter, buf);\n                        }\n                    }\n                } catch (SSLException ssle) {\n                    if (!handler.isHandshakeComplete()) {\n                        SSLException newSsle = new SSLHandshakeException(\n                                \"SSL handshake failed.\");\n                        newSsle.initCause(ssle);\n                        ssle = newSsle;\n                    }\n\n                    throw ssle;\n                }\n            }\n        }\n\n        handler.flushScheduledEvents();\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (writeRequest instanceof EncryptedWriteRequest) {\n            EncryptedWriteRequest wrappedRequest = (EncryptedWriteRequest) writeRequest;\n            nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n        } else {\n            // ignore extra buffers used for handshaking\n        }\n    }\n\n    @Override\n    public void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) throws Exception {\n\n        if (cause instanceof WriteToClosedSessionException) {\n            // Filter out SSL close notify, which is likely to fail to flush\n            // due to disconnection.\n            WriteToClosedSessionException e = (WriteToClosedSessionException) cause;\n            List<WriteRequest> failedRequests = e.getRequests();\n            boolean containsCloseNotify = false;\n            for (WriteRequest r: failedRequests) {\n                if (isCloseNotify(r.getMessage())) {\n                    containsCloseNotify = true;\n                    break;\n                }\n            }\n            \n            if (containsCloseNotify) {\n                if (failedRequests.size() == 1) {\n                    // close notify is the only failed request; bail out.\n                    return;\n                }\n                \n                List<WriteRequest> newFailedRequests =\n                    new ArrayList<WriteRequest>(failedRequests.size() - 1);\n                for (WriteRequest r: failedRequests) {\n                    if (!isCloseNotify(r.getMessage())) {\n                        newFailedRequests.add(r);\n                    }\n                }\n                \n                if (newFailedRequests.isEmpty()) {\n                    // the failedRequests were full with close notify; bail out.\n                    return;\n                }\n                \n                cause = new WriteToClosedSessionException(\n                        newFailedRequests, cause.getMessage(), cause.getCause());\n            }\n        }\n        \n        nextFilter.exceptionCaught(session, cause);\n    }\n        \n    private boolean isCloseNotify(Object message) {\n        if (!(message instanceof IoBuffer)) {\n            return false;\n        }\n        \n        IoBuffer buf = (IoBuffer) message;\n        int offset = buf.position();\n        return buf.remaining() == 23 &&\n               buf.get(offset + 0) == 0x15 && buf.get(offset + 1) == 0x03 &&\n               buf.get(offset + 2) == 0x01 && buf.get(offset + 3) == 0x00 &&\n               buf.get(offset + 4) == 0x12;\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws SSLException {\n        boolean needsFlush = true;\n        SslHandler handler = getSslSessionHandler(session);\n        synchronized (handler) {\n            if (!isSslStarted(session)) {\n                handler.scheduleFilterWrite(nextFilter,\n                        writeRequest);\n            }\n            // Don't encrypt the data if encryption is disabled.\n            else if (session.containsAttribute(DISABLE_ENCRYPTION_ONCE)) {\n                // Remove the marker attribute because it is temporary.\n                session.removeAttribute(DISABLE_ENCRYPTION_ONCE);\n                handler.scheduleFilterWrite(nextFilter,\n                        writeRequest);\n            } else {\n                // Otherwise, encrypt the buffer.\n                IoBuffer buf = (IoBuffer) writeRequest.getMessage();\n\n                if (handler.isWritingEncryptedData()) {\n                    // data already encrypted; simply return buffer\n                    handler.scheduleFilterWrite(nextFilter, writeRequest);\n                } else if (handler.isHandshakeComplete()) {\n                    // SSL encrypt\n                    int pos = buf.position();\n                    handler.encrypt(buf.buf());\n                    buf.position(pos);\n                    IoBuffer encryptedBuffer = handler.fetchOutNetBuffer();\n                    handler.scheduleFilterWrite(\n                            nextFilter,\n                            new EncryptedWriteRequest(\n                                    writeRequest, encryptedBuffer));\n                } else {\n                    if (session.isConnected()) {\n                        // Handshake not complete yet.\n                        handler.schedulePreHandshakeWriteRequest(nextFilter,\n                                writeRequest);\n                    }\n                    needsFlush = false;\n                }\n            }\n        }\n\n        if (needsFlush) {\n            handler.flushScheduledEvents();\n        }\n    }\n\n    @Override\n    public void filterClose(final NextFilter nextFilter, final IoSession session)\n            throws SSLException {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        if (handler == null) {\n            // The connection might already have closed, or\n            // SSL might have not started yet.\n            nextFilter.filterClose(session);\n            return;\n        }\n\n        WriteFuture future = null;\n        try {\n            synchronized (handler) {\n                if (isSslStarted(session)) {\n                    future = initiateClosure(nextFilter, session);\n                    future.addListener(new IoFutureListener<IoFuture>() {\n                        public void operationComplete(IoFuture future) {\n                            nextFilter.filterClose(session);\n                        }\n                    });\n                }\n            }\n\n            handler.flushScheduledEvents();\n        } finally {\n            if (future == null) {\n                nextFilter.filterClose(session);\n            }\n        }\n    }\n\n    private void initiateHandshake(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        \n        synchronized (handler) {\n            handler.handshake(nextFilter);\n        }\n        \n        handler.flushScheduledEvents();\n    }\n\n    private WriteFuture initiateClosure(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        // if already shut down\n        if (!handler.closeOutbound()) {\n            return DefaultWriteFuture.newNotWrittenFuture(\n                    session, new IllegalStateException(\"SSL session is shut down already.\"));\n        }\n\n        // there might be data to write out here?\n        WriteFuture future = handler.writeNetBuffer(nextFilter);\n        if (future == null) {\n            future = DefaultWriteFuture.newWrittenFuture(session);\n        }\n\n        if (handler.isInboundDone()) {\n            handler.destroy();\n        }\n\n        if (session.containsAttribute(USE_NOTIFICATION)) {\n            handler.scheduleMessageReceived(nextFilter, SESSION_UNSECURED);\n        }\n\n        return future;\n    }\n\n    // Utiliities\n\n    private void handleSslData(NextFilter nextFilter, SslHandler handler)\n            throws SSLException {\n        // Flush any buffered write requests occurred before handshaking.\n        if (handler.isHandshakeComplete()) {\n            handler.flushPreHandshakeEvents();\n        }\n\n        // Write encrypted data to be written (if any)\n        handler.writeNetBuffer(nextFilter);\n\n        // handle app. data read (if any)\n        handleAppDataRead(nextFilter, handler);\n    }\n\n    private void handleAppDataRead(NextFilter nextFilter, SslHandler handler) {\n        // forward read app data\n        IoBuffer readBuffer = handler.fetchAppBuffer();\n        if (readBuffer.hasRemaining()) {\n            handler.scheduleMessageReceived(nextFilter, readBuffer);\n        }\n    }\n\n    private SslHandler getSslSessionHandler(IoSession session) {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        \n        if (handler == null) {\n            throw new IllegalStateException();\n        }\n        \n        if (handler.getParent() != this) {\n            throw new IllegalArgumentException(\"Not managed by this filter.\");\n        }\n        \n        return handler;\n    }\n\n    /**\n     * A message that is sent from {@link SslFilter} when the connection became\n     * secure or is not secure anymore.\n     *\n     * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n     */\n    public static class SslFilterMessage {\n        private final String name;\n\n        private SslFilterMessage(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n\n    private static class EncryptedWriteRequest extends WriteRequestWrapper {\n        private final IoBuffer encryptedMessage;\n\n        private EncryptedWriteRequest(WriteRequest writeRequest,\n                IoBuffer encryptedMessage) {\n            super(writeRequest);\n            this.encryptedMessage = encryptedMessage;\n        }\n\n        @Override\n        public Object getMessage() {\n            return encryptedMessage;\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLSession;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An SSL filter that encrypts and decrypts the data exchanged in the session.\n * Adding this filter triggers SSL handshake procedure immediately by sending\n * a SSL 'hello' message, so you don't need to call\n * {@link #startSsl(IoSession)} manually unless you are implementing StartTLS\n * (see below).  If you don't want the handshake procedure to start\n * immediately, please specify {@code false} as {@code autoStart} parameter in\n * the constructor.\n * <p>\n * This filter uses an {@link SSLEngine} which was introduced in Java 5, so\n * Java version 5 or above is mandatory to use this filter. And please note that\n * this filter only works for TCP/IP connections.\n * <p>\n *\n * <h2>Implementing StartTLS<\/h2>\n * <p>\n * You can use {@link #DISABLE_ENCRYPTION_ONCE} attribute to implement StartTLS:\n * <pre>\n * public void messageReceived(IoSession session, Object message) {\n *    if (message instanceof MyStartTLSRequest) {\n *        // Insert SSLFilter to get ready for handshaking\n *        session.getFilterChain().addFirst(sslFilter);\n *\n *        // Disable encryption temporarilly.\n *        // This attribute will be removed by SSLFilter\n *        // inside the Session.write() call below.\n *        session.setAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE, Boolean.TRUE);\n *\n *        // Write StartTLSResponse which won't be encrypted.\n *        session.write(new MyStartTLSResponse(OK));\n *\n *        // Now DISABLE_ENCRYPTION_ONCE attribute is cleared.\n *        assert session.getAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE) == null;\n *    }\n * }\n * <\/pre>\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * @org.apache.xbean.XBean\n */\npublic class SslFilter extends IoFilterAdapter {\n    /** The logger */\n    private static final Logger LOGGER = LoggerFactory.getLogger( SslFilter.class );\n\n    /**\n     * A session attribute key that stores underlying {@link SSLSession}\n     * for each session.\n     */\n    public static final AttributeKey SSL_SESSION = new AttributeKey(SslFilter.class, \"session\");\n\n    /**\n     * A session attribute key that makes next one write request bypass\n     * this filter (not encrypting the data).  This is a marker attribute,\n     * which means that you can put whatever as its value. ({@link Boolean#TRUE}\n     * is preferred.)  The attribute is automatically removed from the session\n     * attribute map as soon as {@link IoSession#write(Object)} is invoked,\n     * and therefore should be put again if you want to make more messages\n     * bypass this filter.  This is especially useful when you implement\n     * StartTLS.\n     */\n    public static final AttributeKey DISABLE_ENCRYPTION_ONCE = new AttributeKey(SslFilter.class, \"disableOnce\");\n\n    /**\n     * A session attribute key that makes this filter to emit a\n     * {@link IoHandler#messageReceived(IoSession, Object)} event with a\n     * special message ({@link #SESSION_SECURED} or {@link #SESSION_UNSECURED}).\n     * This is a marker attribute, which means that you can put whatever as its\n     * value. ({@link Boolean#TRUE} is preferred.)  By default, this filter\n     * doesn't emit any events related with SSL session flow control.\n     */\n    public static final AttributeKey USE_NOTIFICATION = new AttributeKey(SslFilter.class, \"useNotification\");\n\n    /**\n     * A session attribute key that should be set to an {@link InetSocketAddress}.\n     * Setting this attribute causes\n     * {@link SSLContext#createSSLEngine(String, int)} to be called passing the\n     * hostname and port of the {@link InetSocketAddress} to get an\n     * {@link SSLEngine} instance. If not set {@link SSLContext#createSSLEngine()}\n     * will be called.<br/>\n     * Using this feature {@link SSLSession} objects may be cached and reused\n     * when in client mode.\n     *\n     * @see SSLContext#createSSLEngine(String, int)\n     */\n    public static final AttributeKey PEER_ADDRESS = new AttributeKey(SslFilter.class, \"peerAddress\");\n\n    /**\n     * A special message object which is emitted with a {@link IoHandler#messageReceived(IoSession, Object)}\n     * event when the session is secured and its {@link #USE_NOTIFICATION}\n     * attribute is set.\n     */\n    public static final SslFilterMessage SESSION_SECURED = new SslFilterMessage(\n            \"SESSION_SECURED\");\n\n    /**\n     * A special message object which is emitted with a {@link IoHandler#messageReceived(IoSession, Object)}\n     * event when the session is not secure anymore and its {@link #USE_NOTIFICATION}\n     * attribute is set.\n     */\n    public static final SslFilterMessage SESSION_UNSECURED = new SslFilterMessage(\n            \"SESSION_UNSECURED\");\n\n    private static final AttributeKey NEXT_FILTER = new AttributeKey(SslFilter.class, \"nextFilter\");\n    private static final AttributeKey SSL_HANDLER = new AttributeKey(SslFilter.class, \"handler\");\n\n    /** The SslContext used */\n    /* No qualifier */ final SSLContext sslContext;\n\n    /** A flag used to tell the filter to start the handshake immediately */\n    private final boolean autoStart;\n    \n    /** A flag used to determinate if the handshake should start immediately */\n    private static final boolean START_HANDSHAKE = true;\n\n    private boolean client;\n\n    private boolean needClientAuth;\n\n    private boolean wantClientAuth;\n\n    private String[] enabledCipherSuites;\n\n    private String[] enabledProtocols;\n\n    /**\n     * Creates a new SSL filter using the specified {@link SSLContext}.\n     * The handshake will start immediately.\n     */\n    public SslFilter(SSLContext sslContext) {\n        this(sslContext, START_HANDSHAKE);\n    }\n\n    /**\n     * Creates a new SSL filter using the specified {@link SSLContext}.\n     * If the <code>autostart<\/code> flag is set to <code>true<\/code>, the\n     * handshake will start immediately.\n     */\n    public SslFilter(SSLContext sslContext, boolean autoStart) {\n        if (sslContext == null) {\n            throw new NullPointerException(\"sslContext\");\n        }\n\n        this.sslContext = sslContext;\n        this.autoStart = autoStart;\n    }\n\n    /**\n     * Returns the underlying {@link SSLSession} for the specified session.\n     *\n     * @return <tt>null<\/tt> if no {@link SSLSession} is initialized yet.\n     */\n    public SSLSession getSslSession(IoSession session) {\n        return (SSLSession) session.getAttribute(SSL_SESSION);\n    }\n\n    /**\n     * (Re)starts SSL session for the specified <tt>session<\/tt> if not started yet.\n     * Please note that SSL session is automatically started by default, and therefore\n     * you don't need to call this method unless you've used TLS closure.\n     *\n     * @return <tt>true<\/tt> if the SSL session has been started, <tt>false<\/tt> if already started.\n     * @throws SSLException if failed to start the SSL session\n     */\n    public boolean startSsl(IoSession session) throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        boolean started;\n        synchronized (handler) {\n            if (handler.isOutboundDone()) {\n                NextFilter nextFilter = (NextFilter) session\n                        .getAttribute(NEXT_FILTER);\n                handler.destroy();\n                handler.init();\n                handler.handshake(nextFilter);\n                started = true;\n            } else {\n                started = false;\n            }\n        }\n\n        handler.flushScheduledEvents();\n        return started;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if and only if the specified <tt>session<\/tt> is\n     * encrypted/decrypted over SSL/TLS currently. This method will start\n     * to return <tt>false<\/tt> after TLS <tt>close_notify<\/tt> message\n     * is sent and any messages written after then is not going to get encrypted.\n     */\n    public boolean isSslStarted(IoSession session) {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        \n        if (handler == null) {\n            return false;\n        }\n\n        synchronized (handler) {\n            return !handler.isOutboundDone();\n        }\n    }\n\n    /**\n     * Stops the SSL session by sending TLS <tt>close_notify<\/tt> message to\n     * initiate TLS closure.\n     *\n     * @param session the {@link IoSession} to initiate TLS closure\n     * @throws SSLException if failed to initiate TLS closure\n     * @throws IllegalArgumentException if this filter is not managing the specified session\n     */\n    public WriteFuture stopSsl(IoSession session) throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        NextFilter nextFilter = (NextFilter) session.getAttribute(NEXT_FILTER);\n        WriteFuture future;\n        synchronized (handler) {\n            future = initiateClosure(nextFilter, session);\n        }\n\n        handler.flushScheduledEvents();\n\n        return future;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine is set to use client mode\n     * when handshaking.\n     */\n    public boolean isUseClientMode() {\n        return client;\n    }\n\n    /**\n     * Configures the engine to use client (or server) mode when handshaking.\n     */\n    public void setUseClientMode(boolean clientMode) {\n        this.client = clientMode;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine will <em>require<\/em> client authentication.\n     * This option is only useful to engines in the server mode.\n     */\n    public boolean isNeedClientAuth() {\n        return needClientAuth;\n    }\n\n    /**\n     * Configures the engine to <em>require<\/em> client authentication.\n     * This option is only useful for engines in the server mode.\n     */\n    public void setNeedClientAuth(boolean needClientAuth) {\n        this.needClientAuth = needClientAuth;\n    }\n\n    /**\n     * Returns <tt>true<\/tt> if the engine will <em>request<\/em> client authentication.\n     * This option is only useful to engines in the server mode.\n     */\n    public boolean isWantClientAuth() {\n        return wantClientAuth;\n    }\n\n    /**\n     * Configures the engine to <em>request<\/em> client authentication.\n     * This option is only useful for engines in the server mode.\n     */\n    public void setWantClientAuth(boolean wantClientAuth) {\n        this.wantClientAuth = wantClientAuth;\n    }\n\n    /**\n     * Returns the list of cipher suites to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @return <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public String[] getEnabledCipherSuites() {\n        return enabledCipherSuites;\n    }\n\n    /**\n     * Sets the list of cipher suites to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @param cipherSuites <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public void setEnabledCipherSuites(String[] cipherSuites) {\n        this.enabledCipherSuites = cipherSuites;\n    }\n\n    /**\n     * Returns the list of protocols to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @return <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public String[] getEnabledProtocols() {\n        return enabledProtocols;\n    }\n\n    /**\n     * Sets the list of protocols to be enabled when {@link SSLEngine}\n     * is initialized.\n     *\n     * @param protocols <tt>null<\/tt> means 'use {@link SSLEngine}'s default.'\n     */\n    public void setEnabledProtocols(String[] protocols) {\n        this.enabledProtocols = protocols;\n    }\n\n    /**\n     * Executed just before the filter is added into the chain, we do :\n     * <ul>\n     * <li>check that we don't have a SSL filter already present\n     * <li>we update the next filter\n     * <li>we create the SSL handler helper class\n     * <li>and we store it into the session's Attributes\n     * <\/ul>\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        // Check that we don't have a SSL filter already present in the chain\n        if (parent.contains(SslFilter.class)) {\n            String msg = \"Only one SSL filter is permitted in a chain.\";\n            LOGGER.error(msg);\n            throw new IllegalStateException(msg);\n        }\n\n        LOGGER.debug(\"Adding the SSL Filter {} to the chain\", name);\n\n        IoSession session = parent.getSession();\n        session.setAttribute(NEXT_FILTER, nextFilter);\n\n        // Create a SSL handler and start handshake.\n        SslHandler handler = new SslHandler(this, session);\n        handler.init();\n        session.setAttribute(SSL_HANDLER, handler);\n    }\n\n    @Override\n    public void onPostAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        if (autoStart == START_HANDSHAKE) {\n            initiateHandshake(nextFilter, parent.getSession());\n        }\n    }\n\n    @Override\n    public void onPreRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws SSLException {\n        IoSession session = parent.getSession();\n        stopSsl(session);\n        session.removeAttribute(NEXT_FILTER);\n        session.removeAttribute(SSL_HANDLER);\n    }\n\n    // IoFilter impl.\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        try {\n            synchronized (handler) {\n                // release resources\n                handler.destroy();\n            }\n\n            handler.flushScheduledEvents();\n        } finally {\n            // notify closed session\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            if ( isSslStarted(session)) {\n                LOGGER.debug(\"Session[{}](SSL): Message received : {}\", session.getId(), message);\n            } else {\n                LOGGER.debug(\"Session[{}]: Message received : {}\", session.getId(), message);\n            }\n        }\n        \n        SslHandler handler = getSslSessionHandler(session);\n        \n        synchronized (handler) {\n            if (!isSslStarted(session) && handler.isInboundDone()) {\n                // The SSL session must be established first before we \n                // can push data to the application. Store the incoming\n                // data into a queue for a later processing\n                handler.scheduleMessageReceived(nextFilter, message);\n            } else {\n                IoBuffer buf = (IoBuffer) message;\n                \n                try {\n                    // forward read encrypted data to SSL handler\n                    handler.messageReceived(nextFilter, buf.buf());\n\n                    // Handle data to be forwarded to application or written to net\n                    handleSslData(nextFilter, handler);\n\n                    if (handler.isInboundDone()) {\n                        if (handler.isOutboundDone()) {\n                            handler.destroy();\n                        } else {\n                            initiateClosure(nextFilter, session);\n                        }\n\n                        if (buf.hasRemaining()) {\n                            // Forward the data received after closure.\n                            handler.scheduleMessageReceived(nextFilter, buf);\n                        }\n                    }\n                } catch (SSLException ssle) {\n                    if (!handler.isHandshakeComplete()) {\n                        SSLException newSsle = new SSLHandshakeException(\n                                \"SSL handshake failed.\");\n                        newSsle.initCause(ssle);\n                        ssle = newSsle;\n                    }\n\n                    throw ssle;\n                }\n            }\n        }\n\n        handler.flushScheduledEvents();\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (writeRequest instanceof EncryptedWriteRequest) {\n            EncryptedWriteRequest wrappedRequest = (EncryptedWriteRequest) writeRequest;\n            nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n        } else {\n            // ignore extra buffers used for handshaking\n        }\n    }\n\n    @Override\n    public void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) throws Exception {\n\n        if (cause instanceof WriteToClosedSessionException) {\n            // Filter out SSL close notify, which is likely to fail to flush\n            // due to disconnection.\n            WriteToClosedSessionException e = (WriteToClosedSessionException) cause;\n            List<WriteRequest> failedRequests = e.getRequests();\n            boolean containsCloseNotify = false;\n            for (WriteRequest r: failedRequests) {\n                if (isCloseNotify(r.getMessage())) {\n                    containsCloseNotify = true;\n                    break;\n                }\n            }\n            \n            if (containsCloseNotify) {\n                if (failedRequests.size() == 1) {\n                    // close notify is the only failed request; bail out.\n                    return;\n                }\n                \n                List<WriteRequest> newFailedRequests =\n                    new ArrayList<WriteRequest>(failedRequests.size() - 1);\n                for (WriteRequest r: failedRequests) {\n                    if (!isCloseNotify(r.getMessage())) {\n                        newFailedRequests.add(r);\n                    }\n                }\n                \n                if (newFailedRequests.isEmpty()) {\n                    // the failedRequests were full with close notify; bail out.\n                    return;\n                }\n                \n                cause = new WriteToClosedSessionException(\n                        newFailedRequests, cause.getMessage(), cause.getCause());\n            }\n        }\n        \n        nextFilter.exceptionCaught(session, cause);\n    }\n        \n    private boolean isCloseNotify(Object message) {\n        if (!(message instanceof IoBuffer)) {\n            return false;\n        }\n        \n        IoBuffer buf = (IoBuffer) message;\n        int offset = buf.position();\n        return buf.remaining() == 23 &&\n               buf.get(offset + 0) == 0x15 && buf.get(offset + 1) == 0x03 &&\n               buf.get(offset + 2) == 0x01 && buf.get(offset + 3) == 0x00 &&\n               buf.get(offset + 4) == 0x12;\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            if ( isSslStarted(session)) {\n                LOGGER.debug(\"Session[{}](SSL): Writing Message : {}\", session.getId(), writeRequest);\n            } else {\n                LOGGER.debug(\"Session[{}]: Writing Message : {}\", session.getId(), writeRequest);\n            }\n        }\n\n        boolean needsFlush = true;\n        SslHandler handler = getSslSessionHandler(session);\n        synchronized (handler) {\n            if (!isSslStarted(session)) {\n                handler.scheduleFilterWrite(nextFilter,\n                        writeRequest);\n            }\n            // Don't encrypt the data if encryption is disabled.\n            else if (session.containsAttribute(DISABLE_ENCRYPTION_ONCE)) {\n                // Remove the marker attribute because it is temporary.\n                session.removeAttribute(DISABLE_ENCRYPTION_ONCE);\n                handler.scheduleFilterWrite(nextFilter,\n                        writeRequest);\n            } else {\n                // Otherwise, encrypt the buffer.\n                IoBuffer buf = (IoBuffer) writeRequest.getMessage();\n\n                if (handler.isWritingEncryptedData()) {\n                    // data already encrypted; simply return buffer\n                    handler.scheduleFilterWrite(nextFilter, writeRequest);\n                } else if (handler.isHandshakeComplete()) {\n                    // SSL encrypt\n                    int pos = buf.position();\n                    handler.encrypt(buf.buf());\n                    buf.position(pos);\n                    IoBuffer encryptedBuffer = handler.fetchOutNetBuffer();\n                    handler.scheduleFilterWrite(\n                            nextFilter,\n                            new EncryptedWriteRequest(\n                                    writeRequest, encryptedBuffer));\n                } else {\n                    if (session.isConnected()) {\n                        // Handshake not complete yet.\n                        handler.schedulePreHandshakeWriteRequest(nextFilter,\n                                writeRequest);\n                    }\n                    needsFlush = false;\n                }\n            }\n        }\n\n        if (needsFlush) {\n            handler.flushScheduledEvents();\n        }\n    }\n\n    @Override\n    public void filterClose(final NextFilter nextFilter, final IoSession session)\n            throws SSLException {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        if (handler == null) {\n            // The connection might already have closed, or\n            // SSL might have not started yet.\n            nextFilter.filterClose(session);\n            return;\n        }\n\n        WriteFuture future = null;\n        try {\n            synchronized (handler) {\n                if (isSslStarted(session)) {\n                    future = initiateClosure(nextFilter, session);\n                    future.addListener(new IoFutureListener<IoFuture>() {\n                        public void operationComplete(IoFuture future) {\n                            nextFilter.filterClose(session);\n                        }\n                    });\n                }\n            }\n\n            handler.flushScheduledEvents();\n        } finally {\n            if (future == null) {\n                nextFilter.filterClose(session);\n            }\n        }\n    }\n\n    private void initiateHandshake(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        LOGGER.debug(\"Session[{}] : Starting the first handshake\", session.getId());\n        SslHandler handler = getSslSessionHandler(session);\n        \n        synchronized (handler) {\n            handler.handshake(nextFilter);\n        }\n        \n        handler.flushScheduledEvents();\n    }\n\n    private WriteFuture initiateClosure(NextFilter nextFilter, IoSession session)\n            throws SSLException {\n        SslHandler handler = getSslSessionHandler(session);\n        \n        // if already shut down\n        if (!handler.closeOutbound()) {\n            return DefaultWriteFuture.newNotWrittenFuture(\n                    session, new IllegalStateException(\"SSL session is shut down already.\"));\n        }\n\n        // there might be data to write out here?\n        WriteFuture future = handler.writeNetBuffer(nextFilter);\n        \n        if (future == null) {\n            future = DefaultWriteFuture.newWrittenFuture(session);\n        }\n\n        if (handler.isInboundDone()) {\n            handler.destroy();\n        }\n\n        if (session.containsAttribute(USE_NOTIFICATION)) {\n            handler.scheduleMessageReceived(nextFilter, SESSION_UNSECURED);\n        }\n\n        return future;\n    }\n\n    // Utilities\n    private void handleSslData(NextFilter nextFilter, SslHandler handler)\n            throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            IoSession session = handler.getSession();\n            \n            if ( isSslStarted(session)) {\n                LOGGER.debug(\"Session[{}](SSL): Processing the SSL Data \", session.getId());\n            } else {\n                LOGGER.debug(\"Session[{}]: Processing the SSL Data message\", session.getId());\n            }\n        }\n\n        // Flush any buffered write requests occurred before handshaking.\n        if (handler.isHandshakeComplete()) {\n            handler.flushPreHandshakeEvents();\n        }\n\n        // Write encrypted data to be written (if any)\n        handler.writeNetBuffer(nextFilter);\n\n        // handle app. data read (if any)\n        handleAppDataRead(nextFilter, handler);\n    }\n\n    private void handleAppDataRead(NextFilter nextFilter, SslHandler handler) {\n        // forward read app data\n        IoBuffer readBuffer = handler.fetchAppBuffer();\n        \n        if (readBuffer.hasRemaining()) {\n            handler.scheduleMessageReceived(nextFilter, readBuffer);\n        }\n    }\n\n    private SslHandler getSslSessionHandler(IoSession session) {\n        SslHandler handler = (SslHandler) session.getAttribute(SSL_HANDLER);\n        \n        if (handler == null) {\n            throw new IllegalStateException();\n        }\n        \n        if (handler.getSslFilter() != this) {\n            throw new IllegalArgumentException(\"Not managed by this filter.\");\n        }\n        \n        return handler;\n    }\n\n    /**\n     * A message that is sent from {@link SslFilter} when the connection became\n     * secure or is not secure anymore.\n     *\n     * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n     */\n    public static class SslFilterMessage {\n        private final String name;\n\n        private SslFilterMessage(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n\n    private static class EncryptedWriteRequest extends WriteRequestWrapper {\n        private final IoBuffer encryptedMessage;\n\n        private EncryptedWriteRequest(WriteRequest writeRequest,\n                IoBuffer encryptedMessage) {\n            super(writeRequest);\n            this.encryptedMessage = encryptedMessage;\n        }\n\n        @Override\n        public Object getMessage() {\n            return encryptedMessage;\n        }\n    }\n}\n","lineNo":371}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\nclass SslHandler {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    private final SslFilter parent;\n    private final SSLContext sslContext;\n    private final IoSession session;\n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    private boolean initialHandshakeComplete;\n    private boolean handshakeComplete;\n    private boolean writingEncryptedData;\n\n    /** A flag used when the Handlshake is finished */\n    private static final boolean HANDSHAKE_FINISHED = true;\n\n    /**\n     * Constuctor.\n     *\n     * @param sslc\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter parent, SSLContext sslContext, IoSession session) throws SSLException {\n        this.parent = parent;\n        this.session = session;\n        this.sslContext = sslContext;\n        init();\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(parent.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (parent.isWantClientAuth()) {\n            sslEngine.setWantClientAuth(true);\n        }\n\n        if (parent.isNeedClientAuth()) {\n            sslEngine.setNeedClientAuth(true);\n        }\n\n        if (parent.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(parent.getEnabledCipherSuites());\n        }\n\n        if (parent.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(parent.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        handshakeComplete = false;\n        initialHandshakeComplete = false;\n        writingEncryptedData = false;\n    }\n\n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    public SslFilter getParent() {\n        return parent;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            parent.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent e;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((e = filterWriteEventQueue.poll()) != null) {\n                e.getNextFilter().filterWrite(session, (WriteRequest) e.getParameter());\n            }\n        }\n\n        while ((e = messageReceivedEventQueue.poll()) != null) {\n            e.getNextFilter().messageReceived(session, e.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n            case FINISHED:\n                session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                handshakeComplete = true;\n\n                if (!initialHandshakeComplete && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                    // SESSION_SECURED is fired only when it's the first\n                    // handshake.\n                    // (i.e. renegotiation shouldn't trigger SESSION_SECURED.)\n                    initialHandshakeComplete = true;\n                    scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                }\n\n                return;\n\n            case NEED_TASK:\n                handshakeStatus = doTasks();\n                break;\n\n            case NEED_UNWRAP:\n                // we need more data read\n                SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n\n                if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                        && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                    // We need more data or the session is closed\n                    return;\n                }\n\n                break;\n\n            case NEED_WRAP:\n                // First make sure that the out buffer is completely empty.\n                // Since we\n                // cannot call wrap with data left on the buffer\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    return;\n                }\n\n                SSLEngineResult result;\n                createOutNetBuffer(0);\n\n                for (;;) {\n                    result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                        outNetBuffer.limit(outNetBuffer.capacity());\n                    } else {\n                        break;\n                    }\n                }\n\n                outNetBuffer.flip();\n                handshakeStatus = result.getHandshakeStatus();\n                writeNetBuffer(nextFilter);\n                break;\n\n            default:\n                throw new IllegalStateException(\"Invalid Handshaking State\" + handshakeStatus);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            parent.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    parent.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok,\n        // try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = decrypt(HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    private SSLEngineResult decrypt(boolean finished) throws SSLException {\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (\n                            (finished || handshakeComplete) \n                            && \n                            (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        ) \n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n * <p/>\n * This class is not to be used by any client, it's closely associated with the SSL Filter.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\n/** No qualifier*/ class SslHandler {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    \n    /** The SSL Filter which has created this handler */\n    private final SslFilter sslFilter;\n    \n    /** The current session */\n    private final IoSession session;\n    \n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    /** A queue used to stack all the incoming data until the SSL session is established */\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    \n    /** \n     * A flag set to true when the first SSL handshake has been completed\n     * This is used to avoid sending a notification to the application handler\n     * when we switch to a SECURE or UNSECURE session. \n     */\n    private boolean firstSSLNegociation;\n    \n    /** A flag set to true when a SSL Handshake has been completed */\n    private boolean handshakeComplete;\n    \n    /** A flag used to indicate to the SslFilter that the buffer\n     * it will write is already encrypted (this will be the case\n     * for data being produced during the handshake). */\n    private boolean writingEncryptedData;\n\n    /**\n     * Create a new SSL Handler, and initialize it.\n     *\n     * @param sslContext\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter sslFilter, IoSession session) throws SSLException {\n        this.sslFilter = sslFilter;\n        this.session = session;\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException If the underlying SSLEngine handshake initialization failed\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        LOGGER.debug(\"Session[{}]: Initializing the SSL Handler\", session.getId());\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslFilter.sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslFilter.sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(sslFilter.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (!sslEngine.getUseClientMode()) {\n            // Those parameters are only valid when in server mode\n            if (sslFilter.isWantClientAuth()) {\n                sslEngine.setWantClientAuth(true);\n            }\n\n            if (sslFilter.isNeedClientAuth()) {\n                sslEngine.setNeedClientAuth(true);\n            }\n        }\n\n        // Set the cipher suite to use by this SslEngine instance\n        if (sslFilter.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(sslFilter.getEnabledCipherSuites());\n        }\n\n        // Set the list of enabled protocols\n        if (sslFilter.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(sslFilter.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        // However, if we don't call it here, the tests are failing. Why?\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        // Default value\n        writingEncryptedData = false;\n        \n        // We haven't yet started a SSL negotiation\n        // set the flags accordingly\n        firstSSLNegociation = true;\n        handshakeComplete = false;\n\n        LOGGER.debug(\"Session[{}]: SSL Handler Initialization done.\", session.getId());\n    }\n\n    \n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    /**\n     * @return The SSL filter which has created this handler\n     */\n    public SslFilter getSslFilter() {\n        return sslFilter;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check if we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            sslFilter.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    /**\n     * Push the newly received data into a queue, waiting for the SSL session\n     * to be fully established\n     *\n     * @param nextFilter The next filter to call\n     * @param message The incoming data\n     */\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent event;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((event = filterWriteEventQueue.poll()) != null) {\n                NextFilter nextFilter = event.getNextFilter();\n                nextFilter.filterWrite(session, (WriteRequest) event.getParameter());\n            }\n        }\n\n        while ((event = messageReceivedEventQueue.poll()) != null) {\n            NextFilter nextFilter = event.getNextFilter();\n            nextFilter.messageReceived(session, event.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            if ( !isOutboundDone()) {\n                LOGGER.debug(\"Session[{}](SSL): Processing the received message\", session.getId());\n            } else {\n                LOGGER.debug(\"Session[{}]: Processing the received message\", session.getId());\n            }\n        }\n\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n                case FINISHED:\n                    LOGGER.debug(\"Session[{}] : processing the FINISHED state\", session.getId());\n                    session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                    handshakeComplete = true;\n    \n                    // Send the SECURE message only if it's the first SSL handshake\n                    if (firstSSLNegociation && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                        // SESSION_SECURED is fired only when it's the first handshake\n                        firstSSLNegociation = false;\n                        scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                    }\n                    \n                    if ( LOGGER.isDebugEnabled()) {\n                        if ( !isOutboundDone()) {\n                            LOGGER.debug(\"Session[{}] is now secured\", session.getId());\n                        } else {\n                            LOGGER.debug(\"Session[{}] is not secured yet\", session.getId());\n                        }\n                    }\n    \n                    return;\n    \n                case NEED_TASK:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_TASK state\", session.getId());\n                    handshakeStatus = doTasks();\n                    break;\n    \n                case NEED_UNWRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_UNWRAP state\", session.getId());\n                    // we need more data read\n                    SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n    \n                    if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                            && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                        // We need more data or the session is closed\n                        return;\n                    }\n    \n                    break;\n    \n                case NEED_WRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_WRAP state\", session.getId());\n                    // First make sure that the out buffer is completely empty.\n                    // Since we\n                    // cannot call wrap with data left on the buffer\n                    if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                        return;\n                    }\n    \n                    SSLEngineResult result;\n                    createOutNetBuffer(0);\n    \n                    for (;;) {\n                        result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                        if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                            outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                            outNetBuffer.limit(outNetBuffer.capacity());\n                        } else {\n                            break;\n                        }\n                    }\n    \n                    outNetBuffer.flip();\n                    handshakeStatus = result.getHandshakeStatus();\n                    writeNetBuffer(nextFilter);\n                    break;\n    \n                default:\n                    String msg = \"Invalid Handshaking State\" + handshakeStatus + \n                        \" while processing the Handshake for session \" + session.getId();\n                    LOGGER.error(msg);\n                    throw new IllegalStateException(msg);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = unwrap();\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok, try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    /**\n     * Decrypt the incoming buffer and move the decrypted data to an\n     * application buffer. \n     */\n    private SSLEngineResult unwrap() throws SSLException {\n        // We first have to create the application buffer if it does not exist\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            // We already have one, just add the new data into it\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            // Decode the incoming data\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            \n            // We can be processing the Handshake\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                // We have to grow the target buffer, it's too small.\n                // Then we can call the unwrap method again\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) \n                        || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n    \n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        \n        sb.append(\"SSLStatus <\");\n        \n        if (handshakeComplete) {\n            sb.append(\"SSL established\");\n        } else {\n            sb.append(\"Processing Handshake\" ).append(\"; \");\n            sb.append(\"Status : \").append(handshakeStatus).append(\"; \");\n        }\n        \n        sb.append(\", \");\n        sb.append(\"HandshakeComplete :\" ).append(handshakeComplete).append(\", \");\n        sb.append(\">\");\n        return sb.toString();\n    }\n    \n}\n","lineNo":310}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\nclass SslHandler {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    private final SslFilter parent;\n    private final SSLContext sslContext;\n    private final IoSession session;\n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    private boolean initialHandshakeComplete;\n    private boolean handshakeComplete;\n    private boolean writingEncryptedData;\n\n    /** A flag used when the Handlshake is finished */\n    private static final boolean HANDSHAKE_FINISHED = true;\n\n    /**\n     * Constuctor.\n     *\n     * @param sslc\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter parent, SSLContext sslContext, IoSession session) throws SSLException {\n        this.parent = parent;\n        this.session = session;\n        this.sslContext = sslContext;\n        init();\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(parent.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (parent.isWantClientAuth()) {\n            sslEngine.setWantClientAuth(true);\n        }\n\n        if (parent.isNeedClientAuth()) {\n            sslEngine.setNeedClientAuth(true);\n        }\n\n        if (parent.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(parent.getEnabledCipherSuites());\n        }\n\n        if (parent.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(parent.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        handshakeComplete = false;\n        initialHandshakeComplete = false;\n        writingEncryptedData = false;\n    }\n\n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    public SslFilter getParent() {\n        return parent;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            parent.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent e;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((e = filterWriteEventQueue.poll()) != null) {\n                e.getNextFilter().filterWrite(session, (WriteRequest) e.getParameter());\n            }\n        }\n\n        while ((e = messageReceivedEventQueue.poll()) != null) {\n            e.getNextFilter().messageReceived(session, e.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n            case FINISHED:\n                session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                handshakeComplete = true;\n\n                if (!initialHandshakeComplete && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                    // SESSION_SECURED is fired only when it's the first\n                    // handshake.\n                    // (i.e. renegotiation shouldn't trigger SESSION_SECURED.)\n                    initialHandshakeComplete = true;\n                    scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                }\n\n                return;\n\n            case NEED_TASK:\n                handshakeStatus = doTasks();\n                break;\n\n            case NEED_UNWRAP:\n                // we need more data read\n                SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n\n                if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                        && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                    // We need more data or the session is closed\n                    return;\n                }\n\n                break;\n\n            case NEED_WRAP:\n                // First make sure that the out buffer is completely empty.\n                // Since we\n                // cannot call wrap with data left on the buffer\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    return;\n                }\n\n                SSLEngineResult result;\n                createOutNetBuffer(0);\n\n                for (;;) {\n                    result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                        outNetBuffer.limit(outNetBuffer.capacity());\n                    } else {\n                        break;\n                    }\n                }\n\n                outNetBuffer.flip();\n                handshakeStatus = result.getHandshakeStatus();\n                writeNetBuffer(nextFilter);\n                break;\n\n            default:\n                throw new IllegalStateException(\"Invalid Handshaking State\" + handshakeStatus);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            parent.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    parent.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok,\n        // try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = decrypt(HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    private SSLEngineResult decrypt(boolean finished) throws SSLException {\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (\n                            (finished || handshakeComplete) \n                            && \n                            (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        ) \n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n * <p/>\n * This class is not to be used by any client, it's closely associated with the SSL Filter.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\n/** No qualifier*/ class SslHandler {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    \n    /** The SSL Filter which has created this handler */\n    private final SslFilter sslFilter;\n    \n    /** The current session */\n    private final IoSession session;\n    \n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    /** A queue used to stack all the incoming data until the SSL session is established */\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    \n    /** \n     * A flag set to true when the first SSL handshake has been completed\n     * This is used to avoid sending a notification to the application handler\n     * when we switch to a SECURE or UNSECURE session. \n     */\n    private boolean firstSSLNegociation;\n    \n    /** A flag set to true when a SSL Handshake has been completed */\n    private boolean handshakeComplete;\n    \n    /** A flag used to indicate to the SslFilter that the buffer\n     * it will write is already encrypted (this will be the case\n     * for data being produced during the handshake). */\n    private boolean writingEncryptedData;\n\n    /**\n     * Create a new SSL Handler, and initialize it.\n     *\n     * @param sslContext\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter sslFilter, IoSession session) throws SSLException {\n        this.sslFilter = sslFilter;\n        this.session = session;\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException If the underlying SSLEngine handshake initialization failed\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        LOGGER.debug(\"Session[{}]: Initializing the SSL Handler\", session.getId());\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslFilter.sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslFilter.sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(sslFilter.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (!sslEngine.getUseClientMode()) {\n            // Those parameters are only valid when in server mode\n            if (sslFilter.isWantClientAuth()) {\n                sslEngine.setWantClientAuth(true);\n            }\n\n            if (sslFilter.isNeedClientAuth()) {\n                sslEngine.setNeedClientAuth(true);\n            }\n        }\n\n        // Set the cipher suite to use by this SslEngine instance\n        if (sslFilter.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(sslFilter.getEnabledCipherSuites());\n        }\n\n        // Set the list of enabled protocols\n        if (sslFilter.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(sslFilter.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        // However, if we don't call it here, the tests are failing. Why?\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        // Default value\n        writingEncryptedData = false;\n        \n        // We haven't yet started a SSL negotiation\n        // set the flags accordingly\n        firstSSLNegociation = true;\n        handshakeComplete = false;\n\n        LOGGER.debug(\"Session[{}]: SSL Handler Initialization done.\", session.getId());\n    }\n\n    \n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    /**\n     * @return The SSL filter which has created this handler\n     */\n    public SslFilter getSslFilter() {\n        return sslFilter;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check if we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            sslFilter.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    /**\n     * Push the newly received data into a queue, waiting for the SSL session\n     * to be fully established\n     *\n     * @param nextFilter The next filter to call\n     * @param message The incoming data\n     */\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent event;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((event = filterWriteEventQueue.poll()) != null) {\n                NextFilter nextFilter = event.getNextFilter();\n                nextFilter.filterWrite(session, (WriteRequest) event.getParameter());\n            }\n        }\n\n        while ((event = messageReceivedEventQueue.poll()) != null) {\n            NextFilter nextFilter = event.getNextFilter();\n            nextFilter.messageReceived(session, event.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            if ( !isOutboundDone()) {\n                LOGGER.debug(\"Session[{}](SSL): Processing the received message\", session.getId());\n            } else {\n                LOGGER.debug(\"Session[{}]: Processing the received message\", session.getId());\n            }\n        }\n\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n                case FINISHED:\n                    LOGGER.debug(\"Session[{}] : processing the FINISHED state\", session.getId());\n                    session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                    handshakeComplete = true;\n    \n                    // Send the SECURE message only if it's the first SSL handshake\n                    if (firstSSLNegociation && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                        // SESSION_SECURED is fired only when it's the first handshake\n                        firstSSLNegociation = false;\n                        scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                    }\n                    \n                    if ( LOGGER.isDebugEnabled()) {\n                        if ( !isOutboundDone()) {\n                            LOGGER.debug(\"Session[{}] is now secured\", session.getId());\n                        } else {\n                            LOGGER.debug(\"Session[{}] is not secured yet\", session.getId());\n                        }\n                    }\n    \n                    return;\n    \n                case NEED_TASK:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_TASK state\", session.getId());\n                    handshakeStatus = doTasks();\n                    break;\n    \n                case NEED_UNWRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_UNWRAP state\", session.getId());\n                    // we need more data read\n                    SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n    \n                    if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                            && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                        // We need more data or the session is closed\n                        return;\n                    }\n    \n                    break;\n    \n                case NEED_WRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_WRAP state\", session.getId());\n                    // First make sure that the out buffer is completely empty.\n                    // Since we\n                    // cannot call wrap with data left on the buffer\n                    if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                        return;\n                    }\n    \n                    SSLEngineResult result;\n                    createOutNetBuffer(0);\n    \n                    for (;;) {\n                        result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                        if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                            outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                            outNetBuffer.limit(outNetBuffer.capacity());\n                        } else {\n                            break;\n                        }\n                    }\n    \n                    outNetBuffer.flip();\n                    handshakeStatus = result.getHandshakeStatus();\n                    writeNetBuffer(nextFilter);\n                    break;\n    \n                default:\n                    String msg = \"Invalid Handshaking State\" + handshakeStatus + \n                        \" while processing the Handshake for session \" + session.getId();\n                    LOGGER.error(msg);\n                    throw new IllegalStateException(msg);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = unwrap();\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok, try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    /**\n     * Decrypt the incoming buffer and move the decrypted data to an\n     * application buffer. \n     */\n    private SSLEngineResult unwrap() throws SSLException {\n        // We first have to create the application buffer if it does not exist\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            // We already have one, just add the new data into it\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            // Decode the incoming data\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            \n            // We can be processing the Handshake\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                // We have to grow the target buffer, it's too small.\n                // Then we can call the unwrap method again\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) \n                        || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n    \n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        \n        sb.append(\"SSLStatus <\");\n        \n        if (handshakeComplete) {\n            sb.append(\"SSL established\");\n        } else {\n            sb.append(\"Processing Handshake\" ).append(\"; \");\n            sb.append(\"Status : \").append(handshakeStatus).append(\"; \");\n        }\n        \n        sb.append(\", \");\n        sb.append(\"HandshakeComplete :\" ).append(handshakeComplete).append(\", \");\n        sb.append(\">\");\n        return sb.toString();\n    }\n    \n}\n","lineNo":316}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\nclass SslHandler {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    private final SslFilter parent;\n    private final SSLContext sslContext;\n    private final IoSession session;\n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    private boolean initialHandshakeComplete;\n    private boolean handshakeComplete;\n    private boolean writingEncryptedData;\n\n    /** A flag used when the Handlshake is finished */\n    private static final boolean HANDSHAKE_FINISHED = true;\n\n    /**\n     * Constuctor.\n     *\n     * @param sslc\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter parent, SSLContext sslContext, IoSession session) throws SSLException {\n        this.parent = parent;\n        this.session = session;\n        this.sslContext = sslContext;\n        init();\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(parent.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (parent.isWantClientAuth()) {\n            sslEngine.setWantClientAuth(true);\n        }\n\n        if (parent.isNeedClientAuth()) {\n            sslEngine.setNeedClientAuth(true);\n        }\n\n        if (parent.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(parent.getEnabledCipherSuites());\n        }\n\n        if (parent.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(parent.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        handshakeComplete = false;\n        initialHandshakeComplete = false;\n        writingEncryptedData = false;\n    }\n\n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    public SslFilter getParent() {\n        return parent;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            parent.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent e;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((e = filterWriteEventQueue.poll()) != null) {\n                e.getNextFilter().filterWrite(session, (WriteRequest) e.getParameter());\n            }\n        }\n\n        while ((e = messageReceivedEventQueue.poll()) != null) {\n            e.getNextFilter().messageReceived(session, e.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n            case FINISHED:\n                session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                handshakeComplete = true;\n\n                if (!initialHandshakeComplete && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                    // SESSION_SECURED is fired only when it's the first\n                    // handshake.\n                    // (i.e. renegotiation shouldn't trigger SESSION_SECURED.)\n                    initialHandshakeComplete = true;\n                    scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                }\n\n                return;\n\n            case NEED_TASK:\n                handshakeStatus = doTasks();\n                break;\n\n            case NEED_UNWRAP:\n                // we need more data read\n                SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n\n                if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                        && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                    // We need more data or the session is closed\n                    return;\n                }\n\n                break;\n\n            case NEED_WRAP:\n                // First make sure that the out buffer is completely empty.\n                // Since we\n                // cannot call wrap with data left on the buffer\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    return;\n                }\n\n                SSLEngineResult result;\n                createOutNetBuffer(0);\n\n                for (;;) {\n                    result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                        outNetBuffer.limit(outNetBuffer.capacity());\n                    } else {\n                        break;\n                    }\n                }\n\n                outNetBuffer.flip();\n                handshakeStatus = result.getHandshakeStatus();\n                writeNetBuffer(nextFilter);\n                break;\n\n            default:\n                throw new IllegalStateException(\"Invalid Handshaking State\" + handshakeStatus);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            parent.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    parent.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = decrypt(!HANDSHAKE_FINISHED);\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok,\n        // try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = decrypt(HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    private SSLEngineResult decrypt(boolean finished) throws SSLException {\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (\n                            (finished || handshakeComplete) \n                            && \n                            (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        ) \n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n * <p/>\n * This class is not to be used by any client, it's closely associated with the SSL Filter.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\n/** No qualifier*/ class SslHandler {\n    /** A logger for this class */\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    \n    /** The SSL Filter which has created this handler */\n    private final SslFilter sslFilter;\n    \n    /** The current session */\n    private final IoSession session;\n    \n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    /** A queue used to stack all the incoming data until the SSL session is established */\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    \n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Application cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    \n    /** \n     * A flag set to true when the first SSL handshake has been completed\n     * This is used to avoid sending a notification to the application handler\n     * when we switch to a SECURE or UNSECURE session. \n     */\n    private boolean firstSSLNegociation;\n    \n    /** A flag set to true when a SSL Handshake has been completed */\n    private boolean handshakeComplete;\n    \n    /** A flag used to indicate to the SslFilter that the buffer\n     * it will write is already encrypted (this will be the case\n     * for data being produced during the handshake). */\n    private boolean writingEncryptedData;\n\n    /**\n     * Create a new SSL Handler, and initialize it.\n     *\n     * @param sslContext\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter sslFilter, IoSession session) throws SSLException {\n        this.sslFilter = sslFilter;\n        this.session = session;\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException If the underlying SSLEngine handshake initialization failed\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        LOGGER.debug(\"Session[{}]: Initializing the SSL Handler\", session.getId());\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslFilter.sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslFilter.sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(sslFilter.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (!sslEngine.getUseClientMode()) {\n            // Those parameters are only valid when in server mode\n            if (sslFilter.isWantClientAuth()) {\n                sslEngine.setWantClientAuth(true);\n            }\n\n            if (sslFilter.isNeedClientAuth()) {\n                sslEngine.setNeedClientAuth(true);\n            }\n        }\n\n        // Set the cipher suite to use by this SslEngine instance\n        if (sslFilter.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(sslFilter.getEnabledCipherSuites());\n        }\n\n        // Set the list of enabled protocols\n        if (sslFilter.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(sslFilter.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        // However, if we don't call it here, the tests are failing. Why?\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        // Default value\n        writingEncryptedData = false;\n        \n        // We haven't yet started a SSL negotiation\n        // set the flags accordingly\n        firstSSLNegociation = true;\n        handshakeComplete = false;\n\n        LOGGER.debug(\"Session[{}]: SSL Handler Initialization done.\", session.getId());\n    }\n\n    \n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    /**\n     * @return The SSL filter which has created this handler\n     */\n    public SslFilter getSslFilter() {\n        return sslFilter;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check if we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            sslFilter.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    /**\n     * Push the newly received data into a queue, waiting for the SSL session\n     * to be fully established\n     *\n     * @param nextFilter The next filter to call\n     * @param message The incoming data\n     */\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent event;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((event = filterWriteEventQueue.poll()) != null) {\n                NextFilter nextFilter = event.getNextFilter();\n                nextFilter.filterWrite(session, (WriteRequest) event.getParameter());\n            }\n        }\n\n        while ((event = messageReceivedEventQueue.poll()) != null) {\n            NextFilter nextFilter = event.getNextFilter();\n            nextFilter.messageReceived(session, event.getParameter());\n        }\n    }\n\n    /**\n     * Call when data are read from net. It will perform the initial hanshake or decrypt\n     * the data if SSL has been initialiaed. \n     * \n     * @param buf buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        if ( LOGGER.isDebugEnabled()) {\n            if ( !isOutboundDone()) {\n                LOGGER.debug(\"Session[{}](SSL): Processing the received message\", session.getId());\n            } else {\n                LOGGER.debug(\"Session[{}]: Processing the received message\", session.getId());\n            }\n        }\n\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        \n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            // Prepare the net data for reading.\n            inNetBuffer.flip();\n\n            if (!inNetBuffer.hasRemaining()) {\n                return;\n            }\n\n            SSLEngineResult res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            checkStatus(res);\n\n            renegotiateIfNeeded(nextFilter, res);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n                case FINISHED:\n                    LOGGER.debug(\"Session[{}] : processing the FINISHED state\", session.getId());\n                    session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                    handshakeComplete = true;\n    \n                    // Send the SECURE message only if it's the first SSL handshake\n                    if (firstSSLNegociation && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                        // SESSION_SECURED is fired only when it's the first handshake\n                        firstSSLNegociation = false;\n                        scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                    }\n                    \n                    if ( LOGGER.isDebugEnabled()) {\n                        if ( !isOutboundDone()) {\n                            LOGGER.debug(\"Session[{}] is now secured\", session.getId());\n                        } else {\n                            LOGGER.debug(\"Session[{}] is not secured yet\", session.getId());\n                        }\n                    }\n    \n                    return;\n    \n                case NEED_TASK:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_TASK state\", session.getId());\n                    handshakeStatus = doTasks();\n                    break;\n    \n                case NEED_UNWRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_UNWRAP state\", session.getId());\n                    // we need more data read\n                    SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n    \n                    if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                            && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                        // We need more data or the session is closed\n                        return;\n                    }\n    \n                    break;\n    \n                case NEED_WRAP:\n                    LOGGER.debug(\"Session[{}] : processing the NEED_WRAP state\", session.getId());\n                    // First make sure that the out buffer is completely empty.\n                    // Since we\n                    // cannot call wrap with data left on the buffer\n                    if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                        return;\n                    }\n    \n                    SSLEngineResult result;\n                    createOutNetBuffer(0);\n    \n                    for (;;) {\n                        result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                        if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                            outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                            outNetBuffer.limit(outNetBuffer.capacity());\n                        } else {\n                            break;\n                        }\n                    }\n    \n                    outNetBuffer.flip();\n                    handshakeStatus = result.getHandshakeStatus();\n                    writeNetBuffer(nextFilter);\n                    break;\n    \n                default:\n                    String msg = \"Invalid Handshaking State\" + handshakeStatus + \n                        \" while processing the Handshake for session \" + session.getId();\n                    LOGGER.error(msg);\n                    throw new IllegalStateException(msg);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    sslFilter.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = unwrap();\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok, try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = unwrap();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if ( ( res.getStatus() != SSLEngineResult.Status.CLOSED ) && \n             ( res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW ) &&\n             ( res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ) ) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    /**\n     * Decrypt the incoming buffer and move the decrypted data to an\n     * application buffer. \n     */\n    private SSLEngineResult unwrap() throws SSLException {\n        // We first have to create the application buffer if it does not exist\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            // We already have one, just add the new data into it\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            // Decode the incoming data\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            \n            // We can be processing the Handshake\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                // We have to grow the target buffer, it's too small.\n                // Then we can call the unwrap method again\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (\n                    (\n                        (status == SSLEngineResult.Status.OK) \n                        || \n                        (status == SSLEngineResult.Status.BUFFER_OVERFLOW)\n                    )\n                    &&\n                    (\n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)\n                        || \n                        (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                    )\n                );\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n    \n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        \n        sb.append(\"SSLStatus <\");\n        \n        if (handshakeComplete) {\n            sb.append(\"SSL established\");\n        } else {\n            sb.append(\"Processing Handshake\" ).append(\"; \");\n            sb.append(\"Status : \").append(handshakeStatus).append(\"; \");\n        }\n        \n        sb.append(\", \");\n        sb.append(\"HandshakeComplete :\" ).append(handshakeComplete).append(\", \");\n        sb.append(\">\");\n        return sb.toString();\n    }\n    \n}\n","lineNo":576}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\nclass SslHandler {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    private final SslFilter parent;\n    private final SSLContext sslContext;\n    private final IoSession session;\n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Applicaton cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    private boolean initialHandshakeComplete;\n    private boolean handshakeComplete;\n    private boolean writingEncryptedData;\n\n    /**\n     * Constuctor.\n     *\n     * @param sslc\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter parent, SSLContext sslContext, IoSession session)\n            throws SSLException {\n        this.parent = parent;\n        this.session = session;\n        this.sslContext = sslContext;\n        init();\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        InetSocketAddress peer = (InetSocketAddress) session\n                .getAttribute(SslFilter.PEER_ADDRESS);\n        \n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n        \n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(parent.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (parent.isWantClientAuth()) {\n            sslEngine.setWantClientAuth(true);\n        }\n\n        if (parent.isNeedClientAuth()) {\n            sslEngine.setNeedClientAuth(true);\n        }\n\n        if (parent.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(parent.getEnabledCipherSuites());\n        }\n\n        if (parent.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(parent.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        sslEngine.beginHandshake();\n        \n        \n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        handshakeComplete = false;\n        initialHandshakeComplete = false;\n        writingEncryptedData = false;\n    }\n\n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\n                    \"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    public SslFilter getParent() {\n        return parent;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter,\n                                                 WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter,\n                IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            parent.filterWrite(scheduledWrite.getNextFilter(), session,\n                    (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent e;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((e = filterWriteEventQueue.poll()) != null) {\n                e.getNextFilter().filterWrite(session, (WriteRequest) e.getParameter());\n            }\n        }\n\n        while ((e = messageReceivedEventQueue.poll()) != null) {\n            e.getNextFilter().messageReceived(session, e.getParameter());\n        }\n    }\n\n    /**\n     * Call when data read from net. Will perform inial hanshake or decrypt provided\n     * Buffer.\n     * Decrytpted data reurned by getAppBuffer(), if any.\n     *\n     * @param buf        buffer to decrypt\n     * @param nextFilter Next filter in chain\n     * @throws SSLException on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            decrypt(nextFilter);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound is finished.\n            int inNetBufferPosition = inNetBuffer == null? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     *\n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     *\n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     *\n     * @param src data to encrypt\n     * @throws SSLException on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \"\n                        + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     *\n     * @return <tt>true<\/tt> if shutdown process is started.\n     *         <tt>false<\/tt> if shutdown process is already finished.\n     * @throws SSLException on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * Decrypt in net buffer. Result is stored in app buffer.\n     *\n     * @throws SSLException\n     */\n    private void decrypt(NextFilter nextFilter) throws SSLException {\n\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        unwrap(nextFilter);\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res)\n            throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n        * The status may be:\n        * OK - Normal operation\n        * OVERFLOW - Should never happen since the application buffer is\n        *      sized to hold the maximum packet size.\n        * UNDERFLOW - Need to read more data from the socket. It's normal.\n        * CLOSED - The other peer closed the socket. Also normal.\n        */\n        if (status != SSLEngineResult.Status.OK\n                && status != SSLEngineResult.Status.CLOSED\n                && status != SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status\n                    + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n                case FINISHED :\n                    session.setAttribute(\n                            SslFilter.SSL_SESSION, sslEngine.getSession());\n                    handshakeComplete = true;\n                    \n                    if (!initialHandshakeComplete\n                            && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                        // SESSION_SECURED is fired only when it's the first handshake.\n                        // (i.e. renegotiation shouldn't trigger SESSION_SECURED.)\n                        initialHandshakeComplete = true;\n                        scheduleMessageReceived(nextFilter,\n                                SslFilter.SESSION_SECURED);\n                    }\n                    \n                    return;\n                    \n                case NEED_TASK :\n                    handshakeStatus = doTasks();\n                    break;\n                    \n                case NEED_UNWRAP :\n                    // we need more data read\n                    SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n                    \n                    if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n                            handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED ||\n                            isInboundDone()) {\n                        // We need more data or the session is closed\n                        return;\n                    }\n                    \n                    break;\n\n                case NEED_WRAP :\n                    // First make sure that the out buffer is completely empty. Since we\n                    // cannot call wrap with data left on the buffer\n                    if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                        return;\n                    }\n\n                    SSLEngineResult result;\n                    createOutNetBuffer(0);\n                    \n                    for (;;) {\n                        result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                        if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                            outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                            outNetBuffer.limit(outNetBuffer.capacity());\n                        } else {\n                            break;\n                        }\n                    }\n\n                    outNetBuffer.flip();\n                    handshakeStatus = result.getHandshakeStatus();\n                    writeNetBuffer(nextFilter);\n                    break;\n            \n                default :\n                    throw new IllegalStateException(\"Invalid Handshaking State\"\n                            + handshakeStatus);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data.  *Shrug*\n        int capacity = Math.max(\n                expectedRemaining,\n                sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter)\n            throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            parent.filterWrite(nextFilter, session, new DefaultWriteRequest(\n                    writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\n                            \"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    parent.filterWrite(nextFilter, session,\n                            new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private void unwrap(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            return;\n        }\n\n        SSLEngineResult res = unwrap0();\n\n        // prepare to be written again\n        if (inNetBuffer.hasRemaining()) {\n            inNetBuffer.compact();\n        } else {\n            inNetBuffer = null;\n        }\n\n        checkStatus(res);\n\n        renegotiateIfNeeded(nextFilter, res);\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = unwrap0();\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still ok,\n        // try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED\n                && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = unwrap0();\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res)\n            throws SSLException {\n        if (res.getStatus() != SSLEngineResult.Status.CLOSED\n                && res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW\n                && res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    private SSLEngineResult unwrap0() throws SSLException {\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n        do {\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            if (res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while ((res.getStatus() == SSLEngineResult.Status.OK || res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) &&\n                 (handshakeComplete && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING ||\n                  res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP));\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need\n         * for this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes\n     * in the given buffer (between index buf.position() and buf.limit())\n     *\n     * @param src the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.ssl;\n\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.util.CircularQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A helper class using the SSLEngine API to decrypt/encrypt data.\n * <p/>\n * Each connection has a SSLEngine that is used through the lifetime of the connection.\n * We allocate buffers for use as the outbound and inbound network buffers.\n * These buffers handle all of the intermediary data for the SSL connection. To make things easy,\n * we'll require outNetBuffer be completely flushed before trying to wrap any more data.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\nclass SslHandler {\n\n    private final static Logger LOGGER = LoggerFactory.getLogger(SslHandler.class);\n    private final SslFilter parent;\n    private final SSLContext sslContext;\n    private final IoSession session;\n    private final Queue<IoFilterEvent> preHandshakeEventQueue = new CircularQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> filterWriteEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private final Queue<IoFilterEvent> messageReceivedEventQueue = new ConcurrentLinkedQueue<IoFilterEvent>();\n    private SSLEngine sslEngine;\n\n    /**\n     * Encrypted data from the net\n     */\n    private IoBuffer inNetBuffer;\n\n    /**\n     * Encrypted data to be written to the net\n     */\n    private IoBuffer outNetBuffer;\n\n    /**\n     * Applicaton cleartext data to be read by application\n     */\n    private IoBuffer appBuffer;\n\n    /**\n     * Empty buffer used during initial handshake and close operations\n     */\n    private final IoBuffer emptyBuffer = IoBuffer.allocate(0);\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n    private boolean initialHandshakeComplete;\n    private boolean handshakeComplete;\n    private boolean writingEncryptedData;\n\n    /** A flag used when the Handlshake is finished */\n    private static final boolean HANDSHAKE_FINISHED = true;\n\n    /**\n     * Constuctor.\n     *\n     * @param sslc\n     * @throws SSLException\n     */\n    public SslHandler(SslFilter parent, SSLContext sslContext, IoSession session) throws SSLException {\n        this.parent = parent;\n        this.session = session;\n        this.sslContext = sslContext;\n        init();\n    }\n\n    /**\n     * Initialize the SSL handshake.\n     *\n     * @throws SSLException\n     */\n    public void init() throws SSLException {\n        if (sslEngine != null) {\n            // We already have a SSL engine created, no need to create a new one\n            return;\n        }\n\n        InetSocketAddress peer = (InetSocketAddress) session.getAttribute(SslFilter.PEER_ADDRESS);\n\n        // Create the SSL engine here\n        if (peer == null) {\n            sslEngine = sslContext.createSSLEngine();\n        } else {\n            sslEngine = sslContext.createSSLEngine(peer.getHostName(), peer.getPort());\n        }\n\n        // Initialize the engine in client mode if necessary\n        sslEngine.setUseClientMode(parent.isUseClientMode());\n\n        // Initialize the different SslEngine modes\n        if (parent.isWantClientAuth()) {\n            sslEngine.setWantClientAuth(true);\n        }\n\n        if (parent.isNeedClientAuth()) {\n            sslEngine.setNeedClientAuth(true);\n        }\n\n        if (parent.getEnabledCipherSuites() != null) {\n            sslEngine.setEnabledCipherSuites(parent.getEnabledCipherSuites());\n        }\n\n        if (parent.getEnabledProtocols() != null) {\n            sslEngine.setEnabledProtocols(parent.getEnabledProtocols());\n        }\n\n        // TODO : we may not need to call this method...\n        sslEngine.beginHandshake();\n\n        handshakeStatus = sslEngine.getHandshakeStatus();\n\n        handshakeComplete = false;\n        initialHandshakeComplete = false;\n        writingEncryptedData = false;\n    }\n\n    /**\n     * Release allocated buffers.\n     */\n    public void destroy() {\n        if (sslEngine == null) {\n            return;\n        }\n\n        // Close inbound and flush all remaining data if available.\n        try {\n            sslEngine.closeInbound();\n        } catch (SSLException e) {\n            LOGGER.debug(\"Unexpected exception from SSLEngine.closeInbound().\", e);\n        }\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(sslEngine.getSession().getPacketBufferSize());\n        } else {\n            createOutNetBuffer(0);\n        }\n        try {\n            do {\n                outNetBuffer.clear();\n            } while (sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf()).bytesProduced() > 0);\n        } catch (SSLException e) {\n            // Ignore.\n        } finally {\n            destroyOutNetBuffer();\n        }\n\n        sslEngine.closeOutbound();\n        sslEngine = null;\n\n        preHandshakeEventQueue.clear();\n    }\n\n    private void destroyOutNetBuffer() {\n        outNetBuffer.free();\n        outNetBuffer = null;\n    }\n\n    public SslFilter getParent() {\n        return parent;\n    }\n\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * Check we are writing encrypted data.\n     */\n    public boolean isWritingEncryptedData() {\n        return writingEncryptedData;\n    }\n\n    /**\n     * Check if handshake is completed.\n     */\n    public boolean isHandshakeComplete() {\n        return handshakeComplete;\n    }\n\n    public boolean isInboundDone() {\n        return sslEngine == null || sslEngine.isInboundDone();\n    }\n\n    public boolean isOutboundDone() {\n        return sslEngine == null || sslEngine.isOutboundDone();\n    }\n\n    /**\n     * Check if there is any need to complete handshake.\n     */\n    public boolean needToCompleteHandshake() {\n        return handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP && !isInboundDone();\n    }\n\n    public void schedulePreHandshakeWriteRequest(NextFilter nextFilter, WriteRequest writeRequest) {\n        preHandshakeEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void flushPreHandshakeEvents() throws SSLException {\n        IoFilterEvent scheduledWrite;\n\n        while ((scheduledWrite = preHandshakeEventQueue.poll()) != null) {\n            parent.filterWrite(scheduledWrite.getNextFilter(), session, (WriteRequest) scheduledWrite.getParameter());\n        }\n    }\n\n    public void scheduleFilterWrite(NextFilter nextFilter, WriteRequest writeRequest) {\n        filterWriteEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.WRITE, session, writeRequest));\n    }\n\n    public void scheduleMessageReceived(NextFilter nextFilter, Object message) {\n        messageReceivedEventQueue.add(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_RECEIVED, session, message));\n    }\n\n    public void flushScheduledEvents() {\n        // Fire events only when no lock is hold for this handler.\n        if (Thread.holdsLock(this)) {\n            return;\n        }\n\n        IoFilterEvent e;\n\n        // We need synchronization here inevitably because filterWrite can be\n        // called simultaneously and cause 'bad record MAC' integrity error.\n        synchronized (this) {\n            while ((e = filterWriteEventQueue.poll()) != null) {\n                e.getNextFilter().filterWrite(session, (WriteRequest) e.getParameter());\n            }\n        }\n\n        while ((e = messageReceivedEventQueue.poll()) != null) {\n            e.getNextFilter().messageReceived(session, e.getParameter());\n        }\n    }\n\n    /**\n     * Call when data read from net. Will perform inial hanshake or decrypt\n     * provided Buffer. Decrytpted data reurned by getAppBuffer(), if any.\n     * \n     * @param buf\n     *            buffer to decrypt\n     * @param nextFilter\n     *            Next filter in chain\n     * @throws SSLException\n     *             on errors\n     */\n    public void messageReceived(NextFilter nextFilter, ByteBuffer buf) throws SSLException {\n        // append buf to inNetBuffer\n        if (inNetBuffer == null) {\n            inNetBuffer = IoBuffer.allocate(buf.remaining()).setAutoExpand(true);\n        }\n\n        inNetBuffer.put(buf);\n        if (!handshakeComplete) {\n            handshake(nextFilter);\n        } else {\n            decrypt(nextFilter);\n        }\n\n        if (isInboundDone()) {\n            // Rewind the MINA buffer if not all data is processed and inbound\n            // is finished.\n            int inNetBufferPosition = inNetBuffer == null ? 0 : inNetBuffer.position();\n            buf.position(buf.position() - inNetBufferPosition);\n            inNetBuffer = null;\n        }\n    }\n\n    /**\n     * Get decrypted application data.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchAppBuffer() {\n        IoBuffer appBuffer = this.appBuffer.flip();\n        this.appBuffer = null;\n        return appBuffer;\n    }\n\n    /**\n     * Get encrypted data to be sent.\n     * \n     * @return buffer with data\n     */\n    public IoBuffer fetchOutNetBuffer() {\n        IoBuffer answer = outNetBuffer;\n        if (answer == null) {\n            return emptyBuffer;\n        }\n\n        outNetBuffer = null;\n        return answer.shrink();\n    }\n\n    /**\n     * Encrypt provided buffer. Encrypted data returned by getOutNetBuffer().\n     * \n     * @param src\n     *            data to encrypt\n     * @throws SSLException\n     *             on errors\n     */\n    public void encrypt(ByteBuffer src) throws SSLException {\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        if (!src.hasRemaining()) {\n            if (outNetBuffer == null) {\n                outNetBuffer = emptyBuffer;\n            }\n            return;\n        }\n\n        createOutNetBuffer(src.remaining());\n\n        // Loop until there is no more data in src\n        while (src.hasRemaining()) {\n\n            SSLEngineResult result = sslEngine.wrap(src, outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.OK) {\n                if (result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                    doTasks();\n                }\n            } else if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                throw new SSLException(\"SSLEngine error during encrypt: \" + result.getStatus() + \" src: \" + src\n                        + \"outNetBuffer: \" + outNetBuffer);\n            }\n        }\n\n        outNetBuffer.flip();\n    }\n\n    /**\n     * Start SSL shutdown process.\n     * \n     * @return <tt>true<\/tt> if shutdown process is started. <tt>false<\/tt> if\n     *         shutdown process is already finished.\n     * @throws SSLException\n     *             on errors\n     */\n    public boolean closeOutbound() throws SSLException {\n        if (sslEngine == null || sslEngine.isOutboundDone()) {\n            return false;\n        }\n\n        sslEngine.closeOutbound();\n\n        createOutNetBuffer(0);\n        SSLEngineResult result;\n        for (;;) {\n            result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n            if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                outNetBuffer.limit(outNetBuffer.capacity());\n            } else {\n                break;\n            }\n        }\n\n        if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new SSLException(\"Improper close state: \" + result);\n        }\n        outNetBuffer.flip();\n        return true;\n    }\n\n    /**\n     * Decrypt in net buffer. Result is stored in app buffer.\n     * \n     * @throws SSLException\n     */\n    private void decrypt(NextFilter nextFilter) throws SSLException {\n\n        if (!handshakeComplete) {\n            throw new IllegalStateException();\n        }\n\n        unwrap(nextFilter);\n    }\n\n    /**\n     * @param res\n     * @throws SSLException\n     */\n    private void checkStatus(SSLEngineResult res) throws SSLException {\n\n        SSLEngineResult.Status status = res.getStatus();\n\n        /*\n         * The status may be: \n         * OK - Normal operation \n         * OVERFLOW - Should never happen since the application buffer is sized to hold the maximum\n         * packet size. \n         * UNDERFLOW - Need to read more data from the socket. It's normal. \n         * CLOSED - The other peer closed the socket. Also normal.\n         */\n        if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n            throw new SSLException(\"SSLEngine error during decrypt: \" + status + \" inNetBuffer: \" + inNetBuffer + \"appBuffer: \"\n                    + appBuffer);\n        }\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void handshake(NextFilter nextFilter) throws SSLException {\n        for (;;) {\n            switch (handshakeStatus) {\n            case FINISHED:\n                session.setAttribute(SslFilter.SSL_SESSION, sslEngine.getSession());\n                handshakeComplete = true;\n\n                if (!initialHandshakeComplete && session.containsAttribute(SslFilter.USE_NOTIFICATION)) {\n                    // SESSION_SECURED is fired only when it's the first\n                    // handshake.\n                    // (i.e. renegotiation shouldn't trigger SESSION_SECURED.)\n                    initialHandshakeComplete = true;\n                    scheduleMessageReceived(nextFilter, SslFilter.SESSION_SECURED);\n                }\n\n                return;\n\n            case NEED_TASK:\n                handshakeStatus = doTasks();\n                break;\n\n            case NEED_UNWRAP:\n                // we need more data read\n                SSLEngineResult.Status status = unwrapHandshake(nextFilter);\n\n                if (status == SSLEngineResult.Status.BUFFER_UNDERFLOW\n                        && handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED || isInboundDone()) {\n                    // We need more data or the session is closed\n                    return;\n                }\n\n                break;\n\n            case NEED_WRAP:\n                // First make sure that the out buffer is completely empty.\n                // Since we\n                // cannot call wrap with data left on the buffer\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    return;\n                }\n\n                SSLEngineResult result;\n                createOutNetBuffer(0);\n\n                for (;;) {\n                    result = sslEngine.wrap(emptyBuffer.buf(), outNetBuffer.buf());\n                    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n                        outNetBuffer.limit(outNetBuffer.capacity());\n                    } else {\n                        break;\n                    }\n                }\n\n                outNetBuffer.flip();\n                handshakeStatus = result.getHandshakeStatus();\n                writeNetBuffer(nextFilter);\n                break;\n\n            default:\n                throw new IllegalStateException(\"Invalid Handshaking State\" + handshakeStatus);\n            }\n        }\n    }\n\n    private void createOutNetBuffer(int expectedRemaining) {\n        // SSLEngine requires us to allocate unnecessarily big buffer\n        // even for small data. *Shrug*\n        int capacity = Math.max(expectedRemaining, sslEngine.getSession().getPacketBufferSize());\n\n        if (outNetBuffer != null) {\n            outNetBuffer.capacity(capacity);\n        } else {\n            outNetBuffer = IoBuffer.allocate(capacity).minimumCapacity(0);\n        }\n    }\n\n    public WriteFuture writeNetBuffer(NextFilter nextFilter) throws SSLException {\n        // Check if any net data needed to be writen\n        if (outNetBuffer == null || !outNetBuffer.hasRemaining()) {\n            // no; bail out\n            return null;\n        }\n\n        // set flag that we are writing encrypted data\n        // (used in SSLFilter.filterWrite())\n        writingEncryptedData = true;\n\n        // write net data\n        WriteFuture writeFuture = null;\n\n        try {\n            IoBuffer writeBuffer = fetchOutNetBuffer();\n            writeFuture = new DefaultWriteFuture(session);\n            parent.filterWrite(nextFilter, session, new DefaultWriteRequest(writeBuffer, writeFuture));\n\n            // loop while more writes required to complete handshake\n            while (needToCompleteHandshake()) {\n                try {\n                    handshake(nextFilter);\n                } catch (SSLException ssle) {\n                    SSLException newSsle = new SSLHandshakeException(\"SSL handshake failed.\");\n                    newSsle.initCause(ssle);\n                    throw newSsle;\n                }\n\n                IoBuffer outNetBuffer = fetchOutNetBuffer();\n                if (outNetBuffer != null && outNetBuffer.hasRemaining()) {\n                    writeFuture = new DefaultWriteFuture(session);\n                    parent.filterWrite(nextFilter, session, new DefaultWriteRequest(outNetBuffer, writeFuture));\n                }\n            }\n        } finally {\n            writingEncryptedData = false;\n        }\n\n        return writeFuture;\n    }\n\n    private void unwrap(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            return;\n        }\n\n        SSLEngineResult res = unwrap0(!HANDSHAKE_FINISHED);\n\n        // prepare to be written again\n        if (inNetBuffer.hasRemaining()) {\n            inNetBuffer.compact();\n        } else {\n            inNetBuffer = null;\n        }\n\n        checkStatus(res);\n\n        renegotiateIfNeeded(nextFilter, res);\n    }\n\n    private SSLEngineResult.Status unwrapHandshake(NextFilter nextFilter) throws SSLException {\n        // Prepare the net data for reading.\n        if (inNetBuffer != null) {\n            inNetBuffer.flip();\n        }\n\n        if (inNetBuffer == null || !inNetBuffer.hasRemaining()) {\n            // Need more data.\n            return SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        SSLEngineResult res = unwrap0(!HANDSHAKE_FINISHED);\n        handshakeStatus = res.getHandshakeStatus();\n\n        checkStatus(res);\n\n        // If handshake finished, no data was produced, and the status is still\n        // ok,\n        // try to unwrap more\n        if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED && res.getStatus() == SSLEngineResult.Status.OK\n                && inNetBuffer.hasRemaining()) {\n            res = unwrap0(HANDSHAKE_FINISHED);\n\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n\n            renegotiateIfNeeded(nextFilter, res);\n        } else {\n            // prepare to be written again\n            if (inNetBuffer.hasRemaining()) {\n                inNetBuffer.compact();\n            } else {\n                inNetBuffer = null;\n            }\n        }\n\n        return res.getStatus();\n    }\n\n    private void renegotiateIfNeeded(NextFilter nextFilter, SSLEngineResult res) throws SSLException {\n        if (res.getStatus() != SSLEngineResult.Status.CLOSED && res.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW\n                && res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            // Renegotiation required.\n            handshakeComplete = false;\n            handshakeStatus = res.getHandshakeStatus();\n            handshake(nextFilter);\n        }\n    }\n\n    private SSLEngineResult unwrap0(boolean finished) throws SSLException {\n        if (appBuffer == null) {\n            appBuffer = IoBuffer.allocate(inNetBuffer.remaining());\n        } else {\n            appBuffer.expand(inNetBuffer.remaining());\n        }\n\n        SSLEngineResult res;\n\n        Status status = null;\n        HandshakeStatus handshakeStatus = null;\n\n        do {\n            res = sslEngine.unwrap(inNetBuffer.buf(), appBuffer.buf());\n            status = res.getStatus();\n            handshakeStatus = res.getHandshakeStatus();\n\n            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                appBuffer.capacity(appBuffer.capacity() << 1);\n                appBuffer.limit(appBuffer.capacity());\n                continue;\n            }\n        } while (((status == SSLEngineResult.Status.OK) || (status == SSLEngineResult.Status.BUFFER_OVERFLOW))\n                && (((finished || handshakeComplete) && (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)) || (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)));\n\n        return res;\n    }\n\n    /**\n     * Do all the outstanding handshake tasks in the current Thread.\n     */\n    private SSLEngineResult.HandshakeStatus doTasks() {\n        /*\n         * We could run this in a separate thread, but I don't see the need for\n         * this when used from SSLFilter. Use thread filters in MINA instead?\n         */\n        Runnable runnable;\n        while ((runnable = sslEngine.getDelegatedTask()) != null) {\n            // TODO : we may have to use a thread pool here to improve the\n            // performances\n            runnable.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    /**\n     * Creates a new MINA buffer that is a deep copy of the remaining bytes in\n     * the given buffer (between index buf.position() and buf.limit())\n     * \n     * @param src\n     *            the buffer to copy\n     * @return the new buffer, ready to read from\n     */\n    public static IoBuffer copy(ByteBuffer src) {\n        IoBuffer copy = IoBuffer.allocate(src.remaining());\n        copy.put(src);\n        copy.flip();\n        return copy;\n    }\n}\n","lineNo":658}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoProcessor} pool that distributes {@link IoSession}s into one or more\n * {@link IoProcessor}s. Most current transport implementations use this pool internally\n * to perform better in a multi-core environment, and therefore, you won't need to \n * use this pool directly unless you are running multiple {@link IoService}s in the\n * same JVM.\n * <p>\n * If you are running multiple {@link IoService}s, you could want to share the pool\n * among all services.  To do so, you can create a new {@link SimpleIoProcessorPool}\n * instance by yourself and provide the pool as a constructor parameter when you\n * create the services.\n * <p>\n * This pool uses Java reflection API to create multiple {@link IoProcessor} instances.\n * It tries to instantiate the processor in the following order:\n * <ol>\n * <li>A public constructor with one {@link ExecutorService} parameter.<\/li>\n * <li>A public constructor with one {@link Executor} parameter.<\/li>\n * <li>A public default constructor<\/li>\n * <\/ol>\n * The following is an example for the NIO socket transport:\n * <pre><code>\n * // Create a shared pool.\n * SimpleIoProcessorPool&lt;NioSession&gt; pool = \n *         new SimpleIoProcessorPool&lt;NioSession&gt;(NioProcessor.class, 16);\n * \n * // Create two services that share the same pool.\n * SocketAcceptor acceptor = new NioSocketAcceptor(pool);\n * SocketConnector connector = new NioSocketConnector(pool);\n * \n * ...\n * \n * // Release related resources.\n * connector.dispose();\n * acceptor.dispose();\n * pool.dispose();\n * <\/code><\/pre>\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n * @param <T> the type of the {@link IoSession} to be managed by the specified\n *            {@link IoProcessor}.\n */\npublic class SimpleIoProcessorPool<T extends AbstractIoSession> implements IoProcessor<T> {\n    \n    private static final int DEFAULT_SIZE = Runtime.getRuntime().availableProcessors() + 1;\n    private static final AttributeKey PROCESSOR = new AttributeKey(SimpleIoProcessorPool.class, \"processor\");\n    \n    private final static Logger LOGGER = LoggerFactory.getLogger(SimpleIoProcessorPool.class);\n\n    private final IoProcessor<T>[] pool;\n    private final AtomicInteger processorDistributor = new AtomicInteger();\n    private final Executor executor;\n    private final boolean createdExecutor;\n    \n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    \n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType) {\n        this(processorType, null, DEFAULT_SIZE);\n    }\n    \n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType, int size) {\n        this(processorType, null, size);\n    }\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType, Executor executor) {\n        this(processorType, executor, DEFAULT_SIZE);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType, Executor executor, int size) {\n        if (processorType == null) {\n            throw new NullPointerException(\"processorType\");\n        }\n        if (size <= 0) {\n            throw new IllegalArgumentException(\n                    \"size: \" + size + \" (expected: positive integer)\");\n        }\n        \n        if (executor == null) {\n            this.executor = executor = Executors.newCachedThreadPool();\n            this.createdExecutor = true;\n        } else {\n            this.executor = executor;\n            this.createdExecutor = false;\n        }\n        \n        pool = new IoProcessor[size];\n        \n        boolean success = false;\n        try {\n            for (int i = 0; i < pool.length; i ++) {\n                IoProcessor<T> processor = null;\n                \n                // Try to create a new processor with a proper constructor.\n                try {\n                    try {\n                        processor = processorType.getConstructor(ExecutorService.class).newInstance(executor);\n                    } catch (NoSuchMethodException e) {\n                        // To the next step...\n                    }\n                    \n                    if (processor == null) {\n                        try {\n                            processor = processorType.getConstructor(Executor.class).newInstance(executor);\n                        } catch (NoSuchMethodException e) {\n                            // To the next step...\n                        }\n                    }\n                    \n                    if (processor == null) {\n                        try {\n                            processor = processorType.getConstructor().newInstance();\n                        } catch (NoSuchMethodException e) {\n                            // To the next step...\n                        }\n                    }\n                } catch (RuntimeException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeIoException(\n                            \"Failed to create a new instance of \" + processorType.getName(), e);\n                }\n                \n                // Raise an exception if no proper constructor is found.\n                if (processor == null) {\n                    throw new IllegalArgumentException(\n                            String.valueOf(processorType) + \" must have a public constructor \" +\n                            \"with one \" + ExecutorService.class.getSimpleName() + \" parameter, \" +\n                            \"a public constructor with one \" + Executor.class.getSimpleName() + \n                            \" parameter or a public default constructor.\");\n                }\n                \n                pool[i] = processor;\n            }\n            \n            success = true;\n        } finally {\n            if (!success) {\n                dispose();\n            }\n        }\n    }\n    \n    public final void add(T session) {\n        getProcessor(session).add(session);\n    }\n\n    public final void flush(T session) {\n        getProcessor(session).flush(session);\n    }\n\n    public final void remove(T session) {\n        getProcessor(session).remove(session);\n    }\n\n    public final void updateTrafficControl(T session) {\n        getProcessor(session).updateTrafficControl(session);\n    }\n    \n    public boolean isDisposed() {\n        return disposed;\n    }\n\n    public boolean isDisposing() {\n        return disposing;\n    }\n\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                for (int i = pool.length - 1; i >= 0; i --) {\n                    if (pool[i] == null || pool[i].isDisposing()) {\n                        continue;\n                    }\n\n                    try {\n                        pool[i].dispose();\n                    } catch (Exception e) {\n                        LOGGER.warn(\n                                \"Failed to dispose a \" +\n                                pool[i].getClass().getSimpleName() +\n                                \" at index \" + i + \".\", e);\n                    } finally {\n                        pool[i] = null;\n                    }\n                }\n                \n                if (createdExecutor) {\n                    ((ExecutorService) executor).shutdown();\n                }\n            }\n        }\n\n        disposed = true;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    private IoProcessor<T> getProcessor(T session) {\n        IoProcessor<T> p = (IoProcessor<T>) session.getAttribute(PROCESSOR);\n        if (p == null) {\n            p = nextProcessor();\n            IoProcessor<T> oldp =\n                (IoProcessor<T>) session.setAttributeIfAbsent(PROCESSOR, p);\n            if (oldp != null) {\n                p = oldp;\n            }\n        }\n        \n        return p;\n    }\n\n    private IoProcessor<T> nextProcessor() {\n        checkDisposal();\n        return pool[Math.abs(processorDistributor.getAndIncrement()) % pool.length];\n    }\n\n    private void checkDisposal() {\n        if (disposed) {\n            throw new IllegalStateException(\"A disposed processor cannot be accessed.\");\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.lang.reflect.Constructor;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoProcessor} pool that distributes {@link IoSession}s into one or more\n * {@link IoProcessor}s. Most current transport implementations use this pool internally\n * to perform better in a multi-core environment, and therefore, you won't need to \n * use this pool directly unless you are running multiple {@link IoService}s in the\n * same JVM.\n * <p>\n * If you are running multiple {@link IoService}s, you could want to share the pool\n * among all services.  To do so, you can create a new {@link SimpleIoProcessorPool}\n * instance by yourself and provide the pool as a constructor parameter when you\n * create the services.\n * <p>\n * This pool uses Java reflection API to create multiple {@link IoProcessor} instances.\n * It tries to instantiate the processor in the following order:\n * <ol>\n * <li>A public constructor with one {@link ExecutorService} parameter.<\/li>\n * <li>A public constructor with one {@link Executor} parameter.<\/li>\n * <li>A public default constructor<\/li>\n * <\/ol>\n * The following is an example for the NIO socket transport:\n * <pre><code>\n * // Create a shared pool.\n * SimpleIoProcessorPool&lt;NioSession&gt; pool = \n *         new SimpleIoProcessorPool&lt;NioSession&gt;(NioProcessor.class, 16);\n * \n * // Create two services that share the same pool.\n * SocketAcceptor acceptor = new NioSocketAcceptor(pool);\n * SocketConnector connector = new NioSocketConnector(pool);\n * \n * ...\n * \n * // Release related resources.\n * connector.dispose();\n * acceptor.dispose();\n * pool.dispose();\n * <\/code><\/pre>\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n * \n * @param <T> the type of the {@link IoSession} to be managed by the specified\n *            {@link IoProcessor}.\n */\npublic class SimpleIoProcessorPool<T extends AbstractIoSession> implements\n        IoProcessor<T> {\n\n    private static final int DEFAULT_SIZE = Runtime.getRuntime()\n            .availableProcessors() + 1;\n\n    private static final AttributeKey PROCESSOR = new AttributeKey(\n            SimpleIoProcessorPool.class, \"processor\");\n\n    private final static Logger LOGGER = LoggerFactory\n            .getLogger(SimpleIoProcessorPool.class);\n\n    private final IoProcessor<T>[] pool;\n\n    private final AtomicInteger processorDistributor = new AtomicInteger();\n\n    private final Executor executor;\n\n    private final boolean createdExecutor;\n\n    private final Object disposalLock = new Object();\n\n    private volatile boolean disposing;\n\n    private volatile boolean disposed;\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType) {\n        this(processorType, null, DEFAULT_SIZE);\n    }\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            int size) {\n        this(processorType, null, size);\n    }\n\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            Executor executor) {\n        this(processorType, executor, DEFAULT_SIZE);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public SimpleIoProcessorPool(Class<? extends IoProcessor<T>> processorType,\n            Executor executor, int size) {\n        if (processorType == null) {\n            throw new NullPointerException(\"processorType\");\n        }\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"size: \" + size\n                    + \" (expected: positive integer)\");\n        }\n\n        if (executor == null) {\n            this.executor = executor = Executors.newCachedThreadPool();\n            this.createdExecutor = true;\n        } else {\n            this.executor = executor;\n            this.createdExecutor = false;\n        }\n\n        pool = new IoProcessor[size];\n\n        boolean success = false;\n        Constructor<? extends IoProcessor<T>> processorConstructor = null;\n        boolean usesExecutorArg = true;\n\n        try {\n            // We create at least one processor\n            try {\n                try {\n                    processorConstructor = processorType\n                            .getConstructor(ExecutorService.class);\n                    pool[0] = processorConstructor.newInstance(executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType\n                            .getConstructor(Executor.class);\n                    pool[0] = processorConstructor.newInstance(executor);\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n\n                try {\n                    processorConstructor = processorType.getConstructor();\n                    usesExecutorArg = false;\n                    pool[0] = processorConstructor.newInstance();\n                } catch (NoSuchMethodException e) {\n                    // To the next step...\n                }\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new RuntimeIoException(\n                        \"Failed to create a new instance of \"\n                                + processorType.getName(), e);\n            }\n\n            if (processorConstructor == null) {\n                // Raise an exception if no proper constructor is found.\n                throw new IllegalArgumentException(String\n                        .valueOf(processorType)\n                        + \" must have a public constructor \"\n                        + \"with one \"\n                        + ExecutorService.class.getSimpleName()\n                        + \" parameter, \"\n                        + \"a public constructor with one \"\n                        + Executor.class.getSimpleName()\n                        + \" parameter or a public default constructor.\");\n            }\n\n            // Constructor found now use it for all subsequent instantiations\n            for (int i = 1; i < pool.length; i++) {\n                try {\n                    if (usesExecutorArg) {\n                        pool[i] = processorConstructor.newInstance(executor);\n                    } else {\n                        pool[i] = processorConstructor.newInstance();\n                    }\n                } catch (Exception e) {\n                    // Won't happen because it has been done previously\n                }\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                dispose();\n            }\n        }\n    }\n\n    public final void add(T session) {\n        getProcessor(session).add(session);\n    }\n\n    public final void flush(T session) {\n        getProcessor(session).flush(session);\n    }\n\n    public final void remove(T session) {\n        getProcessor(session).remove(session);\n    }\n\n    public final void updateTrafficControl(T session) {\n        getProcessor(session).updateTrafficControl(session);\n    }\n\n    public boolean isDisposed() {\n        return disposed;\n    }\n\n    public boolean isDisposing() {\n        return disposing;\n    }\n\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                for (int i = pool.length - 1; i >= 0; i--) {\n                    if (pool[i] == null || pool[i].isDisposing()) {\n                        continue;\n                    }\n\n                    try {\n                        pool[i].dispose();\n                    } catch (Exception e) {\n                        LOGGER.warn(\"Failed to dispose a \"\n                                + pool[i].getClass().getSimpleName()\n                                + \" at index \" + i + \".\", e);\n                    } finally {\n                        pool[i] = null;\n                    }\n                }\n\n                if (createdExecutor) {\n                    ((ExecutorService) executor).shutdown();\n                }\n            }\n        }\n\n        disposed = true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private IoProcessor<T> getProcessor(T session) {\n        IoProcessor<T> p = (IoProcessor<T>) session.getAttribute(PROCESSOR);\n        if (p == null) {\n            p = nextProcessor();\n            IoProcessor<T> oldp = (IoProcessor<T>) session\n                    .setAttributeIfAbsent(PROCESSOR, p);\n            if (oldp != null) {\n                p = oldp;\n            }\n        }\n\n        return p;\n    }\n\n    private IoProcessor<T> nextProcessor() {\n        if (disposed) {\n            throw new IllegalStateException(\n                    \"A disposed processor cannot be accessed.\");\n        }\n        return pool[Math.abs(processorDistributor.getAndIncrement())\n                % pool.length];\n    }\n}\n","lineNo":139}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession session = (AbstractIoSession) future.getSession();\n                session.scheduledWriteBytes.set(0);\n                session.scheduledWriteMessages.set(0);\n                session.readBytesThroughput = 0;\n                session.readMessagesThroughput = 0;\n                session.writtenBytesThroughput = 0;\n                session.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /** An id generator guaranteed to generate unique IDs for the session */\n    private static AtomicLong idGenerator = new AtomicLong(0);\n    \n    /** The session ID */\n    private long sessionId;\n    \n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    \n    // traffic control\n    private boolean readSuspended=false;\n    private boolean writeSuspended=false;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n        \n        // Set a new ID for this session\n        sessionId = idGenerator.incrementAndGet();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * We use an AtomicLong to guarantee that the session ID are\n     * unique.\n     */\n    public final long getId() {\n        return sessionId;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        }\n        \n        scheduledForFlush.set(false);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        }\n        \n        return closeOnFlush();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            }\n            \n            closing = true;\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    private final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * Create a new close aware write queue, based on the given write queue.\n     * \n     * @param writeRequestQueue The write request queue\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseAwareWriteQueue(writeRequestQueue);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        readSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        writeSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeRead() {\n        readSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeWrite() {\n        writeSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReadSuspended() {\n        return readSuspended;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isWriteSuspended() {\n        return writeSuspended; \n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        }\n        \n        return getRemoteAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (isConnected()||isClosing()) {\n            if (getService() instanceof IoAcceptor) {\n                return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                        getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n            }\n\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                        getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n        \n        return \"Session disconnected ...\";\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        }\n        \n        return tm.getProviderName() + ' ' + tm.getName();\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                IdleStatus.BOTH_IDLE, Math.max(\n                    session.getLastIoTime(),\n                    session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                IdleStatus.READER_IDLE, Math.max(\n                    session.getLastReadTime(),\n                    session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                IdleStatus.WRITER_IDLE, Math.max(\n                    session.getLastWriteTime(),\n                    session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n        notifyWriteTimeout(session, currentTime);\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            IoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close(true);\n            }\n        }\n    }\n\n    \n    \n    /**\n     * A queue which handles the CLOSE request.\n     * \n     * TODO : Check that when closing a session, all the pending\n     * requests are correctly sent.\n     */\n    private class CloseAwareWriteQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        /**\n         * {@inheritDoc}\n         */\n        public CloseAwareWriteQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            \n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            \n            return answer;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession session = (AbstractIoSession) future.getSession();\n                session.scheduledWriteBytes.set(0);\n                session.scheduledWriteMessages.set(0);\n                session.readBytesThroughput = 0;\n                session.readMessagesThroughput = 0;\n                session.writtenBytesThroughput = 0;\n                session.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /** An id generator guaranteed to generate unique IDs for the session */\n    private static AtomicLong idGenerator = new AtomicLong(0);\n    \n    /** The session ID */\n    private long sessionId;\n    \n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    \n    // traffic control\n    private boolean readSuspended=false;\n    private boolean writeSuspended=false;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n        \n        // Set a new ID for this session\n        sessionId = idGenerator.incrementAndGet();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * We use an AtomicLong to guarantee that the session ID are\n     * unique.\n     */\n    public final long getId() {\n        return sessionId;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        }\n        \n        scheduledForFlush.set(false);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        }\n        \n        return closeOnFlush();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            }\n            \n            closing = true;\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    private final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * Create a new close aware write queue, based on the given write queue.\n     * \n     * @param writeRequestQueue The write request queue\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseAwareWriteQueue(writeRequestQueue);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        readSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        writeSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeRead() {\n        readSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeWrite() {\n        writeSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReadSuspended() {\n        return readSuspended;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isWriteSuspended() {\n        return writeSuspended; \n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        }\n        \n        return getRemoteAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (isConnected()||isClosing()) {\n            try {\n                SocketAddress remote = getRemoteAddress();\n                SocketAddress local = getLocalAddress();\n                \n                if (getService() instanceof IoAcceptor) {\n                    return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                            remote + \" => \" + local + ')';\n                }\n    \n                return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                            local + \" => \" + remote + ')';\n            } catch (Exception e) {\n                return \"Session is disconnecting ...\";\n            }\n        }\n        \n        return \"Session disconnected ...\";\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        }\n        \n        return tm.getProviderName() + ' ' + tm.getName();\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                IdleStatus.BOTH_IDLE, Math.max(\n                    session.getLastIoTime(),\n                    session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                IdleStatus.READER_IDLE, Math.max(\n                    session.getLastReadTime(),\n                    session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                IdleStatus.WRITER_IDLE, Math.max(\n                    session.getLastWriteTime(),\n                    session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n        notifyWriteTimeout(session, currentTime);\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            IoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close(true);\n            }\n        }\n    }\n\n    \n    \n    /**\n     * A queue which handles the CLOSE request.\n     * \n     * TODO : Check that when closing a session, all the pending\n     * requests are correctly sent.\n     */\n    private class CloseAwareWriteQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        /**\n         * {@inheritDoc}\n         */\n        public CloseAwareWriteQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            \n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            \n            return answer;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":1137}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession session = (AbstractIoSession) future.getSession();\n                session.scheduledWriteBytes.set(0);\n                session.scheduledWriteMessages.set(0);\n                session.readBytesThroughput = 0;\n                session.readMessagesThroughput = 0;\n                session.writtenBytesThroughput = 0;\n                session.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /** An id generator guaranteed to generate unique IDs for the session */\n    private static AtomicLong idGenerator = new AtomicLong(0);\n    \n    /** The session ID */\n    private long sessionId;\n    \n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    \n    // traffic control\n    private boolean readSuspended=false;\n    private boolean writeSuspended=false;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n        \n        // Set a new ID for this session\n        sessionId = idGenerator.incrementAndGet();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * We use an AtomicLong to guarantee that the session ID are\n     * unique.\n     */\n    public final long getId() {\n        return sessionId;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        }\n        \n        scheduledForFlush.set(false);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        }\n        \n        return closeOnFlush();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            }\n            \n            closing = true;\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    private final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * Create a new close aware write queue, based on the given write queue.\n     * \n     * @param writeRequestQueue The write request queue\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseAwareWriteQueue(writeRequestQueue);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        readSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        writeSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeRead() {\n        readSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeWrite() {\n        writeSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReadSuspended() {\n        return readSuspended;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isWriteSuspended() {\n        return writeSuspended; \n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        }\n        \n        return getRemoteAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (isConnected()||isClosing()) {\n            if (getService() instanceof IoAcceptor) {\n                return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                        getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n            }\n\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                        getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n        \n        return \"Session disconnected ...\";\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        }\n        \n        return tm.getProviderName() + ' ' + tm.getName();\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                IdleStatus.BOTH_IDLE, Math.max(\n                    session.getLastIoTime(),\n                    session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                IdleStatus.READER_IDLE, Math.max(\n                    session.getLastReadTime(),\n                    session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                IdleStatus.WRITER_IDLE, Math.max(\n                    session.getLastWriteTime(),\n                    session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n        notifyWriteTimeout(session, currentTime);\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            IoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close(true);\n            }\n        }\n    }\n\n    \n    \n    /**\n     * A queue which handles the CLOSE request.\n     * \n     * TODO : Check that when closing a session, all the pending\n     * requests are correctly sent.\n     */\n    private class CloseAwareWriteQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        /**\n         * {@inheritDoc}\n         */\n        public CloseAwareWriteQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            \n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            \n            return answer;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author <a href=\"http://mina.apache.org\">Apache MINA Project<\/a>\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession session = (AbstractIoSession) future.getSession();\n                session.scheduledWriteBytes.set(0);\n                session.scheduledWriteMessages.set(0);\n                session.readBytesThroughput = 0;\n                session.readMessagesThroughput = 0;\n                session.writtenBytesThroughput = 0;\n                session.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /** An id generator guaranteed to generate unique IDs for the session */\n    private static AtomicLong idGenerator = new AtomicLong(0);\n    \n    /** The session ID */\n    private long sessionId;\n    \n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    \n    // traffic control\n    private boolean readSuspended=false;\n    private boolean writeSuspended=false;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n        \n        // Set a new ID for this session\n        sessionId = idGenerator.incrementAndGet();\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * We use an AtomicLong to guarantee that the session ID are\n     * unique.\n     */\n    public final long getId() {\n        return sessionId;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        }\n        \n        scheduledForFlush.set(false);\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        }\n        \n        return closeOnFlush();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            }\n            \n            closing = true;\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    private final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * Create a new close aware write queue, based on the given write queue.\n     * \n     * @param writeRequestQueue The write request queue\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseAwareWriteQueue(writeRequestQueue);\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        readSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        writeSuspended = true;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeRead() {\n        readSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final void resumeWrite() {\n        writeSuspended = false;\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n        getProcessor().updateTrafficControl(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReadSuspended() {\n        return readSuspended;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isWriteSuspended() {\n        return writeSuspended; \n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        }\n        \n        return getRemoteAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (isConnected()||isClosing()) {\n            try {\n                SocketAddress remote = getRemoteAddress();\n                SocketAddress local = getLocalAddress();\n                \n                if (getService() instanceof IoAcceptor) {\n                    return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                            remote + \" => \" + local + ')';\n                }\n    \n                return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                            local + \" => \" + remote + ')';\n            } catch (Exception e) {\n                return \"Session is disconnecting ...\";\n            }\n        }\n        \n        return \"Session disconnected ...\";\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        }\n        \n        return tm.getProviderName() + ' ' + tm.getName();\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                IdleStatus.BOTH_IDLE, Math.max(\n                    session.getLastIoTime(),\n                    session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                IdleStatus.READER_IDLE, Math.max(\n                    session.getLastReadTime(),\n                    session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                IdleStatus.WRITER_IDLE, Math.max(\n                    session.getLastWriteTime(),\n                    session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n        notifyWriteTimeout(session, currentTime);\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            IoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close(true);\n            }\n        }\n    }\n\n    \n    \n    /**\n     * A queue which handles the CLOSE request.\n     * \n     * TODO : Check that when closing a session, all the pending\n     * requests are correctly sent.\n     */\n    private class CloseAwareWriteQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        /**\n         * {@inheritDoc}\n         */\n        public CloseAwareWriteQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            \n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            \n            return answer;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":1138}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":60}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":61}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":72}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":76}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":87}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 591770 $, $Date: 2007-11-04 13:22:44 +0100 (Sun, 04 Nov 2007) $\n */\npublic class IoFilterEvent extends IoEvent {\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        switch (getType()) {\n        case MESSAGE_RECEIVED:\n            getNextFilter().messageReceived(getSession(), getParameter());\n            break;\n        case MESSAGE_SENT:\n            getNextFilter().messageSent(getSession(), (WriteRequest) getParameter());\n            break;\n        case WRITE:\n            getNextFilter().filterWrite(getSession(), (WriteRequest) getParameter());\n            break;\n        case CLOSE:\n            getNextFilter().filterClose(getSession());\n            break;\n        case EXCEPTION_CAUGHT:\n            getNextFilter().exceptionCaught(getSession(), (Throwable) getParameter());\n            break;\n        case SESSION_IDLE:\n            getNextFilter().sessionIdle(getSession(), (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            getNextFilter().sessionOpened(getSession());\n            break;\n        case SESSION_CREATED:\n            getNextFilter().sessionCreated(getSession());\n            break;\n        case SESSION_CLOSED:\n            getNextFilter().sessionClosed(getSession());\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + getType());\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.filterchain;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEvent;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An I/O event or an I/O request that MINA provides for {@link IoFilter}s.\n * Most users won't need to use this class.  It is usually used by internal\n * components to store I/O events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n */\npublic class IoFilterEvent extends IoEvent {\n    /** A logger for this class */\n    //static Logger LOGGER = LoggerFactory.getLogger(IoFilterEvent.class);\n\n    private final NextFilter nextFilter;\n\n    public IoFilterEvent(NextFilter nextFilter, IoEventType type,\n            IoSession session, Object parameter) {\n        super(type, session, parameter);\n\n        if (nextFilter == null) {\n            throw new NullPointerException(\"nextFilter\");\n        }\n        this.nextFilter = nextFilter;\n    }\n\n    public NextFilter getNextFilter() {\n        return nextFilter;\n    }\n\n    @Override\n    public void fire() {\n        IoSession session = getSession();\n        NextFilter nextFilter = getNextFilter();\n        IoEventType type = getType();\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Firing a {} event for session {}\",type, session.getId() );\n        }\n        */\n        \n        switch (type) {\n        case MESSAGE_RECEIVED:\n            Object parameter = getParameter();\n            nextFilter.messageReceived(session, parameter);\n            break;\n        case MESSAGE_SENT:\n            WriteRequest writeRequest = (WriteRequest)getParameter();\n            nextFilter.messageSent(session, writeRequest);\n            break;\n        case WRITE:\n            writeRequest = (WriteRequest)getParameter();\n            nextFilter.filterWrite(session, writeRequest);\n            break;\n        case CLOSE:\n            nextFilter.filterClose(session);\n            break;\n        case EXCEPTION_CAUGHT:\n            Throwable throwable = (Throwable)getParameter();\n            nextFilter.exceptionCaught(session, throwable);\n            break;\n        case SESSION_IDLE:\n            nextFilter.sessionIdle(session, (IdleStatus) getParameter());\n            break;\n        case SESSION_OPENED:\n            nextFilter.sessionOpened(session);\n            break;\n        case SESSION_CREATED:\n            nextFilter.sessionCreated(session);\n            break;\n        case SESSION_CLOSED:\n            nextFilter.sessionClosed(session);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown event type: \" + type);\n        }\n        \n        /*\n        if ( LOGGER.isDebugEnabled()) {\n            LOGGER.debug( \"Event {} has been fired for session {}\", type, session.getId() );\n        }\n        */\n    }\n}\n","lineNo":62}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.proxy.handlers.http;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.proxy.ProxyAuthException;\nimport org.apache.mina.proxy.session.ProxyIoSession;\nimport org.apache.mina.proxy.utils.StringUtilities;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * HttpSmartProxyHandler.java - HTTP proxy handler that automatically handles forwarding request \n * to the appropriate authentication mechanism logic handler.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M3\n */\npublic class HttpSmartProxyHandler extends AbstractHttpLogicHandler {\n    private final static Logger logger = LoggerFactory\n            .getLogger(HttpSmartProxyHandler.class);\n\n    /**\n     * Has the HTTP proxy request been sent ?\n     */\n    private boolean requestSent = false;\n\n    /**\n     * The automatically selected http authentication logic handler. \n     */\n    private AbstractAuthLogicHandler authHandler;\n\n    public HttpSmartProxyHandler(final ProxyIoSession proxyIoSession) {\n        super(proxyIoSession);\n    }\n\n    /**\n     * Perform any handshaking processing.\n     */\n    public void doHandshake(final NextFilter nextFilter)\n            throws ProxyAuthException {\n        logger.debug(\" doHandshake()\");\n\n        if (authHandler != null) {\n            authHandler.doHandshake(nextFilter);\n        } else {\n            if (requestSent) {\n                throw new ProxyAuthException(\n                        \"Authentication request already sent\");\n            }\n\n            logger.debug(\"  sending HTTP request\");\n\n            // Send request\n            HttpProxyRequest req = (HttpProxyRequest) getProxyIoSession()\n                    .getRequest();\n            Map<String, List<String>> headers = req.getHeaders() != null ? req\n                    .getHeaders() : new HashMap<String, List<String>>();\n\n            StringUtilities.addValueToHeader(headers, \"Keep-Alive\",\n                    HttpProxyConstants.DEFAULT_KEEP_ALIVE_TIME, true);\n            StringUtilities.addValueToHeader(headers, \"Proxy-Connection\",\n                    \"keep-Alive\", true);\n            req.setHeaders(headers);\n\n            writeRequest(nextFilter, req);\n            requestSent = true;\n        }\n    }\n\n    /**\n     * Automatic selection of the authentication algorithm. If <code>preferedOrder<\/code> is set then\n     * algorithms are selected from the list order otherwise the algorithm tries to select the most \n     * secured algorithm available first.\n     */\n    private void autoSelectAuthHandler(final HttpProxyResponse response)\n            throws ProxyAuthException {\n        // Get the Proxy-Authenticate header\n        List<String> values = response.getHeaders().get(\"Proxy-Authenticate\");\n\n        if (values == null || values.size() == 0) {\n            authHandler = HttpAuthenticationMethods.NO_AUTH\n                    .getNewHandler(getProxyIoSession());\n\n        } else if (getProxyIoSession().getPreferedOrder() == null) {\n            for (String proxyAuthHeader : values) {\n                proxyAuthHeader = proxyAuthHeader.toLowerCase();\n\n                try {\n                    // Test which auth mechanism to use. First found is the first used that's why we test\n                    // in a decreasing security quality order.\n                    if (proxyAuthHeader.contains(\"ntlm\")) {\n                        authHandler = HttpAuthenticationMethods.NTLM\n                                .getNewHandler(getProxyIoSession());\n                        break;\n                    } else if (proxyAuthHeader.contains(\"digest\")) {\n                        authHandler = HttpAuthenticationMethods.DIGEST\n                                .getNewHandler(getProxyIoSession());\n                        break;\n                    } else if (proxyAuthHeader.contains(\"basic\")) {\n                        authHandler = HttpAuthenticationMethods.BASIC\n                                .getNewHandler(getProxyIoSession());\n                        break;\n                    }\n                } catch (Exception ex) {\n                    logger.debug(\"Following exception occured:\", ex);\n                }\n            }\n\n            if (authHandler == null) {\n                authHandler = HttpAuthenticationMethods.NO_AUTH\n                        .getNewHandler(getProxyIoSession());\n            }\n\n        } else {\n            for (HttpAuthenticationMethods method : getProxyIoSession()\n                    .getPreferedOrder()) {\n                if (authHandler != null) {\n                    break;\n                }\n\n                if (method == HttpAuthenticationMethods.NO_AUTH) {\n                    authHandler = HttpAuthenticationMethods.NO_AUTH\n                            .getNewHandler(getProxyIoSession());\n                    break;\n                }\n\n                for (String proxyAuthHeader : values) {\n                    proxyAuthHeader = proxyAuthHeader.toLowerCase();\n\n                    try {\n                        // test which auth mechanism to use\n                        if (proxyAuthHeader.contains(\"basic\")\n                                && method == HttpAuthenticationMethods.BASIC) {\n                            authHandler = HttpAuthenticationMethods.BASIC\n                                    .getNewHandler(getProxyIoSession());\n                            break;\n                        } else if (proxyAuthHeader.contains(\"digest\")\n                                && method == HttpAuthenticationMethods.DIGEST) {\n                            authHandler = HttpAuthenticationMethods.DIGEST\n                                    .getNewHandler(getProxyIoSession());\n                            break;\n                        } else if (proxyAuthHeader.contains(\"ntlm\")\n                                && method == HttpAuthenticationMethods.NTLM) {\n                            authHandler = HttpAuthenticationMethods.NTLM\n                                    .getNewHandler(getProxyIoSession());\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        logger.debug(\"Following exception occured:\", ex);\n                    }\n                }\n            }\n\n        }\n\n        if (authHandler == null) {\n            throw new ProxyAuthException(\n                    \"Unknown authentication mechanism(s): \" + values);\n        }\n    }\n\n    /**\n     * Handle a HTTP response from the proxy server.\n     * \n     * @param response The response.\n     */\n    @Override\n    public void handleResponse(final HttpProxyResponse response)\n            throws ProxyAuthException {\n        if (!isHandshakeComplete()\n                && (\"close\".equalsIgnoreCase(StringUtilities\n                        .getSingleValuedHeader(response.getHeaders(),\n                                \"Proxy-Connection\")) || \"close\"\n                        .equalsIgnoreCase(StringUtilities\n                                .getSingleValuedHeader(response.getHeaders(),\n                                        \"Connection\")))) {\n            getProxyIoSession().setReconnectionNeeded(true);\n        }\n\n        if (response.getStatusCode() == 407) {\n            if (authHandler == null) {\n                autoSelectAuthHandler(response);\n            }\n            authHandler.handleResponse(response);\n        } else {\n            throw new ProxyAuthException(\"Received error response code (\"\n                    + response.getStatusLine() + \").\");\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.proxy.handlers.http;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.mina.core.filterchain.IoFilter.NextFilter;\nimport org.apache.mina.proxy.ProxyAuthException;\nimport org.apache.mina.proxy.session.ProxyIoSession;\nimport org.apache.mina.proxy.utils.StringUtilities;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * HttpSmartProxyHandler.java - HTTP proxy handler that automatically handles forwarding a request \n * to the appropriate authentication mechanism logic handler.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M3\n */\npublic class HttpSmartProxyHandler extends AbstractHttpLogicHandler {\n    private final static Logger logger = LoggerFactory\n            .getLogger(HttpSmartProxyHandler.class);\n\n    /**\n     * Has the HTTP proxy request been sent ?\n     */\n    private boolean requestSent = false;\n\n    /**\n     * The automatically selected http authentication logic handler. \n     */\n    private AbstractAuthLogicHandler authHandler;\n\n    public HttpSmartProxyHandler(final ProxyIoSession proxyIoSession) {\n        super(proxyIoSession);\n    }\n\n    /**\n     * Performs the handshake processing.\n     * \n     * @param nextFilter the next filter\n     */\n    public void doHandshake(final NextFilter nextFilter)\n            throws ProxyAuthException {\n        logger.debug(\" doHandshake()\");\n\n        if (authHandler != null) {\n            authHandler.doHandshake(nextFilter);\n        } else {\n            if (requestSent) {\n            \t// Safety check\n                throw new ProxyAuthException(\n                        \"Authentication request already sent\");\n            }\n\n            logger.debug(\"  sending HTTP request\");\n\n            // Compute request headers\n            HttpProxyRequest req = (HttpProxyRequest) getProxyIoSession()\n                    .getRequest();\n            Map<String, List<String>> headers = req.getHeaders() != null ? req\n                    .getHeaders() : new HashMap<String, List<String>>();\n\n            AbstractAuthLogicHandler.addKeepAliveHeaders(headers);\n            req.setHeaders(headers);\n\n            // Write request to the proxy\n            writeRequest(nextFilter, req);\n            requestSent = true;\n        }\n    }\n\n    /**\n     * Automatic selection of the authentication algorithm. If <code>preferedOrder<\/code> is set then\n     * algorithms are selected from the list order otherwise the algorithm tries to select the most \n     * secured algorithm available first.\n     * \n     * @param response the proxy response\n     */\n    private void autoSelectAuthHandler(final HttpProxyResponse response)\n\t\t\tthrows ProxyAuthException {\n\t\t// Get the Proxy-Authenticate header\n\t\tList<String> values = response.getHeaders().get(\"Proxy-Authenticate\");\n\t\tProxyIoSession proxyIoSession = getProxyIoSession();\n\n\t\tif (values == null || values.size() == 0) {\n\t\t\tauthHandler = HttpAuthenticationMethods.NO_AUTH\n\t\t\t\t\t.getNewHandler(proxyIoSession);\n\n\t\t} else if (getProxyIoSession().getPreferedOrder() == null) {\n\t\t\t// No preference order set for auth mechanisms\n\t\t\tint method = -1;\n\n\t\t\t// Test which auth mechanism to use. First found is the first used\n\t\t\t// that's why we test in a decreasing security quality order.\n\t\t\tfor (String proxyAuthHeader : values) {\n\t\t\t\tproxyAuthHeader = proxyAuthHeader.toLowerCase();\n\n\t\t\t\tif (proxyAuthHeader.contains(\"ntlm\")) {\n\t\t\t\t\tmethod = HttpAuthenticationMethods.NTLM.getId();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (proxyAuthHeader.contains(\"digest\")\n\t\t\t\t\t\t&& method != HttpAuthenticationMethods.NTLM.getId()) {\n\t\t\t\t\tmethod = HttpAuthenticationMethods.DIGEST.getId();\n\t\t\t\t} else if (proxyAuthHeader.contains(\"basic\") && method == -1) {\n\t\t\t\t\tmethod = HttpAuthenticationMethods.BASIC.getId();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (method != -1) {\n\t\t\t\ttry {\n\t\t\t\t\tauthHandler = HttpAuthenticationMethods.getNewHandler(\n\t\t\t\t\t\t\tmethod, proxyIoSession);\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tlogger.debug(\"Following exception occured:\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (authHandler == null) {\n\t\t\t\tauthHandler = HttpAuthenticationMethods.NO_AUTH\n\t\t\t\t\t\t.getNewHandler(proxyIoSession);\n\t\t\t}\n\n\t\t} else {\n\t\t\tfor (HttpAuthenticationMethods method : proxyIoSession\n\t\t\t\t\t.getPreferedOrder()) {\n\t\t\t\tif (authHandler != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (method == HttpAuthenticationMethods.NO_AUTH) {\n\t\t\t\t\tauthHandler = HttpAuthenticationMethods.NO_AUTH\n\t\t\t\t\t\t\t.getNewHandler(proxyIoSession);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (String proxyAuthHeader : values) {\n\t\t\t\t\tproxyAuthHeader = proxyAuthHeader.toLowerCase();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// test which auth mechanism to use\n\t\t\t\t\t\tif (proxyAuthHeader.contains(\"basic\")\n\t\t\t\t\t\t\t\t&& method == HttpAuthenticationMethods.BASIC) {\n\t\t\t\t\t\t\tauthHandler = HttpAuthenticationMethods.BASIC\n\t\t\t\t\t\t\t\t\t.getNewHandler(proxyIoSession);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (proxyAuthHeader.contains(\"digest\")\n\t\t\t\t\t\t\t\t&& method == HttpAuthenticationMethods.DIGEST) {\n\t\t\t\t\t\t\tauthHandler = HttpAuthenticationMethods.DIGEST\n\t\t\t\t\t\t\t\t\t.getNewHandler(proxyIoSession);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (proxyAuthHeader.contains(\"ntlm\")\n\t\t\t\t\t\t\t\t&& method == HttpAuthenticationMethods.NTLM) {\n\t\t\t\t\t\t\tauthHandler = HttpAuthenticationMethods.NTLM\n\t\t\t\t\t\t\t\t\t.getNewHandler(proxyIoSession);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tlogger.debug(\"Following exception occured:\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (authHandler == null) {\n\t\t\tthrow new ProxyAuthException(\n\t\t\t\t\t\"Unknown authentication mechanism(s): \" + values);\n\t\t}\n\t}\n\n    /**\n     * Handle a HTTP response from the proxy server.\n     * \n     * @param response The proxy response.\n     */\n    @Override\n    public void handleResponse(final HttpProxyResponse response)\n            throws ProxyAuthException {\n        if (!isHandshakeComplete()\n                && (\"close\".equalsIgnoreCase(StringUtilities\n                        .getSingleValuedHeader(response.getHeaders(),\n                                \"Proxy-Connection\")) || \"close\"\n                        .equalsIgnoreCase(StringUtilities\n                                .getSingleValuedHeader(response.getHeaders(),\n                                        \"Connection\")))) {\n            getProxyIoSession().setReconnectionNeeded(true);\n        }\n\n        if (response.getStatusCode() == 407) {\n            if (authHandler == null) {\n                autoSelectAuthHandler(response);\n            }\n            authHandler.handleResponse(response);\n        } else {\n            throw new ProxyAuthException(\"Error: unexpected response code \"\n                    + response.getStatusLine() + \" received from proxy.\");\n        }\n    }\n}\n","lineNo":105}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.proxy;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.concurrent.Executor;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.future.DefaultConnectFuture;\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.service.AbstractIoConnector;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.IoSessionInitializer;\nimport org.apache.mina.proxy.filter.ProxyFilter;\nimport org.apache.mina.proxy.handlers.socks.SocksProxyRequest;\nimport org.apache.mina.proxy.session.ProxyIoSession;\nimport org.apache.mina.proxy.session.ProxyIoSessionInitializer;\nimport org.apache.mina.transport.socket.DefaultSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketConnector;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * ProxyConnector.java - Decorator for {@link SocketConnector} to provide proxy support, as suggested by MINA list discussions.\n * <p>\n * Operates by intercepting connect requests and replacing the endpoint address with the proxy address,\n * then adding a {@link ProxyFilter} as the first {@link IoFilter} which performs any necessary\n * handshaking with the proxy before allowing data to flow normally. During the handshake, any outgoing\n * write requests are buffered.\n * \n * @see\t\thttp://www.nabble.com/Meta-Transport%3A-an-idea-on-implementing-reconnection-and-proxy-td12969001.html\n * @see\t\thttp://issues.apache.org/jira/browse/DIRMINA-415\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M3\n */\npublic class ProxyConnector extends AbstractIoConnector {\n    static final TransportMetadata METADATA = new DefaultTransportMetadata(\n            \"proxy\", \"proxyconnector\", false, true, InetSocketAddress.class,\n            SocketSessionConfig.class, IoBuffer.class, FileRegion.class);\n\n    /**\n     * Wrapped connector to use for outgoing TCP connections.\n     */\n    private SocketConnector connector = null;\n\n    /**\n     * Proxy filter instance.\n     */\n    private final ProxyFilter proxyFilter = new ProxyFilter();\n\n    /**\n     * The {@link ProxyIoSession} in use.\n     */\n    private ProxyIoSession proxyIoSession;\n\n    /**\n     * This future will notify it's listeners when really connected to the target\n     */\n    private DefaultConnectFuture future;\n\n    /**\n     * Creates a new proxy connector.\n     */\n    public ProxyConnector() {\n        super(new DefaultSocketSessionConfig(), null);\n    }\n\n    /**\n     * Creates a new proxy connector.\n     * \n     * @param connector         Connector used to establish proxy connections.\n     */\n    public ProxyConnector(final SocketConnector connector) {        \n        this(connector, new DefaultSocketSessionConfig(), null);\n    }\n\n    /**\n     * Creates a new proxy connector. \n     * @see AbstractIoConnector(IoSessionConfig, Executor).\n     */\n    public ProxyConnector(final SocketConnector connector, IoSessionConfig config, Executor executor) {\n        super(config, executor);\n        setConnector(connector);\n    }    \n        \n    @Override\n    public IoSessionConfig getSessionConfig() {\n        return connector.getSessionConfig();\n    }\n\n    public ProxyIoSession getProxyIoSession() {\n        return proxyIoSession;\n    }\n\n    public void setProxyIoSession(ProxyIoSession proxyIoSession) {\n        if (proxyIoSession == null) {\n            throw new NullPointerException(\"proxySession cannot be null\");\n        }\n\n        if (proxyIoSession.getProxyAddress() == null) {\n            throw new NullPointerException(\n                    \"proxySession.proxyAddress cannot be null\");\n        }\n\n        proxyIoSession.setConnector(this);\n        setDefaultRemoteAddress(proxyIoSession.getProxyAddress());\n        this.proxyIoSession = proxyIoSession;\n    }\n\n    /**\n     * Connects to the specified <code>address<\/code>.  If communication starts\n     * successfully, events are fired to the specified\n     * <code>handler<\/code>.\n     * \n     * @return {@link ConnectFuture} that will tell the result of the connection attempt\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected ConnectFuture connect0(\n            final SocketAddress remoteAddress,\n            final SocketAddress localAddress,\n            final IoSessionInitializer<? extends ConnectFuture> sessionInitializer) {\n        if (!proxyIoSession.isReconnectionNeeded()) {\n            // First connection\n            IoHandler handler = getHandler();\n            if (!(handler instanceof AbstractProxyIoHandler)) {\n                throw new IllegalArgumentException(\n                        \"IoHandler must be an instance of AbstractProxyIoHandler\");\n            }\n\n            connector.setHandler(handler);\n            future = new DefaultConnectFuture();\n        }\n\n        ConnectFuture conFuture = connector.connect(proxyIoSession\n                .getProxyAddress(), new ProxyIoSessionInitializer(\n                sessionInitializer, proxyIoSession));\n\n        if (proxyIoSession.getRequest() instanceof SocksProxyRequest\n                || proxyIoSession.isReconnectionNeeded()) {\n            return conFuture;\n        } else {\n            return future;\n        }\n    }\n\n    public void cancelConnectFuture() {\n        future.cancel();\n    }\n\n    protected ConnectFuture fireConnected(final IoSession session) {\n        future.setSession(session);\n        return future;\n    }\n\n    /**\n     * Get the {@link SocketConnector} to be used for connections\n     * to the proxy server.\n     */\n    public final SocketConnector getConnector() {\n        return connector;\n    }\n\n    /**\n     * Set the {@link SocketConnector} to be used for connections\n     * to the proxy server.\n     */\n    public final void setConnector(final SocketConnector newConnector) {\n        if (newConnector == null) {\n            throw new NullPointerException(\"connector cannot be null\");\n        }\n\n        SocketConnector oldConnector = this.connector;\n\n        // Remove the ProxyFilter from the old filter chain builder\n        if (oldConnector != null) {\n            oldConnector.getFilterChain().remove(ProxyFilter.class.getName());\n        }\n\n        this.connector = newConnector;\n\n        // Insert the ProxyFilter as the first filter in the filter chain builder\n        if (newConnector.getFilterChain().contains(ProxyFilter.class.getName())) {\n            newConnector.getFilterChain().remove(ProxyFilter.class.getName());\n        }\n\n        newConnector.getFilterChain().addFirst(ProxyFilter.class.getName(),\n                proxyFilter);\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.mina.common.AbstractIoService#dispose0()\n     */\n    @Override\n    protected IoFuture dispose0() throws Exception {\n        if (connector != null) {\n            connector.dispose();\n        }\n        return null;\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.mina.common.IoService#getTransportMetadata()\n     */\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.proxy;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.concurrent.Executor;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.future.DefaultConnectFuture;\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.service.AbstractIoConnector;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.session.IoSessionInitializer;\nimport org.apache.mina.proxy.filter.ProxyFilter;\nimport org.apache.mina.proxy.handlers.socks.SocksProxyRequest;\nimport org.apache.mina.proxy.session.ProxyIoSession;\nimport org.apache.mina.proxy.session.ProxyIoSessionInitializer;\nimport org.apache.mina.transport.socket.DefaultSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketConnector;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * ProxyConnector.java - Decorator for {@link SocketConnector} to provide proxy support, \n * as suggested by MINA list discussions.\n * <p>\n * Operates by intercepting connect requests and replacing the endpoint address with the \n * proxy address, then adding a {@link ProxyFilter} as the first {@link IoFilter} which \n * performs any necessary handshaking with the proxy before allowing data to flow \n * normally. During the handshake, any outgoing write requests are buffered.\n * \n * @see\t\thttp://www.nabble.com/Meta-Transport%3A-an-idea-on-implementing-reconnection-and-proxy-td12969001.html\n * @see\t\thttp://issues.apache.org/jira/browse/DIRMINA-415\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M3\n */\npublic class ProxyConnector extends AbstractIoConnector {\n    static final TransportMetadata METADATA = new DefaultTransportMetadata(\n            \"proxy\", \"proxyconnector\", false, true, InetSocketAddress.class,\n            SocketSessionConfig.class, IoBuffer.class, FileRegion.class);\n\n    /**\n     * Wrapped connector to use for outgoing TCP connections.\n     */\n    private SocketConnector connector = null;\n\n    /**\n     * Proxy filter instance.\n     */\n    private final ProxyFilter proxyFilter = new ProxyFilter();\n\n    /**\n     * The {@link ProxyIoSession} in use.\n     */\n    private ProxyIoSession proxyIoSession;\n\n    /**\n     * This future will notify it's listeners when really connected to the target\n     */\n    private DefaultConnectFuture future;\n\n    /**\n     * Creates a new proxy connector.\n     */\n    public ProxyConnector() {\n        super(new DefaultSocketSessionConfig(), null);\n    }\n\n    /**\n     * Creates a new proxy connector.\n     * \n     * @param connector Connector used to establish proxy connections.\n     */\n    public ProxyConnector(final SocketConnector connector) {        \n        this(connector, new DefaultSocketSessionConfig(), null);\n    }\n\n    /**\n     * Creates a new proxy connector. \n     * @see AbstractIoConnector(IoSessionConfig, Executor).\n     */\n    public ProxyConnector(final SocketConnector connector, IoSessionConfig config, Executor executor) {\n        super(config, executor);\n        setConnector(connector);\n    }    \n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IoSessionConfig getSessionConfig() {\n        return connector.getSessionConfig();\n    }\n\n    /**\n     * Returns the {@link ProxyIoSession} linked with this connector.\n     */\n    public ProxyIoSession getProxyIoSession() {\n        return proxyIoSession;\n    }\n\n    /**\n     * Sets the proxy session object of this connector.\n     * @param proxyIoSession the configuration of this connector.\n     */\n    public void setProxyIoSession(ProxyIoSession proxyIoSession) {\n        if (proxyIoSession == null) {\n            throw new NullPointerException(\"proxySession object cannot be null\");\n        }\n\n        if (proxyIoSession.getProxyAddress() == null) {\n            throw new NullPointerException(\n                    \"proxySession.proxyAddress cannot be null\");\n        }\n\n        proxyIoSession.setConnector(this);\n        setDefaultRemoteAddress(proxyIoSession.getProxyAddress());\n        this.proxyIoSession = proxyIoSession;\n    }\n\n    /**\n     * Connects to the specified <code>address<\/code>.  If communication starts\n     * successfully, events are fired to the connector's <code>handler<\/code>.\n     * \n     * @param remoteAddress the remote address to connect to\n     * @param localAddress the local address\n     * @param sessionInitializer the session initializer\n     * @return {@link ConnectFuture} that will tell the result of the connection attempt\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected ConnectFuture connect0(\n            final SocketAddress remoteAddress,\n            final SocketAddress localAddress,\n            final IoSessionInitializer<? extends ConnectFuture> sessionInitializer) {\n        if (!proxyIoSession.isReconnectionNeeded()) {\n            // First connection\n            IoHandler handler = getHandler();\n            if (!(handler instanceof AbstractProxyIoHandler)) {\n                throw new IllegalArgumentException(\n                        \"IoHandler must be an instance of AbstractProxyIoHandler\");\n            }\n\n            connector.setHandler(handler);\n            future = new DefaultConnectFuture();\n        }\n\n        ConnectFuture conFuture = connector.connect(proxyIoSession\n                .getProxyAddress(), new ProxyIoSessionInitializer(\n                sessionInitializer, proxyIoSession));\n\n        // If proxy does not use reconnection like socks the connector's \n        // future is returned. If we're in the middle of a reconnection\n        // then we send back the connector's future which is only used\n        // internally while <code>future<\/code> will be used to notify\n        // the user of the connection state.\n        if (proxyIoSession.getRequest() instanceof SocksProxyRequest\n                || proxyIoSession.isReconnectionNeeded()) {\n            return conFuture;\n        } else {\n            return future;\n        }\n    }\n\n    /**\n     * Cancels the real connection when reconnection is in use.\n     */\n    public void cancelConnectFuture() {\n        future.cancel();\n    }\n\n    /**\n     * Fires the connection event on the real future to notify the client.\n     * \n     * @param session the current session\n     * @return the future holding the connected session\n     */\n    protected ConnectFuture fireConnected(final IoSession session) {\n        future.setSession(session);\n        return future;\n    }\n\n    /**\n     * Get the {@link SocketConnector} to be used for connections\n     * to the proxy server.\n     */\n    public final SocketConnector getConnector() {\n        return connector;\n    }\n\n    /**\n     * Sets the {@link SocketConnector} to be used for connections\n     * to the proxy server.\n     * \n     * @param connector the connector to use\n     */\n    private final void setConnector(final SocketConnector connector) {\n        if (connector == null) {\n            throw new NullPointerException(\"connector cannot be null\");\n        }\n\n        this.connector = connector;\n        String className = ProxyFilter.class.getName();\n\n        // Removes an old ProxyFilter instance from the chain\n        if (connector.getFilterChain().contains(className)) {\n        \tconnector.getFilterChain().remove(className);\n        }\n\n        // Insert the ProxyFilter as the first filter in the filter chain builder        \n        connector.getFilterChain().addFirst(className, proxyFilter);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected IoFuture dispose0() throws Exception {\n        if (connector != null) {\n            connector.dispose();\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n}\n","lineNo":229}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":621}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":635}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":650}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":665}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":680}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":695}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":710}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The initial pool size\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     * \n     * @param executor the user's managed Executor to use in this filter\n     * @param eventTypes The event for which the executor will be used\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize The initial pool sizePoolSize\n     * @param maximumPoolSize The maximum pool size\n     * @param keepAliveTime Default duration for a thread\n     * @param unit Time unit used for the keepAlive value\n     * @param threadFactory The factory used to create threads\n     * @param queueHandler The queue used to store events\n     * @return An instance of the created Executor\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if ((eventTypes == null) || (eventTypes.length == 0)) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                session, null); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                session, status); \n            fireEvent(event);\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.EXCEPTION_CAUGHT, session, cause); \n            fireEvent(event);\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter,\n                IoEventType.MESSAGE_RECEIVED, session, message); \n            fireEvent(event);\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                session, writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                writeRequest); \n            fireEvent(event);\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            IoFilterEvent event = new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                null); \n            fireEvent(event);\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":725}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.AbstractSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * An {@link IoSession} for socket transport (TCP/IP).\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\nclass NioSocketSession extends NioSession {\n\n    static final TransportMetadata METADATA =\n            new DefaultTransportMetadata(\n                    \"nio\", \"socket\", false, true,\n                    InetSocketAddress.class,\n                    SocketSessionConfig.class,\n                    IoBuffer.class, FileRegion.class);\n\n    private final IoService service;\n\n    private final SocketSessionConfig config = new SessionConfigImpl();\n\n    private final IoProcessor<NioSession> processor;\n\n    private final IoFilterChain filterChain = new DefaultIoFilterChain(this);\n\n    private final SocketChannel ch;\n\n    private final IoHandler handler;\n\n    private SelectionKey key;\n\n    \n    /**\n     * \n     * Creates a new instance of NioSocketSession.\n     *\n     * @param service the associated IoService \n     * @param processor the associated IoProcessor\n     * @param ch the used channel\n     */\n    public NioSocketSession(IoService service, IoProcessor<NioSession> processor, SocketChannel ch) {\n        this.service = service;\n        this.processor = processor;\n        this.ch = ch;\n        this.handler = service.getHandler();\n        this.config.setAll(service.getSessionConfig());\n    }\n\n    public IoService getService() {\n        return service;\n    }\n\n    public SocketSessionConfig getConfig() {\n        return config;\n    }\n\n    @Override\n    public IoProcessor<NioSession> getProcessor() {\n        return processor;\n    }\n\n    public IoFilterChain getFilterChain() {\n        return filterChain;\n    }\n\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n\n    @Override\n    SocketChannel getChannel() {\n        return ch;\n    }\n\n    @Override\n    SelectionKey getSelectionKey() {\n        return key;\n    }\n\n    @Override\n    void setSelectionKey(SelectionKey key) {\n        this.key = key;\n    }\n\n    public IoHandler getHandler() {\n        return handler;\n    }\n\n    public InetSocketAddress getRemoteAddress() {\n        return (InetSocketAddress) ch.socket().getRemoteSocketAddress();\n    }\n\n    public InetSocketAddress getLocalAddress() {\n        return (InetSocketAddress) ch.socket().getLocalSocketAddress();\n    }\n\n    @Override\n    public InetSocketAddress getServiceAddress() {\n        return (InetSocketAddress) super.getServiceAddress();\n    }\n\n    private class SessionConfigImpl extends AbstractSocketSessionConfig {\n        public boolean isKeepAlive() {\n            try {\n                return ch.socket().getKeepAlive();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setKeepAlive(boolean on) {\n            try {\n                ch.socket().setKeepAlive(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isOobInline() {\n            try {\n                return ch.socket().getOOBInline();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setOobInline(boolean on) {\n            try {\n                ch.socket().setOOBInline(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isReuseAddress() {\n            try {\n                return ch.socket().getReuseAddress();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReuseAddress(boolean on) {\n            try {\n                ch.socket().setReuseAddress(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSoLinger() {\n            try {\n                return ch.socket().getSoLinger();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSoLinger(int linger) {\n            try {\n                if (linger < 0) {\n                    ch.socket().setSoLinger(false, 0);\n                } else {\n                    ch.socket().setSoLinger(true, linger);\n                }\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isTcpNoDelay() {\n            if (!isConnected()) {\n                return false;\n            }\n\n            try {\n                return ch.socket().getTcpNoDelay();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setTcpNoDelay(boolean on) {\n            try {\n                ch.socket().setTcpNoDelay(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getTrafficClass() {\n            try {\n                return ch.socket().getTrafficClass();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setTrafficClass(int tc) {\n            try {\n                ch.socket().setTrafficClass(tc);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSendBufferSize() {\n            try {\n                return ch.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSendBufferSize(int size) {\n            try {\n                ch.socket().setSendBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getReceiveBufferSize() {\n            try {\n                return ch.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReceiveBufferSize(int size) {\n            try {\n                ch.socket().setReceiveBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.AbstractSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * An {@link IoSession} for socket transport (TCP/IP).\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\nclass NioSocketSession extends NioSession {\n\n    static final TransportMetadata METADATA =\n            new DefaultTransportMetadata(\n                    \"nio\", \"socket\", false, true,\n                    InetSocketAddress.class,\n                    SocketSessionConfig.class,\n                    IoBuffer.class, FileRegion.class);\n\n    private final IoService service;\n\n    private final SocketSessionConfig config = new SessionConfigImpl();\n\n    private final IoProcessor<NioSession> processor;\n\n    private final IoFilterChain filterChain = new DefaultIoFilterChain(this);\n\n    private final SocketChannel ch;\n\n    private final IoHandler handler;\n\n    private SelectionKey key;\n\n    \n    /**\n     * \n     * Creates a new instance of NioSocketSession.\n     *\n     * @param service the associated IoService \n     * @param processor the associated IoProcessor\n     * @param ch the used channel\n     */\n    public NioSocketSession(IoService service, IoProcessor<NioSession> processor, SocketChannel ch) {\n        this.service = service;\n        this.processor = processor;\n        this.ch = ch;\n        this.handler = service.getHandler();\n        this.config.setAll(service.getSessionConfig());\n    }\n\n    public IoService getService() {\n        return service;\n    }\n\n    public SocketSessionConfig getConfig() {\n        return config;\n    }\n\n    @Override\n    public IoProcessor<NioSession> getProcessor() {\n        return processor;\n    }\n\n    public IoFilterChain getFilterChain() {\n        return filterChain;\n    }\n\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n\n    @Override\n    SocketChannel getChannel() {\n        return ch;\n    }\n\n    @Override\n    SelectionKey getSelectionKey() {\n        return key;\n    }\n\n    @Override\n    void setSelectionKey(SelectionKey key) {\n        this.key = key;\n    }\n\n    public IoHandler getHandler() {\n        return handler;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public InetSocketAddress getRemoteAddress() {\n        if ( ch == null ) {\n            return null;\n        }\n        \n        Socket socket = ch.socket();\n        \n        if ( socket == null ) {\n            return null;\n        }\n        \n        return (InetSocketAddress) socket.getRemoteSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public InetSocketAddress getLocalAddress() {\n        if ( ch == null ) {\n            return null;\n        }\n        \n        Socket socket = ch.socket();\n        \n        if ( socket == null ) {\n            return null;\n        }\n        \n        return (InetSocketAddress) socket.getLocalSocketAddress();\n    }\n\n    @Override\n    public InetSocketAddress getServiceAddress() {\n        return (InetSocketAddress) super.getServiceAddress();\n    }\n\n    private class SessionConfigImpl extends AbstractSocketSessionConfig {\n        public boolean isKeepAlive() {\n            try {\n                return ch.socket().getKeepAlive();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setKeepAlive(boolean on) {\n            try {\n                ch.socket().setKeepAlive(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isOobInline() {\n            try {\n                return ch.socket().getOOBInline();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setOobInline(boolean on) {\n            try {\n                ch.socket().setOOBInline(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isReuseAddress() {\n            try {\n                return ch.socket().getReuseAddress();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReuseAddress(boolean on) {\n            try {\n                ch.socket().setReuseAddress(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSoLinger() {\n            try {\n                return ch.socket().getSoLinger();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSoLinger(int linger) {\n            try {\n                if (linger < 0) {\n                    ch.socket().setSoLinger(false, 0);\n                } else {\n                    ch.socket().setSoLinger(true, linger);\n                }\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isTcpNoDelay() {\n            if (!isConnected()) {\n                return false;\n            }\n\n            try {\n                return ch.socket().getTcpNoDelay();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setTcpNoDelay(boolean on) {\n            try {\n                ch.socket().setTcpNoDelay(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getTrafficClass() {\n            try {\n                return ch.socket().getTrafficClass();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setTrafficClass(int tc) {\n            try {\n                ch.socket().setTrafficClass(tc);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSendBufferSize() {\n            try {\n                return ch.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSendBufferSize(int size) {\n            try {\n                ch.socket().setSendBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getReceiveBufferSize() {\n            try {\n                return ch.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReceiveBufferSize(int size) {\n            try {\n                ch.socket().setReceiveBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n    }\n}\n","lineNo":136}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.AbstractSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * An {@link IoSession} for socket transport (TCP/IP).\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\nclass NioSocketSession extends NioSession {\n\n    static final TransportMetadata METADATA =\n            new DefaultTransportMetadata(\n                    \"nio\", \"socket\", false, true,\n                    InetSocketAddress.class,\n                    SocketSessionConfig.class,\n                    IoBuffer.class, FileRegion.class);\n\n    private final IoService service;\n\n    private final SocketSessionConfig config = new SessionConfigImpl();\n\n    private final IoProcessor<NioSession> processor;\n\n    private final IoFilterChain filterChain = new DefaultIoFilterChain(this);\n\n    private final SocketChannel ch;\n\n    private final IoHandler handler;\n\n    private SelectionKey key;\n\n    \n    /**\n     * \n     * Creates a new instance of NioSocketSession.\n     *\n     * @param service the associated IoService \n     * @param processor the associated IoProcessor\n     * @param ch the used channel\n     */\n    public NioSocketSession(IoService service, IoProcessor<NioSession> processor, SocketChannel ch) {\n        this.service = service;\n        this.processor = processor;\n        this.ch = ch;\n        this.handler = service.getHandler();\n        this.config.setAll(service.getSessionConfig());\n    }\n\n    public IoService getService() {\n        return service;\n    }\n\n    public SocketSessionConfig getConfig() {\n        return config;\n    }\n\n    @Override\n    public IoProcessor<NioSession> getProcessor() {\n        return processor;\n    }\n\n    public IoFilterChain getFilterChain() {\n        return filterChain;\n    }\n\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n\n    @Override\n    SocketChannel getChannel() {\n        return ch;\n    }\n\n    @Override\n    SelectionKey getSelectionKey() {\n        return key;\n    }\n\n    @Override\n    void setSelectionKey(SelectionKey key) {\n        this.key = key;\n    }\n\n    public IoHandler getHandler() {\n        return handler;\n    }\n\n    public InetSocketAddress getRemoteAddress() {\n        return (InetSocketAddress) ch.socket().getRemoteSocketAddress();\n    }\n\n    public InetSocketAddress getLocalAddress() {\n        return (InetSocketAddress) ch.socket().getLocalSocketAddress();\n    }\n\n    @Override\n    public InetSocketAddress getServiceAddress() {\n        return (InetSocketAddress) super.getServiceAddress();\n    }\n\n    private class SessionConfigImpl extends AbstractSocketSessionConfig {\n        public boolean isKeepAlive() {\n            try {\n                return ch.socket().getKeepAlive();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setKeepAlive(boolean on) {\n            try {\n                ch.socket().setKeepAlive(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isOobInline() {\n            try {\n                return ch.socket().getOOBInline();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setOobInline(boolean on) {\n            try {\n                ch.socket().setOOBInline(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isReuseAddress() {\n            try {\n                return ch.socket().getReuseAddress();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReuseAddress(boolean on) {\n            try {\n                ch.socket().setReuseAddress(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSoLinger() {\n            try {\n                return ch.socket().getSoLinger();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSoLinger(int linger) {\n            try {\n                if (linger < 0) {\n                    ch.socket().setSoLinger(false, 0);\n                } else {\n                    ch.socket().setSoLinger(true, linger);\n                }\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isTcpNoDelay() {\n            if (!isConnected()) {\n                return false;\n            }\n\n            try {\n                return ch.socket().getTcpNoDelay();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setTcpNoDelay(boolean on) {\n            try {\n                ch.socket().setTcpNoDelay(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getTrafficClass() {\n            try {\n                return ch.socket().getTrafficClass();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setTrafficClass(int tc) {\n            try {\n                ch.socket().setTrafficClass(tc);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSendBufferSize() {\n            try {\n                return ch.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSendBufferSize(int size) {\n            try {\n                ch.socket().setSendBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getReceiveBufferSize() {\n            try {\n                return ch.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReceiveBufferSize(int size) {\n            try {\n                ch.socket().setReceiveBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.service.DefaultTransportMetadata;\nimport org.apache.mina.core.service.IoHandler;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.AbstractSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * An {@link IoSession} for socket transport (TCP/IP).\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\nclass NioSocketSession extends NioSession {\n\n    static final TransportMetadata METADATA =\n            new DefaultTransportMetadata(\n                    \"nio\", \"socket\", false, true,\n                    InetSocketAddress.class,\n                    SocketSessionConfig.class,\n                    IoBuffer.class, FileRegion.class);\n\n    private final IoService service;\n\n    private final SocketSessionConfig config = new SessionConfigImpl();\n\n    private final IoProcessor<NioSession> processor;\n\n    private final IoFilterChain filterChain = new DefaultIoFilterChain(this);\n\n    private final SocketChannel ch;\n\n    private final IoHandler handler;\n\n    private SelectionKey key;\n\n    \n    /**\n     * \n     * Creates a new instance of NioSocketSession.\n     *\n     * @param service the associated IoService \n     * @param processor the associated IoProcessor\n     * @param ch the used channel\n     */\n    public NioSocketSession(IoService service, IoProcessor<NioSession> processor, SocketChannel ch) {\n        this.service = service;\n        this.processor = processor;\n        this.ch = ch;\n        this.handler = service.getHandler();\n        this.config.setAll(service.getSessionConfig());\n    }\n\n    public IoService getService() {\n        return service;\n    }\n\n    public SocketSessionConfig getConfig() {\n        return config;\n    }\n\n    @Override\n    public IoProcessor<NioSession> getProcessor() {\n        return processor;\n    }\n\n    public IoFilterChain getFilterChain() {\n        return filterChain;\n    }\n\n    public TransportMetadata getTransportMetadata() {\n        return METADATA;\n    }\n\n    @Override\n    SocketChannel getChannel() {\n        return ch;\n    }\n\n    @Override\n    SelectionKey getSelectionKey() {\n        return key;\n    }\n\n    @Override\n    void setSelectionKey(SelectionKey key) {\n        this.key = key;\n    }\n\n    public IoHandler getHandler() {\n        return handler;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public InetSocketAddress getRemoteAddress() {\n        if ( ch == null ) {\n            return null;\n        }\n        \n        Socket socket = ch.socket();\n        \n        if ( socket == null ) {\n            return null;\n        }\n        \n        return (InetSocketAddress) socket.getRemoteSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public InetSocketAddress getLocalAddress() {\n        if ( ch == null ) {\n            return null;\n        }\n        \n        Socket socket = ch.socket();\n        \n        if ( socket == null ) {\n            return null;\n        }\n        \n        return (InetSocketAddress) socket.getLocalSocketAddress();\n    }\n\n    @Override\n    public InetSocketAddress getServiceAddress() {\n        return (InetSocketAddress) super.getServiceAddress();\n    }\n\n    private class SessionConfigImpl extends AbstractSocketSessionConfig {\n        public boolean isKeepAlive() {\n            try {\n                return ch.socket().getKeepAlive();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setKeepAlive(boolean on) {\n            try {\n                ch.socket().setKeepAlive(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isOobInline() {\n            try {\n                return ch.socket().getOOBInline();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setOobInline(boolean on) {\n            try {\n                ch.socket().setOOBInline(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isReuseAddress() {\n            try {\n                return ch.socket().getReuseAddress();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReuseAddress(boolean on) {\n            try {\n                ch.socket().setReuseAddress(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSoLinger() {\n            try {\n                return ch.socket().getSoLinger();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSoLinger(int linger) {\n            try {\n                if (linger < 0) {\n                    ch.socket().setSoLinger(false, 0);\n                } else {\n                    ch.socket().setSoLinger(true, linger);\n                }\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public boolean isTcpNoDelay() {\n            if (!isConnected()) {\n                return false;\n            }\n\n            try {\n                return ch.socket().getTcpNoDelay();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setTcpNoDelay(boolean on) {\n            try {\n                ch.socket().setTcpNoDelay(on);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int getTrafficClass() {\n            try {\n                return ch.socket().getTrafficClass();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setTrafficClass(int tc) {\n            try {\n                ch.socket().setTrafficClass(tc);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getSendBufferSize() {\n            try {\n                return ch.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setSendBufferSize(int size) {\n            try {\n                ch.socket().setSendBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public int getReceiveBufferSize() {\n            try {\n                return ch.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n\n        public void setReceiveBufferSize(int size) {\n            try {\n                ch.socket().setReceiveBufferSize(size);\n            } catch (SocketException e) {\n                throw new RuntimeIoException(e);\n            }\n        }\n    }\n}\n","lineNo":153}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.future;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.polling.AbstractPollingIoProcessor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * A default implementation of {@link IoFuture} associated with\n * an {@link IoSession}.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev:671827 $, $Date:2008-06-26 09:49:48 +0100 (jeu., 26 juin 2008) $\n */\npublic class DefaultIoFuture implements IoFuture {\n\n    /** A number of seconds to wait between two deadlock controls ( 5 seconds ) */\n    private static final int DEAD_LOCK_CHECK_INTERVAL = 5000;\n\n    private final IoSession session;\n    \n    /** A lock used by the wait() method */\n    private final Object lock;\n    private IoFutureListener<?> firstListener;\n    private List<IoFutureListener<?>> otherListeners;\n    private Object result;\n    private boolean ready;\n    private int waiters;\n\n    /**\n     * Creates a new instance associated with an {@link IoSession}.\n     *\n     * @param session an {@link IoSession} which is associated with this future\n     */\n    public DefaultIoFuture(IoSession session) {\n        this.session = session;\n        this.lock = this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * @deprecated Replaced with {@link #awaitUninterruptibly()}.\n     */\n    @Deprecated\n    public void join() {\n        awaitUninterruptibly();\n    }\n\n    /**\n     * @deprecated Replaced with {@link #awaitUninterruptibly(long)}.\n     */\n    @Deprecated\n    public boolean join(long timeoutMillis) {\n        return awaitUninterruptibly(timeoutMillis);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture await() throws InterruptedException {\n        synchronized (lock) {\n            while (!ready) {\n                waiters++;\n                try {\n                    // Wait for a notify, or if no notify is called,\n                    // assume that we have a deadlock and exit the \n                    // loop to check for a potential deadlock.\n                    lock.wait(DEAD_LOCK_CHECK_INTERVAL);\n                } finally {\n                    waiters--;\n                    if (!ready) {\n                        checkDeadLock();\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean await(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return await(unit.toMillis(timeout));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean await(long timeoutMillis) throws InterruptedException {\n        return await0(timeoutMillis, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture awaitUninterruptibly() {\n        try {\n            await0(Long.MAX_VALUE, false);\n        } catch ( InterruptedException ie) {\n            // Do nothing : this catch is just mandatory by contract\n        }\n        \n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {\n        return awaitUninterruptibly(unit.toMillis(timeout));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean awaitUninterruptibly(long timeoutMillis) {\n        try {\n            return await0(timeoutMillis, false);\n        } catch (InterruptedException e) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Wait for the Future to be ready. If the requested delay is 0 or \n     * negative, this method immediately returns the value of the \n     * 'ready' flag. \n     * Every 5 second, the wait will be suspended to be able to check if \n     * there is a deadlock or not.\n     * \n     * @param timeoutMillis The delay we will wait for the Future to be ready\n     * @param interruptable Tells if the wait can be interrupted or not\n     * @return <code>true<\/code> if the Future is ready\n     * @throws InterruptedException If the thread has been interrupted\n     * when it's not allowed.\n     */\n    private boolean await0(long timeoutMillis, boolean interruptable) throws InterruptedException {\n        long endTime = System.currentTimeMillis() + timeoutMillis;\n\n        synchronized (lock) {\n            if (ready) {\n                return ready;\n            } else if (timeoutMillis <= 0) {\n                return ready;\n            }\n\n            waiters++;\n            try {\n                for (;;) {\n                    try {\n                        lock.wait(Math.min(timeoutMillis, DEAD_LOCK_CHECK_INTERVAL));\n                    } catch (InterruptedException e) {\n                        if (interruptable) {\n                            throw e;\n                        }\n                    }\n\n                    if (ready) {\n                        return true;\n                    } else {\n                        if (endTime > System.currentTimeMillis()) {\n                            return ready;\n                        }\n                    }\n                }\n            } finally {\n                waiters--;\n                if (!ready) {\n                    checkDeadLock();\n                }\n            }\n        }\n    }\n\n    \n    /**\n     * \n     * TODO checkDeadLock.\n     *\n     */\n    private void checkDeadLock() {\n        // Only read / write / connect / write future can cause dead lock. \n        if (!(this instanceof CloseFuture || this instanceof WriteFuture ||\n              this instanceof ReadFuture || this instanceof ConnectFuture)) {\n            return;\n        }\n        \n        // Get the current thread stackTrace. \n        // Using Thread.currentThread().getStackTrace() is the best solution,\n        // even if slightly less efficient than doing a new Exception().getStackTrace(),\n        // as internally, it does exactly the same thing. The advantage of using\n        // this solution is that we may benefit some improvement with some\n        // future versions of Java.\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\n        // Simple and quick check.\n        for (StackTraceElement s: stackTrace) {\n            if (AbstractPollingIoProcessor.class.getName().equals(s.getClassName())) {\n                IllegalStateException e = new IllegalStateException( \"t\" );\n                e.getStackTrace();\n                throw new IllegalStateException(\n                    \"DEAD LOCK: \" + IoFuture.class.getSimpleName() +\n                    \".await() was invoked from an I/O processor thread.  \" +\n                    \"Please use \" + IoFutureListener.class.getSimpleName() +\n                    \" or configure a proper thread model alternatively.\");\n            }\n        }\n\n        // And then more precisely.\n        for (StackTraceElement s: stackTrace) {\n            try {\n                Class<?> cls = DefaultIoFuture.class.getClassLoader().loadClass(s.getClassName());\n                if (IoProcessor.class.isAssignableFrom(cls)) {\n                    throw new IllegalStateException(\n                        \"DEAD LOCK: \" + IoFuture.class.getSimpleName() +\n                        \".await() was invoked from an I/O processor thread.  \" +\n                        \"Please use \" + IoFutureListener.class.getSimpleName() +\n                        \" or configure a proper thread model alternatively.\");\n                }\n            } catch (Exception cnfe) {\n                // Ignore\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDone() {\n        synchronized (lock) {\n            return ready;\n        }\n    }\n\n    /**\n     * Sets the result of the asynchronous operation, and mark it as finished.\n     */\n    public void setValue(Object newValue) {\n        synchronized (lock) {\n            // Allow only once.\n            if (ready) {\n                return;\n            }\n\n            result = newValue;\n            ready = true;\n            if (waiters > 0) {\n                lock.notifyAll();\n            }\n        }\n\n        notifyListeners();\n    }\n\n    /**\n     * Returns the result of the asynchronous operation.\n     */\n    protected Object getValue() {\n        synchronized (lock) {\n            return result;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture addListener(IoFutureListener<?> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"listener\");\n        }\n\n        boolean notifyNow = false;\n        synchronized (lock) {\n            if (ready) {\n                notifyNow = true;\n            } else {\n                if (firstListener == null) {\n                    firstListener = listener;\n                } else {\n                    if (otherListeners == null) {\n                        otherListeners = new ArrayList<IoFutureListener<?>>(1);\n                    }\n                    otherListeners.add(listener);\n                }\n            }\n        }\n\n        if (notifyNow) {\n            notifyListener(listener);\n        }\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture removeListener(IoFutureListener<?> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"listener\");\n        }\n\n        synchronized (lock) {\n            if (!ready) {\n                if (listener == firstListener) {\n                    if (otherListeners != null && !otherListeners.isEmpty()) {\n                        firstListener = otherListeners.remove(0);\n                    } else {\n                        firstListener = null;\n                    }\n                } else if (otherListeners != null) {\n                    otherListeners.remove(listener);\n                }\n            }\n        }\n\n        return this;\n    }\n\n    private void notifyListeners() {\n        // There won't be any visibility problem or concurrent modification\n        // because 'ready' flag will be checked against both addListener and\n        // removeListener calls.\n        if (firstListener != null) {\n            notifyListener(firstListener);\n            firstListener = null;\n\n            if (otherListeners != null) {\n                for (IoFutureListener<?> l : otherListeners) {\n                    notifyListener(l);\n                }\n                otherListeners = null;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void notifyListener(IoFutureListener l) {\n        try {\n            l.operationComplete(this);\n        } catch (Throwable t) {\n            ExceptionMonitor.getInstance().exceptionCaught(t);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.future;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.polling.AbstractPollingIoProcessor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * A default implementation of {@link IoFuture} associated with\n * an {@link IoSession}.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev:671827 $, $Date:2008-06-26 09:49:48 +0100 (jeu., 26 juin 2008) $\n */\npublic class DefaultIoFuture implements IoFuture {\n\n    /** A number of seconds to wait between two deadlock controls ( 5 seconds ) */\n    private static final long DEAD_LOCK_CHECK_INTERVAL = 5000L;\n\n    private final IoSession session;\n    \n    /** A lock used by the wait() method */\n    private final Object lock;\n    private IoFutureListener<?> firstListener;\n    private List<IoFutureListener<?>> otherListeners;\n    private Object result;\n    private boolean ready;\n    private int waiters;\n\n    /**\n     * Creates a new instance associated with an {@link IoSession}.\n     *\n     * @param session an {@link IoSession} which is associated with this future\n     */\n    public DefaultIoFuture(IoSession session) {\n        this.session = session;\n        this.lock = this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoSession getSession() {\n        return session;\n    }\n\n    /**\n     * @deprecated Replaced with {@link #awaitUninterruptibly()}.\n     */\n    @Deprecated\n    public void join() {\n        awaitUninterruptibly();\n    }\n\n    /**\n     * @deprecated Replaced with {@link #awaitUninterruptibly(long)}.\n     */\n    @Deprecated\n    public boolean join(long timeoutMillis) {\n        return awaitUninterruptibly(timeoutMillis);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture await() throws InterruptedException {\n        synchronized (lock) {\n            while (!ready) {\n                waiters++;\n                try {\n                    // Wait for a notify, or if no notify is called,\n                    // assume that we have a deadlock and exit the \n                    // loop to check for a potential deadlock.\n                    lock.wait(DEAD_LOCK_CHECK_INTERVAL);\n                } finally {\n                    waiters--;\n                    if (!ready) {\n                        checkDeadLock();\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean await(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return await(unit.toMillis(timeout));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean await(long timeoutMillis) throws InterruptedException {\n        return await0(timeoutMillis, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture awaitUninterruptibly() {\n        try {\n            await0(Long.MAX_VALUE, false);\n        } catch ( InterruptedException ie) {\n            // Do nothing : this catch is just mandatory by contract\n        }\n        \n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {\n        return awaitUninterruptibly(unit.toMillis(timeout));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean awaitUninterruptibly(long timeoutMillis) {\n        try {\n            return await0(timeoutMillis, false);\n        } catch (InterruptedException e) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Wait for the Future to be ready. If the requested delay is 0 or \n     * negative, this method immediately returns the value of the \n     * 'ready' flag. \n     * Every 5 second, the wait will be suspended to be able to check if \n     * there is a deadlock or not.\n     * \n     * @param timeoutMillis The delay we will wait for the Future to be ready\n     * @param interruptable Tells if the wait can be interrupted or not\n     * @return <code>true<\/code> if the Future is ready\n     * @throws InterruptedException If the thread has been interrupted\n     * when it's not allowed.\n     */\n    private boolean await0(long timeoutMillis, boolean interruptable) throws InterruptedException {\n        long endTime = System.currentTimeMillis() + timeoutMillis;\n\n        synchronized (lock) {\n            if (ready) {\n                return ready;\n            } else if (timeoutMillis <= 0) {\n                return ready;\n            }\n\n            waiters++;\n            try {\n                for (;;) {\n                    try {\n                        long timeOut = Math.min(timeoutMillis, DEAD_LOCK_CHECK_INTERVAL);\n                        lock.wait(timeOut);\n                    } catch (InterruptedException e) {\n                        if (interruptable) {\n                            throw e;\n                        }\n                    }\n\n                    if (ready) {\n                        return true;\n                    } else {\n                        if (endTime < System.currentTimeMillis()) {\n                            return ready;\n                        }\n                    }\n                }\n            } finally {\n                waiters--;\n                if (!ready) {\n                    checkDeadLock();\n                }\n            }\n        }\n    }\n\n    \n    /**\n     * \n     * TODO checkDeadLock.\n     *\n     */\n    private void checkDeadLock() {\n        // Only read / write / connect / write future can cause dead lock. \n        if (!(this instanceof CloseFuture || this instanceof WriteFuture ||\n              this instanceof ReadFuture || this instanceof ConnectFuture)) {\n            return;\n        }\n        \n        // Get the current thread stackTrace. \n        // Using Thread.currentThread().getStackTrace() is the best solution,\n        // even if slightly less efficient than doing a new Exception().getStackTrace(),\n        // as internally, it does exactly the same thing. The advantage of using\n        // this solution is that we may benefit some improvement with some\n        // future versions of Java.\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\n        // Simple and quick check.\n        for (StackTraceElement s: stackTrace) {\n            if (AbstractPollingIoProcessor.class.getName().equals(s.getClassName())) {\n                IllegalStateException e = new IllegalStateException( \"t\" );\n                e.getStackTrace();\n                throw new IllegalStateException(\n                    \"DEAD LOCK: \" + IoFuture.class.getSimpleName() +\n                    \".await() was invoked from an I/O processor thread.  \" +\n                    \"Please use \" + IoFutureListener.class.getSimpleName() +\n                    \" or configure a proper thread model alternatively.\");\n            }\n        }\n\n        // And then more precisely.\n        for (StackTraceElement s: stackTrace) {\n            try {\n                Class<?> cls = DefaultIoFuture.class.getClassLoader().loadClass(s.getClassName());\n                if (IoProcessor.class.isAssignableFrom(cls)) {\n                    throw new IllegalStateException(\n                        \"DEAD LOCK: \" + IoFuture.class.getSimpleName() +\n                        \".await() was invoked from an I/O processor thread.  \" +\n                        \"Please use \" + IoFutureListener.class.getSimpleName() +\n                        \" or configure a proper thread model alternatively.\");\n                }\n            } catch (Exception cnfe) {\n                // Ignore\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDone() {\n        synchronized (lock) {\n            return ready;\n        }\n    }\n\n    /**\n     * Sets the result of the asynchronous operation, and mark it as finished.\n     */\n    public void setValue(Object newValue) {\n        synchronized (lock) {\n            // Allow only once.\n            if (ready) {\n                return;\n            }\n\n            result = newValue;\n            ready = true;\n            if (waiters > 0) {\n                lock.notifyAll();\n            }\n        }\n\n        notifyListeners();\n    }\n\n    /**\n     * Returns the result of the asynchronous operation.\n     */\n    protected Object getValue() {\n        synchronized (lock) {\n            return result;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture addListener(IoFutureListener<?> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"listener\");\n        }\n\n        boolean notifyNow = false;\n        synchronized (lock) {\n            if (ready) {\n                notifyNow = true;\n            } else {\n                if (firstListener == null) {\n                    firstListener = listener;\n                } else {\n                    if (otherListeners == null) {\n                        otherListeners = new ArrayList<IoFutureListener<?>>(1);\n                    }\n                    otherListeners.add(listener);\n                }\n            }\n        }\n\n        if (notifyNow) {\n            notifyListener(listener);\n        }\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IoFuture removeListener(IoFutureListener<?> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"listener\");\n        }\n\n        synchronized (lock) {\n            if (!ready) {\n                if (listener == firstListener) {\n                    if (otherListeners != null && !otherListeners.isEmpty()) {\n                        firstListener = otherListeners.remove(0);\n                    } else {\n                        firstListener = null;\n                    }\n                } else if (otherListeners != null) {\n                    otherListeners.remove(listener);\n                }\n            }\n        }\n\n        return this;\n    }\n\n    private void notifyListeners() {\n        // There won't be any visibility problem or concurrent modification\n        // because 'ready' flag will be checked against both addListener and\n        // removeListener calls.\n        if (firstListener != null) {\n            notifyListener(firstListener);\n            firstListener = null;\n\n            if (otherListeners != null) {\n                for (IoFutureListener<?> l : otherListeners) {\n                    notifyListener(l);\n                }\n                otherListeners = null;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void notifyListener(IoFutureListener l) {\n        try {\n            l.operationComplete(this);\n        } catch (Throwable t) {\n            ExceptionMonitor.getInstance().exceptionCaught(t);\n        }\n    }\n}\n","lineNo":183}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.util.ExceptionMonitor;\n\n/**\n * A helper which provides addition and removal of {@link IoServiceListener}s and firing\n * events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic class IoServiceListenerSupport {\n    /**\n     * The {@link IoService} that this instance manages.\n     */\n    private final IoService service;\n\n    /**\n     * A list of {@link IoServiceListener}s.\n     */\n    private final List<IoServiceListener> listeners = new CopyOnWriteArrayList<IoServiceListener>();\n\n    /**\n     * Tracks managed sessions.\n     */\n    private final ConcurrentMap<Long, IoSession> managedSessions = new ConcurrentHashMap<Long, IoSession>();\n\n    /**\n     * Read only version of {@link #managedSessions}.\n     */\n    private final Map<Long, IoSession> readOnlyManagedSessions = Collections.unmodifiableMap(managedSessions);\n\n    private final AtomicBoolean activated = new AtomicBoolean();\n    private volatile long activationTime;\n    private volatile int largestManagedSessionCount;\n    private volatile long cumulativeManagedSessionCount;\n\n    /**\n     * Creates a new instance.\n     */\n    public IoServiceListenerSupport(IoService service) {\n        if (service == null) {\n            throw new NullPointerException(\"service\");\n        }\n        this.service = service;\n    }\n\n    /**\n     * Adds a new listener.\n     */\n    public void add(IoServiceListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes an existing listener.\n     */\n    public void remove(IoServiceListener listener) {\n        listeners.remove(listener);\n    }\n\n    public long getActivationTime() {\n        return activationTime;\n    }\n\n    public Map<Long, IoSession> getManagedSessions() {\n        return readOnlyManagedSessions;\n    }\n\n    public int getManagedSessionCount() {\n        return managedSessions.size();\n    }\n\n    public int getLargestManagedSessionCount() {\n        return largestManagedSessionCount;\n    }\n\n    public long getCumulativeManagedSessionCount() {\n        return cumulativeManagedSessionCount;\n    }\n\n    public boolean isActive() {\n        return activated.get();\n    }\n\n    /**\n     * Calls {@link IoServiceListener#serviceActivated(IoService)}\n     * for all registered listeners.\n     */\n    public void fireServiceActivated() {\n        if (!activated.compareAndSet(false, true)) {\n            return;\n        }\n\n        activationTime = System.currentTimeMillis();\n\n        for (IoServiceListener l : listeners) {\n            try {\n                l.serviceActivated(service);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#serviceIdle(IoService, IdleStatus)}\n     * for all registered listeners.\n     */\n    public void fireServiceIdle(IdleStatus status) {\n        if (!activated.get()) {\n            return;\n        }\n\n        for (IoServiceListener l : listeners) {\n            try {\n                l.serviceIdle(service, status);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n\n    /**\n     * Calls {@link IoServiceListener#serviceDeactivated(IoService)}\n     * for all registered listeners.\n     */\n    public void fireServiceDeactivated() {\n        if (!activated.compareAndSet(true, false)) {\n            return;\n        }\n\n        try {\n            for (IoServiceListener l : listeners) {\n                try {\n                    l.serviceDeactivated(service);\n                } catch (Throwable e) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e);\n                }\n            }\n        } finally {\n            disconnectSessions();\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#sessionCreated(IoSession)} for all registered listeners.\n     */\n    public void fireSessionCreated(IoSession session) {\n        boolean firstSession = false;\n        if (session.getService() instanceof IoConnector) {\n            synchronized (managedSessions) {\n                firstSession = managedSessions.isEmpty();\n            }\n        }\n\n        // If already registered, ignore.\n        if (managedSessions.putIfAbsent(Long.valueOf(session.getId()), session) != null) {\n            return;\n        }\n\n        // If the first connector session, fire a virtual service activation event.\n        if (firstSession) {\n            fireServiceActivated();\n        }\n\n        // Fire session events.\n        session.getFilterChain().fireSessionCreated();\n        session.getFilterChain().fireSessionOpened();\n\n        int managedSessionCount = managedSessions.size();\n        if (managedSessionCount > largestManagedSessionCount) {\n            largestManagedSessionCount = managedSessionCount;\n        }\n        cumulativeManagedSessionCount ++;\n\n        // Fire listener events.\n        for (IoServiceListener l : listeners) {\n            try {\n                l.sessionCreated(session);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#sessionDestroyed(IoSession)} for all registered listeners.\n     */\n    public void fireSessionDestroyed(IoSession session) {\n        // Try to remove the remaining empty session set after removal.\n        if (managedSessions.remove(Long.valueOf(session.getId())) == null) {\n            return;\n        }\n\n        // Fire session events.\n        session.getFilterChain().fireSessionClosed();\n\n        // Fire listener events.\n        try {\n            for (IoServiceListener l : listeners) {\n                try {\n                    l.sessionDestroyed(session);\n                } catch (Throwable e) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e);\n                }\n            }\n        } finally {\n            // Fire a virtual service deactivation event for the last session of the connector.\n            if (session.getService() instanceof IoConnector) {\n                boolean lastSession = false;\n                synchronized (managedSessions) {\n                    lastSession = managedSessions.isEmpty();\n                }\n                if (lastSession) {\n                    fireServiceDeactivated();\n                }\n            }\n        }\n    }\n\n    private void disconnectSessions() {\n        if (!(service instanceof IoAcceptor)) {\n            return;\n        }\n\n        if (!((IoAcceptor) service).isCloseOnDeactivation()) {\n            return;\n        }\n\n        Object lock = new Object();\n        IoFutureListener<IoFuture> listener = new LockNotifyingListener(lock);\n\n        for (IoSession s : managedSessions.values()) {\n            s.close().addListener(listener);\n        }\n\n        try {\n            synchronized (lock) {\n                while (!managedSessions.isEmpty()) {\n                    lock.wait(500);\n                }\n            }\n        } catch (InterruptedException ie) {\n            // Ignored\n        }\n    }\n\n    private static class LockNotifyingListener implements IoFutureListener<IoFuture> {\n        private final Object lock;\n\n        public LockNotifyingListener(Object lock) {\n            this.lock = lock;\n        }\n\n        public void operationComplete(IoFuture future) {\n            synchronized (lock) {\n                lock.notifyAll();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.service;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.core.filterchain.IoFilterChain;\n\n/**\n * A helper which provides addition and removal of {@link IoServiceListener}s and firing\n * events.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic class IoServiceListenerSupport {\n    /**\n     * The {@link IoService} that this instance manages.\n     */\n    private final IoService service;\n\n    /**\n     * A list of {@link IoServiceListener}s.\n     */\n    private final List<IoServiceListener> listeners = new CopyOnWriteArrayList<IoServiceListener>();\n\n    /**\n     * Tracks managed sessions.\n     */\n    private final ConcurrentMap<Long, IoSession> managedSessions = new ConcurrentHashMap<Long, IoSession>();\n\n    /**\n     * Read only version of {@link #managedSessions}.\n     */\n    private final Map<Long, IoSession> readOnlyManagedSessions = Collections.unmodifiableMap(managedSessions);\n\n    private final AtomicBoolean activated = new AtomicBoolean();\n    private volatile long activationTime;\n    private volatile int largestManagedSessionCount;\n    private volatile long cumulativeManagedSessionCount;\n\n    /**\n     * Creates a new instance.\n     */\n    public IoServiceListenerSupport(IoService service) {\n        if (service == null) {\n            throw new NullPointerException(\"service\");\n        }\n        this.service = service;\n    }\n\n    /**\n     * Adds a new listener.\n     */\n    public void add(IoServiceListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes an existing listener.\n     */\n    public void remove(IoServiceListener listener) {\n        listeners.remove(listener);\n    }\n\n    public long getActivationTime() {\n        return activationTime;\n    }\n\n    public Map<Long, IoSession> getManagedSessions() {\n        return readOnlyManagedSessions;\n    }\n\n    public int getManagedSessionCount() {\n        return managedSessions.size();\n    }\n\n    public int getLargestManagedSessionCount() {\n        return largestManagedSessionCount;\n    }\n\n    public long getCumulativeManagedSessionCount() {\n        return cumulativeManagedSessionCount;\n    }\n\n    public boolean isActive() {\n        return activated.get();\n    }\n\n    /**\n     * Calls {@link IoServiceListener#serviceActivated(IoService)}\n     * for all registered listeners.\n     */\n    public void fireServiceActivated() {\n        if (!activated.compareAndSet(false, true)) {\n            return;\n        }\n\n        activationTime = System.currentTimeMillis();\n\n        for (IoServiceListener l : listeners) {\n            try {\n                l.serviceActivated(service);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#serviceIdle(IoService, IdleStatus)}\n     * for all registered listeners.\n     */\n    public void fireServiceIdle(IdleStatus status) {\n        if (!activated.get()) {\n            return;\n        }\n\n        for (IoServiceListener l : listeners) {\n            try {\n                l.serviceIdle(service, status);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n\n    /**\n     * Calls {@link IoServiceListener#serviceDeactivated(IoService)}\n     * for all registered listeners.\n     */\n    public void fireServiceDeactivated() {\n        if (!activated.compareAndSet(true, false)) {\n            return;\n        }\n\n        try {\n            for (IoServiceListener l : listeners) {\n                try {\n                    l.serviceDeactivated(service);\n                } catch (Throwable e) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e);\n                }\n            }\n        } finally {\n            disconnectSessions();\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#sessionCreated(IoSession)} for all registered listeners.\n     */\n    public void fireSessionCreated(IoSession session) {\n        boolean firstSession = false;\n        if (session.getService() instanceof IoConnector) {\n            synchronized (managedSessions) {\n                firstSession = managedSessions.isEmpty();\n            }\n        }\n\n        // If already registered, ignore.\n        if (managedSessions.putIfAbsent(Long.valueOf(session.getId()), session) != null) {\n            return;\n        }\n\n        // If the first connector session, fire a virtual service activation event.\n        if (firstSession) {\n            fireServiceActivated();\n        }\n\n        // Fire session events.\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireSessionCreated();\n        filterChain.fireSessionOpened();\n\n        int managedSessionCount = managedSessions.size();\n        if (managedSessionCount > largestManagedSessionCount) {\n            largestManagedSessionCount = managedSessionCount;\n        }\n        cumulativeManagedSessionCount ++;\n\n        // Fire listener events.\n        for (IoServiceListener l : listeners) {\n            try {\n                l.sessionCreated(session);\n            } catch (Throwable e) {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n            }\n        }\n    }\n\n    /**\n     * Calls {@link IoServiceListener#sessionDestroyed(IoSession)} for all registered listeners.\n     */\n    public void fireSessionDestroyed(IoSession session) {\n        // Try to remove the remaining empty session set after removal.\n        if (managedSessions.remove(Long.valueOf(session.getId())) == null) {\n            return;\n        }\n\n        // Fire session events.\n        session.getFilterChain().fireSessionClosed();\n\n        // Fire listener events.\n        try {\n            for (IoServiceListener l : listeners) {\n                try {\n                    l.sessionDestroyed(session);\n                } catch (Throwable e) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e);\n                }\n            }\n        } finally {\n            // Fire a virtual service deactivation event for the last session of the connector.\n            if (session.getService() instanceof IoConnector) {\n                boolean lastSession = false;\n                synchronized (managedSessions) {\n                    lastSession = managedSessions.isEmpty();\n                }\n                if (lastSession) {\n                    fireServiceDeactivated();\n                }\n            }\n        }\n    }\n\n    private void disconnectSessions() {\n        if (!(service instanceof IoAcceptor)) {\n            return;\n        }\n\n        if (!((IoAcceptor) service).isCloseOnDeactivation()) {\n            return;\n        }\n\n        Object lock = new Object();\n        IoFutureListener<IoFuture> listener = new LockNotifyingListener(lock);\n\n        for (IoSession s : managedSessions.values()) {\n            s.close().addListener(listener);\n        }\n\n        try {\n            synchronized (lock) {\n                while (!managedSessions.isEmpty()) {\n                    lock.wait(500);\n                }\n            }\n        } catch (InterruptedException ie) {\n            // Ignored\n        }\n    }\n\n    private static class LockNotifyingListener implements IoFutureListener<IoFuture> {\n        private final Object lock;\n\n        public LockNotifyingListener(Object lock) {\n            this.lock = lock;\n        }\n\n        public void operationComplete(IoFuture future) {\n            synchronized (lock) {\n                lock.notifyAll();\n            }\n        }\n    }\n}\n","lineNo":201}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport java.net.SocketAddress;\nimport java.util.Queue;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.NothingWrittenException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into\n * message object and vice versa using {@link ProtocolCodecFactory},\n * {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @org.apache.xbean.XBean\n */\npublic class ProtocolCodecFilter extends IoFilterAdapter {\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n    private static final IoBuffer EMPTY_BUFFER = IoBuffer.wrap(new byte[0]);\n\n    private final AttributeKey ENCODER = new AttributeKey(getClass(), \"encoder\");\n    private final AttributeKey DECODER = new AttributeKey(getClass(), \"decoder\");\n    private final AttributeKey DECODER_OUT = new AttributeKey(getClass(), \"decoderOut\");\n    \n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory factory;\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory\n     * for the creation of the encoder and decoder.\n     *\n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory factory) {\n        if (factory == null) {\n            throw new NullPointerException(\"factory\");\n        }\n        this.factory = factory;\n    }\n\n    \n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder). \n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(final ProtocolEncoder encoder,\n            final ProtocolDecoder decoder) {\n        if (encoder == null) {\n            throw new NullPointerException(\"encoder\");\n        }\n        if (decoder == null) {\n            throw new NullPointerException(\"decoder\");\n        }\n\n        // Create the inner Factory based on the two parameters\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder), which are class names. Instances\n     * for those classes will be created in this constructor.\n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(\n            final Class<? extends ProtocolEncoder> encoderClass,\n            final Class<? extends ProtocolDecoder> decoderClass) {\n        if (encoderClass == null) {\n            throw new NullPointerException(\"encoderClass\");\n        }\n        if (decoderClass == null) {\n            throw new NullPointerException(\"decoderClass\");\n        }\n        if (!ProtocolEncoder.class.isAssignableFrom(encoderClass)) {\n            throw new IllegalArgumentException(\"encoderClass: \"\n                    + encoderClass.getName());\n        }\n        if (!ProtocolDecoder.class.isAssignableFrom(decoderClass)) {\n            throw new IllegalArgumentException(\"decoderClass: \"\n                    + decoderClass.getName());\n        }\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"encoderClass doesn't have a public default constructor.\");\n        }\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"decoderClass doesn't have a public default constructor.\");\n        }\n\n        // Create the inner Factory based on the two parameters. We instanciate\n        // the encoder and decoder locally.\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n                return encoderClass.newInstance();\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n                return decoderClass.newInstance();\n            }\n        };\n    }\n\n    \n    /**\n     * Get the encoder instance from a given session.\n     *\n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder getEncoder(IoSession session) {\n        return (ProtocolEncoder) session.getAttribute(ENCODER);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     *\n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance\n     */\n    public ProtocolDecoder getDecoder(IoSession session) {\n        return (ProtocolDecoder) session.getAttribute(DECODER);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public void onPostRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(parent.getSession());\n        disposeDecoder(parent.getSession());\n        \n        // We also remove the callback  \n        disposeDecoderOut(parent.getSession());\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming\n     * buffer might contains more than one messages, we have to loop until the decoder\n     * throws an exception.\n     * \n     *  while ( buffer not empty )\n     *    try \n     *      decode ( buffer )\n     *    catch\n     *      break;\n     *    \n     */\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws Exception {\n        if (!(message instanceof IoBuffer)) {\n            nextFilter.messageReceived(session, message);\n            return;\n        }\n\n        IoBuffer in = (IoBuffer) message;\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoderOut must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n\n        // Loop until we don't have anymore byte in the buffer,\n        // or until the decoder throws an unrecoverable exception or \n        // can't decoder a message, because there are not enough \n        // data in the buffer\n        while (in.hasRemaining()) {\n            int oldPos = in.position();\n            try {\n                synchronized (decoderOut) {\n                    // Call the decoder with the read bytes\n                    decoder.decode(session, in, decoderOut);\n                }\n                // Finish decoding if no exception was thrown.\n                decoderOut.flush();\n                \n                // TODO :\n                // here, we shouldn't break,\n                // we should loop to decode the next portion of the buffer.\n                break;\n            } catch (Throwable t) {\n                ProtocolDecoderException pde;\n                if (t instanceof ProtocolDecoderException) {\n                    pde = (ProtocolDecoderException) t;\n                } else {\n                    pde = new ProtocolDecoderException(t);\n                }\n                \n                if (pde.getHexdump() == null) {\n                    // Generate a message hex dump\n                    int curPos = in.position();\n                    in.position(oldPos);\n                    pde.setHexdump(in.getHexDump());\n                    in.position(curPos);\n                }\n\n                // Fire the exceptionCaught event.\n                decoderOut.flush();\n                nextFilter.exceptionCaught(session, pde);\n\n                // Retry only if the type of the caught exception is\n                // recoverable and the buffer position has changed.\n                // We check buffer position additionally to prevent an\n                // infinite loop.\n                if (!(t instanceof RecoverableProtocolDecoderException) ||\n                        (in.position() == oldPos)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        if (writeRequest instanceof EncodedWriteRequest) {\n            return;\n        }\n\n        if (!(writeRequest instanceof MessageWriteRequest)) {\n            nextFilter.messageSent(session, writeRequest);\n            return;\n        }\n\n        MessageWriteRequest wrappedRequest = (MessageWriteRequest) writeRequest;\n        nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        Object message = writeRequest.getMessage();\n        \n        // Bypass the encoding if the message is contained in a ByteBuffer,\n        // as it has already been encoded before\n        if (message instanceof IoBuffer || message instanceof FileRegion) {\n            nextFilter.filterWrite(session, writeRequest);\n            return;\n        }\n\n        // Get the encoder in the session\n        ProtocolEncoder encoder = getEncoder(session);\n\n        if ( encoder == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolEncoderOutputImpl encoderOut = getEncoderOut(session,\n                nextFilter, writeRequest);\n\n        if ( encoderOut == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            // Now we can try to encode the response\n            encoder.encode(session, message, encoderOut);\n            \n            // Send it directly\n            encoderOut.flushWithoutFuture();\n            \n            // Call the next filter\n            nextFilter.filterWrite(session, new MessageWriteRequest(\n                    writeRequest));\n        } catch (Throwable t) {\n            ProtocolEncoderException pee;\n            \n            // Generate the correct exception\n            if (t instanceof ProtocolEncoderException) {\n                pee = (ProtocolEncoderException) t;\n            } else {\n                pee = new ProtocolEncoderException(t);\n            }\n            \n            throw pee;\n        }\n    }\n    \n    /**\n     * Associate a decoder and encoder instances to the newly created session.\n     * <br>\n     * <br>\n     * In order to get the encoder and decoder crea\n     * \n     * @param nextFilter The next filter to invoke when having processed the current \n     * method\n     * @param session The newly created session\n     * @throws Exception if we can't create instances of the decoder or encoder\n     */\n    @Override\n    public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {\n        // Creates the decoder and stores it into the newly created session \n        ProtocolDecoder decoder = factory.getDecoder(session);\n        session.setAttribute(DECODER, decoder);\n\n        // Creates the encoder and stores it into the newly created session \n        ProtocolEncoder encoder = factory.getEncoder(session);\n        session.setAttribute(ENCODER, encoder);\n\n        // Call the next filter\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        // Call finishDecode() first when a connection is closed.\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            decoder.finishDecode(session, decoderOut);\n        } catch (Throwable t) {\n            ProtocolDecoderException pde;\n            if (t instanceof ProtocolDecoderException) {\n                pde = (ProtocolDecoderException) t;\n            } else {\n                pde = new ProtocolDecoderException(t);\n            }\n            throw pde;\n        } finally {\n            // Dispose all.\n            disposeEncoder(session);\n            disposeDecoder(session);\n            disposeDecoderOut(session);\n            decoderOut.flush();\n        }\n\n        nextFilter.sessionClosed(session);\n    }\n\n    private ProtocolEncoderOutputImpl getEncoderOut(IoSession session,\n            NextFilter nextFilter, WriteRequest writeRequest) {\n        return new ProtocolEncoderOutputImpl(session, nextFilter, writeRequest);\n    }\n\n    private ProtocolDecoderOutput getDecoderOut(IoSession session,\n            NextFilter nextFilter) {\n        ProtocolDecoderOutput out = (ProtocolDecoderOutput) session.getAttribute(DECODER_OUT);\n        if (out == null) {\n            out = new ProtocolDecoderOutputImpl(session, nextFilter);\n            session.setAttribute(DECODER_OUT, out);\n        }\n        return out;\n    }\n\n    private void disposeEncoder(IoSession session) {\n        ProtocolEncoder encoder = (ProtocolEncoder) session\n                .removeAttribute(ENCODER);\n        if (encoder == null) {\n            return;\n        }\n\n        try {\n            encoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Failed to dispose: \" + encoder.getClass().getName() + \" (\" + encoder + ')');\n        }\n    }\n\n    private void disposeDecoder(IoSession session) {\n        ProtocolDecoder decoder = (ProtocolDecoder) session\n                .removeAttribute(DECODER);\n        if (decoder == null) {\n            return;\n        }\n\n        try {\n            decoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Falied to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n\n    private void disposeDecoderOut(IoSession session) {\n        session.removeAttribute(DECODER_OUT);\n    }\n\n    private static class EncodedWriteRequest extends DefaultWriteRequest {\n        private EncodedWriteRequest(Object encodedMessage,\n                WriteFuture future, SocketAddress destination) {\n            super(encodedMessage, future, destination);\n        }\n    }\n\n    private static class MessageWriteRequest extends WriteRequestWrapper {\n        private MessageWriteRequest(WriteRequest writeRequest) {\n            super(writeRequest);\n        }\n\n        @Override\n        public Object getMessage() {\n            return EMPTY_BUFFER;\n        }\n    }\n\n    private static class ProtocolDecoderOutputImpl extends\n            AbstractProtocolDecoderOutput {\n        private final IoSession session;\n        private final NextFilter nextFilter;\n\n        public ProtocolDecoderOutputImpl(\n                IoSession session, NextFilter nextFilter) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n        }\n\n        public void flush() {\n            Queue<Object> messageQueue = getMessageQueue();\n            while (!messageQueue.isEmpty()) {\n                nextFilter.messageReceived(session, messageQueue.poll());\n            }\n        }\n    }\n\n    private static class ProtocolEncoderOutputImpl extends\n            AbstractProtocolEncoderOutput {\n        private final IoSession session;\n\n        private final NextFilter nextFilter;\n\n        private final WriteRequest writeRequest;\n\n        public ProtocolEncoderOutputImpl(IoSession session,\n                NextFilter nextFilter, WriteRequest writeRequest) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n            this.writeRequest = writeRequest;\n        }\n\n        public WriteFuture flush() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            WriteFuture future = null;\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    future = new DefaultWriteFuture(session);\n                    nextFilter.filterWrite(session, new EncodedWriteRequest(encodedMessage,\n                            future, writeRequest.getDestination()));\n                }\n            }\n\n            if (future == null) {\n                future = DefaultWriteFuture.newNotWrittenFuture(\n                        session, new NothingWrittenException(writeRequest));\n            }\n\n            return future;\n        }\n        \n        public void flushWithoutFuture() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    nextFilter.filterWrite(\n                            session, new EncodedWriteRequest(\n                                    encodedMessage, null, writeRequest.getDestination()));\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport java.net.SocketAddress;\nimport java.util.Queue;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.NothingWrittenException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into\n * message object and vice versa using {@link ProtocolCodecFactory},\n * {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @org.apache.xbean.XBean\n */\npublic class ProtocolCodecFilter extends IoFilterAdapter {\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n    private static final IoBuffer EMPTY_BUFFER = IoBuffer.wrap(new byte[0]);\n\n    private final AttributeKey ENCODER = new AttributeKey(getClass(), \"encoder\");\n    private final AttributeKey DECODER = new AttributeKey(getClass(), \"decoder\");\n    private final AttributeKey DECODER_OUT = new AttributeKey(getClass(), \"decoderOut\");\n    \n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory factory;\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory\n     * for the creation of the encoder and decoder.\n     *\n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory factory) {\n        if (factory == null) {\n            throw new NullPointerException(\"factory\");\n        }\n        this.factory = factory;\n    }\n\n    \n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder). \n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(final ProtocolEncoder encoder,\n            final ProtocolDecoder decoder) {\n        if (encoder == null) {\n            throw new NullPointerException(\"encoder\");\n        }\n        if (decoder == null) {\n            throw new NullPointerException(\"decoder\");\n        }\n\n        // Create the inner Factory based on the two parameters\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder), which are class names. Instances\n     * for those classes will be created in this constructor.\n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(\n            final Class<? extends ProtocolEncoder> encoderClass,\n            final Class<? extends ProtocolDecoder> decoderClass) {\n        if (encoderClass == null) {\n            throw new NullPointerException(\"encoderClass\");\n        }\n        if (decoderClass == null) {\n            throw new NullPointerException(\"decoderClass\");\n        }\n        if (!ProtocolEncoder.class.isAssignableFrom(encoderClass)) {\n            throw new IllegalArgumentException(\"encoderClass: \"\n                    + encoderClass.getName());\n        }\n        if (!ProtocolDecoder.class.isAssignableFrom(decoderClass)) {\n            throw new IllegalArgumentException(\"decoderClass: \"\n                    + decoderClass.getName());\n        }\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"encoderClass doesn't have a public default constructor.\");\n        }\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"decoderClass doesn't have a public default constructor.\");\n        }\n\n        // Create the inner Factory based on the two parameters. We instanciate\n        // the encoder and decoder locally.\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n                return encoderClass.newInstance();\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n                return decoderClass.newInstance();\n            }\n        };\n    }\n\n    \n    /**\n     * Get the encoder instance from a given session.\n     *\n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder getEncoder(IoSession session) {\n        return (ProtocolEncoder) session.getAttribute(ENCODER);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     *\n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance\n     */\n    public ProtocolDecoder getDecoder(IoSession session) {\n        return (ProtocolDecoder) session.getAttribute(DECODER);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public void onPostRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(parent.getSession());\n        disposeDecoder(parent.getSession());\n        \n        // We also remove the callback  \n        disposeDecoderOut(parent.getSession());\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming\n     * buffer might contains more than one messages, we have to loop until the decoder\n     * throws an exception.\n     * \n     *  while ( buffer not empty )\n     *    try \n     *      decode ( buffer )\n     *    catch\n     *      break;\n     *    \n     */\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws Exception {\n        if (!(message instanceof IoBuffer)) {\n            nextFilter.messageReceived(session, message);\n            return;\n        }\n\n        IoBuffer in = (IoBuffer) message;\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoderOut must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n\n        // Loop until we don't have anymore byte in the buffer,\n        // or until the decoder throws an unrecoverable exception or \n        // can't decoder a message, because there are not enough \n        // data in the buffer\n        while (in.hasRemaining()) {\n            int oldPos = in.position();\n            try {\n                synchronized (decoderOut) {\n                    // Call the decoder with the read bytes\n                    decoder.decode(session, in, decoderOut);\n                }\n                // Finish decoding if no exception was thrown.\n                decoderOut.flush();\n                \n                // TODO :\n                // here, we shouldn't break,\n                // we should loop to decode the next portion of the buffer.\n                break;\n            } catch (Throwable t) {\n                ProtocolDecoderException pde;\n                if (t instanceof ProtocolDecoderException) {\n                    pde = (ProtocolDecoderException) t;\n                } else {\n                    pde = new ProtocolDecoderException(t);\n                }\n                \n                if (pde.getHexdump() == null) {\n                    // Generate a message hex dump\n                    int curPos = in.position();\n                    in.position(oldPos);\n                    pde.setHexdump(in.getHexDump());\n                    in.position(curPos);\n                }\n\n                // Fire the exceptionCaught event.\n                decoderOut.flush();\n                nextFilter.exceptionCaught(session, pde);\n\n                // Retry only if the type of the caught exception is\n                // recoverable and the buffer position has changed.\n                // We check buffer position additionally to prevent an\n                // infinite loop.\n                if (!(t instanceof RecoverableProtocolDecoderException) ||\n                        (in.position() == oldPos)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        if (writeRequest instanceof EncodedWriteRequest) {\n            return;\n        }\n\n        if (!(writeRequest instanceof MessageWriteRequest)) {\n            nextFilter.messageSent(session, writeRequest);\n            return;\n        }\n\n        MessageWriteRequest wrappedRequest = (MessageWriteRequest) writeRequest;\n        nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        Object message = writeRequest.getMessage();\n        \n        // Bypass the encoding if the message is contained in a ByteBuffer,\n        // as it has already been encoded before\n        if (message instanceof IoBuffer || message instanceof FileRegion) {\n            nextFilter.filterWrite(session, writeRequest);\n            return;\n        }\n\n        // Get the encoder in the session\n        ProtocolEncoder encoder = getEncoder(session);\n\n        if ( encoder == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolEncoderOutputImpl encoderOut = getEncoderOut(session,\n                nextFilter, writeRequest);\n\n        if ( encoderOut == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            // Now we can try to encode the response\n            encoder.encode(session, message, encoderOut);\n            \n            // Send it directly\n            encoderOut.flushWithoutFuture();\n            \n            // Call the next filter\n            nextFilter.filterWrite(session, new MessageWriteRequest(\n                    writeRequest));\n        } catch (Throwable t) {\n            ProtocolEncoderException pee;\n            \n            // Generate the correct exception\n            if (t instanceof ProtocolEncoderException) {\n                pee = (ProtocolEncoderException) t;\n            } else {\n                pee = new ProtocolEncoderException(t);\n            }\n            \n            throw pee;\n        }\n    }\n    \n    /**\n     * Associate a decoder and encoder instances to the newly created session.\n     * <br>\n     * <br>\n     * In order to get the encoder and decoder crea\n     * \n     * @param nextFilter The next filter to invoke when having processed the current \n     * method\n     * @param session The newly created session\n     * @throws Exception if we can't create instances of the decoder or encoder\n     */\n    @Override\n    public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {\n        // Creates the decoder and stores it into the newly created session \n        ProtocolDecoder decoder = factory.getDecoder(session);\n        session.setAttribute(DECODER, decoder);\n\n        // Creates the encoder and stores it into the newly created session \n        ProtocolEncoder encoder = factory.getEncoder(session);\n        session.setAttribute(ENCODER, encoder);\n\n        // Call the next filter\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        // Call finishDecode() first when a connection is closed.\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            decoder.finishDecode(session, decoderOut);\n        } catch (Throwable t) {\n            ProtocolDecoderException pde;\n            if (t instanceof ProtocolDecoderException) {\n                pde = (ProtocolDecoderException) t;\n            } else {\n                pde = new ProtocolDecoderException(t);\n            }\n            throw pde;\n        } finally {\n            // Dispose all.\n            disposeEncoder(session);\n            disposeDecoder(session);\n            disposeDecoderOut(session);\n            decoderOut.flush();\n        }\n\n        nextFilter.sessionClosed(session);\n    }\n\n    private ProtocolEncoderOutputImpl getEncoderOut(IoSession session,\n            NextFilter nextFilter, WriteRequest writeRequest) {\n        return new ProtocolEncoderOutputImpl(session, nextFilter, writeRequest);\n    }\n\n    private ProtocolDecoderOutput getDecoderOut(IoSession session,\n            NextFilter nextFilter) {\n        ProtocolDecoderOutput out = (ProtocolDecoderOutput) session.getAttribute(DECODER_OUT);\n        if (out == null) {\n            out = new ProtocolDecoderOutputImpl(session, nextFilter);\n            session.setAttribute(DECODER_OUT, out);\n        }\n        return out;\n    }\n\n    private void disposeEncoder(IoSession session) {\n        ProtocolEncoder encoder = (ProtocolEncoder) session\n                .removeAttribute(ENCODER);\n        if (encoder == null) {\n            return;\n        }\n\n        try {\n            encoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Failed to dispose: \" + encoder.getClass().getName() + \" (\" + encoder + ')');\n        }\n    }\n\n    private void disposeDecoder(IoSession session) {\n        ProtocolDecoder decoder = (ProtocolDecoder) session\n                .removeAttribute(DECODER);\n        if (decoder == null) {\n            return;\n        }\n\n        try {\n            decoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Falied to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n\n    private void disposeDecoderOut(IoSession session) {\n        session.removeAttribute(DECODER_OUT);\n    }\n\n    private static class EncodedWriteRequest extends DefaultWriteRequest {\n        private EncodedWriteRequest(Object encodedMessage,\n                WriteFuture future, SocketAddress destination) {\n            super(encodedMessage, future, destination);\n        }\n    }\n\n    private static class MessageWriteRequest extends WriteRequestWrapper {\n        private MessageWriteRequest(WriteRequest writeRequest) {\n            super(writeRequest);\n        }\n\n        @Override\n        public Object getMessage() {\n            return EMPTY_BUFFER;\n        }\n    }\n\n    private static class ProtocolDecoderOutputImpl extends\n            AbstractProtocolDecoderOutput {\n        private final IoSession session;\n        private final NextFilter nextFilter;\n\n        public ProtocolDecoderOutputImpl(\n                IoSession session, NextFilter nextFilter) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n        }\n\n        public void flush() {\n            Queue<Object> messageQueue = getMessageQueue();\n            while (!messageQueue.isEmpty()) {\n                nextFilter.messageReceived(session, messageQueue.poll());\n            }\n        }\n    }\n\n    private static class ProtocolEncoderOutputImpl extends\n            AbstractProtocolEncoderOutput {\n        private final IoSession session;\n\n        private final NextFilter nextFilter;\n\n        private final WriteRequest writeRequest;\n\n        public ProtocolEncoderOutputImpl(IoSession session,\n                NextFilter nextFilter, WriteRequest writeRequest) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n            this.writeRequest = writeRequest;\n        }\n\n        public WriteFuture flush() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            WriteFuture future = null;\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    future = new DefaultWriteFuture(session);\n                    nextFilter.filterWrite(session, new EncodedWriteRequest(encodedMessage,\n                            future, writeRequest.getDestination()));\n                }\n            }\n\n            if (future == null) {\n                future = DefaultWriteFuture.newNotWrittenFuture(\n                        session, new NothingWrittenException(writeRequest));\n            }\n\n            return future;\n        }\n        \n        public void flushWithoutFuture() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    SocketAddress destination = writeRequest.getDestination();\n                    WriteRequest writeRequest = new EncodedWriteRequest(\n                        encodedMessage, null, destination); \n                    nextFilter.filterWrite(session, writeRequest);\n                }\n            }\n        }\n    }\n}\n","lineNo":600}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport java.net.SocketAddress;\nimport java.util.Queue;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.NothingWrittenException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into\n * message object and vice versa using {@link ProtocolCodecFactory},\n * {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @org.apache.xbean.XBean\n */\npublic class ProtocolCodecFilter extends IoFilterAdapter {\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n    private static final IoBuffer EMPTY_BUFFER = IoBuffer.wrap(new byte[0]);\n\n    private final AttributeKey ENCODER = new AttributeKey(getClass(), \"encoder\");\n    private final AttributeKey DECODER = new AttributeKey(getClass(), \"decoder\");\n    private final AttributeKey DECODER_OUT = new AttributeKey(getClass(), \"decoderOut\");\n    \n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory factory;\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory\n     * for the creation of the encoder and decoder.\n     *\n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory factory) {\n        if (factory == null) {\n            throw new NullPointerException(\"factory\");\n        }\n        this.factory = factory;\n    }\n\n    \n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder). \n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(final ProtocolEncoder encoder,\n            final ProtocolDecoder decoder) {\n        if (encoder == null) {\n            throw new NullPointerException(\"encoder\");\n        }\n        if (decoder == null) {\n            throw new NullPointerException(\"decoder\");\n        }\n\n        // Create the inner Factory based on the two parameters\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder), which are class names. Instances\n     * for those classes will be created in this constructor.\n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(\n            final Class<? extends ProtocolEncoder> encoderClass,\n            final Class<? extends ProtocolDecoder> decoderClass) {\n        if (encoderClass == null) {\n            throw new NullPointerException(\"encoderClass\");\n        }\n        if (decoderClass == null) {\n            throw new NullPointerException(\"decoderClass\");\n        }\n        if (!ProtocolEncoder.class.isAssignableFrom(encoderClass)) {\n            throw new IllegalArgumentException(\"encoderClass: \"\n                    + encoderClass.getName());\n        }\n        if (!ProtocolDecoder.class.isAssignableFrom(decoderClass)) {\n            throw new IllegalArgumentException(\"decoderClass: \"\n                    + decoderClass.getName());\n        }\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"encoderClass doesn't have a public default constructor.\");\n        }\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"decoderClass doesn't have a public default constructor.\");\n        }\n\n        // Create the inner Factory based on the two parameters. We instanciate\n        // the encoder and decoder locally.\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n                return encoderClass.newInstance();\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n                return decoderClass.newInstance();\n            }\n        };\n    }\n\n    \n    /**\n     * Get the encoder instance from a given session.\n     *\n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder getEncoder(IoSession session) {\n        return (ProtocolEncoder) session.getAttribute(ENCODER);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     *\n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance\n     */\n    public ProtocolDecoder getDecoder(IoSession session) {\n        return (ProtocolDecoder) session.getAttribute(DECODER);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public void onPostRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(parent.getSession());\n        disposeDecoder(parent.getSession());\n        \n        // We also remove the callback  \n        disposeDecoderOut(parent.getSession());\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming\n     * buffer might contains more than one messages, we have to loop until the decoder\n     * throws an exception.\n     * \n     *  while ( buffer not empty )\n     *    try \n     *      decode ( buffer )\n     *    catch\n     *      break;\n     *    \n     */\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws Exception {\n        if (!(message instanceof IoBuffer)) {\n            nextFilter.messageReceived(session, message);\n            return;\n        }\n\n        IoBuffer in = (IoBuffer) message;\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoderOut must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n\n        // Loop until we don't have anymore byte in the buffer,\n        // or until the decoder throws an unrecoverable exception or \n        // can't decoder a message, because there are not enough \n        // data in the buffer\n        while (in.hasRemaining()) {\n            int oldPos = in.position();\n            try {\n                synchronized (decoderOut) {\n                    // Call the decoder with the read bytes\n                    decoder.decode(session, in, decoderOut);\n                }\n                // Finish decoding if no exception was thrown.\n                decoderOut.flush();\n                \n                // TODO :\n                // here, we shouldn't break,\n                // we should loop to decode the next portion of the buffer.\n                break;\n            } catch (Throwable t) {\n                ProtocolDecoderException pde;\n                if (t instanceof ProtocolDecoderException) {\n                    pde = (ProtocolDecoderException) t;\n                } else {\n                    pde = new ProtocolDecoderException(t);\n                }\n                \n                if (pde.getHexdump() == null) {\n                    // Generate a message hex dump\n                    int curPos = in.position();\n                    in.position(oldPos);\n                    pde.setHexdump(in.getHexDump());\n                    in.position(curPos);\n                }\n\n                // Fire the exceptionCaught event.\n                decoderOut.flush();\n                nextFilter.exceptionCaught(session, pde);\n\n                // Retry only if the type of the caught exception is\n                // recoverable and the buffer position has changed.\n                // We check buffer position additionally to prevent an\n                // infinite loop.\n                if (!(t instanceof RecoverableProtocolDecoderException) ||\n                        (in.position() == oldPos)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        if (writeRequest instanceof EncodedWriteRequest) {\n            return;\n        }\n\n        if (!(writeRequest instanceof MessageWriteRequest)) {\n            nextFilter.messageSent(session, writeRequest);\n            return;\n        }\n\n        MessageWriteRequest wrappedRequest = (MessageWriteRequest) writeRequest;\n        nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        Object message = writeRequest.getMessage();\n        \n        // Bypass the encoding if the message is contained in a ByteBuffer,\n        // as it has already been encoded before\n        if (message instanceof IoBuffer || message instanceof FileRegion) {\n            nextFilter.filterWrite(session, writeRequest);\n            return;\n        }\n\n        // Get the encoder in the session\n        ProtocolEncoder encoder = getEncoder(session);\n\n        if ( encoder == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolEncoderOutputImpl encoderOut = getEncoderOut(session,\n                nextFilter, writeRequest);\n\n        if ( encoderOut == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            // Now we can try to encode the response\n            encoder.encode(session, message, encoderOut);\n            \n            // Send it directly\n            encoderOut.flushWithoutFuture();\n            \n            // Call the next filter\n            nextFilter.filterWrite(session, new MessageWriteRequest(\n                    writeRequest));\n        } catch (Throwable t) {\n            ProtocolEncoderException pee;\n            \n            // Generate the correct exception\n            if (t instanceof ProtocolEncoderException) {\n                pee = (ProtocolEncoderException) t;\n            } else {\n                pee = new ProtocolEncoderException(t);\n            }\n            \n            throw pee;\n        }\n    }\n    \n    /**\n     * Associate a decoder and encoder instances to the newly created session.\n     * <br>\n     * <br>\n     * In order to get the encoder and decoder crea\n     * \n     * @param nextFilter The next filter to invoke when having processed the current \n     * method\n     * @param session The newly created session\n     * @throws Exception if we can't create instances of the decoder or encoder\n     */\n    @Override\n    public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {\n        // Creates the decoder and stores it into the newly created session \n        ProtocolDecoder decoder = factory.getDecoder(session);\n        session.setAttribute(DECODER, decoder);\n\n        // Creates the encoder and stores it into the newly created session \n        ProtocolEncoder encoder = factory.getEncoder(session);\n        session.setAttribute(ENCODER, encoder);\n\n        // Call the next filter\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        // Call finishDecode() first when a connection is closed.\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            decoder.finishDecode(session, decoderOut);\n        } catch (Throwable t) {\n            ProtocolDecoderException pde;\n            if (t instanceof ProtocolDecoderException) {\n                pde = (ProtocolDecoderException) t;\n            } else {\n                pde = new ProtocolDecoderException(t);\n            }\n            throw pde;\n        } finally {\n            // Dispose all.\n            disposeEncoder(session);\n            disposeDecoder(session);\n            disposeDecoderOut(session);\n            decoderOut.flush();\n        }\n\n        nextFilter.sessionClosed(session);\n    }\n\n    private ProtocolEncoderOutputImpl getEncoderOut(IoSession session,\n            NextFilter nextFilter, WriteRequest writeRequest) {\n        return new ProtocolEncoderOutputImpl(session, nextFilter, writeRequest);\n    }\n\n    private ProtocolDecoderOutput getDecoderOut(IoSession session,\n            NextFilter nextFilter) {\n        ProtocolDecoderOutput out = (ProtocolDecoderOutput) session.getAttribute(DECODER_OUT);\n        if (out == null) {\n            out = new ProtocolDecoderOutputImpl(session, nextFilter);\n            session.setAttribute(DECODER_OUT, out);\n        }\n        return out;\n    }\n\n    private void disposeEncoder(IoSession session) {\n        ProtocolEncoder encoder = (ProtocolEncoder) session\n                .removeAttribute(ENCODER);\n        if (encoder == null) {\n            return;\n        }\n\n        try {\n            encoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Failed to dispose: \" + encoder.getClass().getName() + \" (\" + encoder + ')');\n        }\n    }\n\n    private void disposeDecoder(IoSession session) {\n        ProtocolDecoder decoder = (ProtocolDecoder) session\n                .removeAttribute(DECODER);\n        if (decoder == null) {\n            return;\n        }\n\n        try {\n            decoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Falied to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n\n    private void disposeDecoderOut(IoSession session) {\n        session.removeAttribute(DECODER_OUT);\n    }\n\n    private static class EncodedWriteRequest extends DefaultWriteRequest {\n        private EncodedWriteRequest(Object encodedMessage,\n                WriteFuture future, SocketAddress destination) {\n            super(encodedMessage, future, destination);\n        }\n    }\n\n    private static class MessageWriteRequest extends WriteRequestWrapper {\n        private MessageWriteRequest(WriteRequest writeRequest) {\n            super(writeRequest);\n        }\n\n        @Override\n        public Object getMessage() {\n            return EMPTY_BUFFER;\n        }\n    }\n\n    private static class ProtocolDecoderOutputImpl extends\n            AbstractProtocolDecoderOutput {\n        private final IoSession session;\n        private final NextFilter nextFilter;\n\n        public ProtocolDecoderOutputImpl(\n                IoSession session, NextFilter nextFilter) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n        }\n\n        public void flush() {\n            Queue<Object> messageQueue = getMessageQueue();\n            while (!messageQueue.isEmpty()) {\n                nextFilter.messageReceived(session, messageQueue.poll());\n            }\n        }\n    }\n\n    private static class ProtocolEncoderOutputImpl extends\n            AbstractProtocolEncoderOutput {\n        private final IoSession session;\n\n        private final NextFilter nextFilter;\n\n        private final WriteRequest writeRequest;\n\n        public ProtocolEncoderOutputImpl(IoSession session,\n                NextFilter nextFilter, WriteRequest writeRequest) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n            this.writeRequest = writeRequest;\n        }\n\n        public WriteFuture flush() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            WriteFuture future = null;\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    future = new DefaultWriteFuture(session);\n                    nextFilter.filterWrite(session, new EncodedWriteRequest(encodedMessage,\n                            future, writeRequest.getDestination()));\n                }\n            }\n\n            if (future == null) {\n                future = DefaultWriteFuture.newNotWrittenFuture(\n                        session, new NothingWrittenException(writeRequest));\n            }\n\n            return future;\n        }\n        \n        public void flushWithoutFuture() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    nextFilter.filterWrite(\n                            session, new EncodedWriteRequest(\n                                    encodedMessage, null, writeRequest.getDestination()));\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.codec;\n\nimport java.net.SocketAddress;\nimport java.util.Queue;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.session.AttributeKey;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.NothingWrittenException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} which translates binary or protocol specific data into\n * message object and vice versa using {@link ProtocolCodecFactory},\n * {@link ProtocolEncoder}, or {@link ProtocolDecoder}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @org.apache.xbean.XBean\n */\npublic class ProtocolCodecFilter extends IoFilterAdapter {\n\n    private static final Class<?>[] EMPTY_PARAMS = new Class[0];\n    private static final IoBuffer EMPTY_BUFFER = IoBuffer.wrap(new byte[0]);\n\n    private final AttributeKey ENCODER = new AttributeKey(getClass(), \"encoder\");\n    private final AttributeKey DECODER = new AttributeKey(getClass(), \"decoder\");\n    private final AttributeKey DECODER_OUT = new AttributeKey(getClass(), \"decoderOut\");\n    \n    /** The factory responsible for creating the encoder and decoder */\n    private final ProtocolCodecFactory factory;\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * \n     * Creates a new instance of ProtocolCodecFilter, associating a factory\n     * for the creation of the encoder and decoder.\n     *\n     * @param factory The associated factory\n     */\n    public ProtocolCodecFilter(ProtocolCodecFactory factory) {\n        if (factory == null) {\n            throw new NullPointerException(\"factory\");\n        }\n        this.factory = factory;\n    }\n\n    \n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder). \n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(final ProtocolEncoder encoder,\n            final ProtocolDecoder decoder) {\n        if (encoder == null) {\n            throw new NullPointerException(\"encoder\");\n        }\n        if (decoder == null) {\n            throw new NullPointerException(\"decoder\");\n        }\n\n        // Create the inner Factory based on the two parameters\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) {\n                return encoder;\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) {\n                return decoder;\n            }\n        };\n    }\n\n    /**\n     * Creates a new instance of ProtocolCodecFilter, without any factory.\n     * The encoder/decoder factory will be created as an inner class, using\n     * the two parameters (encoder and decoder), which are class names. Instances\n     * for those classes will be created in this constructor.\n     * \n     * @param encoder The class responsible for encoding the message\n     * @param decoder The class responsible for decoding the message\n     */\n    public ProtocolCodecFilter(\n            final Class<? extends ProtocolEncoder> encoderClass,\n            final Class<? extends ProtocolDecoder> decoderClass) {\n        if (encoderClass == null) {\n            throw new NullPointerException(\"encoderClass\");\n        }\n        if (decoderClass == null) {\n            throw new NullPointerException(\"decoderClass\");\n        }\n        if (!ProtocolEncoder.class.isAssignableFrom(encoderClass)) {\n            throw new IllegalArgumentException(\"encoderClass: \"\n                    + encoderClass.getName());\n        }\n        if (!ProtocolDecoder.class.isAssignableFrom(decoderClass)) {\n            throw new IllegalArgumentException(\"decoderClass: \"\n                    + decoderClass.getName());\n        }\n        try {\n            encoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"encoderClass doesn't have a public default constructor.\");\n        }\n        try {\n            decoderClass.getConstructor(EMPTY_PARAMS);\n        } catch (NoSuchMethodException e) {\n            throw new IllegalArgumentException(\n                    \"decoderClass doesn't have a public default constructor.\");\n        }\n\n        // Create the inner Factory based on the two parameters. We instanciate\n        // the encoder and decoder locally.\n        this.factory = new ProtocolCodecFactory() {\n            public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n                return encoderClass.newInstance();\n            }\n\n            public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n                return decoderClass.newInstance();\n            }\n        };\n    }\n\n    \n    /**\n     * Get the encoder instance from a given session.\n     *\n     * @param session The associated session we will get the encoder from\n     * @return The encoder instance, if any\n     */\n    public ProtocolEncoder getEncoder(IoSession session) {\n        return (ProtocolEncoder) session.getAttribute(ENCODER);\n    }\n\n    /**\n     * Get the decoder instance from a given session.\n     *\n     * @param session The associated session we will get the decoder from\n     * @return The decoder instance\n     */\n    public ProtocolDecoder getDecoder(IoSession session) {\n        return (ProtocolDecoder) session.getAttribute(DECODER);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public void onPostRemove(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        // We just remove the two instances of encoder/decoder to release resources\n        // from the session\n        disposeEncoder(parent.getSession());\n        disposeDecoder(parent.getSession());\n        \n        // We also remove the callback  \n        disposeDecoderOut(parent.getSession());\n    }\n\n    /**\n     * Process the incoming message, calling the session decoder. As the incoming\n     * buffer might contains more than one messages, we have to loop until the decoder\n     * throws an exception.\n     * \n     *  while ( buffer not empty )\n     *    try \n     *      decode ( buffer )\n     *    catch\n     *      break;\n     *    \n     */\n    @Override\n    public void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) throws Exception {\n        if (!(message instanceof IoBuffer)) {\n            nextFilter.messageReceived(session, message);\n            return;\n        }\n\n        IoBuffer in = (IoBuffer) message;\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoderOut must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n\n        // Loop until we don't have anymore byte in the buffer,\n        // or until the decoder throws an unrecoverable exception or \n        // can't decoder a message, because there are not enough \n        // data in the buffer\n        while (in.hasRemaining()) {\n            int oldPos = in.position();\n            try {\n                synchronized (decoderOut) {\n                    // Call the decoder with the read bytes\n                    decoder.decode(session, in, decoderOut);\n                }\n                // Finish decoding if no exception was thrown.\n                decoderOut.flush();\n                \n                // TODO :\n                // here, we shouldn't break,\n                // we should loop to decode the next portion of the buffer.\n                break;\n            } catch (Throwable t) {\n                ProtocolDecoderException pde;\n                if (t instanceof ProtocolDecoderException) {\n                    pde = (ProtocolDecoderException) t;\n                } else {\n                    pde = new ProtocolDecoderException(t);\n                }\n                \n                if (pde.getHexdump() == null) {\n                    // Generate a message hex dump\n                    int curPos = in.position();\n                    in.position(oldPos);\n                    pde.setHexdump(in.getHexDump());\n                    in.position(curPos);\n                }\n\n                // Fire the exceptionCaught event.\n                decoderOut.flush();\n                nextFilter.exceptionCaught(session, pde);\n\n                // Retry only if the type of the caught exception is\n                // recoverable and the buffer position has changed.\n                // We check buffer position additionally to prevent an\n                // infinite loop.\n                if (!(t instanceof RecoverableProtocolDecoderException) ||\n                        (in.position() == oldPos)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        if (writeRequest instanceof EncodedWriteRequest) {\n            return;\n        }\n\n        if (!(writeRequest instanceof MessageWriteRequest)) {\n            nextFilter.messageSent(session, writeRequest);\n            return;\n        }\n\n        MessageWriteRequest wrappedRequest = (MessageWriteRequest) writeRequest;\n        nextFilter.messageSent(session, wrappedRequest.getParentRequest());\n    }\n\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n        Object message = writeRequest.getMessage();\n        \n        // Bypass the encoding if the message is contained in a ByteBuffer,\n        // as it has already been encoded before\n        if (message instanceof IoBuffer || message instanceof FileRegion) {\n            nextFilter.filterWrite(session, writeRequest);\n            return;\n        }\n\n        // Get the encoder in the session\n        ProtocolEncoder encoder = getEncoder(session);\n\n        if ( encoder == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolEncoderOutputImpl encoderOut = getEncoderOut(session,\n                nextFilter, writeRequest);\n\n        if ( encoderOut == null) {\n            // The encoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot encode if the encoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            // Now we can try to encode the response\n            encoder.encode(session, message, encoderOut);\n            \n            // Send it directly\n            encoderOut.flushWithoutFuture();\n            \n            // Call the next filter\n            nextFilter.filterWrite(session, new MessageWriteRequest(\n                    writeRequest));\n        } catch (Throwable t) {\n            ProtocolEncoderException pee;\n            \n            // Generate the correct exception\n            if (t instanceof ProtocolEncoderException) {\n                pee = (ProtocolEncoderException) t;\n            } else {\n                pee = new ProtocolEncoderException(t);\n            }\n            \n            throw pee;\n        }\n    }\n    \n    /**\n     * Associate a decoder and encoder instances to the newly created session.\n     * <br>\n     * <br>\n     * In order to get the encoder and decoder crea\n     * \n     * @param nextFilter The next filter to invoke when having processed the current \n     * method\n     * @param session The newly created session\n     * @throws Exception if we can't create instances of the decoder or encoder\n     */\n    @Override\n    public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {\n        // Creates the decoder and stores it into the newly created session \n        ProtocolDecoder decoder = factory.getDecoder(session);\n        session.setAttribute(DECODER, decoder);\n\n        // Creates the encoder and stores it into the newly created session \n        ProtocolEncoder encoder = factory.getEncoder(session);\n        session.setAttribute(ENCODER, encoder);\n\n        // Call the next filter\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        // Call finishDecode() first when a connection is closed.\n        ProtocolDecoder decoder = getDecoder(session);\n        \n        if ( decoder == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);\n        \n        if ( decoderOut == null) {\n            // The decoder must not be null. It's null if\n            // the sessionCreated message has not be called, for\n            // instance if the filter has been added after the \n            // first session is created.\n            ProtocolDecoderException pde = new ProtocolDecoderException(\n                \"Cannot decode if the decoder is null. Add the filter in the chain\" +\n                \"before the first session is created\" ); \n            nextFilter.exceptionCaught(session, pde);\n            return;\n        }\n        \n        try {\n            decoder.finishDecode(session, decoderOut);\n        } catch (Throwable t) {\n            ProtocolDecoderException pde;\n            if (t instanceof ProtocolDecoderException) {\n                pde = (ProtocolDecoderException) t;\n            } else {\n                pde = new ProtocolDecoderException(t);\n            }\n            throw pde;\n        } finally {\n            // Dispose all.\n            disposeEncoder(session);\n            disposeDecoder(session);\n            disposeDecoderOut(session);\n            decoderOut.flush();\n        }\n\n        nextFilter.sessionClosed(session);\n    }\n\n    private ProtocolEncoderOutputImpl getEncoderOut(IoSession session,\n            NextFilter nextFilter, WriteRequest writeRequest) {\n        return new ProtocolEncoderOutputImpl(session, nextFilter, writeRequest);\n    }\n\n    private ProtocolDecoderOutput getDecoderOut(IoSession session,\n            NextFilter nextFilter) {\n        ProtocolDecoderOutput out = (ProtocolDecoderOutput) session.getAttribute(DECODER_OUT);\n        if (out == null) {\n            out = new ProtocolDecoderOutputImpl(session, nextFilter);\n            session.setAttribute(DECODER_OUT, out);\n        }\n        return out;\n    }\n\n    private void disposeEncoder(IoSession session) {\n        ProtocolEncoder encoder = (ProtocolEncoder) session\n                .removeAttribute(ENCODER);\n        if (encoder == null) {\n            return;\n        }\n\n        try {\n            encoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Failed to dispose: \" + encoder.getClass().getName() + \" (\" + encoder + ')');\n        }\n    }\n\n    private void disposeDecoder(IoSession session) {\n        ProtocolDecoder decoder = (ProtocolDecoder) session\n                .removeAttribute(DECODER);\n        if (decoder == null) {\n            return;\n        }\n\n        try {\n            decoder.dispose(session);\n        } catch (Throwable t) {\n            logger.warn(\n                    \"Falied to dispose: \" + decoder.getClass().getName() + \" (\" + decoder + ')');\n        }\n    }\n\n    private void disposeDecoderOut(IoSession session) {\n        session.removeAttribute(DECODER_OUT);\n    }\n\n    private static class EncodedWriteRequest extends DefaultWriteRequest {\n        private EncodedWriteRequest(Object encodedMessage,\n                WriteFuture future, SocketAddress destination) {\n            super(encodedMessage, future, destination);\n        }\n    }\n\n    private static class MessageWriteRequest extends WriteRequestWrapper {\n        private MessageWriteRequest(WriteRequest writeRequest) {\n            super(writeRequest);\n        }\n\n        @Override\n        public Object getMessage() {\n            return EMPTY_BUFFER;\n        }\n    }\n\n    private static class ProtocolDecoderOutputImpl extends\n            AbstractProtocolDecoderOutput {\n        private final IoSession session;\n        private final NextFilter nextFilter;\n\n        public ProtocolDecoderOutputImpl(\n                IoSession session, NextFilter nextFilter) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n        }\n\n        public void flush() {\n            Queue<Object> messageQueue = getMessageQueue();\n            while (!messageQueue.isEmpty()) {\n                nextFilter.messageReceived(session, messageQueue.poll());\n            }\n        }\n    }\n\n    private static class ProtocolEncoderOutputImpl extends\n            AbstractProtocolEncoderOutput {\n        private final IoSession session;\n\n        private final NextFilter nextFilter;\n\n        private final WriteRequest writeRequest;\n\n        public ProtocolEncoderOutputImpl(IoSession session,\n                NextFilter nextFilter, WriteRequest writeRequest) {\n            this.session = session;\n            this.nextFilter = nextFilter;\n            this.writeRequest = writeRequest;\n        }\n\n        public WriteFuture flush() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            WriteFuture future = null;\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    future = new DefaultWriteFuture(session);\n                    nextFilter.filterWrite(session, new EncodedWriteRequest(encodedMessage,\n                            future, writeRequest.getDestination()));\n                }\n            }\n\n            if (future == null) {\n                future = DefaultWriteFuture.newNotWrittenFuture(\n                        session, new NothingWrittenException(writeRequest));\n            }\n\n            return future;\n        }\n        \n        public void flushWithoutFuture() {\n            Queue<Object> bufferQueue = getMessageQueue();\n            for (;;) {\n                Object encodedMessage = bufferQueue.poll();\n                if (encodedMessage == null) {\n                    break;\n                }\n\n                // Flush only when the buffer has remaining.\n                if (!(encodedMessage instanceof IoBuffer) ||\n                        ((IoBuffer) encodedMessage).hasRemaining()) {\n                    SocketAddress destination = writeRequest.getDestination();\n                    WriteRequest writeRequest = new EncodedWriteRequest(\n                        encodedMessage, null, destination); \n                    nextFilter.filterWrite(session, writeRequest);\n                }\n            }\n        }\n    }\n}\n","lineNo":601}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.util.ConcurrentHashSet;\n\n/**\n * Detects idle sessions and fires <tt>sessionIdle<\/tt> events to them.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 525369 $, $Date: 2007-04-04 05:05:11 +0200 (mer., 04 avr. 2007) $\n */\npublic class IdleStatusChecker {\n    private final Set<AbstractIoSession> sessions =\n        new ConcurrentHashSet<AbstractIoSession>();\n    private final Set<AbstractIoService> services =\n        new ConcurrentHashSet<AbstractIoService>();\n\n    private final NotifyingTask notifyingTask = new NotifyingTask();\n    private final IoFutureListener<IoFuture> sessionCloseListener =\n        new SessionCloseListener();\n\n    public IdleStatusChecker() {}\n\n    public void addSession(AbstractIoSession session) {\n        sessions.add(session);\n        session.getCloseFuture().addListener(sessionCloseListener);\n    }\n\n    public void addService(AbstractIoService service) {\n        services.add(service);\n    }\n\n    public void removeSession(AbstractIoSession session) {\n        sessions.remove(session);\n    }\n\n    public void removeService(AbstractIoService service) {\n        services.remove(service);\n    }\n\n    public NotifyingTask getNotifyingTask() {\n        return notifyingTask;\n    }\n\n    public class NotifyingTask implements Runnable {\n        private volatile boolean cancelled;\n        private volatile Thread thread;\n\n        public void run() {\n            thread = Thread.currentThread();\n            try {\n                while (!cancelled) {\n                    // Check idleness with fixed delay (1 second).\n                    long currentTime = System.currentTimeMillis();\n                    notifyServices(currentTime);\n                    notifySessions(currentTime);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // will exit the loop if interrupted from interrupt()\n                    }\n                }\n            } finally {\n                thread = null;\n            }\n        }\n\n        public void cancel() {\n            cancelled = true;\n            Thread thread = this.thread;\n            if (thread != null) {\n                thread.interrupt();\n            }\n        }\n\n        private void notifyServices(long currentTime) {\n            Iterator<AbstractIoService> it = services.iterator();\n            while (it.hasNext()) {\n                AbstractIoService service = it.next();\n                if (service.isActive()) {\n                    notifyIdleness(service, currentTime, false);\n                }\n            }\n        }\n\n        private void notifySessions(long currentTime) {\n            Iterator<AbstractIoSession> it = sessions.iterator();\n            while (it.hasNext()) {\n                AbstractIoSession session = it.next();\n                if (session.isConnected()) {\n                    notifyIdleSession(session, currentTime);\n                }\n            }\n        }\n    }\n\n    private class SessionCloseListener implements IoFutureListener<IoFuture> {\n        public void operationComplete(IoFuture future) {\n            removeSession((AbstractIoSession) future.getSession());\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    public static void notifyIdleness(IoService service, long currentTime) {\n        notifyIdleness(service, currentTime, true);\n    }\n\n    private static void notifyIdleness(IoService service, long currentTime, boolean includeSessions) {\n        if (!(service instanceof AbstractIoService)) {\n            return;\n        }\n\n        ((AbstractIoService) service).notifyIdleness(currentTime);\n\n        if (includeSessions) {\n            notifyIdleness(service.getManagedSessions().values().iterator(), currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        if (session instanceof AbstractIoSession) {\n            AbstractIoSession s = (AbstractIoSession) session;\n            notifyIdleSession1(\n                    s, currentTime,\n                    s.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                    IdleStatus.BOTH_IDLE, Math.max(\n                            s.getLastIoTime(),\n                            s.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n            notifyIdleSession1(\n                    s, currentTime,\n                    s.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                    IdleStatus.READER_IDLE, Math.max(\n                            s.getLastReadTime(),\n                            s.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n            notifyIdleSession1(\n                    s, currentTime,\n                    s.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                    IdleStatus.WRITER_IDLE, Math.max(\n                            s.getLastWriteTime(),\n                            s.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n            notifyWriteTimeout(s, currentTime);\n            updateThroughput(s, currentTime);\n        } else {\n            notifyIdleSession0(\n                    session, currentTime,\n                    session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                    IdleStatus.BOTH_IDLE, Math.max(\n                            session.getLastIoTime(),\n                            session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n            notifyIdleSession0(\n                    session, currentTime,\n                    session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                    IdleStatus.READER_IDLE, Math.max(\n                            session.getLastReadTime(),\n                            session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n            notifyIdleSession0(\n                    session, currentTime,\n                    session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                    IdleStatus.WRITER_IDLE, Math.max(\n                            session.getLastWriteTime(),\n                            session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n        }\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyIdleSession1(\n            AbstractIoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            AbstractIoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close();\n            }\n        }\n    }\n\n    private static void updateThroughput(\n            AbstractIoSession session, long currentTime) {\n        session.updateThroughput(currentTime, false);\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.IoFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteTimeoutException;\nimport org.apache.mina.util.ConcurrentHashSet;\n\n/**\n * Detects idle sessions and fires <tt>sessionIdle<\/tt> events to them.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 525369 $, $Date: 2007-04-04 05:05:11 +0200 (mer., 04 avr. 2007) $\n */\npublic class IdleStatusChecker {\n    private final Set<AbstractIoSession> sessions =\n        new ConcurrentHashSet<AbstractIoSession>();\n    private final Set<AbstractIoService> services =\n        new ConcurrentHashSet<AbstractIoService>();\n\n    private final NotifyingTask notifyingTask = new NotifyingTask();\n    private final IoFutureListener<IoFuture> sessionCloseListener =\n        new SessionCloseListener();\n\n    public IdleStatusChecker() {}\n\n    public void addSession(AbstractIoSession session) {\n        sessions.add(session);\n        CloseFuture closeFuture = session.getCloseFuture();\n        closeFuture.addListener(sessionCloseListener);\n    }\n\n    public void addService(AbstractIoService service) {\n        services.add(service);\n    }\n\n    public void removeSession(AbstractIoSession session) {\n        sessions.remove(session);\n    }\n\n    public void removeService(AbstractIoService service) {\n        services.remove(service);\n    }\n\n    public NotifyingTask getNotifyingTask() {\n        return notifyingTask;\n    }\n\n    public class NotifyingTask implements Runnable {\n        private volatile boolean cancelled;\n        private volatile Thread thread;\n\n        public void run() {\n            thread = Thread.currentThread();\n            try {\n                while (!cancelled) {\n                    // Check idleness with fixed delay (1 second).\n                    long currentTime = System.currentTimeMillis();\n                    notifyServices(currentTime);\n                    notifySessions(currentTime);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // will exit the loop if interrupted from interrupt()\n                    }\n                }\n            } finally {\n                thread = null;\n            }\n        }\n\n        public void cancel() {\n            cancelled = true;\n            Thread thread = this.thread;\n            if (thread != null) {\n                thread.interrupt();\n            }\n        }\n\n        private void notifyServices(long currentTime) {\n            Iterator<AbstractIoService> it = services.iterator();\n            while (it.hasNext()) {\n                AbstractIoService service = it.next();\n                if (service.isActive()) {\n                    notifyIdleness(service, currentTime, false);\n                }\n            }\n        }\n\n        private void notifySessions(long currentTime) {\n            Iterator<AbstractIoSession> it = sessions.iterator();\n            while (it.hasNext()) {\n                AbstractIoSession session = it.next();\n                if (session.isConnected()) {\n                    notifyIdleSession(session, currentTime);\n                }\n            }\n        }\n    }\n\n    private class SessionCloseListener implements IoFutureListener<IoFuture> {\n        public void operationComplete(IoFuture future) {\n            removeSession((AbstractIoSession) future.getSession());\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event to any applicable\n     * sessions in the specified collection.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleness(Iterator<? extends IoSession> sessions, long currentTime) {\n        IoSession s = null;\n        while (sessions.hasNext()) {\n            s = sessions.next();\n            notifyIdleSession(s, currentTime);\n        }\n    }\n\n    public static void notifyIdleness(IoService service, long currentTime) {\n        notifyIdleness(service, currentTime, true);\n    }\n\n    private static void notifyIdleness(IoService service, long currentTime, boolean includeSessions) {\n        if (!(service instanceof AbstractIoService)) {\n            return;\n        }\n\n        ((AbstractIoService) service).notifyIdleness(currentTime);\n\n        if (includeSessions) {\n            notifyIdleness(service.getManagedSessions().values().iterator(), currentTime);\n        }\n    }\n\n    /**\n     * Fires a {@link IoEventType#SESSION_IDLE} event if applicable for the\n     * specified {@code session}.\n     *\n     * @param currentTime the current time (i.e. {@link System#currentTimeMillis()})\n     */\n    public static void notifyIdleSession(IoSession session, long currentTime) {\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.BOTH_IDLE),\n                IdleStatus.BOTH_IDLE, Math.max(\n                    session.getLastIoTime(),\n                    session.getLastIdleTime(IdleStatus.BOTH_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.READER_IDLE),\n                IdleStatus.READER_IDLE, Math.max(\n                    session.getLastReadTime(),\n                    session.getLastIdleTime(IdleStatus.READER_IDLE)));\n\n        notifyIdleSession0(\n                session, currentTime,\n                session.getConfig().getIdleTimeInMillis(IdleStatus.WRITER_IDLE),\n                IdleStatus.WRITER_IDLE, Math.max(\n                    session.getLastWriteTime(),\n                    session.getLastIdleTime(IdleStatus.WRITER_IDLE)));\n\n        notifyWriteTimeout(session, currentTime);\n        updateThroughput(session, currentTime);\n    }\n\n    private static void notifyIdleSession0(\n            IoSession session, long currentTime,\n            long idleTime, IdleStatus status, long lastIoTime) {\n        if (idleTime > 0 && lastIoTime != 0\n                && currentTime - lastIoTime >= idleTime) {\n            session.getFilterChain().fireSessionIdle(status);\n        }\n    }\n\n    private static void notifyWriteTimeout(\n            IoSession session, long currentTime) {\n\n        long writeTimeout = session.getConfig().getWriteTimeoutInMillis();\n        if (writeTimeout > 0 &&\n                currentTime - session.getLastWriteTime() >= writeTimeout &&\n                !session.getWriteRequestQueue().isEmpty(session)) {\n            WriteRequest request = session.getCurrentWriteRequest();\n            if (request != null) {\n                session.setCurrentWriteRequest(null);\n                WriteTimeoutException cause = new WriteTimeoutException(request);\n                request.getFuture().setException(cause);\n                session.getFilterChain().fireExceptionCaught(cause);\n                // WriteException is an IOException, so we close the session.\n                session.close();\n            }\n        }\n    }\n\n    private static void updateThroughput(\n            IoSession session, long currentTime) {\n        session.updateThroughput(currentTime, false);\n    }\n}\n","lineNo":54}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":431}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":487}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":513}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":533}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":587}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":606}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":639}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":740}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":807}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":845}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                IoFilterChain filterChain = session.getFilterChain(); \n                filterChain.fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    IoFilterChain filterChain = session.getFilterChain(); \n                    filterChain.fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        IoFilterChain filterChain = session.getFilterChain(); \n        filterChain.fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            IoFilterChain filterChain = session.getFilterChain(); \n            filterChain.fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":854}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            future.setException(new WriteToClosedSessionException(request));\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        WriteFuture future = new DefaultWriteFuture(this);\n        getFilterChain().fireFilterWrite(\n                new DefaultWriteRequest(message, future, remoteAddress));\n\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            future.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        return future;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * Update all statistical properties related with throughput assuming\n     * the specified time is the current time.  By default this method returns\n     * silently without updating the throughput properties if they were\n     * calculated already within last\n     * {@link IoSessionConfig#getThroughputCalculationInterval() calculation interval}.\n     * If, however, <tt>force<\/tt> is specified as <tt>true<\/tt>, this method\n     * updates the throughput properties immediately.\n\n     * @param currentTime the current time in milliseconds\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":382}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            future.setException(new WriteToClosedSessionException(request));\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        WriteFuture future = new DefaultWriteFuture(this);\n        getFilterChain().fireFilterWrite(\n                new DefaultWriteRequest(message, future, remoteAddress));\n\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            future.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        return future;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * Update all statistical properties related with throughput assuming\n     * the specified time is the current time.  By default this method returns\n     * silently without updating the throughput properties if they were\n     * calculated already within last\n     * {@link IoSessionConfig#getThroughputCalculationInterval() calculation interval}.\n     * If, however, <tt>force<\/tt> is specified as <tt>true<\/tt>, this method\n     * updates the throughput properties immediately.\n\n     * @param currentTime the current time in milliseconds\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":412}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            future.setException(new WriteToClosedSessionException(request));\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        WriteFuture future = new DefaultWriteFuture(this);\n        getFilterChain().fireFilterWrite(\n                new DefaultWriteRequest(message, future, remoteAddress));\n\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            future.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        return future;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * Update all statistical properties related with throughput assuming\n     * the specified time is the current time.  By default this method returns\n     * silently without updating the throughput properties if they were\n     * calculated already within last\n     * {@link IoSessionConfig#getThroughputCalculationInterval() calculation interval}.\n     * If, however, <tt>force<\/tt> is specified as <tt>true<\/tt>, this method\n     * updates the throughput properties immediately.\n\n     * @param currentTime the current time in milliseconds\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.session;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.DefaultFileRegion;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.future.CloseFuture;\nimport org.apache.mina.core.future.DefaultCloseFuture;\nimport org.apache.mina.core.future.DefaultReadFuture;\nimport org.apache.mina.core.future.DefaultWriteFuture;\nimport org.apache.mina.core.future.IoFutureListener;\nimport org.apache.mina.core.future.ReadFuture;\nimport org.apache.mina.core.future.WriteFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteException;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.CircularQueue;\nimport org.apache.mina.util.ExceptionMonitor;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        // We can't send a message to a connected session if we don't have \n        // the remote address\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        \n        // If the session has been closed or is closing, we can't either\n        // send a message to the remote side. We generate a future\n        // containing an exception.\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            WriteException writeException = new WriteToClosedSessionException(request);\n            future.setException(writeException);\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        \n        // TODO: remove this code as soon as we use InputStream\n        // instead of Object for the message.\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                // Nothing to write : probably an error in the user code\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        // Now, we can write the message. First, create a future\n        WriteFuture writeFuture = new DefaultWriteFuture(this);\n        WriteRequest writeRequest = new DefaultWriteRequest(message, writeFuture, remoteAddress);\n        \n        // Then, get the chain and inject the WriteRequest into it\n        IoFilterChain filterChain = getFilterChain();\n        filterChain.fireFilterWrite(writeRequest);\n\n        // TODO : This is not our business ! The caller has created a FileChannel,\n        // he has to close it !\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            writeFuture.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        // Return the WriteFuture.\n        return writeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).getStatistics().decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    public final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":415}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        // The following optimization has been disabled because it can cause StackOverflowError.\n        //if (Thread.currentThread() == workerThread) {\n        //    // Bypass the queue if called from the worker thread itself\n        //    // (i.e. single thread model).\n        //    flushNow(session, System.currentTimeMillis());\n        //    return;\n        //}\n\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n            process(i.next());\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.core.polling;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.file.FileRegion;\nimport org.apache.mina.core.future.DefaultIoFuture;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.session.AbstractIoSession;\nimport org.apache.mina.core.session.IdleStatusChecker;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteToClosedSessionException;\nimport org.apache.mina.util.ExceptionMonitor;\nimport org.apache.mina.util.NamePreservingRunnable;\n\n/**\n * An abstract implementation of {@link IoProcessor} which helps\n * transport developers to write an {@link IoProcessor} easily.\n * This class is in charge of active polling a set of {@link IoSession}\n * and trigger events when some I/O operation is possible.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractPollingIoProcessor<T extends AbstractIoSession> implements IoProcessor<T> {\n    /**\n     * The maximum loop count for a write operation until\n     * {@link #write(AbstractIoSession, IoBuffer, int)} returns non-zero value.\n     * It is similar to what a spin lock is for in concurrency programming.\n     * It improves memory utilization and write throughput significantly.\n     */\n    private static final int WRITE_SPIN_COUNT = 256;\n\n    /** A map containing the last Thread ID for each class */\n    private static final Map<Class<?>, AtomicInteger> threadIds = \n        new HashMap<Class<?>, AtomicInteger>();\n\n    private final Object lock = new Object();\n    private final String threadName;\n    private final Executor executor;\n\n    /** A Session queue containing the newly created sessions */\n    private final Queue<T> newSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> removingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> flushingSessions = new ConcurrentLinkedQueue<T>();\n    private final Queue<T> trafficControllingSessions = new ConcurrentLinkedQueue<T>();\n\n    /** The processor thread : it handles the incoming messages */\n    private Processor processor;\n    \n    private long lastIdleCheckTime;\n\n    private final Object disposalLock = new Object();\n    private volatile boolean disposing;\n    private volatile boolean disposed;\n    private final DefaultIoFuture disposalFuture = new DefaultIoFuture(null);\n\n    /**\n     * Create an {@link AbstractPollingIoProcessor} with the given {@link Executor}\n     * for handling I/Os events.\n     * \n     * @param executor the {@link Executor} for handling I/O events\n     */\n    protected AbstractPollingIoProcessor(Executor executor) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        this.threadName = nextThreadName();\n        this.executor = executor;\n    }\n\n    /**\n     * Compute the thread ID for this class instance. As we may have different\n     * classes, we store the last ID number into a Map associating the class\n     * name to the last assigned ID.\n     *   \n     * @return a name for the current thread, based on the class name and\n     * an incremental value, starting at 1. \n     */\n    private String nextThreadName() {\n        Class<?> cls = getClass();\n        int newThreadId;\n        \n        // We synchronize this block to avoid a concurrent access to \n        // the actomicInteger (it can be modified by another thread, while\n        // being seen as null by another thread)\n        synchronized( threadIds ) {\n            // Get the current ID associated to this class' name\n            AtomicInteger threadId = threadIds.get(cls);\n            \n            if (threadId == null) {\n                // We never have seen this class before, just create a\n                // new ID starting at 1 for it, and associate this ID\n                // with the class name in the map.\n                newThreadId = 1;\n                threadIds.put(cls, new AtomicInteger(newThreadId));\n            } else {\n                // Just increment the lat ID, and get it.\n                newThreadId = threadId.incrementAndGet();\n            }\n        }\n        \n        // Now we can compute the name for this thread\n        return cls.getSimpleName() + '-' + newThreadId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposing() {\n        return disposing;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isDisposed() {\n        return disposed;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public final void dispose() {\n        if (disposed) {\n            return;\n        }\n\n        synchronized (disposalLock) {\n            if (!disposing) {\n                disposing = true;\n                startupWorker();\n            }\n        }\n\n        disposalFuture.awaitUninterruptibly();\n        disposed = true;\n    }\n\n    /**\n     * Dispose the resources used by this {@link IoProcessor} for polling \n     * the client connections\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract void dispose0() throws Exception;\n\n    /**\n     * poll those sessions for the given timeout\n     * @param timeout milliseconds before the call timeout if no event appear\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select(int timeout) throws Exception;\n    \n    /**\n     * poll those sessions forever\n     * @return The number of session ready for read or for write\n     * @throws Exception if some low level IO error occurs\n     */\n    protected abstract int select() throws Exception;\n    \n    /**\n     * Say if the list of {@link IoSession} polled by this {@link IoProcessor} \n     * is empty\n     * @return true if at least a session is managed by this {@link IoProcessor}\n     */\n    protected abstract boolean isSelectorEmpty();\n    \n    /**\n     * Interrupt the {@link AbstractPollingIoProcessor#select(int) call.\n     */\n    protected abstract void wakeup();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} polled by this\n     * {@link IoProcessor}   \n     * @return {@link Iterator} of {@link IoSession}\n     */\n    protected abstract Iterator<T> allSessions();\n    \n    /**\n     * Get an {@link Iterator} for the list of {@link IoSession} found selected \n     * by the last call of {@link AbstractPollingIoProcessor#select(int)\n     * @return {@link Iterator} of {@link IoSession} read for I/Os operation\n     */\n    protected abstract Iterator<T> selectedSessions();\n    \n    /**\n     * Get the sate of a session (preparing, open, closed)\n     * @param session the {@link IoSession} to inspect\n     * @return the state of the session\n     */\n    protected abstract SessionState state(T session);\n\n    /**\n     * Is the session ready for writing\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isWritable(T session);\n\n    /**\n     * Is the session ready for reading\n     * @param session the session queried\n     * @return true is ready, false if not ready\n     */\n    protected abstract boolean isReadable(T session);\n\n    /**\n     * register a session for writing\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInWrite(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * register a session for reading\n     * @param session the session registered\n     * @param interested true for registering, false for removing\n     */\n    protected abstract void setInterestedInRead(T session, boolean interested)\n            throws Exception;\n\n    /**\n     * is this session registered for reading\n     * @param session the session queried\n     * @return true is registered for reading\n     */\n    protected abstract boolean isInterestedInRead(T session);\n\n    /**\n     * is this session registered for writing\n     * @param session the session queried\n     * @return true is registered for writing\n     */\n    protected abstract boolean isInterestedInWrite(T session);\n\n    /**\n     * Initialize the polling of a session. Add it to the polling process. \n     * @param session the {@link IoSession} to add to the polling\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void init(T session) throws Exception;\n    \n    /**\n     * Destroy the underlying client socket handle\n     * @param session the {@link IoSession}\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract void destroy(T session) throws Exception;\n    \n    /**\n     * Reads a sequence of bytes from a {@link IoSession} into the given {@link IoBuffer}. \n     * Is called when the session was found ready for reading.\n     * @param session the session to read\n     * @param buf the buffer to fill\n     * @return the number of bytes read\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int read(T session, IoBuffer buf) throws Exception;\n\n    /**\n     * Write a sequence of bytes to a {@link IoSession}, means to be called when a session\n     * was found ready for writing.\n     * @param session the session to write\n     * @param buf the buffer to write\n     * @param length the number of bytes to write can be superior to the number of bytes remaining\n     * in the buffer\n     * @return the number of byte written\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int write(T session, IoBuffer buf, int length) throws Exception;\n    \n    /**\n     * Write a part of a file to a {@link IoSession}, if the underlying API isn't supporting\n     * system calls like sendfile(), you can throw a {@link UnsupportedOperationException} so \n     * the file will be send using usual {@link #write(AbstractIoSession, IoBuffer, int)} call. \n     * @param session the session to write\n     * @param region the file region to write\n     * @param length the length of the portion to send\n     * @return the number of written bytes\n     * @throws Exception any exception thrown by the underlying system calls\n     */\n    protected abstract int transferFile(T session, FileRegion region, int length) throws Exception;\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void add(T session) {\n        if (isDisposing()) {\n            throw new IllegalStateException(\"Already disposed.\");\n        }\n\n        // Adds the session to the newSession queue and starts the worker\n        newSessions.add(session);\n        startupWorker();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void remove(T session) {\n        scheduleRemove(session);\n        startupWorker();\n    }\n\n    private void scheduleRemove(T session) {\n        removingSessions.add(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void flush(T session) {\n        boolean needsWakeup = flushingSessions.isEmpty();\n        if (scheduleFlush(session) && needsWakeup) {\n            wakeup();\n        }\n    }\n\n    private boolean scheduleFlush(T session) {\n        if (session.setScheduledForFlush(true)) {\n            flushingSessions.add(session);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void updateTrafficMask(T session) {\n        scheduleTrafficControl(session);\n        wakeup();\n    }\n\n    private void scheduleTrafficControl(T session) {\n        trafficControllingSessions.add(session);\n    }\n\n    private void startupWorker() {\n        synchronized (lock) {\n            if (processor == null) {\n                processor = new Processor();\n                executor.execute(new NamePreservingRunnable(processor, threadName));\n            }\n        }\n        wakeup();\n    }\n\n    private int add() {\n        int addedSessions = 0;\n        \n        // Loop on the new sessions blocking queue, to count\n        // the number of sessions who has been created\n        for (;;) {\n            T session = newSessions.poll();\n\n            if (session == null) {\n                // We don't have anymore new sessions\n                break;\n            }\n\n\n            if (addNow(session)) {\n                // The new session has been added to the \n                addedSessions ++;\n            }\n        }\n\n        return addedSessions;\n    }\n\n    private boolean addNow(T session) {\n\n        boolean registered = false;\n        boolean notified = false;\n        try {\n            init(session);\n            registered = true;\n\n            // Build the filter chain of this session.\n            session.getService().getFilterChainBuilder().buildFilterChain(\n                    session.getFilterChain());\n\n            // DefaultIoFilterChain.CONNECT_FUTURE is cleared inside here\n            // in AbstractIoFilterChain.fireSessionOpened().\n            ((AbstractIoService) session.getService()).getListeners().fireSessionCreated(session);\n            notified = true;\n        } catch (Throwable e) {\n            if (notified) {\n                // Clear the DefaultIoFilterChain.CONNECT_FUTURE attribute\n                // and call ConnectFuture.setException().\n                scheduleRemove(session);\n                session.getFilterChain().fireExceptionCaught(e);\n                wakeup();\n            } else {\n                ExceptionMonitor.getInstance().exceptionCaught(e);\n                try {\n                    destroy(session);\n                } catch (Exception e1) {\n                    ExceptionMonitor.getInstance().exceptionCaught(e1);\n                } finally {\n                    registered = false;\n                }\n            }\n        }\n        return registered;\n    }\n\n    private int remove() {\n        int removedSessions = 0;\n        for (; ;) {\n            T session = removingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                if (removeNow(session)) {\n                    removedSessions ++;\n                }\n                break;\n            case CLOSED:\n                // Skip if channel is already closed\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.close() is called before addSession() is processed)\n                scheduleRemove(session);\n                return removedSessions;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n\n        return removedSessions;\n    }\n\n    private boolean removeNow(T session) {\n        clearWriteRequestQueue(session);\n\n        try {\n            destroy(session);\n            return true;\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        } finally {\n            clearWriteRequestQueue(session);\n            ((AbstractIoService) session.getService()).getListeners().fireSessionDestroyed(session);\n        }\n        return false;\n    }\n\n    private void clearWriteRequestQueue(T session) {\n        WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n        WriteRequest req;\n\n        List<WriteRequest> failedRequests = new ArrayList<WriteRequest>();\n\n        if ((req = writeRequestQueue.poll(session)) != null) {\n            Object m = req.getMessage();\n            if (m instanceof IoBuffer) {\n                IoBuffer buf = (IoBuffer) req.getMessage();\n\n                // The first unwritten empty buffer must be\n                // forwarded to the filter chain.\n                if (buf.hasRemaining()) {\n                    buf.reset();\n                    failedRequests.add(req);\n                } else {\n                    session.getFilterChain().fireMessageSent(req);\n                }\n            } else {\n                failedRequests.add(req);\n            }\n\n            // Discard others.\n            while ((req = writeRequestQueue.poll(session)) != null) {\n                failedRequests.add(req);\n            }\n        }\n\n        // Create an exception and notify.\n        if (!failedRequests.isEmpty()) {\n            WriteToClosedSessionException cause = new WriteToClosedSessionException(failedRequests);\n            for (WriteRequest r: failedRequests) {\n                session.decreaseScheduledBytesAndMessages(r);\n                r.getFuture().setException(cause);\n            }\n            session.getFilterChain().fireExceptionCaught(cause);\n        }\n    }\n\n    private void process() throws Exception {\n        for (Iterator<T> i = selectedSessions(); i.hasNext();) {\n        \tT session = i.next();\n            process(session);\n            i.remove();\n        }\n    }\n\n    private void process(T session) {\n\n        if (isReadable(session) && session.getTrafficMask().isReadable()) {\n            read(session);\n        }\n\n        if (isWritable(session) && session.getTrafficMask().isWritable()) {\n            scheduleFlush(session);\n        }\n    }\n\n    private void read(T session) {\n        IoSessionConfig config = session.getConfig();\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize();\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    private void notifyIdleSessions(long currentTime) throws Exception {\n        // process idle sessions\n        if (currentTime - lastIdleCheckTime >= 1000) {\n            lastIdleCheckTime = currentTime;\n            IdleStatusChecker.notifyIdleness(allSessions(), currentTime);\n        }\n    }\n\n    private void flush(long currentTime) {\n        final T firstSession = flushingSessions.peek();\n        if (firstSession == null) {\n            return;\n        }\n\n        T session = flushingSessions.poll(); // the same one with firstSession\n        for (; ;) {\n            session.setScheduledForFlush(false);\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                try {\n                    boolean flushedAll = flushNow(session, currentTime);\n                    if (flushedAll && !session.getWriteRequestQueue().isEmpty(session) &&\n                        !session.isScheduledForFlush()) {\n                        scheduleFlush(session);\n                    }\n                } catch (Exception e) {\n                    scheduleRemove(session);\n                    session.getFilterChain().fireExceptionCaught(e);\n                }\n                break;\n            case CLOSED:\n                // Skip if the channel is already closed.\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.write() is called before addSession() is processed)\n                scheduleFlush(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n\n            session = flushingSessions.peek();\n            if (session == null || session == firstSession) {\n                break;\n            }\n            session = flushingSessions.poll();\n        }\n    }\n\n    private boolean flushNow(T session, long currentTime) {\n        if (!session.isConnected()) {\n            scheduleRemove(session);\n            return false;\n        }\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        final WriteRequestQueue writeRequestQueue = session.getWriteRequestQueue();\n\n        // Set limitation for the number of written bytes for read-write\n        // fairness.  I used maxReadBufferSize * 3 / 2, which yields best\n        // performance in my experience while not breaking fairness much.\n        final int maxWrittenBytes = session.getConfig().getMaxReadBufferSize() +\n                              (session.getConfig().getMaxReadBufferSize() >>> 1);\n        int writtenBytes = 0;\n        try {\n            // Clear OP_WRITE\n            setInterestedInWrite(session, false);\n            do {\n                // Check for pending writes.\n                WriteRequest req = session.getCurrentWriteRequest();\n                if (req == null) {\n                    req = writeRequestQueue.poll(session);\n                    if (req == null) {\n                        break;\n                    }\n                    session.setCurrentWriteRequest(req);\n                }\n\n                int localWrittenBytes = 0;\n                Object message = req.getMessage();\n                if (message instanceof IoBuffer) {\n                    localWrittenBytes = writeBuffer(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n                    if (localWrittenBytes > 0 && ((IoBuffer)message).hasRemaining() ) {\n                    \t// the buffer isn't empty, we re-interest it in writing \n                    \twrittenBytes += localWrittenBytes;    \t\n                    \tsetInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else if (message instanceof FileRegion) {\n                    localWrittenBytes = writeFile(\n                            session, req, hasFragmentation,\n                            maxWrittenBytes - writtenBytes,\n                            currentTime);\n\n                    // Fix for Java bug on Linux http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5103988\n                    // If there's still data to be written in the FileRegion, return 0 indicating that we need\n                    // to pause until writing may resume.\n                    if (localWrittenBytes > 0 && ((FileRegion) message).getRemainingBytes() > 0) {\n                        writtenBytes += localWrittenBytes;\n                        setInterestedInWrite(session, true);\n                        return false;\n                    }\n                } else {\n                    throw new IllegalStateException(\"Don't know how to handle message of type '\" + message.getClass().getName() + \"'.  Are you missing a protocol encoder?\");\n                }\n\n                if (localWrittenBytes == 0) {\n                    // Kernel buffer is full.\n                    setInterestedInWrite(session, true);\n                    return false;\n                }\n\n                writtenBytes += localWrittenBytes;\n\n                if (writtenBytes >= maxWrittenBytes) {\n                    // Wrote too much\n                    scheduleFlush(session);\n                    return false;\n                }\n            } while (writtenBytes < maxWrittenBytes);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n            return false;\n        }\n\n        return true;\n    }\n\n    private int writeBuffer(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        IoBuffer buf = (IoBuffer) req.getMessage();\n        int localWrittenBytes = 0;\n        if (buf.hasRemaining()) {\n            int length;\n            if (hasFragmentation) {\n                length = Math.min(buf.remaining(), maxLength);\n            } else {\n                length = buf.remaining();\n            }\n            for (int i = WRITE_SPIN_COUNT; i > 0; i --) {\n                localWrittenBytes = write(session, buf, length);\n                if (localWrittenBytes != 0) {\n                    break;\n                }\n            }\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (!buf.hasRemaining() ||\n                !hasFragmentation && localWrittenBytes != 0) {\n            // Buffer has been sent, clear the current request.\n            buf.reset();\n            fireMessageSent(session, req);\n        }\n        return localWrittenBytes;\n    }\n\n    private int writeFile(T session, WriteRequest req,\n            boolean hasFragmentation, int maxLength, long currentTime) throws Exception {\n        int localWrittenBytes;\n        FileRegion region = (FileRegion) req.getMessage();\n        if (region.getRemainingBytes() > 0) {\n            int length;\n            if (hasFragmentation) {\n                length = (int) Math.min(region.getRemainingBytes(), maxLength);\n            } else {\n                length = (int) Math.min(Integer.MAX_VALUE, region.getRemainingBytes());\n            }\n            localWrittenBytes = transferFile(session, region, length);\n            region.update(localWrittenBytes);\n        } else {\n            localWrittenBytes = 0;\n        }\n\n        session.increaseWrittenBytes(localWrittenBytes, currentTime);\n\n        if (region.getRemainingBytes() <= 0 ||\n                    !hasFragmentation && localWrittenBytes != 0) {\n            fireMessageSent(session, req);\n        }\n\n        return localWrittenBytes;\n    }\n\n    private void fireMessageSent(T session, WriteRequest req) {\n        session.setCurrentWriteRequest(null);\n        session.getFilterChain().fireMessageSent(req);\n    }\n\n    private void updateTrafficMask() {\n        for (; ;) {\n            T session = trafficControllingSessions.poll();\n\n            if (session == null) {\n                break;\n            }\n\n            SessionState state = state(session);\n            switch (state) {\n            case OPEN:\n                updateTrafficMaskNow(session);\n                break;\n            case CLOSED:\n                break;\n            case PREPARING:\n                // Retry later if session is not yet fully initialized.\n                // (In case that Session.suspend??() or session.resume??() is\n                // called before addSession() is processed)\n                scheduleTrafficControl(session);\n                return;\n            default:\n                throw new IllegalStateException(String.valueOf(state));\n            }\n        }\n    }\n\n    private void updateTrafficMaskNow(T session) {\n        // The normal is OP_READ and, if there are write requests in the\n        // session's write queue, set OP_WRITE to trigger flushing.\n        int mask = session.getTrafficMask().getInterestOps();\n        try {\n            setInterestedInRead(session, (mask & SelectionKey.OP_READ) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n        try {\n            setInterestedInWrite(\n                    session,\n                    !session.getWriteRequestQueue().isEmpty(session) &&\n                            (mask & SelectionKey.OP_WRITE) != 0);\n        } catch (Exception e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    \n    private class Processor implements Runnable {\n        public void run() {\n            int nSessions = 0;\n            lastIdleCheckTime = System.currentTimeMillis();\n\n            for (;;) {\n                try {\n                    int selected = select(1000);\n\n                    nSessions += add();\n                    updateTrafficMask();\n\n                    if (selected > 0) {\n                        process();\n                    }\n\n                    long currentTime = System.currentTimeMillis();\n                    flush(currentTime);\n                    nSessions -= remove();\n                    notifyIdleSessions(currentTime);\n\n                    if (nSessions == 0) {\n                        synchronized (lock) {\n                            if (newSessions.isEmpty() && isSelectorEmpty()) {\n                                processor = null;\n                                break;\n                            }\n                        }\n                    }\n\n                    // Disconnect all sessions immediately if disposal has been\n                    // requested so that we exit this loop eventually.\n                    if (isDisposing()) {\n                        for (Iterator<T> i = allSessions(); i.hasNext(); ) {\n                            scheduleRemove(i.next());\n                        }\n                        wakeup();\n                    }\n                } catch (Throwable t) {\n                    ExceptionMonitor.getInstance().exceptionCaught(t);\n\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e1) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e1);\n                    }\n                }\n            }\n\n            try {\n                synchronized (disposalLock) {\n                    if (isDisposing()) {\n                        dispose0();\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionMonitor.getInstance().exceptionCaught(t);\n            } finally {\n                disposalFuture.setValue(true);\n            }\n        }\n    }\n\n    protected static enum SessionState {\n        OPEN,\n        CLOSED,\n        PREPARING,\n    }\n}\n","lineNo":535}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.concurrent.Executor;\n\nimport org.apache.mina.core.polling.AbstractPollingIoAcceptor;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.transport.socket.DefaultSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * {@link IoAcceptor} for socket transport (TCP/IP).  This class\n * handles incoming TCP/IP based socket connections.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 389042 $, $Date: 2006-03-27 07:49:41Z $\n */\npublic final class NioSocketAcceptor\n        extends AbstractPollingIoAcceptor<NioSession, ServerSocketChannel>\n        implements SocketAcceptor {\n\n    private int backlog = 50;\n    private boolean reuseAddress = false;\n\n    private volatile Selector selector;\n\n    /**\n     * Constructor for {@link NioSocketAcceptor} using default parameters (multiple thread model).\n     */\n    public NioSocketAcceptor() {\n        super(new DefaultSocketSessionConfig(), NioProcessor.class);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     * Constructor for {@link NioSocketAcceptor} using default parameters, and \n     * given number of {@link NioProcessor} for multithreading I/O operations.\n     * \n     * @param processorCount the number of processor to create and place in a\n     * {@link SimpleIoProcessorPool} \n     */\n    public NioSocketAcceptor(int processorCount) {\n        super(new DefaultSocketSessionConfig(), NioProcessor.class, processorCount);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n    *  Constructor for {@link NioSocketAcceptor} with default configuration but a\n     *  specific {@link IoProcessor}, useful for sharing the same processor over multiple\n     *  {@link IoService} of the same type.\n     * @param processor the processor to use for managing I/O events\n     */\n    public NioSocketAcceptor(IoProcessor<NioSession> processor) {\n        super(new DefaultSocketSessionConfig(), processor);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     *  Constructor for {@link NioSocketAcceptor} with a given {@link Executor} for handling \n     *  connection events and a given {@link IoProcessor} for handling I/O events, useful for \n     *  sharing the same processor and executor over multiple {@link IoService} of the same type.\n     * @param executor the executor for connection\n     * @param processor the processor for I/O operations\n     */\n    public NioSocketAcceptor(Executor executor, IoProcessor<NioSession> processor) {\n        super(new DefaultSocketSessionConfig(), executor, processor);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void init() throws Exception {\n        selector = Selector.open();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void destroy() throws Exception {\n        if (selector != null) {\n            selector.close();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public TransportMetadata getTransportMetadata() {\n        return NioSocketSession.METADATA;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketSessionConfig getSessionConfig() {\n        return (SocketSessionConfig) super.getSessionConfig();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetSocketAddress getLocalAddress() {\n        return (InetSocketAddress) super.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetSocketAddress getDefaultLocalAddress() {\n        return (InetSocketAddress) super.getDefaultLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setDefaultLocalAddress(InetSocketAddress localAddress) {\n        setDefaultLocalAddress((SocketAddress) localAddress);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReuseAddress() {\n        return reuseAddress;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setReuseAddress(boolean reuseAddress) {\n        synchronized (bindLock) {\n            if (isActive()) {\n                throw new IllegalStateException(\n                        \"reuseAddress can't be set while the acceptor is bound.\");\n            }\n\n            this.reuseAddress = reuseAddress;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getBacklog() {\n        return backlog;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setBacklog(int backlog) {\n        synchronized (bindLock) {\n            if (isActive()) {\n                throw new IllegalStateException(\n                        \"backlog can't be set while the acceptor is bound.\");\n            }\n\n            this.backlog = backlog;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected NioSession accept(IoProcessor<NioSession> processor,\n            ServerSocketChannel handle) throws Exception {\n\n        SelectionKey key = handle.keyFor(selector);\n        if (!key.isAcceptable()) {\n            return null;\n        }\n\n        // accept the connection from the client\n        SocketChannel ch = handle.accept();\n        if (ch == null) {\n            return null;\n        }\n\n        return new NioSocketSession(this, processor, ch);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected ServerSocketChannel open(SocketAddress localAddress)\n            throws Exception {\n        ServerSocketChannel c = ServerSocketChannel.open();\n        boolean success = false;\n        try {\n            c.configureBlocking(false);\n            // Configure the server socket,\n            c.socket().setReuseAddress(isReuseAddress());\n            // XXX: Do we need to provide this property? (I think we need to remove it.)\n            c.socket().setReceiveBufferSize(\n                    getSessionConfig().getReceiveBufferSize());\n            // and bind.\n            c.socket().bind(localAddress, getBacklog());\n            c.register(selector, SelectionKey.OP_ACCEPT);\n            success = true;\n        } finally {\n            if (!success) {\n                close(c);\n            }\n        }\n        return c;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected SocketAddress localAddress(ServerSocketChannel handle)\n            throws Exception {\n        return handle.socket().getLocalSocketAddress();\n    }\n\n    /**\n      * Check if we have at least one key whose corresponding channels is \n      * ready for I/O operations.\n      *\n      * This method performs a blocking selection operation. \n      * It returns only after at least one channel is selected, \n      * this selector's wakeup method is invoked, or the current thread \n      * is interrupted, whichever comes first.\n      * \n      * @return <code>true<\/code> if one key has its ready-operation set updated\n      * @throws IOException If an I/O error occurs\n      * @throws ClosedSelectorException If this selector is closed \n      */\n    @Override\n    protected boolean select() throws Exception {\n        return selector.select() > 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected Iterator<ServerSocketChannel> selectedHandles() {\n        return new ServerSocketChannelIterator(selector.selectedKeys());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void close(ServerSocketChannel handle) throws Exception {\n        SelectionKey key = handle.keyFor(selector);\n        if (key != null) {\n            key.cancel();\n        }\n        handle.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void wakeup() {\n        selector.wakeup();\n    }\n\n    private static class ServerSocketChannelIterator implements Iterator<ServerSocketChannel> {\n\n        private final Iterator<SelectionKey> i;\n\n        private ServerSocketChannelIterator(Collection<SelectionKey> selectedKeys) {\n            i = selectedKeys.iterator();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean hasNext() {\n            return i.hasNext();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public ServerSocketChannel next() {\n            SelectionKey key = i.next();\n            return (ServerSocketChannel) key.channel();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void remove() {\n            i.remove();\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.transport.socket.nio;\n\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.concurrent.Executor;\n\nimport org.apache.mina.core.polling.AbstractPollingIoAcceptor;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoProcessor;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.core.service.TransportMetadata;\nimport org.apache.mina.transport.socket.DefaultSocketSessionConfig;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\n\n/**\n * {@link IoAcceptor} for socket transport (TCP/IP).  This class\n * handles incoming TCP/IP based socket connections.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev: 389042 $, $Date: 2006-03-27 07:49:41Z $\n */\npublic final class NioSocketAcceptor\n        extends AbstractPollingIoAcceptor<NioSession, ServerSocketChannel>\n        implements SocketAcceptor {\n\n    /** \n     * Define the number of socket that can wait to be accepted. Default\n     * to 50 (as in the SocketServer default).\n     */\n    private int backlog = 50;\n\n    private boolean reuseAddress = false;\n\n    private volatile Selector selector;\n\n    /**\n     * Constructor for {@link NioSocketAcceptor} using default parameters (multiple thread model).\n     */\n    public NioSocketAcceptor() {\n        super(new DefaultSocketSessionConfig(), NioProcessor.class);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     * Constructor for {@link NioSocketAcceptor} using default parameters, and \n     * given number of {@link NioProcessor} for multithreading I/O operations.\n     * \n     * @param processorCount the number of processor to create and place in a\n     * {@link SimpleIoProcessorPool} \n     */\n    public NioSocketAcceptor(int processorCount) {\n        super(new DefaultSocketSessionConfig(), NioProcessor.class, processorCount);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n    *  Constructor for {@link NioSocketAcceptor} with default configuration but a\n     *  specific {@link IoProcessor}, useful for sharing the same processor over multiple\n     *  {@link IoService} of the same type.\n     * @param processor the processor to use for managing I/O events\n     */\n    public NioSocketAcceptor(IoProcessor<NioSession> processor) {\n        super(new DefaultSocketSessionConfig(), processor);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     *  Constructor for {@link NioSocketAcceptor} with a given {@link Executor} for handling \n     *  connection events and a given {@link IoProcessor} for handling I/O events, useful for \n     *  sharing the same processor and executor over multiple {@link IoService} of the same type.\n     * @param executor the executor for connection\n     * @param processor the processor for I/O operations\n     */\n    public NioSocketAcceptor(Executor executor, IoProcessor<NioSession> processor) {\n        super(new DefaultSocketSessionConfig(), executor, processor);\n        ((DefaultSocketSessionConfig) getSessionConfig()).init(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void init() throws Exception {\n        selector = Selector.open();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void destroy() throws Exception {\n        if (selector != null) {\n            selector.close();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public TransportMetadata getTransportMetadata() {\n        return NioSocketSession.METADATA;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketSessionConfig getSessionConfig() {\n        return (SocketSessionConfig) super.getSessionConfig();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetSocketAddress getLocalAddress() {\n        return (InetSocketAddress) super.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetSocketAddress getDefaultLocalAddress() {\n        return (InetSocketAddress) super.getDefaultLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setDefaultLocalAddress(InetSocketAddress localAddress) {\n        setDefaultLocalAddress((SocketAddress) localAddress);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isReuseAddress() {\n        return reuseAddress;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setReuseAddress(boolean reuseAddress) {\n        synchronized (bindLock) {\n            if (isActive()) {\n                throw new IllegalStateException(\n                        \"reuseAddress can't be set while the acceptor is bound.\");\n            }\n\n            this.reuseAddress = reuseAddress;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int getBacklog() {\n        return backlog;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setBacklog(int backlog) {\n        synchronized (bindLock) {\n            if (isActive()) {\n                throw new IllegalStateException(\n                        \"backlog can't be set while the acceptor is bound.\");\n            }\n\n            this.backlog = backlog;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected NioSession accept(IoProcessor<NioSession> processor,\n            ServerSocketChannel handle) throws Exception {\n\n        SelectionKey key = handle.keyFor(selector);\n        \n        if (!key.isValid()) {\n            return null;\n        }\n\n        if (!key.isAcceptable()) {\n            return null;\n        }\n\n        // accept the connection from the client\n        SocketChannel ch = handle.accept();\n        if (ch == null) {\n            return null;\n        }\n\n        return new NioSocketSession(this, processor, ch);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected ServerSocketChannel open(SocketAddress localAddress)\n            throws Exception {\n        ServerSocketChannel channel = ServerSocketChannel.open();\n        boolean success = false;\n        try {\n            channel.configureBlocking(false);\n            // Configure the server socket,\n            ServerSocket socket = channel.socket();\n            socket.setReuseAddress(isReuseAddress());\n            // XXX: Do we need to provide this property? (I think we need to remove it.)\n            socket.setReceiveBufferSize(getSessionConfig().getReceiveBufferSize());\n            // and bind.\n            socket.bind(localAddress, getBacklog());\n            // Register the channel within the selector for ACCEPT event\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n            success = true;\n        } finally {\n            if (!success) {\n                close(channel);\n            }\n        }\n        return channel;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected SocketAddress localAddress(ServerSocketChannel handle)\n            throws Exception {\n        return handle.socket().getLocalSocketAddress();\n    }\n\n    /**\n      * Check if we have at least one key whose corresponding channels is \n      * ready for I/O operations.\n      *\n      * This method performs a blocking selection operation. \n      * It returns only after at least one channel is selected, \n      * this selector's wakeup method is invoked, or the current thread \n      * is interrupted, whichever comes first.\n      * \n      * @return The number of keys having their ready-operation set updated\n      * @throws IOException If an I/O error occurs\n      * @throws ClosedSelectorException If this selector is closed \n      */\n    @Override\n    protected int select() throws Exception {\n        return selector.select();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected Iterator<ServerSocketChannel> selectedHandles() {\n        return new ServerSocketChannelIterator(selector.selectedKeys());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void close(ServerSocketChannel handle) throws Exception {\n        SelectionKey key = handle.keyFor(selector);\n        if (key != null) {\n            key.cancel();\n        }\n        handle.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void wakeup() {\n        selector.wakeup();\n    }\n\n    /**\n     * Defines an iterator for the selected-key Set returned by the \n     * selector.selectedKeys(). It replaces the SelectionKey operator.\n     */\n    private static class ServerSocketChannelIterator implements Iterator<ServerSocketChannel> {\n        /** The selected-key iterator */\n        private final Iterator<SelectionKey> iterator;\n\n        /**\n         * Build a SocketChannel iterator which will return a SocketChannel instead of\n         * a SelectionKey.\n         * \n         * @param selectedKeys The selector selected-key set \n         */\n        private ServerSocketChannelIterator(Collection<SelectionKey> selectedKeys) {\n            iterator = selectedKeys.iterator();\n        }\n\n        /**\n         * Tells if there are more SockectChannel left in the iterator\n         * @return <code>true<\/code> if there is at least one more \n         * SockectChannel object to read\n         */\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        /**\n         * Get the next SocketChannel in the operator we have built from\n         * the selected-key et for this selector.\n         * \n         * @return The next SocketChannel in the iterator\n         */\n        public ServerSocketChannel next() {\n            SelectionKey key = iterator.next();\n            \n            if ( key.isValid() && key.isAcceptable() ) {\n                return (ServerSocketChannel) key.channel();\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * Remove the current SocketChannel from the iterator \n         */\n        public void remove() {\n            iterator.remove();\n        }\n    }\n}\n","lineNo":241}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n\n    private final EnumSet<IoEventType> eventTypes;\n    private final Executor executor;\n    private final boolean createdExecutor;\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter() {\n        this(16, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        this(0, maximumPoolSize, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        this(corePoolSize, maximumPoolSize, 30, TimeUnit.SECONDS, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), queueHandler, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, null, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        this(new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler), true, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        this(16, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        this(0, maximumPoolSize, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, 30, TimeUnit.SECONDS, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), queueHandler, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, null, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        this(new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler), true, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        this(executor, false, (IoEventType[]) null);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        this(executor, false, eventTypes);\n    }\n\n    private ExecutorFilter(Executor executor, boolean createdExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = new IoEventType[] { IoEventType.EXCEPTION_CAUGHT,\n                    IoEventType.MESSAGE_RECEIVED, IoEventType.MESSAGE_SENT,\n                    IoEventType.SESSION_CLOSED, IoEventType.SESSION_IDLE,\n                    IoEventType.SESSION_OPENED, };\n        }\n\n        for (IoEventType t : eventTypes) {\n            if (t == IoEventType.SESSION_CREATED) {\n                throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                        + \" is not allowed.\");\n            }\n        }\n\n        this.executor = executor;\n        this.createdExecutor = createdExecutor;\n\n        Collection<IoEventType> eventTypeCollection = new ArrayList<IoEventType>(\n                eventTypes.length);\n        Collections.addAll(eventTypeCollection, eventTypes);\n        this.eventTypes = EnumSet.copyOf(eventTypeCollection);\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter is creates via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (createdExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionCreated(NextFilter nextFilter, IoSession session) {\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":288}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n\n    private final EnumSet<IoEventType> eventTypes;\n    private final Executor executor;\n    private final boolean createdExecutor;\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter() {\n        this(16, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        this(0, maximumPoolSize, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        this(corePoolSize, maximumPoolSize, 30, TimeUnit.SECONDS, (IoEventType[]) null);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), queueHandler, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, null, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        this(new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler), true, (IoEventType[]) null);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        this(16, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        this(0, maximumPoolSize, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, 30, TimeUnit.SECONDS, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, Executors.defaultThreadFactory(), queueHandler, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, null, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        this(new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler), true, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        this(executor, false, (IoEventType[]) null);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        this(executor, false, eventTypes);\n    }\n\n    private ExecutorFilter(Executor executor, boolean createdExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = new IoEventType[] { IoEventType.EXCEPTION_CAUGHT,\n                    IoEventType.MESSAGE_RECEIVED, IoEventType.MESSAGE_SENT,\n                    IoEventType.SESSION_CLOSED, IoEventType.SESSION_IDLE,\n                    IoEventType.SESSION_OPENED, };\n        }\n\n        for (IoEventType t : eventTypes) {\n            if (t == IoEventType.SESSION_CREATED) {\n                throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                        + \" is not allowed.\");\n            }\n        }\n\n        this.executor = executor;\n        this.createdExecutor = createdExecutor;\n\n        Collection<IoEventType> eventTypeCollection = new ArrayList<IoEventType>(\n                eventTypes.length);\n        Collections.addAll(eventTypeCollection, eventTypes);\n        this.eventTypes = EnumSet.copyOf(eventTypeCollection);\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter is creates via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (createdExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionCreated(NextFilter nextFilter, IoSession session) {\n        nextFilter.sessionCreated(session);\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.executor;\n\nimport java.util.EnumSet;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterEvent;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoEventType;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.WriteRequest;\n\n/**\n * A filter that forwards I/O events to {@link Executor} to enforce a certain\n * thread model while allowing the events per session to be processed\n * simultaneously. You can apply various thread model by inserting this filter\n * to a {@link IoFilterChain}.\n * \n * <h2>Life Cycle Management<\/h2>\n * \n * Please note that this filter doesn't manage the life cycle of the {@link Executor}.\n * If you created this filter using {@link #ExecutorFilter(Executor)} or similar\n * constructor that accepts an {@link Executor} that you've instantiated, you have\n * full control and responsibility of managing its life cycle (e.g. calling\n * {@link ExecutorService#shutdown()}.\n * <p> \n * If you created this filter using convenience constructors like\n * {@link #ExecutorFilter(int)}, then you can shut down the executor by calling\n * {@link #destroy()} explicitly.\n * \n * <h2>Event Ordering<\/h2>\n * \n * All convenience constructors of this filter creates a new\n * {@link OrderedThreadPoolExecutor} instance.  Therefore, the order of event is\n * maintained like the following:\n * <ul>\n * <li>All event handler methods are called exclusively.\n *     (e.g. messageReceived and messageSent can't be invoked at the same time.)<\/li>\n * <li>The event order is never mixed up.\n *     (e.g. messageReceived is always invoked before sessionClosed or messageSent.)<\/li>\n * <\/ul>\n * However, if you specified other {@link Executor} instance in the constructor,\n * the order of events are not maintained at all.  This means more than one event\n * handler methods can be invoked at the same time with mixed order.  For example,\n * let's assume that messageReceived, messageSent, and sessionClosed events are\n * fired.\n * <ul>\n * <li>All event handler methods can be called simultaneously.\n *     (e.g. messageReceived and messageSent can be invoked at the same time.)<\/li>\n * <li>The event order can be mixed up.\n *     (e.g. sessionClosed or messageSent can be invoked before messageReceived\n *           is invoked.)<\/li>\n * <\/ul>\n * If you need to maintain the order of events per session, please specify an\n * {@link OrderedThreadPoolExecutor} instance or use the convenience constructors.\n * \n * <h2>Selective Filtering<\/h2>\n * \n * By default, all event types but <tt>sessionCreated<\/tt>, <tt>filterWrite<\/tt>,\n * <tt>filterClose<\/tt> and <tt>filterSetTrafficMask<\/tt> are submitted to the\n * underlying executor, which is most common setting.\n * <p>\n * If you want to submit only a certain set of event types, you can specify them\n * in the constructor.  For example, you could configure a thread pool for\n * write operation for the maximum performance:\n * <pre><code>\n * IoService service = ...;\n * DefaultIoFilterChainBuilder chain = service.getFilterChain();\n * \n * chain.addLast(\"codec\", new ProtocolCodecFilter(...));\n * // Use one thread pool for most events.\n * chain.addLast(\"executor1\", new ExecutorFilter());\n * // and another dedicated thread pool for 'filterWrite' events.\n * chain.addLast(\"executor2\", new ExecutorFilter(IoEventType.WRITE));\n * <\/code><\/pre>\n * \n * <h2>Preventing {@link OutOfMemoryError}<\/h2>\n * \n * Please refer to {@link IoEventQueueThrottle}, which is specified as\n * a parameter of the convenience constructors.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * \n * @see OrderedThreadPoolExecutor\n * @see UnorderedThreadPoolExecutor\n * @org.apache.xbean.XBean\n */\npublic class ExecutorFilter extends IoFilterAdapter {\n    /** The list of handled events */\n    private EnumSet<IoEventType> eventTypes;\n    \n    /** The associated executor */\n    private Executor executor;\n    \n    /** A flag set if the executor can be managed */ \n    private boolean manageableExecutor;\n    \n    /** The default pool size */\n    private static final int DEFAULT_MAX_POOL_SIZE = 16;\n    \n    /** The number of thread to create at startup */\n    private static final int BASE_THREAD_NUMBER = 0;\n    \n    /** The default KeepAlive time, in seconds */\n    private static final long DEFAULT_KEEPALIVE_TIME = 30;\n    \n    /** \n     * A set of flags used to tell if the Executor has been created \n     * in the constructor or passed as an argument. In the second case, \n     * the executor state can be managed.\n     **/\n    private static final boolean MANAGEABLE_EXECUTOR = true;\n    private static final boolean NOT_MANAGEABLE_EXECUTOR = false;\n    \n    /** A list of default EventTypes to be handled by the executor */\n    private static IoEventType[] DEFAULT_EVENT_SET = new IoEventType[] {\n        IoEventType.EXCEPTION_CAUGHT,\n        IoEventType.MESSAGE_RECEIVED, \n        IoEventType.MESSAGE_SENT,\n        IoEventType.SESSION_CLOSED, \n        IoEventType.SESSION_IDLE,\n        IoEventType.SESSION_OPENED\n    };\n    \n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, and a \n     * maximum of 16 threads in the pool. All the event will be handled \n     * by this default executor.\n     */\n    public ExecutorFilter() {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, no thread in the pool, but \n     * a maximum of threads in the pool is given. All the event will be handled \n     * by this default executor.\n     * \n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}, a number of thread to start with, a  \n     * maximum of threads the pool can contain. All the event will be handled \n     * by this default executor.\n     *\n     * @param corePoolSize the base number of threads the pool will contain at startup\n     * @param maximumPoolSize The maximum number of thread the default executor can \n     * use\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n            TimeUnit unit) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            DEFAULT_MAX_POOL_SIZE,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            BASE_THREAD_NUMBER,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(int corePoolSize, int maximumPoolSize, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            DEFAULT_KEEPALIVE_TIME,\n            TimeUnit.SECONDS,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            IoEventQueueHandler queueHandler, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            Executors.defaultThreadFactory(),\n            queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = createDefaultExecutor(\n            corePoolSize,\n            maximumPoolSize,\n            keepAliveTime,\n            unit,\n            threadFactory,\n            null);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n\n    /**\n     * (Convenience constructor) Creates a new instance with a new\n     * {@link OrderedThreadPoolExecutor}.\n     * \n     * @param corePoolSize The base number of thread in the pool\n     * @param maximumPoolSize The macimum thread contained in the executor\n     * @param keepAliveTime The KeepAlive timeout, expressed using the time unit\n     * @param unit The time unit\n     * @param threadFactory\n     * @param queueHandler\n     * @param eventTypes The list of events handled by the created executor\n     */\n    public ExecutorFilter(\n            int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit,\n            ThreadFactory threadFactory, IoEventQueueHandler queueHandler, \n            IoEventType... eventTypes) {\n        // Create a new default Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        // Initialize the filter\n        init(executor, MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, DEFAULT_EVENT_SET);\n    }\n\n    /**\n     * Creates a new instance with the specified {@link Executor}.\n     */\n    public ExecutorFilter(Executor executor, IoEventType... eventTypes) {\n        // Initialize the filter\n        init(executor, NOT_MANAGEABLE_EXECUTOR, eventTypes);\n    }\n    \n    /**\n     * Create an OrderedThreadPool executor.\n     *\n     * @param corePoolSize\n     * @param maximumPoolSize\n     * @param keepAliveTime\n     * @param unit\n     * @param threadFactory\n     * @param queueHandler\n     * @return\n     */\n    private Executor createDefaultExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n        TimeUnit unit, ThreadFactory threadFactory, IoEventQueueHandler queueHandler) {\n        // Create a new Executor\n        Executor executor = new OrderedThreadPoolExecutor(corePoolSize, maximumPoolSize, \n            keepAliveTime, unit, threadFactory, queueHandler);\n        \n        return executor;\n    }\n    \n    /**\n     * Create an EnumSet from an array of EventTypes, and set the associated\n     * eventTypes field.\n     *\n     * @param eventTypes The array of handled events\n     */\n    private void initEventTypes(IoEventType... eventTypes) {\n        if (eventTypes == null || eventTypes.length == 0) {\n            eventTypes = DEFAULT_EVENT_SET;\n        }\n\n        // Copy the list of handled events in the event set\n        this.eventTypes = EnumSet.of(eventTypes[0], eventTypes);\n        \n        // Check that we don't have the SESSION_CREATED event in the set\n        if (this.eventTypes.contains( IoEventType.SESSION_CREATED )) {\n            this.eventTypes = null;\n            throw new IllegalArgumentException(IoEventType.SESSION_CREATED\n                + \" is not allowed.\");\n        }\n    }\n\n    /**\n     * Creates a new instance of ExecutorFilter. This private constructor is called by all\n     * the public constructor.\n     *\n     * @param executor The underlying {@link Executor} in charge of managing the Thread pool.\n     * @param manageableExecutor Tells if the Executor's Life Cycle can be managed or not\n     * @param eventTypes The lit of event which are handled by the executor\n     * @param\n     */\n    private void init(Executor executor, boolean manageableExecutor, IoEventType... eventTypes) {\n        if (executor == null) {\n            throw new NullPointerException(\"executor\");\n        }\n\n        initEventTypes(eventTypes);\n        this.executor = executor;\n        this.manageableExecutor = manageableExecutor;\n    }\n    \n    /**\n     * Shuts down the underlying executor if this filter hase been created via\n     * a convenience constructor.\n     */\n    @Override\n    public void destroy() {\n        if (manageableExecutor) {\n            ((ExecutorService) executor).shutdown();\n        }\n    }\n\n    /**\n     * Returns the underlying {@link Executor} instance this filter uses.\n     * \n     * @return The underlying {@link Executor}\n     */\n    public final Executor getExecutor() {\n        return executor;\n    }\n\n    /**\n     * Fires the specified event through the underlying executor.\n     */\n    protected void fireEvent(IoFilterEvent event) {\n        getExecutor().execute(event);\n    }\n\n    /**\n     * A trigger fired when adding this filter in a chain. As this filter can be\n     * added only once in a chain, if the chain already contains the same filter,\n     * and exception will be thrown.\n     * \n     * @param parent The chain in which we want to inject this filter\n     * @param name The Fitler's name\n     * @param nextFilter The next filter in the chain\n     * \n     * @throws IllegalArgumentException If the filter is already present in the chain\n     */\n    @Override\n    public void onPreAdd(IoFilterChain parent, String name,\n            NextFilter nextFilter) throws Exception {\n        if (parent.contains(this)) {\n            throw new IllegalArgumentException(\n                    \"You can't add the same filter instance more than once.  Create another instance and add it.\");\n        }\n    }\n\n    @Override\n    public final void sessionOpened(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_OPENED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_OPENED,\n                    session, null));\n        } else {\n            nextFilter.sessionOpened(session);\n        }\n    }\n\n    @Override\n    public final void sessionClosed(NextFilter nextFilter, IoSession session) {\n        if (eventTypes.contains(IoEventType.SESSION_CLOSED)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_CLOSED,\n                    session, null));\n        } else {\n            nextFilter.sessionClosed(session);\n        }\n    }\n\n    @Override\n    public final void sessionIdle(NextFilter nextFilter, IoSession session,\n            IdleStatus status) {\n        if (eventTypes.contains(IoEventType.SESSION_IDLE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.SESSION_IDLE,\n                    session, status));\n        } else {\n            nextFilter.sessionIdle(session, status);\n        }\n    }\n\n    @Override\n    public final void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) {\n        if (eventTypes.contains(IoEventType.EXCEPTION_CAUGHT)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.EXCEPTION_CAUGHT, session, cause));\n        } else {\n            nextFilter.exceptionCaught(session, cause);\n        }\n    }\n\n    @Override\n    public final void messageReceived(NextFilter nextFilter, IoSession session,\n            Object message) {\n        if (eventTypes.contains(IoEventType.MESSAGE_RECEIVED)) {\n            fireEvent(new IoFilterEvent(nextFilter,\n                    IoEventType.MESSAGE_RECEIVED, session, message));\n        } else {\n            nextFilter.messageReceived(session, message);\n        }\n    }\n\n    @Override\n    public final void messageSent(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.MESSAGE_SENT)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.MESSAGE_SENT,\n                    session, writeRequest));\n        } else {\n            nextFilter.messageSent(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) {\n        if (eventTypes.contains(IoEventType.WRITE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.WRITE, session,\n                    writeRequest));\n        } else {\n            nextFilter.filterWrite(session, writeRequest);\n        }\n    }\n\n    @Override\n    public final void filterClose(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        if (eventTypes.contains(IoEventType.CLOSE)) {\n            fireEvent(new IoFilterEvent(nextFilter, IoEventType.CLOSE, session,\n                    null));\n        } else {\n            nextFilter.filterClose(session);\n        }\n    }\n}\n","lineNo":427}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.buffer;\n\nimport java.io.BufferedOutputStream;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} implementation used to buffer outgoing {@link WriteRequest} almost \n * like what {@link BufferedOutputStream} does. Using this filter allows to be less dependent \n * from network latency. It is also useful when a session is generating very small messages \n * too frequently and consequently generating unnecessary traffic overhead.\n * \n * Please note that it should always be placed before the {@link ProtocolCodecFilter} \n * as it only handles {@link WriteRequest}'s carrying {@link IoBuffer} objects.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M2\n */\npublic final class BufferedWriteFilter extends IoFilterAdapter {\n    private final Logger logger = LoggerFactory\n            .getLogger(BufferedWriteFilter.class);\n\n    /**\n     * Default buffer size value in bytes.\n     */\n    public final static int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * The buffer size allocated for each new session's buffer.\n     */\n    private int bufferSize = DEFAULT_BUFFER_SIZE;\n\n    /**\n     * The map that matches an {@link IoSession} and it's {@link IoBuffer}\n     * buffer.\n     */\n    private final ConcurrentMap<IoSession, IoBuffer> buffersMap;\n\n    /**\n     * Default constructor. Sets buffer size to {@link #DEFAULT_BUFFER_SIZE}\n     * bytes.\n     */\n    public BufferedWriteFilter() {\n        this(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Constructor which sets buffer size to <code>bufferSize<\/code>.\n     * \n     * @param bufferSize the new buffer size\n     */\n    public BufferedWriteFilter(int bufferSize) {\n        super();\n        this.bufferSize = bufferSize;\n        buffersMap = new ConcurrentHashMap<IoSession, IoBuffer>();\n    }\n\n    /**\n     * Returns buffer size.\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the buffer size but only for the newly created buffers.\n     * \n     * @param bufferSize the new buffer size\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @throws Exception if <code>writeRequest.message<\/code> isn't an\n     *                   {@link IoBuffer} instance.\n     */\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n\n        Object data = writeRequest.getMessage();\n\n        if (data instanceof IoBuffer) {\n            write(session, (IoBuffer) data);\n        } else {\n            throw new IllegalArgumentException(\n                    \"This filter should only buffer IoBuffer objects\");\n        }\n    }\n\n    /**\n     * Writes an {@link IoBuffer} to the session's buffer.\n     * \n     * @param session the session to which a write is requested\n     * @param data the data to buffer\n     */\n    private void write(IoSession session, IoBuffer data) {\n        IoBuffer dest = buffersMap.get(session);\n        if (dest == null) {\n            buffersMap.putIfAbsent(session, IoBuffer.allocate(bufferSize));\n            dest = buffersMap.get(session);\n        }\n\n        write(session, data, dest);\n    }\n\n    /**\n     * Writes <code>data<\/code> {@link IoBuffer} to the <code>buf<\/code>\n     * {@link IoBuffer} which buffers write requests for the\n     * <code>session<\/code> {@ link IoSession} until buffer is full \n     * or manually flushed.\n     * \n     * @param session the session where buffer will be written\n     * @param data the data to buffer\n     * @param buf the buffer where data will be temporarily written \n     */\n    private void write(IoSession session, IoBuffer data, IoBuffer buf) {\n        try {\n            int len = data.remaining();\n            if (len >= buf.capacity()) {\n                /*\n                 * If the request length exceeds the size of the output buffer,\n                 * flush the output buffer and then write the data directly.\n                 */\n                NextFilter nextFilter = session.getFilterChain().getNextFilter(\n                        this);\n                internalFlush(nextFilter, session, buf);\n                nextFilter.filterWrite(session, new DefaultWriteRequest(data));\n                return;\n            }\n            if (len > (buf.limit() - buf.position())) {\n                internalFlush(session.getFilterChain().getNextFilter(this),\n                        session, buf);\n            }\n            synchronized (buf) {\n                buf.put(data);\n            }\n        } catch (Throwable e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * Internal method that actually flushes the buffered data.\n     * \n     * @param nextFilter the {@link NextFilter} of this filter\n     * @param session the session where buffer will be written\n     * @param buf the data to write\n     * @throws Exception if a write operation fails\n     */\n    private void internalFlush(NextFilter nextFilter, IoSession session,\n            IoBuffer buf) throws Exception {\n        synchronized (buf) {\n            buf.flip();\n            logger.debug(\"Flushing buffer: {}\", buf);\n            nextFilter.filterWrite(session, new DefaultWriteRequest(buf\n                    .duplicate()));\n            buf.clear();\n        }\n    }\n\n    /**\n     * Flushes the buffered data.\n     * \n     * @param session the session where buffer will be written\n     */\n    public void flush(IoSession session) {\n        try {\n            internalFlush(session.getFilterChain().getNextFilter(this),\n                    session, buffersMap.get(session));\n        } catch (Throwable e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * Internal method that actually frees the {@link IoBuffer} that contains\n     * the buffered data that has not been flushed.\n     * \n     * @param session the session we operate on\n     */\n    private void free(IoSession session) {\n        IoBuffer buf = buffersMap.remove(session);\n        if (buf != null) {\n            buf.free();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) throws Exception {\n        free(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        free(session);\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.filter.buffer;\n\nimport java.io.BufferedOutputStream;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.filterchain.IoFilterAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.write.DefaultWriteRequest;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An {@link IoFilter} implementation used to buffer outgoing {@link WriteRequest} almost \n * like what {@link BufferedOutputStream} does. Using this filter allows to be less dependent \n * from network latency. It is also useful when a session is generating very small messages \n * too frequently and consequently generating unnecessary traffic overhead.\n * \n * Please note that it should always be placed before the {@link ProtocolCodecFilter} \n * as it only handles {@link WriteRequest}'s carrying {@link IoBuffer} objects.\n * \n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n * @since MINA 2.0.0-M2\n */\npublic final class BufferedWriteFilter extends IoFilterAdapter {\n    private final Logger logger = LoggerFactory\n            .getLogger(BufferedWriteFilter.class);\n\n    /**\n     * Default buffer size value in bytes.\n     */\n    public final static int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * The buffer size allocated for each new session's buffer.\n     */\n    private int bufferSize = DEFAULT_BUFFER_SIZE;\n\n    /**\n     * The map that matches an {@link IoSession} and it's {@link IoBuffer}\n     * buffer.\n     */\n    private final ConcurrentMap<IoSession, IoBuffer> buffersMap;\n\n    /**\n     * Default constructor. Sets buffer size to {@link #DEFAULT_BUFFER_SIZE}\n     * bytes. Uses a default instance of {@link ConcurrentHashMap}.\n     */\n    public BufferedWriteFilter() {\n        this(DEFAULT_BUFFER_SIZE, null);\n    }\n\n    /**\n     * Constructor which sets buffer size to <code>bufferSize<\/code>.Uses a default \n     * instance of {@link ConcurrentHashMap}.\n     * \n     * @param bufferSize the new buffer size\n     */\n    public BufferedWriteFilter(int bufferSize) {\n        this(bufferSize, null);\n    }\n\n    /**\n     * Constructor which sets buffer size to <code>bufferSize<\/code>. If \n     * <code>buffersMap<\/code> is null then a default instance of {@link ConcurrentHashMap} \n     * is created else the provided instance is used.\n     * \n     * @param bufferSize the new buffer size\n     * @param buffersMap the map to use for storing each session buffer \n     */\n    public BufferedWriteFilter(int bufferSize,\n            final ConcurrentMap<IoSession, IoBuffer> buffersMap) {\n        super();\n        this.bufferSize = bufferSize;\n        if (buffersMap == null) {\n            this.buffersMap = new ConcurrentHashMap<IoSession, IoBuffer>();\n        } else {\n            this.buffersMap = buffersMap;\n        }\n    }\n\n    /**\n     * Returns buffer size.\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the buffer size but only for the newly created buffers.\n     * \n     * @param bufferSize the new buffer size\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize = bufferSize;\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @throws Exception if <code>writeRequest.message<\/code> isn't an\n     *                   {@link IoBuffer} instance.\n     */\n    @Override\n    public void filterWrite(NextFilter nextFilter, IoSession session,\n            WriteRequest writeRequest) throws Exception {\n\n        Object data = writeRequest.getMessage();\n\n        if (data instanceof IoBuffer) {\n            write(session, (IoBuffer) data);\n        } else {\n            throw new IllegalArgumentException(\n                    \"This filter should only buffer IoBuffer objects\");\n        }\n    }\n\n    /**\n     * Writes an {@link IoBuffer} to the session's buffer.\n     * \n     * @param session the session to which a write is requested\n     * @param data the data to buffer\n     */\n    private void write(IoSession session, IoBuffer data) {\n        IoBuffer dest = buffersMap.get(session);\n        if (dest == null) {\n            buffersMap.putIfAbsent(session, IoBuffer.allocate(bufferSize));\n            dest = buffersMap.get(session);\n        }\n\n        write(session, data, dest);\n    }\n\n    /**\n     * Writes <code>data<\/code> {@link IoBuffer} to the <code>buf<\/code>\n     * {@link IoBuffer} which buffers write requests for the\n     * <code>session<\/code> {@ link IoSession} until buffer is full \n     * or manually flushed.\n     * \n     * @param session the session where buffer will be written\n     * @param data the data to buffer\n     * @param buf the buffer where data will be temporarily written \n     */\n    private void write(IoSession session, IoBuffer data, IoBuffer buf) {\n        try {\n            int len = data.remaining();\n            if (len >= buf.capacity()) {\n                /*\n                 * If the request length exceeds the size of the output buffer,\n                 * flush the output buffer and then write the data directly.\n                 */\n                NextFilter nextFilter = session.getFilterChain().getNextFilter(\n                        this);\n                internalFlush(nextFilter, session, buf);\n                nextFilter.filterWrite(session, new DefaultWriteRequest(data));\n                return;\n            }\n            if (len > (buf.limit() - buf.position())) {\n                internalFlush(session.getFilterChain().getNextFilter(this),\n                        session, buf);\n            }\n            synchronized (buf) {\n                buf.put(data);\n            }\n        } catch (Throwable e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * Internal method that actually flushes the buffered data.\n     * \n     * @param nextFilter the {@link NextFilter} of this filter\n     * @param session the session where buffer will be written\n     * @param buf the data to write\n     * @throws Exception if a write operation fails\n     */\n    private void internalFlush(NextFilter nextFilter, IoSession session,\n            IoBuffer buf) throws Exception {\n        IoBuffer tmp = null;\n        synchronized (buf) {\n            buf.flip();            \n            tmp = buf.duplicate();\n            buf.clear();\n        }\n        logger.debug(\"Flushing buffer: {}\", tmp);\n        nextFilter.filterWrite(session, new DefaultWriteRequest(tmp));\n    }\n\n    /**\n     * Flushes the buffered data.\n     * \n     * @param session the session where buffer will be written\n     */\n    public void flush(IoSession session) {\n        try {\n            internalFlush(session.getFilterChain().getNextFilter(this),\n                    session, buffersMap.get(session));\n        } catch (Throwable e) {\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n\n    /**\n     * Internal method that actually frees the {@link IoBuffer} that contains\n     * the buffered data that has not been flushed.\n     * \n     * @param session the session we operate on\n     */\n    private void free(IoSession session) {\n        IoBuffer buf = buffersMap.remove(session);\n        if (buf != null) {\n            buf.free();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void exceptionCaught(NextFilter nextFilter, IoSession session,\n            Throwable cause) throws Exception {\n        free(session);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sessionClosed(NextFilter nextFilter, IoSession session)\n            throws Exception {\n        free(session);\n    }\n}\n","lineNo":204}
{"Smelly Sample":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.common;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.util.CircularQueue;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    private static final AttributeKey WAITING_READ_FUTURES =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    protected AbstractIoSession() {\n        creationTime = lastThroughputCalculationTime =\n            lastReadTime = lastWriteTime =\n            lastIdleTimeForBoth = lastIdleTimeForRead =\n            lastIdleTimeForWrite = System.currentTimeMillis();\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    protected final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    protected final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    protected final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    protected final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    protected final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            future.setException(new WriteToClosedSessionException(request));\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        WriteFuture future = new DefaultWriteFuture(this);\n        getFilterChain().fireFilterWrite(\n                new DefaultWriteRequest(message, future, remoteAddress));\n\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            future.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        return future;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    protected final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    protected final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    protected final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    protected final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * Update all statistical properties related with throughput assuming\n     * the specified time is the current time.  By default this method returns\n     * silently without updating the throughput properties if they were\n     * calculated already within last\n     * {@link IoSessionConfig#getThroughputCalculationInterval() calculation interval}.\n     * If, however, <tt>force<\/tt> is specified as <tt>true<\/tt>, this method\n     * updates the throughput properties immediately.\n\n     * @param currentTime the current time in milliseconds\n     */\n    protected final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    protected final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    protected final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseReadMessages(currentTime);\n        }\n    }\n\n    protected final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    protected final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    protected final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    protected final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseScheduledWriteMessages();\n        }\n    }\n\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).decreaseScheduledWriteMessages();\n        }\n    }\n\n    protected final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    protected final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    protected final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    protected final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    protected final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    protected final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","Method after Refactoring":"/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.common;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.FileChannel;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.mina.util.CircularQueue;\n\n\n/**\n * Base implementation of {@link IoSession}.\n *\n * @author The Apache MINA Project (dev@mina.apache.org)\n * @version $Rev$, $Date$\n */\npublic abstract class AbstractIoSession implements IoSession {\n\n    private static final AttributeKey READY_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"readyReadFutures\");\n    \n    private static final AttributeKey WAITING_READ_FUTURES_KEY =\n        new AttributeKey(AbstractIoSession.class, \"waitingReadFutures\");\n\n    private static final IoFutureListener<CloseFuture> SCHEDULED_COUNTER_RESETTER =\n        new IoFutureListener<CloseFuture>() {\n            public void operationComplete(CloseFuture future) {\n                AbstractIoSession s = (AbstractIoSession) future.getSession();\n                s.scheduledWriteBytes.set(0);\n                s.scheduledWriteMessages.set(0);\n                s.readBytesThroughput = 0;\n                s.readMessagesThroughput = 0;\n                s.writtenBytesThroughput = 0;\n                s.writtenMessagesThroughput = 0;\n            }\n    };\n\n    /**\n     * An internal write request object that triggers session close.\n     * @see #writeRequestQueue\n     */\n    private static final WriteRequest CLOSE_REQUEST =\n        new DefaultWriteRequest(new Object());\n\n    private final Object lock = new Object();\n\n    private IoSessionAttributeMap attributes;\n    private WriteRequestQueue writeRequestQueue;\n    private WriteRequest currentWriteRequest;\n    \n    // The Session creation's time */\n    private final long creationTime;\n\n    /**\n     * A future that will be set 'closed' when the connection is closed.\n     */\n    private final CloseFuture closeFuture = new DefaultCloseFuture(this);\n\n    private volatile boolean closing;\n    private volatile TrafficMask trafficMask = TrafficMask.ALL;\n\n    // Status variables\n    private final AtomicBoolean scheduledForFlush = new AtomicBoolean();\n    private final AtomicInteger scheduledWriteBytes = new AtomicInteger();\n    private final AtomicInteger scheduledWriteMessages = new AtomicInteger();\n\n    private long readBytes;\n    private long writtenBytes;\n    private long readMessages;\n    private long writtenMessages;\n    private long lastReadTime;\n    private long lastWriteTime;\n\n    private long lastThroughputCalculationTime;\n    private long lastReadBytes;\n    private long lastWrittenBytes;\n    private long lastReadMessages;\n    private long lastWrittenMessages;\n    private double readBytesThroughput;\n    private double writtenBytesThroughput;\n    private double readMessagesThroughput;\n    private double writtenMessagesThroughput;\n\n    private int idleCountForBoth;\n    private int idleCountForRead;\n    private int idleCountForWrite;\n\n    private long lastIdleTimeForBoth;\n    private long lastIdleTimeForRead;\n    private long lastIdleTimeForWrite;\n\n    private boolean deferDecreaseReadBuffer = true;\n\n    /**\n     * TODO Add method documentation\n     */\n    protected AbstractIoSession() {\n        // Initialize all the Session counters to the current time \n        long currentTime = System.currentTimeMillis();\n        creationTime = currentTime;\n        lastThroughputCalculationTime = currentTime;\n        lastReadTime = currentTime;\n        lastWriteTime = currentTime;\n        lastIdleTimeForBoth = currentTime;\n        lastIdleTimeForRead = currentTime;\n        lastIdleTimeForWrite = currentTime;\n        \n        // TODO add documentation\n        closeFuture.addListener(SCHEDULED_COUNTER_RESETTER);\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * TODO this method implementation is totally wrong. It has to\n     * be rewritten.\n     */\n    public final long getId() {\n        return hashCode() & 0xFFFFFFFFL;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected abstract IoProcessor getProcessor();\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isConnected() {\n        return !closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isClosing() {\n        return closing || closeFuture.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture getCloseFuture() {\n        return closeFuture;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final boolean isScheduledForFlush() {\n        return scheduledForFlush.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final boolean setScheduledForFlush(boolean flag) {\n        if (flag) {\n            return scheduledForFlush.compareAndSet(false, true);\n        } else {\n            scheduledForFlush.set(false);\n            return true;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close(boolean rightNow) {\n        if (rightNow) {\n            return close();\n        } else {\n            return closeOnFlush();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture close() {\n        synchronized (lock) {\n            if (isClosing()) {\n                return closeFuture;\n            } else {\n                closing = true;\n            }\n        }\n\n        getFilterChain().fireFilterClose();\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final CloseFuture closeOnFlush() {\n        getWriteRequestQueue().offer(this, CLOSE_REQUEST);\n        getProcessor().flush(this);\n        return closeFuture;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final ReadFuture read() {\n        if (!getConfig().isUseReadOperation()) {\n            throw new IllegalStateException(\"useReadOperation is not enabled.\");\n        }\n\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = readyReadFutures.poll();\n            if (future != null) {\n                if (future.isClosed()) {\n                    // Let other readers get notified.\n                    readyReadFutures.offer(future);\n                }\n            } else {\n                future = new DefaultReadFuture(this);\n                getWaitingReadFutures().offer(future);\n            }\n        }\n\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void offerReadFuture(Object message) {\n        newReadFuture().setRead(message);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void offerFailedReadFuture(Throwable exception) {\n        newReadFuture().setException(exception);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void offerClosedReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        synchronized (readyReadFutures) {\n            newReadFuture().setClosed();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private ReadFuture newReadFuture() {\n        Queue<ReadFuture> readyReadFutures = getReadyReadFutures();\n        Queue<ReadFuture> waitingReadFutures = getWaitingReadFutures();\n        ReadFuture future;\n        synchronized (readyReadFutures) {\n            future = waitingReadFutures.poll();\n            if (future == null) {\n                future = new DefaultReadFuture(this);\n                readyReadFutures.offer(future);\n            }\n        }\n        return future;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getReadyReadFutures() {\n        Queue<ReadFuture> readyReadFutures =\n            (Queue<ReadFuture>) getAttribute(READY_READ_FUTURES_KEY);\n        if (readyReadFutures == null) {\n            readyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        READY_READ_FUTURES_KEY, readyReadFutures);\n            if (oldReadyReadFutures != null) {\n                readyReadFutures = oldReadyReadFutures;\n            }\n        }\n        return readyReadFutures;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private Queue<ReadFuture> getWaitingReadFutures() {\n        Queue<ReadFuture> waitingReadyReadFutures =\n            (Queue<ReadFuture>) getAttribute(WAITING_READ_FUTURES_KEY);\n        if (waitingReadyReadFutures == null) {\n            waitingReadyReadFutures = new CircularQueue<ReadFuture>();\n\n            Queue<ReadFuture> oldWaitingReadyReadFutures =\n                (Queue<ReadFuture>) setAttributeIfAbsent(\n                        WAITING_READ_FUTURES_KEY, waitingReadyReadFutures);\n            if (oldWaitingReadyReadFutures != null) {\n                waitingReadyReadFutures = oldWaitingReadyReadFutures;\n            }\n        }\n        return waitingReadyReadFutures;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message) {\n        return write(message, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteFuture write(Object message, SocketAddress remoteAddress) {\n        if (message == null) {\n            throw new NullPointerException(\"message\");\n        }\n\n        if (!getTransportMetadata().isConnectionless() &&\n                remoteAddress != null) {\n            throw new UnsupportedOperationException();\n        }\n\n        if (isClosing() || !isConnected()) {\n            WriteFuture future = new DefaultWriteFuture(this);\n            WriteRequest request = new DefaultWriteRequest(message, future, remoteAddress);\n            future.setException(new WriteToClosedSessionException(request));\n            return future;\n        }\n\n        FileChannel openedFileChannel = null;\n        try {\n            if (message instanceof IoBuffer\n                    && !((IoBuffer) message).hasRemaining()) {\n                throw new IllegalArgumentException(\n                \"message is empty. Forgot to call flip()?\");\n            } else if (message instanceof FileChannel) {\n                FileChannel fileChannel = (FileChannel) message;\n                message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());\n            } else if (message instanceof File) {\n                File file = (File) message;\n                openedFileChannel = new FileInputStream(file).getChannel();\n                message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());\n            }\n        } catch (IOException e) {\n            ExceptionMonitor.getInstance().exceptionCaught(e);\n            return DefaultWriteFuture.newNotWrittenFuture(this, e);\n        }\n\n        WriteFuture future = new DefaultWriteFuture(this);\n        getFilterChain().fireFilterWrite(\n                new DefaultWriteRequest(message, future, remoteAddress));\n\n        if (openedFileChannel != null) {\n            // If we opened a FileChannel, it needs to be closed when the write has completed\n            final FileChannel finalChannel = openedFileChannel;\n            future.addListener(new IoFutureListener<WriteFuture>() {\n                public void operationComplete(WriteFuture future) {\n                    try {\n                        finalChannel.close();\n                    } catch (IOException e) {\n                        ExceptionMonitor.getInstance().exceptionCaught(e);\n                    }\n                }\n            });\n        }\n\n        return future;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttachment() {\n        return getAttribute(\"\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttachment(Object attachment) {\n        return setAttribute(\"\", attachment);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key) {\n        return getAttribute(key, null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getAttribute(Object key, Object defaultValue) {\n        return attributes.getAttribute(this, key, defaultValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key, Object value) {\n        return attributes.setAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttribute(Object key) {\n        return setAttribute(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key, Object value) {\n        return attributes.setAttributeIfAbsent(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object setAttributeIfAbsent(Object key) {\n        return setAttributeIfAbsent(key, Boolean.TRUE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object removeAttribute(Object key) {\n        return attributes.removeAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean removeAttribute(Object key, Object value) {\n        return attributes.removeAttribute(this, key, value);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean replaceAttribute(Object key, Object oldValue, Object newValue) {\n        return attributes.replaceAttribute(this, key, oldValue, newValue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean containsAttribute(Object key) {\n        return attributes.containsAttribute(this, key);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Set<Object> getAttributeKeys() {\n        return attributes.getAttributeKeys(this);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final IoSessionAttributeMap getAttributeMap() {\n        return attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void setAttributeMap(IoSessionAttributeMap attributes) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void setWriteRequestQueue(WriteRequestQueue writeRequestQueue) {\n        this.writeRequestQueue =\n            new CloseRequestAwareWriteRequestQueue(writeRequestQueue);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final TrafficMask getTrafficMask() {\n        return trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void setTrafficMask(TrafficMask trafficMask) {\n        if (trafficMask == null) {\n            throw new NullPointerException(\"trafficMask\");\n        }\n\n        if (isClosing() || !isConnected()) {\n            return;\n        }\n\n        getFilterChain().fireFilterSetTrafficMask(trafficMask);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void setTrafficMaskNow(TrafficMask trafficMask) {\n        this.trafficMask = trafficMask;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendRead() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.READ.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void suspendWrite() {\n        setTrafficMask(getTrafficMask().and(TrafficMask.WRITE.not()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeRead() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.READ));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final void resumeWrite() {\n        setTrafficMask(getTrafficMask().or(TrafficMask.WRITE));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadBytes() {\n        return readBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenBytes() {\n        return writtenBytes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getReadMessages() {\n        return readMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getWrittenMessages() {\n        return writtenMessages;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadBytesThroughput() {\n        return readBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenBytesThroughput() {\n        return writtenBytesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getReadMessagesThroughput() {\n        return readMessagesThroughput;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final double getWrittenMessagesThroughput() {\n        return writtenMessagesThroughput;\n    }\n\n    /**\n     * Update all statistical properties related with throughput assuming\n     * the specified time is the current time.  By default this method returns\n     * silently without updating the throughput properties if they were\n     * calculated already within last\n     * {@link IoSessionConfig#getThroughputCalculationInterval() calculation interval}.\n     * If, however, <tt>force<\/tt> is specified as <tt>true<\/tt>, this method\n     * updates the throughput properties immediately.\n\n     * @param currentTime the current time in milliseconds\n     */\n    protected final void updateThroughput(long currentTime, boolean force) {\n        int interval = (int) (currentTime - lastThroughputCalculationTime);\n\n        long minInterval = getConfig().getThroughputCalculationIntervalInMillis();\n        if (minInterval == 0 || interval < minInterval) {\n            if (!force) {\n                return;\n            }\n        }\n\n        readBytesThroughput = (readBytes - lastReadBytes) * 1000.0 / interval;\n        writtenBytesThroughput = (writtenBytes - lastWrittenBytes) * 1000.0 / interval;\n        readMessagesThroughput = (readMessages - lastReadMessages) * 1000.0 / interval;\n        writtenMessagesThroughput = (writtenMessages - lastWrittenMessages) * 1000.0 / interval;\n\n        lastReadBytes = readBytes;\n        lastWrittenBytes = writtenBytes;\n        lastReadMessages = readMessages;\n        lastWrittenMessages = writtenMessages;\n\n        lastThroughputCalculationTime = currentTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getScheduledWriteBytes() {\n        return scheduledWriteBytes.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getScheduledWriteMessages() {\n        return scheduledWriteMessages.get();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteBytes(int byteCount){\n        scheduledWriteBytes.set(byteCount);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected void setScheduledWriteMessages(int messages) {\n        scheduledWriteMessages.set(messages);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseReadBytes(long increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        readBytes += increment;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseReadBytes(increment, currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseReadMessages(long currentTime) {\n        readMessages++;\n        lastReadTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForRead = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseReadMessages(currentTime);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseWrittenBytes(int increment, long currentTime) {\n        if (increment <= 0) {\n            return;\n        }\n\n        writtenBytes += increment;\n        lastWriteTime = currentTime;\n        idleCountForBoth = 0;\n        idleCountForWrite = 0;\n\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseWrittenBytes(increment, currentTime);\n        }\n\n        increaseScheduledWriteBytes(-increment);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseWrittenMessages(\n            WriteRequest request, long currentTime) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                return;\n            }\n        }\n\n        writtenMessages++;\n        lastWriteTime = currentTime;\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseWrittenMessages(currentTime);\n        }\n\n        decreaseScheduledWriteMessages();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseScheduledWriteBytes(int increment) {\n        scheduledWriteBytes.addAndGet(increment);\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseScheduledWriteBytes(increment);\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseScheduledWriteMessages() {\n        scheduledWriteMessages.incrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).increaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private void decreaseScheduledWriteMessages() {\n        scheduledWriteMessages.decrementAndGet();\n        if (getService() instanceof AbstractIoService) {\n            ((AbstractIoService) getService()).decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void decreaseScheduledBytesAndMessages(WriteRequest request) {\n        Object message = request.getMessage();\n        if (message instanceof IoBuffer) {\n            IoBuffer b = (IoBuffer) message;\n            if (b.hasRemaining()) {\n                increaseScheduledWriteBytes(-((IoBuffer) message).remaining());\n            } else {\n                decreaseScheduledWriteMessages();\n            }\n        } else {\n            decreaseScheduledWriteMessages();\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final WriteRequestQueue getWriteRequestQueue() {\n        if (writeRequestQueue == null) {\n            throw new IllegalStateException();\n        }\n        return writeRequestQueue;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final WriteRequest getCurrentWriteRequest() {\n        return currentWriteRequest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final Object getCurrentWriteMessage() {\n        WriteRequest req = getCurrentWriteRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getMessage();\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void setCurrentWriteRequest(WriteRequest currentWriteRequest) {\n        this.currentWriteRequest = currentWriteRequest;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseReadBufferSize() {\n        int newReadBufferSize = getConfig().getReadBufferSize() << 1;\n        if (newReadBufferSize <= getConfig().getMaxReadBufferSize()) {\n            getConfig().setReadBufferSize(newReadBufferSize);\n        } else {\n            getConfig().setReadBufferSize(getConfig().getMaxReadBufferSize());\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void decreaseReadBufferSize() {\n        if (deferDecreaseReadBuffer) {\n            deferDecreaseReadBuffer = false;\n            return;\n        }\n\n        if (getConfig().getReadBufferSize() > getConfig().getMinReadBufferSize()) {\n            getConfig().setReadBufferSize(getConfig().getReadBufferSize() >>> 1);\n        }\n\n        deferDecreaseReadBuffer = true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getCreationTime() {\n        return creationTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIoTime() {\n        return Math.max(lastReadTime, lastWriteTime);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReadTime() {\n        return lastReadTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriteTime() {\n        return lastWriteTime;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isIdle(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth > 0;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead > 0;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite > 0;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isBothIdle() {\n        return isIdle(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isReaderIdle() {\n        return isIdle(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final boolean isWriterIdle() {\n        return isIdle(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getIdleCount(IdleStatus status) {\n        if (getConfig().getIdleTime(status) == 0) {\n            if (status == IdleStatus.BOTH_IDLE) {\n                idleCountForBoth = 0;\n            }\n\n            if (status == IdleStatus.READER_IDLE) {\n                idleCountForRead = 0;\n            }\n\n            if (status == IdleStatus.WRITER_IDLE) {\n                idleCountForWrite = 0;\n            }\n        }\n\n        if (status == IdleStatus.BOTH_IDLE) {\n            return idleCountForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return idleCountForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return idleCountForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastIdleTime(IdleStatus status) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            return lastIdleTimeForBoth;\n        }\n\n        if (status == IdleStatus.READER_IDLE) {\n            return lastIdleTimeForRead;\n        }\n\n        if (status == IdleStatus.WRITER_IDLE) {\n            return lastIdleTimeForWrite;\n        }\n\n        throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    protected final void increaseIdleCount(IdleStatus status, long currentTime) {\n        if (status == IdleStatus.BOTH_IDLE) {\n            idleCountForBoth++;\n            lastIdleTimeForBoth = currentTime;\n        } else if (status == IdleStatus.READER_IDLE) {\n            idleCountForRead++;\n            lastIdleTimeForRead = currentTime;\n        } else if (status == IdleStatus.WRITER_IDLE) {\n            idleCountForWrite++;\n            lastIdleTimeForWrite = currentTime;\n        } else {\n            throw new IllegalArgumentException(\"Unknown idle status: \" + status);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getBothIdleCount() {\n        return getIdleCount(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastBothIdleTime() {\n        return getLastIdleTime(IdleStatus.BOTH_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastReaderIdleTime() {\n        return getLastIdleTime(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final long getLastWriterIdleTime() {\n        return getLastIdleTime(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getReaderIdleCount() {\n        return getIdleCount(IdleStatus.READER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public final int getWriterIdleCount() {\n        return getIdleCount(IdleStatus.WRITER_IDLE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public SocketAddress getServiceAddress() {\n        IoService service = getService();\n        if (service instanceof IoAcceptor) {\n            return ((IoAcceptor) service).getLocalAddress();\n        } else {\n            return getRemoteAddress();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     * TODO This is a ridiculous implementation. Need to be replaced.\n     */\n    @Override\n    public final boolean equals(Object o) {\n        return super.equals(o);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString() {\n        if (getService() instanceof IoAcceptor) {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", server, \" +\n                    getRemoteAddress() + \" => \" + getLocalAddress() + ')';\n        } else {\n            return \"(\" + getIdAsString() + \": \" + getServiceName() + \", client, \" +\n                    getLocalAddress() + \" => \" + getRemoteAddress() + ')';\n        }\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getIdAsString() {\n        String id = Long.toHexString(getId()).toUpperCase();\n\n        // Somewhat inefficient, but it won't happen that often\n        // because an ID is often a big integer.\n        while (id.length() < 8) {\n            id = '0' + id; // padding\n        }\n        id = \"0x\" + id;\n\n        return id;\n    }\n\n    /**\n     * TODO Add method documentation\n     */\n    private String getServiceName() {\n        TransportMetadata tm = getTransportMetadata();\n        if (tm == null) {\n            return \"null\";\n        } else {\n            return tm.getProviderName() + ' ' + tm.getName();\n        }\n    }\n\n    /**\n     * TODO Add method documentation. Name is ridiculously too long.\n     */\n    private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {\n\n        private final WriteRequestQueue q;\n\n        public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {\n            this.q = q;\n        }\n\n        public synchronized WriteRequest poll(IoSession session) {\n            WriteRequest answer = q.poll(session);\n            if (answer == CLOSE_REQUEST) {\n                AbstractIoSession.this.close();\n                dispose(session);\n                answer = null;\n            }\n            return answer;\n        }\n\n        public void offer(IoSession session, WriteRequest e) {\n            q.offer(session, e);\n        }\n\n        public boolean isEmpty(IoSession session) {\n            return q.isEmpty(session);\n        }\n\n        public void clear(IoSession session) {\n            q.clear(session);\n        }\n\n        public void dispose(IoSession session) {\n            q.dispose(session);\n        }\n    }\n}\n","lineNo":123}
