{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    // Call() methods and parameters\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n    private static final String METHOD_GARBAGE_COLLECT = \"garbage_collect\";\n    private static final String DO_DELETE = \"delete\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        Cursor emptyCursor = new MatrixCursor((projection == null) ?\n                (new String[] {}) : projection);\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n                    selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return emptyCursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, (\"thread_id=\" + threadId));\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(projection, selection, sortOrder,\n                        smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase(Locale.ROOT) : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        if (matchIndex == URI_PENDING_MSG) {\n            int subId;\n            if (values.containsKey(PendingMessages.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(PendingMessages.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(PendingMessages.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                    callerUid, getCallingPackage());\n                return null;\n            }\n\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            return null;\n        }\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        } else if (METHOD_GARBAGE_COLLECT.equals(method)) {\n            Bundle result = new Bundle();\n            boolean doDelete = TextUtils.equals(DO_DELETE, arg);\n            MmsPartsCleanup.cleanupDanglingParts(getContext(), doDelete, result);\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    // Call() methods and parameters\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n    private static final String METHOD_GARBAGE_COLLECT = \"garbage_collect\";\n    private static final String DO_DELETE = \"delete\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        Cursor emptyCursor = new MatrixCursor((projection == null) ?\n                (new String[] {}) : projection);\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n                    selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return emptyCursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, (\"thread_id=\" + threadId));\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(projection, selection, sortOrder,\n                        smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase(Locale.ROOT) : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                // TODO (b/256992531): Currently, one sim card is set as default sms subId in work\n                //  profile. Default sms subId should be updated based on user pref.\n                int subId = SmsManager.getDefaultSmsSubscriptionId();\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n                contentValues.put(CanonicalAddressesColumns.SUBSCRIPTION_ID, subId);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", sub_id=\" + subId + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        // TODO (b/256992531): Currently, one sim card is set as default sms subId in work\n        //  profile. Default sms subId should be updated based on user pref.\n        values.put(ThreadsColumns.SUBSCRIPTION_ID, SmsManager.getDefaultSmsSubscriptionId());\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        // TODO (b/256992531): Currently, one sim card is set as default sms subId in work\n        //  profile. Default sms subId should be updated based on user pref.\n        int defaultSmsSubId = SmsManager.getDefaultSmsSubscriptionId();\n        if (matchIndex == URI_PENDING_MSG) {\n            int subId;\n            if (values.containsKey(PendingMessages.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(PendingMessages.SUBSCRIPTION_ID);\n            } else {\n                subId = defaultSmsSubId;\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(PendingMessages.SUBSCRIPTION_ID, subId);\n                }\n            }\n\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                        callerUid, getCallingPackage());\n                return null;\n            }\n\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            if (!values.containsKey(CanonicalAddressesColumns.SUBSCRIPTION_ID)) {\n                if (SubscriptionManager.isValidSubscriptionId(defaultSmsSubId)) {\n                    values.put(CanonicalAddressesColumns.SUBSCRIPTION_ID, defaultSmsSubId);\n                }\n            }\n\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            return null;\n        }\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        } else if (METHOD_GARBAGE_COLLECT.equals(method)) {\n            Bundle result = new Bundle();\n            boolean doDelete = TextUtils.equals(DO_DELETE, arg);\n            MmsPartsCleanup.cleanupDanglingParts(getContext(), doDelete, result);\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","lineNo":1449}
{"Smelly Sample":"/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.content.ComponentName;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Process;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Telephony;\nimport android.telephony.SubscriptionInfo;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.emergency.EmergencyNumber;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.SmsApplication;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * Helpers\n */\npublic class ProviderUtil {\n    private final static String TAG = \"SmsProvider\";\n\n    /**\n     * Check if a caller of the provider has restricted access,\n     * i.e. being non-system, non-phone, non-default SMS app\n     *\n     * @param context the context to use\n     * @param packageName the caller package name\n     * @param uid the caller uid\n     * @return true if the caller is not system, or phone or default sms app, false otherwise\n     */\n    public static boolean isAccessRestricted(Context context, String packageName, int uid) {\n        return (uid != Process.SYSTEM_UID\n                && uid != Process.PHONE_UID\n                && !SmsApplication.isDefaultSmsApplication(context, packageName));\n    }\n\n    /**\n     * Whether should set CREATOR for an insertion\n     *\n     * @param values The content of the message\n     * @param uid The caller UID of the insertion\n     * @return true if we should set CREATOR, false otherwise\n     */\n    public static boolean shouldSetCreator(ContentValues values, int uid) {\n        return (uid != Process.SYSTEM_UID && uid != Process.PHONE_UID) ||\n                (!values.containsKey(Telephony.Sms.CREATOR) &&\n                        !values.containsKey(Telephony.Mms.CREATOR));\n    }\n\n    /**\n     * Whether should remove CREATOR for an update\n     *\n     * @param values The content of the message\n     * @param uid The caller UID of the update\n     * @return true if we should remove CREATOR, false otherwise\n     */\n    public static boolean shouldRemoveCreator(ContentValues values, int uid) {\n        return (uid != Process.SYSTEM_UID && uid != Process.PHONE_UID) &&\n                (values.containsKey(Telephony.Sms.CREATOR) ||\n                        values.containsKey(Telephony.Mms.CREATOR));\n    }\n\n    /**\n     * Notify the default SMS app of an SMS/MMS provider change if the change is being made\n     * by a package other than the default SMS app itself.\n     *\n     * @param uri The uri the provider change applies to\n     * @param callingPackage The package name of the provider caller\n     * @param Context\n     */\n    public static void notifyIfNotDefaultSmsApp(final Uri uri, final String callingPackage,\n            final Context context) {\n        if (TextUtils.equals(callingPackage, Telephony.Sms.getDefaultSmsPackage(context))) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"notifyIfNotDefaultSmsApp - called from default sms app\");\n            }\n            return;\n        }\n        // Direct the intent to only the default SMS app, and only if the SMS app has a receiver\n        // for the intent.\n        ComponentName componentName =\n                SmsApplication.getDefaultExternalTelephonyProviderChangedApplication(context, true);\n        if (componentName == null) {\n            return;     // the default sms app doesn't have a receiver for this intent\n        }\n\n        final Intent intent =\n                new Intent(Telephony.Sms.Intents.ACTION_EXTERNAL_PROVIDER_CHANGE);\n        intent.setFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);\n        intent.setComponent(componentName);\n        if (uri != null) {\n            intent.setData(uri);\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"notifyIfNotDefaultSmsApp - called from \" + callingPackage + \", notifying\");\n        }\n        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        context.sendBroadcast(intent);\n    }\n\n    public static Context getCredentialEncryptedContext(Context context) {\n        if (context.isCredentialProtectedStorage()) {\n            return context;\n        }\n        return context.createCredentialProtectedStorageContext();\n    }\n\n    public static Context getDeviceEncryptedContext(Context context) {\n        if (context.isDeviceProtectedStorage()) {\n            return context;\n        }\n        return context.createDeviceProtectedStorageContext();\n    }\n\n    /**\n     * Get subscriptions associated with the user in the format of a selection string.\n     * @param context context\n     * @param userHandle caller user handle.\n     * @return subscriptions associated with the user in the format of a selection string\n     * or {@code null} if user is not associated with any subscription.\n     */\n    @Nullable\n    public static String getSelectionBySubIds(Context context, @NonNull UserHandle userHandle) {\n        List<SubscriptionInfo> associatedSubscriptionsList = new ArrayList<>();\n        SubscriptionManager subManager = context.getSystemService(SubscriptionManager.class);\n        if (subManager != null) {\n            // Get list of subscriptions associated with this user.\n            associatedSubscriptionsList = subManager\n                    .getSubscriptionInfoListAssociatedWithUser(userHandle);\n        }\n\n        UserManager userManager = context.getSystemService(UserManager.class);\n        if ((userManager != null) && (!userManager.isManagedProfile(userHandle.getIdentifier()))) {\n            // SMS/MMS restored from another device have sub_id=-1.\n            // To query/update/delete those messages, sub_id=-1 should be in the selection string.\n            SubscriptionInfo invalidSubInfo = new SubscriptionInfo.Builder()\n                    .setId(SubscriptionManager.INVALID_SUBSCRIPTION_ID)\n                    .build();\n            associatedSubscriptionsList.add(invalidSubInfo);\n        }\n\n        if (associatedSubscriptionsList.isEmpty()) {\n            return null;\n        }\n\n        // Converts [1,2,3,4,-1] to \"'1','2','3','4','-1'\" so that it can be appended to\n        // selection string\n        String subIdListStr = associatedSubscriptionsList.stream()\n                .map(subInfo -> (\"'\" + subInfo.getSubscriptionId() + \"'\"))\n                .collect(Collectors.joining(\",\"));\n        return (Telephony.Sms.SUBSCRIPTION_ID + \" IN (\" + subIdListStr + \")\");\n    }\n\n    /**\n     * Get emergency number list in the format of a selection string.\n     * @param context context\n     * @return emergency number list in the format of a selection string\n     * or {@code null} if emergency number list is empty.\n     */\n    @Nullable\n    public static String getSelectionByEmergencyNumbers(@NonNull Context context) {\n        // Get emergency number list to add it to selection string.\n        TelephonyManager tm = context.getSystemService(TelephonyManager.class);\n        Map<Integer, List<EmergencyNumber>> emergencyNumberList = null;\n        if (tm != null) {\n            emergencyNumberList = tm.getEmergencyNumberList();\n        }\n\n        String selectionByEmergencyNumber = null;\n        if (emergencyNumberList != null && !emergencyNumberList.isEmpty()) {\n            String emergencyNumberListStr = \"\";\n            for (Map.Entry<Integer, List<EmergencyNumber>> entry : emergencyNumberList.entrySet()) {\n                if (!emergencyNumberListStr.isEmpty() && !entry.getValue().isEmpty()) {\n                    emergencyNumberListStr += ',';\n                }\n\n                emergencyNumberListStr += entry.getValue().stream()\n                        .map(emergencyNumber -> (\"'\" + emergencyNumber.getNumber() + \"'\"))\n                        .collect(Collectors.joining(\",\"));\n            }\n            selectionByEmergencyNumber = Telephony.Sms.ADDRESS +\n                    \" IN (\" + emergencyNumberListStr + \")\";\n        }\n        return selectionByEmergencyNumber;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.content.ComponentName;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Process;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Telephony;\nimport android.telephony.SubscriptionInfo;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.emergency.EmergencyNumber;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.SmsApplication;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * Helpers\n */\npublic class ProviderUtil {\n    private final static String TAG = \"SmsProvider\";\n\n    /**\n     * Check if a caller of the provider has restricted access,\n     * i.e. being non-system, non-phone, non-default SMS app\n     *\n     * @param context the context to use\n     * @param packageName the caller package name\n     * @param uid the caller uid\n     * @return true if the caller is not system, or phone or default sms app, false otherwise\n     */\n    public static boolean isAccessRestricted(Context context, String packageName, int uid) {\n        return (uid != Process.SYSTEM_UID\n                && uid != Process.PHONE_UID\n                && !SmsApplication.isDefaultSmsApplication(context, packageName));\n    }\n\n    /**\n     * Whether should set CREATOR for an insertion\n     *\n     * @param values The content of the message\n     * @param uid The caller UID of the insertion\n     * @return true if we should set CREATOR, false otherwise\n     */\n    public static boolean shouldSetCreator(ContentValues values, int uid) {\n        return (uid != Process.SYSTEM_UID && uid != Process.PHONE_UID) ||\n                (!values.containsKey(Telephony.Sms.CREATOR) &&\n                        !values.containsKey(Telephony.Mms.CREATOR));\n    }\n\n    /**\n     * Whether should remove CREATOR for an update\n     *\n     * @param values The content of the message\n     * @param uid The caller UID of the update\n     * @return true if we should remove CREATOR, false otherwise\n     */\n    public static boolean shouldRemoveCreator(ContentValues values, int uid) {\n        return (uid != Process.SYSTEM_UID && uid != Process.PHONE_UID) &&\n                (values.containsKey(Telephony.Sms.CREATOR) ||\n                        values.containsKey(Telephony.Mms.CREATOR));\n    }\n\n    /**\n     * Notify the default SMS app of an SMS/MMS provider change if the change is being made\n     * by a package other than the default SMS app itself.\n     *\n     * @param uri The uri the provider change applies to\n     * @param callingPackage The package name of the provider caller\n     * @param Context\n     */\n    public static void notifyIfNotDefaultSmsApp(final Uri uri, final String callingPackage,\n            final Context context) {\n        if (TextUtils.equals(callingPackage, Telephony.Sms.getDefaultSmsPackage(context))) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"notifyIfNotDefaultSmsApp - called from default sms app\");\n            }\n            return;\n        }\n        // Direct the intent to only the default SMS app, and only if the SMS app has a receiver\n        // for the intent.\n        ComponentName componentName =\n                SmsApplication.getDefaultExternalTelephonyProviderChangedApplication(context, true);\n        if (componentName == null) {\n            return;     // the default sms app doesn't have a receiver for this intent\n        }\n\n        final Intent intent =\n                new Intent(Telephony.Sms.Intents.ACTION_EXTERNAL_PROVIDER_CHANGE);\n        intent.setFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);\n        intent.setComponent(componentName);\n        if (uri != null) {\n            intent.setData(uri);\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"notifyIfNotDefaultSmsApp - called from \" + callingPackage + \", notifying\");\n        }\n        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        context.sendBroadcast(intent);\n    }\n\n    public static Context getCredentialEncryptedContext(Context context) {\n        if (context.isCredentialProtectedStorage()) {\n            return context;\n        }\n        return context.createCredentialProtectedStorageContext();\n    }\n\n    public static Context getDeviceEncryptedContext(Context context) {\n        if (context.isDeviceProtectedStorage()) {\n            return context;\n        }\n        return context.createDeviceProtectedStorageContext();\n    }\n\n    /**\n     * Get subscriptions associated with the user in the format of a selection string.\n     * @param context context\n     * @param userHandle caller user handle.\n     * @return subscriptions associated with the user in the format of a selection string\n     * or {@code null} if user is not associated with any subscription.\n     */\n    @Nullable\n    public static String getSelectionBySubIds(Context context, @NonNull UserHandle userHandle) {\n        List<SubscriptionInfo> associatedSubscriptionsList = new ArrayList<>();\n        SubscriptionManager subManager = context.getSystemService(SubscriptionManager.class);\n        if (subManager != null) {\n            // Get list of subscriptions associated with this user.\n            associatedSubscriptionsList = subManager\n                    .getSubscriptionInfoListAssociatedWithUser(userHandle);\n        }\n\n        UserManager userManager = context.getSystemService(UserManager.class);\n        if ((userManager != null) && (!userManager.isManagedProfile(userHandle.getIdentifier()))) {\n            // SMS/MMS restored from another device have sub_id=-1.\n            // To query/update/delete those messages, sub_id=-1 should be in the selection string.\n            SubscriptionInfo invalidSubInfo = new SubscriptionInfo.Builder()\n                    .setId(SubscriptionManager.INVALID_SUBSCRIPTION_ID)\n                    .build();\n            associatedSubscriptionsList.add(invalidSubInfo);\n        }\n\n        if (associatedSubscriptionsList.isEmpty()) {\n            return null;\n        }\n\n        // Converts [1,2,3,4,-1] to \"'1','2','3','4','-1'\" so that it can be appended to\n        // selection string\n        String subIdListStr = associatedSubscriptionsList.stream()\n                .map(subInfo -> (\"'\" + subInfo.getSubscriptionId() + \"'\"))\n                .collect(Collectors.joining(\",\"));\n        String selectionBySubId = (Telephony.Sms.SUBSCRIPTION_ID + \" IN (\" + subIdListStr + \")\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"getSelectionBySubIds: \" + selectionBySubId);\n        }\n        return selectionBySubId;\n    }\n\n    /**\n     * Get emergency number list in the format of a selection string.\n     * @param context context\n     * @return emergency number list in the format of a selection string\n     * or {@code null} if emergency number list is empty.\n     */\n    @Nullable\n    public static String getSelectionByEmergencyNumbers(@NonNull Context context) {\n        // Get emergency number list to add it to selection string.\n        TelephonyManager tm = context.getSystemService(TelephonyManager.class);\n        Map<Integer, List<EmergencyNumber>> emergencyNumberList = null;\n        if (tm != null) {\n            emergencyNumberList = tm.getEmergencyNumberList();\n        }\n\n        String selectionByEmergencyNumber = null;\n        if (emergencyNumberList != null && !emergencyNumberList.isEmpty()) {\n            String emergencyNumberListStr = \"\";\n            for (Map.Entry<Integer, List<EmergencyNumber>> entry : emergencyNumberList.entrySet()) {\n                if (!emergencyNumberListStr.isEmpty() && !entry.getValue().isEmpty()) {\n                    emergencyNumberListStr += ',';\n                }\n\n                emergencyNumberListStr += entry.getValue().stream()\n                        .map(emergencyNumber -> (\"'\" + emergencyNumber.getNumber() + \"'\"))\n                        .collect(Collectors.joining(\",\"));\n            }\n            selectionByEmergencyNumber = Telephony.Sms.ADDRESS +\n                    \" IN (\" + emergencyNumberListStr + \")\";\n        }\n        return selectionByEmergencyNumber;\n    }\n}\n","lineNo":180}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.Mms.Addr;\nimport android.provider.Telephony.Mms.Part;\nimport android.provider.Telephony.Mms.Rate;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Threads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\n\nimport com.google.android.mms.pdu.PduHeaders;\nimport com.google.android.mms.util.DownloadDrmHelper;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * The class to provide base facility to access MMS related content,\n * which is stored in a SQLite database and in the file system.\n */\npublic class MmsProvider extends ContentProvider {\n    static final String TABLE_PDU  = \"pdu\";\n    static final String TABLE_ADDR = \"addr\";\n    static final String TABLE_PART = \"part\";\n    static final String TABLE_RATE = \"rate\";\n    static final String TABLE_DRM  = \"drm\";\n    static final String TABLE_WORDS = \"words\";\n    static final String VIEW_PDU_RESTRICTED = \"pdu_restricted\";\n\n    // The name of parts directory. The full dir is \"app_parts\".\n    static final String PARTS_DIR_NAME = \"parts\";\n\n    private ProviderUtilWrapper providerUtilWrapper = new ProviderUtilWrapper();\n\n    @VisibleForTesting\n    public void setProviderUtilWrapper(ProviderUtilWrapper providerUtilWrapper) {\n        this.providerUtilWrapper = providerUtilWrapper;\n    }\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    // wrapper class to allow easier mocking of the static ProviderUtil in tests\n    @VisibleForTesting\n    public static class ProviderUtilWrapper {\n        public boolean isAccessRestricted(Context context, String packageName, int uid) {\n            return ProviderUtil.isAccessRestricted(context, packageName, uid);\n        }\n    }\n\n    /**\n     * Return the proper view of \"pdu\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the mms data\n     */\n    public static String getPduTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_PDU_RESTRICTED : TABLE_PDU;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        // First check if a restricted view of the \"pdu\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n        }\n\n        final String pduTable = getPduTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Query uri=\" + uri + \", match=\" + match);\n        }\n\n        switch (match) {\n            case MMS_ALL:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_ALL, pduTable);\n                break;\n            case MMS_INBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_INBOX, pduTable);\n                break;\n            case MMS_SENT:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_SENT, pduTable);\n                break;\n            case MMS_DRAFTS:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_DRAFTS, pduTable);\n                break;\n            case MMS_OUTBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_OUTBOX, pduTable);\n                break;\n            case MMS_ALL_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(1));\n                qb.appendWhere(\" AND \" + Mms.MESSAGE_BOX + \"=\"\n                        + getMessageBoxByMatch(match));\n                break;\n            case MMS_ALL_PART:\n                qb.setTables(TABLE_PART);\n                break;\n            case MMS_MSG_PART:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_PART_ID:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part._ID + \"=\" + uri.getPathSegments().get(1));\n                break;\n            case MMS_MSG_ADDR:\n                qb.setTables(TABLE_ADDR);\n                qb.appendWhere(Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_REPORT_STATUS:\n                /*\n                   SELECT DISTINCT address,\n                                   T.delivery_status AS delivery_status,\n                                   T.read_status AS read_status\n                   FROM addr\n                   INNER JOIN (SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134\n                               LEFT JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               UNION\n                               SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               LEFT JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134) T\n                   ON (msg_id = id2 AND type = 151)\n                   OR (msg_id = id3 AND type = 137)\n                   WHERE T.id1 = ?;\n                 */\n                qb.setTables(TABLE_ADDR + \" INNER JOIN \"\n                        + \"(SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134 \"\n                        + \"LEFT JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"UNION \"\n                        + \"SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"LEFT JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134) T \"\n                        + \"ON (msg_id=id2 AND type=151) OR (msg_id=id3 AND type=137)\");\n                qb.appendWhere(\"T.id1 = \" + uri.getLastPathSegment());\n                qb.setDistinct(true);\n                break;\n            case MMS_REPORT_REQUEST:\n                /*\n                   SELECT address, d_rpt, rr\n                   FROM addr join pdu on pdu._id = addr.msg_id\n                   WHERE pdu._id = messageId AND addr.type = 151\n                 */\n                qb.setTables(TABLE_ADDR + \" join \" +\n                        pduTable + \" on \" + pduTable + \"._id = addr.msg_id\");\n                qb.appendWhere(pduTable + \"._id = \" + uri.getLastPathSegment());\n                qb.appendWhere(\" AND \" + TABLE_ADDR + \".type = \" + PduHeaders.TO);\n                break;\n            case MMS_SENDING_RATE:\n                qb.setTables(TABLE_RATE);\n                break;\n            case MMS_DRM_STORAGE_ID:\n                qb.setTables(TABLE_DRM);\n                qb.appendWhere(BaseColumns._ID + \"=\" + uri.getLastPathSegment());\n                break;\n            case MMS_THREADS:\n                qb.setTables(pduTable + \" group by thread_id\");\n                break;\n            default:\n                Log.e(TAG, \"query: invalid request: \" + uri);\n                return null;\n        }\n\n        String finalSortOrder = null;\n        if (TextUtils.isEmpty(sortOrder)) {\n            if (qb.getTables().equals(pduTable)) {\n                finalSortOrder = Mms.DATE + \" DESC\";\n            } else if (qb.getTables().equals(TABLE_PART)) {\n                finalSortOrder = Part.SEQ;\n            }\n        } else {\n            finalSortOrder = sortOrder;\n        }\n\n        Cursor ret;\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            ret = qb.query(db, projection, selection,\n                    selectionArgs, null, null, finalSortOrder);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"returning NULL cursor, query: \" + uri, e);\n            return null;\n        }\n\n        // TODO: Does this need to be a URI for this provider.\n        ret.setNotificationUri(getContext().getContentResolver(), uri);\n        return ret;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int msgBox, String pduTable) {\n        qb.setTables(pduTable);\n\n        if (msgBox != Mms.MESSAGE_BOX_ALL) {\n            qb.appendWhere(Mms.MESSAGE_BOX + \"=\" + msgBox);\n        }\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        int match = sURLMatcher.match(uri);\n        switch (match) {\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                return VND_ANDROID_DIR_MMS;\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                return VND_ANDROID_MMS;\n            case MMS_PART_ID: {\n                Cursor cursor = mOpenHelper.getReadableDatabase().query(\n                        TABLE_PART, new String[] { Part.CONTENT_TYPE },\n                        Part._ID + \" = ?\", new String[] { uri.getLastPathSegment() },\n                        null, null, null);\n                if (cursor != null) {\n                    try {\n                        if ((cursor.getCount() == 1) && cursor.moveToFirst()) {\n                            return cursor.getString(0);\n                        } else {\n                            Log.e(TAG, \"cursor.count() != 1: \" + uri);\n                        }\n                    } finally {\n                        cursor.close();\n                    }\n                } else {\n                    Log.e(TAG, \"cursor == null: \" + uri);\n                }\n                return \"*/*\";\n            }\n            case MMS_ALL_PART:\n            case MMS_MSG_PART:\n            case MMS_MSG_ADDR:\n            default:\n                return \"*/*\";\n        }\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int msgBox = Mms.MESSAGE_BOX_ALL;\n        boolean notify = true;\n\n        boolean forceNoNotify = values.containsKey(TelephonyBackupAgent.NOTIFY)\n                && !values.getAsBoolean(TelephonyBackupAgent.NOTIFY);\n        values.remove(TelephonyBackupAgent.NOTIFY);\n        // check isAccessRestricted to prevent third parties from setting NOTIFY = false maliciously\n        if (forceNoNotify && !providerUtilWrapper.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            notify = false;\n        }\n\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Insert uri=\" + uri + \", match=\" + match);\n        }\n\n        String table = TABLE_PDU;\n        switch (match) {\n            case MMS_ALL:\n                Object msgBoxObj = values.getAsInteger(Mms.MESSAGE_BOX);\n                if (msgBoxObj != null) {\n                    msgBox = (Integer) msgBoxObj;\n                }\n                else {\n                    // default to inbox\n                    msgBox = Mms.MESSAGE_BOX_INBOX;\n                }\n                break;\n            case MMS_INBOX:\n                msgBox = Mms.MESSAGE_BOX_INBOX;\n                break;\n            case MMS_SENT:\n                msgBox = Mms.MESSAGE_BOX_SENT;\n                break;\n            case MMS_DRAFTS:\n                msgBox = Mms.MESSAGE_BOX_DRAFTS;\n                break;\n            case MMS_OUTBOX:\n                msgBox = Mms.MESSAGE_BOX_OUTBOX;\n                break;\n            case MMS_MSG_PART:\n                notify = false;\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_ADDR:\n                notify = false;\n                table = TABLE_ADDR;\n                break;\n            case MMS_SENDING_RATE:\n                notify = false;\n                table = TABLE_RATE;\n                break;\n            case MMS_DRM_STORAGE:\n                notify = false;\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.e(TAG, \"insert: invalid request: \" + uri);\n                return null;\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        ContentValues finalValues;\n        Uri res = Mms.CONTENT_URI;\n        Uri caseSpecificUri = null;\n        long rowId;\n\n        if (table.equals(TABLE_PDU)) {\n            boolean addDate = !values.containsKey(Mms.DATE);\n            boolean addMsgBox = !values.containsKey(Mms.MESSAGE_BOX);\n\n            // Filter keys we don't support yet.\n            filterUnsupportedKeys(values);\n\n            // TODO: Should initialValues be validated, e.g. if it\n            // missed some significant keys?\n            finalValues = new ContentValues(values);\n\n            long timeInMillis = System.currentTimeMillis();\n\n            if (addDate) {\n                finalValues.put(Mms.DATE, timeInMillis / 1000L);\n            }\n\n            if (addMsgBox && (msgBox != Mms.MESSAGE_BOX_ALL)) {\n                finalValues.put(Mms.MESSAGE_BOX, msgBox);\n            }\n\n            if (msgBox != Mms.MESSAGE_BOX_INBOX) {\n                // Mark all non-inbox messages read.\n                finalValues.put(Mms.READ, 1);\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Mms.THREAD_ID);\n            String address = values.getAsString(CanonicalAddressesColumns.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                finalValues.put(Mms.THREAD_ID, Threads.getOrCreateThreadId(getContext(), address));\n            }\n\n            if (ProviderUtil.shouldSetCreator(finalValues, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                finalValues.put(Telephony.Mms.CREATOR, callerPkg);\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            // Notify change when an MMS is received.\n            if (msgBox == Mms.MESSAGE_BOX_INBOX) {\n                caseSpecificUri = ContentUris.withAppendedId(Mms.Inbox.CONTENT_URI, rowId);\n            }\n\n            res = Uri.parse(res + \"/\" + rowId);\n        } else if (table.equals(TABLE_ADDR)) {\n            finalValues = new ContentValues(values);\n            finalValues.put(Addr.MSG_ID, uri.getPathSegments().get(0));\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"Failed to insert address\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/addr/\" + rowId);\n        } else if (table.equals(TABLE_PART)) {\n            boolean containsDataPath = values != null && values.containsKey(Part._DATA);\n            finalValues = new ContentValues(values);\n\n            if (match == MMS_MSG_PART) {\n                finalValues.put(Part.MSG_ID, uri.getPathSegments().get(0));\n            }\n\n            String contentType = values.getAsString(\"ct\");\n\n            // text/plain and app application/smil store their \"data\" inline in the\n            // table so there's no need to create the file\n            boolean plainText = false;\n            boolean smilText = false;\n            if (\"text/plain\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert text/plain with _data\");\n                    return null;\n                }\n                plainText = true;\n            } else if (\"application/smil\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert application/smil with _data\");\n                    return null;\n                }\n                smilText = true;\n            }\n            if (!plainText && !smilText) {\n                String path;\n                if (containsDataPath) {\n                    // The _data column is filled internally in MmsProvider or from the\n                    // TelephonyBackupAgent, so this check is just to avoid it from being\n                    // inadvertently set. This is not supposed to be a protection against malicious\n                    // attack, since sql injection could still be attempted to bypass the check.\n                    // On the other hand, the MmsProvider does verify that the _data column has an\n                    // allowed value before opening any uri/files.\n                    if (!\"com.android.providers.telephony\".equals(callerPkg)) {\n                        Log.e(TAG, \"insert: can't insert _data\");\n                        return null;\n                    }\n                    try {\n                        path = values.getAsString(Part._DATA);\n                        final String partsDirPath = getContext()\n                                .getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                        if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                            Log.e(TAG, \"insert: path \"\n                                    + path\n                                    + \" does not start with \"\n                                    + partsDirPath);\n                            // Don't care return value\n                            return null;\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"insert part: create path failed \" + e, e);\n                        return null;\n                    }\n                } else {\n                    // Use the filename if possible, otherwise use the current time as the name.\n                    String contentLocation = values.getAsString(\"cl\");\n                    if (!TextUtils.isEmpty(contentLocation)) {\n                        File f = new File(contentLocation);\n                        contentLocation = \"_\" + f.getName();\n                    } else {\n                        contentLocation = \"\";\n                    }\n\n                    // Generate the '_data' field of the part with default\n                    // permission settings.\n                    path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                            + \"/PART_\" + System.currentTimeMillis() + contentLocation;\n\n                    if (DownloadDrmHelper.isDrmConvertNeeded(contentType)) {\n                        // Adds the .fl extension to the filename if contentType is\n                        // \"application/vnd.oma.drm.message\"\n                        path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n                    }\n                }\n\n                finalValues.put(Part._DATA, path);\n\n                File partFile = new File(path);\n                if (!partFile.exists()) {\n                    try {\n                        if (!partFile.createNewFile()) {\n                            throw new IllegalStateException(\n                                    \"Unable to create new partFile: \" + path);\n                        }\n                        // Give everyone rw permission until we encrypt the file\n                        // (in PduPersister.persistData). Once the file is encrypted, the\n                        // permissions will be set to 0644.\n                        try {\n                            Os.chmod(path, 0666);\n                            if (LOCAL_LOGV) {\n                                Log.d(TAG, \"MmsProvider.insert chmod is successful\");\n                            }\n                        } catch (ErrnoException e) {\n                            Log.e(TAG, \"Exception in chmod: \" + e);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"createNewFile\", e);\n                        throw new IllegalStateException(\n                                \"Unable to create new partFile: \" + path);\n                    }\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/part/\" + rowId);\n\n            // Don't use a trigger for updating the words table because of a bug\n            // in FTS3.  The bug is such that the call to get the last inserted\n            // row is incorrect.\n            if (plainText) {\n                // Update the words table with a corresponding row.  The words table\n                // allows us to search for words quickly, without scanning the whole\n                // table;\n                ContentValues cv = new ContentValues();\n\n                // we're using the row id of the part table row but we're also using ids\n                // from the sms table so this divides the space into two large chunks.\n                // The row ids from the part table start at 2 << 32.\n                cv.put(Telephony.MmsSms.WordsTable.ID, (2L << 32) + rowId);\n                cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"text\"));\n                cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowId);\n                cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 2);\n                db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n            }\n\n        } else if (table.equals(TABLE_RATE)) {\n            long now = values.getAsLong(Rate.SENT_TIME);\n            long oneHourAgo = now - 1000 * 60 * 60;\n            // Delete all unused rows (time earlier than one hour ago).\n            db.delete(table, Rate.SENT_TIME + \"<=\" + oneHourAgo, null);\n            db.insert(table, null, values);\n        } else if (table.equals(TABLE_DRM)) {\n            String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                    + \"/PART_\" + System.currentTimeMillis();\n            finalValues = new ContentValues(1);\n            finalValues.put(\"_data\", path);\n\n            File partFile = new File(path);\n            if (!partFile.exists()) {\n                try {\n                    if (!partFile.createNewFile()) {\n                        throw new IllegalStateException(\n                                \"Unable to create new file: \" + path);\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"createNewFile\", e);\n                    throw new IllegalStateException(\n                            \"Unable to create new file: \" + path);\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n            res = Uri.parse(res + \"/drm/\" + rowId);\n        } else {\n            throw new AssertionError(\"Unknown table type: \" + table);\n        }\n\n        if (notify) {\n            notifyChange(res, caseSpecificUri);\n        }\n        return res;\n    }\n\n    private int getMessageBoxByMatch(int match) {\n        switch (match) {\n            case MMS_INBOX_ID:\n            case MMS_INBOX:\n                return Mms.MESSAGE_BOX_INBOX;\n            case MMS_SENT_ID:\n            case MMS_SENT:\n                return Mms.MESSAGE_BOX_SENT;\n            case MMS_DRAFTS_ID:\n            case MMS_DRAFTS:\n                return Mms.MESSAGE_BOX_DRAFTS;\n            case MMS_OUTBOX_ID:\n            case MMS_OUTBOX:\n                return Mms.MESSAGE_BOX_OUTBOX;\n            default:\n                throw new IllegalArgumentException(\"bad Arg: \" + match);\n        }\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Delete uri=\" + uri + \", match=\" + match);\n        }\n\n        String table, extraSelection = null;\n        boolean notify = false;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                notify = true;\n                table = TABLE_PDU;\n                extraSelection = Mms._ID + \"=\" + uri.getLastPathSegment();\n                break;\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                if (match != MMS_ALL) {\n                    int msgBox = getMessageBoxByMatch(match);\n                    extraSelection = Mms.MESSAGE_BOX + \"=\" + msgBox;\n                }\n                break;\n            case MMS_ALL_PART:\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_PART:\n                table = TABLE_PART;\n                extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                break;\n            case MMS_MSG_ADDR:\n                table = TABLE_ADDR;\n                extraSelection = Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_DRM_STORAGE:\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.w(TAG, \"No match for URI '\" + uri + \"'\");\n                return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int deletedRows = 0;\n\n        if (TABLE_PDU.equals(table)) {\n            deletedRows = deleteMessages(getContext(), db, finalSelection,\n                                         selectionArgs, uri);\n        } else if (TABLE_PART.equals(table)) {\n            deletedRows = deleteParts(db, finalSelection, selectionArgs);\n        } else if (TABLE_DRM.equals(table)) {\n            deletedRows = deleteTempDrmData(db, finalSelection, selectionArgs);\n        } else {\n            deletedRows = db.delete(table, finalSelection, selectionArgs);\n        }\n\n        if ((deletedRows > 0) && notify) {\n            notifyChange(uri, null);\n        }\n        return deletedRows;\n    }\n\n    static int deleteMessages(Context context, SQLiteDatabase db,\n            String selection, String[] selectionArgs, Uri uri) {\n        Cursor cursor = db.query(TABLE_PDU, new String[] { Mms._ID },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                deleteParts(db, Part.MSG_ID + \" = ?\",\n                        new String[] { String.valueOf(cursor.getLong(0)) });\n            }\n        } finally {\n            cursor.close();\n        }\n\n        int count = db.delete(TABLE_PDU, selection, selectionArgs);\n        if (count > 0) {\n            Intent intent = new Intent(Mms.Intents.CONTENT_CHANGED_ACTION);\n            intent.putExtra(Mms.Intents.DELETED_CONTENTS, uri);\n            if (LOCAL_LOGV) {\n                Log.v(TAG, \"Broadcasting intent: \" + intent);\n            }\n            context.sendBroadcast(intent);\n        }\n        return count;\n    }\n\n    private static int deleteParts(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_PART, selection, selectionArgs);\n    }\n\n    private static int deleteTempDrmData(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_DRM, selection, selectionArgs);\n    }\n\n    private static int deleteDataRows(SQLiteDatabase db, String table,\n            String selection, String[] selectionArgs) {\n        Cursor cursor = db.query(table, new String[] { \"_data\" },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            // FIXME: This might be an error, ignore it may cause\n            // unpredictable result.\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                try {\n                    // Delete the associated files saved on file-system.\n                    String path = cursor.getString(0);\n                    if (path != null) {\n                        new File(path).delete();\n                    }\n                } catch (Throwable ex) {\n                    Log.e(TAG, ex.getMessage(), ex);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return db.delete(table, selection, selectionArgs);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        // The _data column is filled internally in MmsProvider, so this check is just to avoid\n        // it from being inadvertently set. This is not supposed to be a protection against\n        // malicious attack, since sql injection could still be attempted to bypass the check. On\n        // the other hand, the MmsProvider does verify that the _data column has an allowed value\n        // before opening any uri/files.\n        if (values != null && values.containsKey(Part._DATA)) {\n            return 0;\n        }\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Update uri=\" + uri + \", match=\" + match);\n        }\n\n        boolean notify = false;\n        String msgId = null;\n        String table;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                msgId = uri.getLastPathSegment();\n            // fall-through\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                break;\n\n            case MMS_MSG_PART:\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                break;\n\n            case MMS_PART_RESET_FILE_PERMISSION:\n                String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath() + '/' +\n                        uri.getPathSegments().get(1);\n\n                try {\n                    String partsDirPath = getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                    if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                        EventLog.writeEvent(0x534e4554, \"240685104\",\n                                Binder.getCallingUid(), (TAG + \" update: path \" + path +\n                                        \" does not start with \" + partsDirPath));\n                        return 0;\n                    }\n                    // Reset the file permission back to read for everyone but me.\n                    Os.chmod(path, 0644);\n                    if (LOCAL_LOGV) {\n                        Log.d(TAG, \"MmsProvider.update chmod is successful for path: \" + path);\n                    }\n                } catch (ErrnoException | IOException e) {\n                    Log.e(TAG, \"Exception in chmod: \" + e);\n                }\n                return 0;\n\n            default:\n                Log.w(TAG, \"Update operation for '\" + uri + \"' not implemented.\");\n                return 0;\n        }\n\n        String extraSelection = null;\n        ContentValues finalValues;\n        if (table.equals(TABLE_PDU)) {\n            // Filter keys that we don't support yet.\n            filterUnsupportedKeys(values);\n            if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n                // CREATOR should not be changed by non-SYSTEM/PHONE apps\n                Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n                values.remove(Mms.CREATOR);\n            }\n            finalValues = new ContentValues(values);\n\n            if (msgId != null) {\n                extraSelection = Mms._ID + \"=\" + msgId;\n            }\n        } else if (table.equals(TABLE_PART)) {\n            finalValues = new ContentValues(values);\n\n            switch (match) {\n                case MMS_MSG_PART:\n                    extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                    break;\n                case MMS_PART_ID:\n                    extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count = db.update(table, finalValues, finalSelection, selectionArgs);\n        if (notify && (count > 0)) {\n            notifyChange(uri, null);\n        }\n        return count;\n    }\n\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        int match = sURLMatcher.match(uri);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"openFile: uri=\" + uri + \", mode=\" + mode + \", match=\" + match);\n        }\n\n        if (match != MMS_PART_ID) {\n            return null;\n        }\n\n        return safeOpenFileHelper(uri, mode);\n    }\n\n    @NonNull\n    private ParcelFileDescriptor safeOpenFileHelper(\n            @NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {\n        Cursor c = query(uri, new String[]{\"_data\"}, null, null, null);\n        int count = (c != null) ? c.getCount() : 0;\n        if (count != 1) {\n            // If there is not exactly one result, throw an appropriate\n            // exception.\n            if (c != null) {\n                c.close();\n            }\n            if (count == 0) {\n                throw new FileNotFoundException(\"No entry for \" + uri);\n            }\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        c.moveToFirst();\n        int i = c.getColumnIndex(\"_data\");\n        String path = (i >= 0 ? c.getString(i) : null);\n        c.close();\n\n        if (path == null) {\n            throw new FileNotFoundException(\"Column _data not found.\");\n        }\n\n        File filePath = new File(path);\n        try {\n            // The MmsProvider shouldn't open a file that isn't MMS data, so we verify that the\n            // _data path actually points to MMS data. That safeguards ourselves from callers who\n            // inserted or updated a URI (more specifically the _data column) with disallowed paths.\n            // TODO(afurtado): provide a more robust mechanism to avoid disallowed _data paths to\n            // be inserted/updated in the first place, including via SQL injection.\n            if (!filePath.getCanonicalPath()\n                    .startsWith(getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath())) {\n                Log.e(TAG, \"openFile: path \"\n                        + filePath.getCanonicalPath()\n                        + \" does not start with \"\n                        + getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath());\n                // Don't care return value\n                return null;\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"openFile: create path failed \" + e, e);\n            return null;\n        }\n\n        int modeBits = ParcelFileDescriptor.parseMode(mode);\n        return ParcelFileDescriptor.open(filePath, modeBits);\n    }\n\n    private void filterUnsupportedKeys(ContentValues values) {\n        // Some columns are unsupported.  They should therefore\n        // neither be inserted nor updated.  Filter them out.\n        values.remove(Mms.DELIVERY_TIME_TOKEN);\n        values.remove(Mms.SENDER_VISIBILITY);\n        values.remove(Mms.REPLY_CHARGING);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE_TOKEN);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE);\n        values.remove(Mms.REPLY_CHARGING_ID);\n        values.remove(Mms.REPLY_CHARGING_SIZE);\n        values.remove(Mms.PREVIOUSLY_SENT_BY);\n        values.remove(Mms.PREVIOUSLY_SENT_DATE);\n        values.remove(Mms.STORE);\n        values.remove(Mms.MM_STATE);\n        values.remove(Mms.MM_FLAGS_TOKEN);\n        values.remove(Mms.MM_FLAGS);\n        values.remove(Mms.STORE_STATUS);\n        values.remove(Mms.STORE_STATUS_TEXT);\n        values.remove(Mms.STORED);\n        values.remove(Mms.TOTALS);\n        values.remove(Mms.MBOX_TOTALS);\n        values.remove(Mms.MBOX_TOTALS_TOKEN);\n        values.remove(Mms.QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS_TOKEN);\n        values.remove(Mms.MESSAGE_COUNT);\n        values.remove(Mms.START);\n        values.remove(Mms.DISTRIBUTION_INDICATOR);\n        values.remove(Mms.ELEMENT_DESCRIPTOR);\n        values.remove(Mms.LIMIT);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE_TEXT);\n        values.remove(Mms.STATUS_TEXT);\n        values.remove(Mms.APPLIC_ID);\n        values.remove(Mms.REPLY_APPLIC_ID);\n        values.remove(Mms.AUX_APPLIC_ID);\n        values.remove(Mms.DRM_CONTENT);\n        values.remove(Mms.ADAPTATION_ALLOWED);\n        values.remove(Mms.REPLACE_ID);\n        values.remove(Mms.CANCEL_ID);\n        values.remove(Mms.CANCEL_STATUS);\n\n        // Keys shouldn't be inserted or updated.\n        values.remove(Mms._ID);\n    }\n\n    private void notifyChange(final Uri uri, final Uri caseSpecificUri) {\n        final Context context = getContext();\n        if (caseSpecificUri != null) {\n            context.getContentResolver().notifyChange(\n                caseSpecificUri, null, true, UserHandle.USER_ALL);\n        }\n        context.getContentResolver().notifyChange(\n                MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        ProviderUtil.notifyIfNotDefaultSmsApp(caseSpecificUri == null ? uri : caseSpecificUri,\n                getCallingPackage(), context);\n    }\n\n    private final static String TAG = \"MmsProvider\";\n    private final static String VND_ANDROID_MMS = \"vnd.android/mms\";\n    private final static String VND_ANDROID_DIR_MMS = \"vnd.android-dir/mms\";\n    private final static boolean DEBUG = false;\n    private final static boolean LOCAL_LOGV = false;\n\n    private static final int MMS_ALL                      = 0;\n    private static final int MMS_ALL_ID                   = 1;\n    private static final int MMS_INBOX                    = 2;\n    private static final int MMS_INBOX_ID                 = 3;\n    private static final int MMS_SENT                     = 4;\n    private static final int MMS_SENT_ID                  = 5;\n    private static final int MMS_DRAFTS                   = 6;\n    private static final int MMS_DRAFTS_ID                = 7;\n    private static final int MMS_OUTBOX                   = 8;\n    private static final int MMS_OUTBOX_ID                = 9;\n    private static final int MMS_ALL_PART                 = 10;\n    private static final int MMS_MSG_PART                 = 11;\n    private static final int MMS_PART_ID                  = 12;\n    private static final int MMS_MSG_ADDR                 = 13;\n    private static final int MMS_SENDING_RATE             = 14;\n    private static final int MMS_REPORT_STATUS            = 15;\n    private static final int MMS_REPORT_REQUEST           = 16;\n    private static final int MMS_DRM_STORAGE              = 17;\n    private static final int MMS_DRM_STORAGE_ID           = 18;\n    private static final int MMS_THREADS                  = 19;\n    private static final int MMS_PART_RESET_FILE_PERMISSION = 20;\n\n    private static final UriMatcher\n            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         MMS_ALL);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"sent\",       MMS_SENT);\n        sURLMatcher.addURI(\"mms\", \"sent/#\",     MMS_SENT_ID);\n        sURLMatcher.addURI(\"mms\", \"drafts\",     MMS_DRAFTS);\n        sURLMatcher.addURI(\"mms\", \"drafts/#\",   MMS_DRAFTS_ID);\n        sURLMatcher.addURI(\"mms\", \"outbox\",     MMS_OUTBOX);\n        sURLMatcher.addURI(\"mms\", \"outbox/#\",   MMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"part\",       MMS_ALL_PART);\n        sURLMatcher.addURI(\"mms\", \"#/part\",     MMS_MSG_PART);\n        sURLMatcher.addURI(\"mms\", \"part/#\",     MMS_PART_ID);\n        sURLMatcher.addURI(\"mms\", \"#/addr\",     MMS_MSG_ADDR);\n        sURLMatcher.addURI(\"mms\", \"rate\",       MMS_SENDING_RATE);\n        sURLMatcher.addURI(\"mms\", \"report-status/#\",  MMS_REPORT_STATUS);\n        sURLMatcher.addURI(\"mms\", \"report-request/#\", MMS_REPORT_REQUEST);\n        sURLMatcher.addURI(\"mms\", \"drm\",        MMS_DRM_STORAGE);\n        sURLMatcher.addURI(\"mms\", \"drm/#\",      MMS_DRM_STORAGE_ID);\n        sURLMatcher.addURI(\"mms\", \"threads\",    MMS_THREADS);\n        sURLMatcher.addURI(\"mms\", \"resetFilePerm/*\",    MMS_PART_RESET_FILE_PERMISSION);\n    }\n\n    @VisibleForTesting\n    public SQLiteOpenHelper mOpenHelper;\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.Mms.Addr;\nimport android.provider.Telephony.Mms.Part;\nimport android.provider.Telephony.Mms.Rate;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Threads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\n\nimport com.google.android.mms.pdu.PduHeaders;\nimport com.google.android.mms.util.DownloadDrmHelper;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * The class to provide base facility to access MMS related content,\n * which is stored in a SQLite database and in the file system.\n */\npublic class MmsProvider extends ContentProvider {\n    static final String TABLE_PDU  = \"pdu\";\n    static final String TABLE_ADDR = \"addr\";\n    static final String TABLE_PART = \"part\";\n    static final String TABLE_RATE = \"rate\";\n    static final String TABLE_DRM  = \"drm\";\n    static final String TABLE_WORDS = \"words\";\n    static final String VIEW_PDU_RESTRICTED = \"pdu_restricted\";\n\n    // The name of parts directory. The full dir is \"app_parts\".\n    static final String PARTS_DIR_NAME = \"parts\";\n\n    private ProviderUtilWrapper providerUtilWrapper = new ProviderUtilWrapper();\n\n    @VisibleForTesting\n    public void setProviderUtilWrapper(ProviderUtilWrapper providerUtilWrapper) {\n        this.providerUtilWrapper = providerUtilWrapper;\n    }\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    // wrapper class to allow easier mocking of the static ProviderUtil in tests\n    @VisibleForTesting\n    public static class ProviderUtilWrapper {\n        public boolean isAccessRestricted(Context context, String packageName, int uid) {\n            return ProviderUtil.isAccessRestricted(context, packageName, uid);\n        }\n    }\n\n    /**\n     * Return the proper view of \"pdu\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the mms data\n     */\n    public static String getPduTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_PDU_RESTRICTED : TABLE_PDU;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        // First check if a restricted view of the \"pdu\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n        }\n\n        final String pduTable = getPduTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Query uri=\" + uri + \", match=\" + match);\n        }\n\n        switch (match) {\n            case MMS_ALL:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_ALL, pduTable);\n                break;\n            case MMS_INBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_INBOX, pduTable);\n                break;\n            case MMS_SENT:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_SENT, pduTable);\n                break;\n            case MMS_DRAFTS:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_DRAFTS, pduTable);\n                break;\n            case MMS_OUTBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_OUTBOX, pduTable);\n                break;\n            case MMS_ALL_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(1));\n                qb.appendWhere(\" AND \" + Mms.MESSAGE_BOX + \"=\"\n                        + getMessageBoxByMatch(match));\n                break;\n            case MMS_ALL_PART:\n                qb.setTables(TABLE_PART);\n                break;\n            case MMS_MSG_PART:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_PART_ID:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part._ID + \"=\" + uri.getPathSegments().get(1));\n                break;\n            case MMS_MSG_ADDR:\n                qb.setTables(TABLE_ADDR);\n                qb.appendWhere(Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_REPORT_STATUS:\n                /*\n                   SELECT DISTINCT address,\n                                   T.delivery_status AS delivery_status,\n                                   T.read_status AS read_status\n                   FROM addr\n                   INNER JOIN (SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134\n                               LEFT JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               UNION\n                               SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               LEFT JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134) T\n                   ON (msg_id = id2 AND type = 151)\n                   OR (msg_id = id3 AND type = 137)\n                   WHERE T.id1 = ?;\n                 */\n                qb.setTables(TABLE_ADDR + \" INNER JOIN \"\n                        + \"(SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134 \"\n                        + \"LEFT JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"UNION \"\n                        + \"SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"LEFT JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134) T \"\n                        + \"ON (msg_id=id2 AND type=151) OR (msg_id=id3 AND type=137)\");\n                qb.appendWhere(\"T.id1 = \" + uri.getLastPathSegment());\n                qb.setDistinct(true);\n                break;\n            case MMS_REPORT_REQUEST:\n                /*\n                   SELECT address, d_rpt, rr\n                   FROM addr join pdu on pdu._id = addr.msg_id\n                   WHERE pdu._id = messageId AND addr.type = 151\n                 */\n                qb.setTables(TABLE_ADDR + \" join \" +\n                        pduTable + \" on \" + pduTable + \"._id = addr.msg_id\");\n                qb.appendWhere(pduTable + \"._id = \" + uri.getLastPathSegment());\n                qb.appendWhere(\" AND \" + TABLE_ADDR + \".type = \" + PduHeaders.TO);\n                break;\n            case MMS_SENDING_RATE:\n                qb.setTables(TABLE_RATE);\n                break;\n            case MMS_DRM_STORAGE_ID:\n                qb.setTables(TABLE_DRM);\n                qb.appendWhere(BaseColumns._ID + \"=\" + uri.getLastPathSegment());\n                break;\n            case MMS_THREADS:\n                qb.setTables(pduTable + \" group by thread_id\");\n                break;\n            default:\n                Log.e(TAG, \"query: invalid request: \" + uri);\n                return null;\n        }\n\n        if (qb.getTables().equals(pduTable)) {\n            String selectionBySubIds;\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Filter MMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return new MatrixCursor((projection == null) ? (new String[] {}) : projection);\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String finalSortOrder = null;\n        if (TextUtils.isEmpty(sortOrder)) {\n            if (qb.getTables().equals(pduTable)) {\n                finalSortOrder = Mms.DATE + \" DESC\";\n            } else if (qb.getTables().equals(TABLE_PART)) {\n                finalSortOrder = Part.SEQ;\n            }\n        } else {\n            finalSortOrder = sortOrder;\n        }\n\n        Cursor ret;\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            ret = qb.query(db, projection, selection,\n                    selectionArgs, null, null, finalSortOrder);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"returning NULL cursor, query: \" + uri, e);\n            return null;\n        }\n\n        // TODO: Does this need to be a URI for this provider.\n        ret.setNotificationUri(getContext().getContentResolver(), uri);\n        return ret;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int msgBox, String pduTable) {\n        qb.setTables(pduTable);\n\n        if (msgBox != Mms.MESSAGE_BOX_ALL) {\n            qb.appendWhere(Mms.MESSAGE_BOX + \"=\" + msgBox);\n        }\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        int match = sURLMatcher.match(uri);\n        switch (match) {\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                return VND_ANDROID_DIR_MMS;\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                return VND_ANDROID_MMS;\n            case MMS_PART_ID: {\n                Cursor cursor = mOpenHelper.getReadableDatabase().query(\n                        TABLE_PART, new String[] { Part.CONTENT_TYPE },\n                        Part._ID + \" = ?\", new String[] { uri.getLastPathSegment() },\n                        null, null, null);\n                if (cursor != null) {\n                    try {\n                        if ((cursor.getCount() == 1) && cursor.moveToFirst()) {\n                            return cursor.getString(0);\n                        } else {\n                            Log.e(TAG, \"cursor.count() != 1: \" + uri);\n                        }\n                    } finally {\n                        cursor.close();\n                    }\n                } else {\n                    Log.e(TAG, \"cursor == null: \" + uri);\n                }\n                return \"*/*\";\n            }\n            case MMS_ALL_PART:\n            case MMS_MSG_PART:\n            case MMS_MSG_ADDR:\n            default:\n                return \"*/*\";\n        }\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int msgBox = Mms.MESSAGE_BOX_ALL;\n        boolean notify = true;\n\n        boolean forceNoNotify = values.containsKey(TelephonyBackupAgent.NOTIFY)\n                && !values.getAsBoolean(TelephonyBackupAgent.NOTIFY);\n        values.remove(TelephonyBackupAgent.NOTIFY);\n        // check isAccessRestricted to prevent third parties from setting NOTIFY = false maliciously\n        if (forceNoNotify && !providerUtilWrapper.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid)) {\n            notify = false;\n        }\n\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Insert uri=\" + uri + \", match=\" + match);\n        }\n\n        String table = TABLE_PDU;\n        switch (match) {\n            case MMS_ALL:\n                Object msgBoxObj = values.getAsInteger(Mms.MESSAGE_BOX);\n                if (msgBoxObj != null) {\n                    msgBox = (Integer) msgBoxObj;\n                }\n                else {\n                    // default to inbox\n                    msgBox = Mms.MESSAGE_BOX_INBOX;\n                }\n                break;\n            case MMS_INBOX:\n                msgBox = Mms.MESSAGE_BOX_INBOX;\n                break;\n            case MMS_SENT:\n                msgBox = Mms.MESSAGE_BOX_SENT;\n                break;\n            case MMS_DRAFTS:\n                msgBox = Mms.MESSAGE_BOX_DRAFTS;\n                break;\n            case MMS_OUTBOX:\n                msgBox = Mms.MESSAGE_BOX_OUTBOX;\n                break;\n            case MMS_MSG_PART:\n                notify = false;\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_ADDR:\n                notify = false;\n                table = TABLE_ADDR;\n                break;\n            case MMS_SENDING_RATE:\n                notify = false;\n                table = TABLE_RATE;\n                break;\n            case MMS_DRM_STORAGE:\n                notify = false;\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.e(TAG, \"insert: invalid request: \" + uri);\n                return null;\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        ContentValues finalValues;\n        Uri res = Mms.CONTENT_URI;\n        Uri caseSpecificUri = null;\n        long rowId;\n\n        if (table.equals(TABLE_PDU)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n                return null;\n            }\n\n            boolean addDate = !values.containsKey(Mms.DATE);\n            boolean addMsgBox = !values.containsKey(Mms.MESSAGE_BOX);\n\n            // Filter keys we don't support yet.\n            filterUnsupportedKeys(values);\n\n            // TODO: Should initialValues be validated, e.g. if it\n            // missed some significant keys?\n            finalValues = new ContentValues(values);\n\n            long timeInMillis = System.currentTimeMillis();\n\n            if (addDate) {\n                finalValues.put(Mms.DATE, timeInMillis / 1000L);\n            }\n\n            if (addMsgBox && (msgBox != Mms.MESSAGE_BOX_ALL)) {\n                finalValues.put(Mms.MESSAGE_BOX, msgBox);\n            }\n\n            if (msgBox != Mms.MESSAGE_BOX_INBOX) {\n                // Mark all non-inbox messages read.\n                finalValues.put(Mms.READ, 1);\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Mms.THREAD_ID);\n            String address = values.getAsString(CanonicalAddressesColumns.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                finalValues.put(Mms.THREAD_ID, Threads.getOrCreateThreadId(getContext(), address));\n            }\n\n            if (ProviderUtil.shouldSetCreator(finalValues, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                finalValues.put(Telephony.Mms.CREATOR, callerPkg);\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            // Notify change when an MMS is received.\n            if (msgBox == Mms.MESSAGE_BOX_INBOX) {\n                caseSpecificUri = ContentUris.withAppendedId(Mms.Inbox.CONTENT_URI, rowId);\n            }\n\n            res = Uri.parse(res + \"/\" + rowId);\n        } else if (table.equals(TABLE_ADDR)) {\n            finalValues = new ContentValues(values);\n            finalValues.put(Addr.MSG_ID, uri.getPathSegments().get(0));\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"Failed to insert address\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/addr/\" + rowId);\n        } else if (table.equals(TABLE_PART)) {\n            boolean containsDataPath = values != null && values.containsKey(Part._DATA);\n            finalValues = new ContentValues(values);\n\n            if (match == MMS_MSG_PART) {\n                finalValues.put(Part.MSG_ID, uri.getPathSegments().get(0));\n            }\n\n            String contentType = values.getAsString(\"ct\");\n\n            // text/plain and app application/smil store their \"data\" inline in the\n            // table so there's no need to create the file\n            boolean plainText = false;\n            boolean smilText = false;\n            if (\"text/plain\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert text/plain with _data\");\n                    return null;\n                }\n                plainText = true;\n            } else if (\"application/smil\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert application/smil with _data\");\n                    return null;\n                }\n                smilText = true;\n            }\n            if (!plainText && !smilText) {\n                String path;\n                if (containsDataPath) {\n                    // The _data column is filled internally in MmsProvider or from the\n                    // TelephonyBackupAgent, so this check is just to avoid it from being\n                    // inadvertently set. This is not supposed to be a protection against malicious\n                    // attack, since sql injection could still be attempted to bypass the check.\n                    // On the other hand, the MmsProvider does verify that the _data column has an\n                    // allowed value before opening any uri/files.\n                    if (!\"com.android.providers.telephony\".equals(callerPkg)) {\n                        Log.e(TAG, \"insert: can't insert _data\");\n                        return null;\n                    }\n                    try {\n                        path = values.getAsString(Part._DATA);\n                        final String partsDirPath = getContext()\n                                .getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                        if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                            Log.e(TAG, \"insert: path \"\n                                    + path\n                                    + \" does not start with \"\n                                    + partsDirPath);\n                            // Don't care return value\n                            return null;\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"insert part: create path failed \" + e, e);\n                        return null;\n                    }\n                } else {\n                    // Use the filename if possible, otherwise use the current time as the name.\n                    String contentLocation = values.getAsString(\"cl\");\n                    if (!TextUtils.isEmpty(contentLocation)) {\n                        File f = new File(contentLocation);\n                        contentLocation = \"_\" + f.getName();\n                    } else {\n                        contentLocation = \"\";\n                    }\n\n                    // Generate the '_data' field of the part with default\n                    // permission settings.\n                    path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                            + \"/PART_\" + System.currentTimeMillis() + contentLocation;\n\n                    if (DownloadDrmHelper.isDrmConvertNeeded(contentType)) {\n                        // Adds the .fl extension to the filename if contentType is\n                        // \"application/vnd.oma.drm.message\"\n                        path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n                    }\n                }\n\n                finalValues.put(Part._DATA, path);\n\n                File partFile = new File(path);\n                if (!partFile.exists()) {\n                    try {\n                        if (!partFile.createNewFile()) {\n                            throw new IllegalStateException(\n                                    \"Unable to create new partFile: \" + path);\n                        }\n                        // Give everyone rw permission until we encrypt the file\n                        // (in PduPersister.persistData). Once the file is encrypted, the\n                        // permissions will be set to 0644.\n                        try {\n                            Os.chmod(path, 0666);\n                            if (LOCAL_LOGV) {\n                                Log.d(TAG, \"MmsProvider.insert chmod is successful\");\n                            }\n                        } catch (ErrnoException e) {\n                            Log.e(TAG, \"Exception in chmod: \" + e);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"createNewFile\", e);\n                        throw new IllegalStateException(\n                                \"Unable to create new partFile: \" + path);\n                    }\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/part/\" + rowId);\n\n            // Don't use a trigger for updating the words table because of a bug\n            // in FTS3.  The bug is such that the call to get the last inserted\n            // row is incorrect.\n            if (plainText) {\n                // Update the words table with a corresponding row.  The words table\n                // allows us to search for words quickly, without scanning the whole\n                // table;\n                ContentValues cv = new ContentValues();\n\n                // we're using the row id of the part table row but we're also using ids\n                // from the sms table so this divides the space into two large chunks.\n                // The row ids from the part table start at 2 << 32.\n                cv.put(Telephony.MmsSms.WordsTable.ID, (2L << 32) + rowId);\n                cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"text\"));\n                cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowId);\n                cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 2);\n                db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n            }\n\n        } else if (table.equals(TABLE_RATE)) {\n            long now = values.getAsLong(Rate.SENT_TIME);\n            long oneHourAgo = now - 1000 * 60 * 60;\n            // Delete all unused rows (time earlier than one hour ago).\n            db.delete(table, Rate.SENT_TIME + \"<=\" + oneHourAgo, null);\n            db.insert(table, null, values);\n        } else if (table.equals(TABLE_DRM)) {\n            String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                    + \"/PART_\" + System.currentTimeMillis();\n            finalValues = new ContentValues(1);\n            finalValues.put(\"_data\", path);\n\n            File partFile = new File(path);\n            if (!partFile.exists()) {\n                try {\n                    if (!partFile.createNewFile()) {\n                        throw new IllegalStateException(\n                                \"Unable to create new file: \" + path);\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"createNewFile\", e);\n                    throw new IllegalStateException(\n                            \"Unable to create new file: \" + path);\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n            res = Uri.parse(res + \"/drm/\" + rowId);\n        } else {\n            throw new AssertionError(\"Unknown table type: \" + table);\n        }\n\n        if (notify) {\n            notifyChange(res, caseSpecificUri);\n        }\n        return res;\n    }\n\n    private int getMessageBoxByMatch(int match) {\n        switch (match) {\n            case MMS_INBOX_ID:\n            case MMS_INBOX:\n                return Mms.MESSAGE_BOX_INBOX;\n            case MMS_SENT_ID:\n            case MMS_SENT:\n                return Mms.MESSAGE_BOX_SENT;\n            case MMS_DRAFTS_ID:\n            case MMS_DRAFTS:\n                return Mms.MESSAGE_BOX_DRAFTS;\n            case MMS_OUTBOX_ID:\n            case MMS_OUTBOX:\n                return Mms.MESSAGE_BOX_OUTBOX;\n            default:\n                throw new IllegalArgumentException(\"bad Arg: \" + match);\n        }\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Delete uri=\" + uri + \", match=\" + match);\n        }\n\n        String table, extraSelection = null;\n        boolean notify = false;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                notify = true;\n                table = TABLE_PDU;\n                extraSelection = Mms._ID + \"=\" + uri.getLastPathSegment();\n                break;\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                if (match != MMS_ALL) {\n                    int msgBox = getMessageBoxByMatch(match);\n                    extraSelection = Mms.MESSAGE_BOX + \"=\" + msgBox;\n                }\n                break;\n            case MMS_ALL_PART:\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_PART:\n                table = TABLE_PART;\n                extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                break;\n            case MMS_MSG_ADDR:\n                table = TABLE_ADDR;\n                extraSelection = Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_DRM_STORAGE:\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.w(TAG, \"No match for URI '\" + uri + \"'\");\n                return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int deletedRows = 0;\n\n        if (TABLE_PDU.equals(table)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0.\n                return 0;\n            }\n            finalSelection = DatabaseUtils.concatenateWhere(finalSelection, selectionBySubIds);\n\n            deletedRows = deleteMessages(getContext(), db, finalSelection,\n                                         selectionArgs, uri);\n        } else if (TABLE_PART.equals(table)) {\n            deletedRows = deleteParts(db, finalSelection, selectionArgs);\n        } else if (TABLE_DRM.equals(table)) {\n            deletedRows = deleteTempDrmData(db, finalSelection, selectionArgs);\n        } else {\n            deletedRows = db.delete(table, finalSelection, selectionArgs);\n        }\n\n        if ((deletedRows > 0) && notify) {\n            notifyChange(uri, null);\n        }\n        return deletedRows;\n    }\n\n    static int deleteMessages(Context context, SQLiteDatabase db,\n            String selection, String[] selectionArgs, Uri uri) {\n        Cursor cursor = db.query(TABLE_PDU, new String[] { Mms._ID },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                deleteParts(db, Part.MSG_ID + \" = ?\",\n                        new String[] { String.valueOf(cursor.getLong(0)) });\n            }\n        } finally {\n            cursor.close();\n        }\n\n        int count = db.delete(TABLE_PDU, selection, selectionArgs);\n        if (count > 0) {\n            Intent intent = new Intent(Mms.Intents.CONTENT_CHANGED_ACTION);\n            intent.putExtra(Mms.Intents.DELETED_CONTENTS, uri);\n            if (LOCAL_LOGV) {\n                Log.v(TAG, \"Broadcasting intent: \" + intent);\n            }\n            context.sendBroadcast(intent);\n        }\n        return count;\n    }\n\n    private static int deleteParts(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_PART, selection, selectionArgs);\n    }\n\n    private static int deleteTempDrmData(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_DRM, selection, selectionArgs);\n    }\n\n    private static int deleteDataRows(SQLiteDatabase db, String table,\n            String selection, String[] selectionArgs) {\n        Cursor cursor = db.query(table, new String[] { \"_data\" },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            // FIXME: This might be an error, ignore it may cause\n            // unpredictable result.\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                try {\n                    // Delete the associated files saved on file-system.\n                    String path = cursor.getString(0);\n                    if (path != null) {\n                        new File(path).delete();\n                    }\n                } catch (Throwable ex) {\n                    Log.e(TAG, ex.getMessage(), ex);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return db.delete(table, selection, selectionArgs);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        // The _data column is filled internally in MmsProvider, so this check is just to avoid\n        // it from being inadvertently set. This is not supposed to be a protection against\n        // malicious attack, since sql injection could still be attempted to bypass the check. On\n        // the other hand, the MmsProvider does verify that the _data column has an allowed value\n        // before opening any uri/files.\n        if (values != null && values.containsKey(Part._DATA)) {\n            return 0;\n        }\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Update uri=\" + uri + \", match=\" + match);\n        }\n\n        boolean notify = false;\n        String msgId = null;\n        String table;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                msgId = uri.getLastPathSegment();\n            // fall-through\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                break;\n\n            case MMS_MSG_PART:\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                break;\n\n            case MMS_PART_RESET_FILE_PERMISSION:\n                String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath() + '/' +\n                        uri.getPathSegments().get(1);\n\n                try {\n                    String partsDirPath = getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                    if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                        EventLog.writeEvent(0x534e4554, \"240685104\",\n                                callerUid, (TAG + \" update: path \" + path +\n                                        \" does not start with \" + partsDirPath));\n                        return 0;\n                    }\n                    // Reset the file permission back to read for everyone but me.\n                    Os.chmod(path, 0644);\n                    if (LOCAL_LOGV) {\n                        Log.d(TAG, \"MmsProvider.update chmod is successful for path: \" + path);\n                    }\n                } catch (ErrnoException | IOException e) {\n                    Log.e(TAG, \"Exception in chmod: \" + e);\n                }\n                return 0;\n\n            default:\n                Log.w(TAG, \"Update operation for '\" + uri + \"' not implemented.\");\n                return 0;\n        }\n\n        String extraSelection = null;\n        ContentValues finalValues;\n        if (table.equals(TABLE_PDU)) {\n            // Filter keys that we don't support yet.\n            filterUnsupportedKeys(values);\n            if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n                // CREATOR should not be changed by non-SYSTEM/PHONE apps\n                Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n                values.remove(Mms.CREATOR);\n            }\n            finalValues = new ContentValues(values);\n\n            if (msgId != null) {\n                extraSelection = Mms._ID + \"=\" + msgId;\n            }\n\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter MMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0.\n                return 0;\n            }\n            extraSelection = DatabaseUtils.concatenateWhere(extraSelection, selectionBySubIds);\n        } else if (table.equals(TABLE_PART)) {\n            finalValues = new ContentValues(values);\n\n            switch (match) {\n                case MMS_MSG_PART:\n                    extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                    break;\n                case MMS_PART_ID:\n                    extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count = db.update(table, finalValues, finalSelection, selectionArgs);\n        if (notify && (count > 0)) {\n            notifyChange(uri, null);\n        }\n        return count;\n    }\n\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        int match = sURLMatcher.match(uri);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"openFile: uri=\" + uri + \", mode=\" + mode + \", match=\" + match);\n        }\n\n        if (match != MMS_PART_ID) {\n            return null;\n        }\n\n        return safeOpenFileHelper(uri, mode);\n    }\n\n    @NonNull\n    private ParcelFileDescriptor safeOpenFileHelper(\n            @NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {\n        Cursor c = query(uri, new String[]{\"_data\"}, null, null, null);\n        int count = (c != null) ? c.getCount() : 0;\n        if (count != 1) {\n            // If there is not exactly one result, throw an appropriate\n            // exception.\n            if (c != null) {\n                c.close();\n            }\n            if (count == 0) {\n                throw new FileNotFoundException(\"No entry for \" + uri);\n            }\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        c.moveToFirst();\n        int i = c.getColumnIndex(\"_data\");\n        String path = (i >= 0 ? c.getString(i) : null);\n        c.close();\n\n        if (path == null) {\n            throw new FileNotFoundException(\"Column _data not found.\");\n        }\n\n        File filePath = new File(path);\n        try {\n            // The MmsProvider shouldn't open a file that isn't MMS data, so we verify that the\n            // _data path actually points to MMS data. That safeguards ourselves from callers who\n            // inserted or updated a URI (more specifically the _data column) with disallowed paths.\n            // TODO(afurtado): provide a more robust mechanism to avoid disallowed _data paths to\n            // be inserted/updated in the first place, including via SQL injection.\n            if (!filePath.getCanonicalPath()\n                    .startsWith(getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath())) {\n                Log.e(TAG, \"openFile: path \"\n                        + filePath.getCanonicalPath()\n                        + \" does not start with \"\n                        + getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath());\n                // Don't care return value\n                return null;\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"openFile: create path failed \" + e, e);\n            return null;\n        }\n\n        int modeBits = ParcelFileDescriptor.parseMode(mode);\n        return ParcelFileDescriptor.open(filePath, modeBits);\n    }\n\n    private void filterUnsupportedKeys(ContentValues values) {\n        // Some columns are unsupported.  They should therefore\n        // neither be inserted nor updated.  Filter them out.\n        values.remove(Mms.DELIVERY_TIME_TOKEN);\n        values.remove(Mms.SENDER_VISIBILITY);\n        values.remove(Mms.REPLY_CHARGING);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE_TOKEN);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE);\n        values.remove(Mms.REPLY_CHARGING_ID);\n        values.remove(Mms.REPLY_CHARGING_SIZE);\n        values.remove(Mms.PREVIOUSLY_SENT_BY);\n        values.remove(Mms.PREVIOUSLY_SENT_DATE);\n        values.remove(Mms.STORE);\n        values.remove(Mms.MM_STATE);\n        values.remove(Mms.MM_FLAGS_TOKEN);\n        values.remove(Mms.MM_FLAGS);\n        values.remove(Mms.STORE_STATUS);\n        values.remove(Mms.STORE_STATUS_TEXT);\n        values.remove(Mms.STORED);\n        values.remove(Mms.TOTALS);\n        values.remove(Mms.MBOX_TOTALS);\n        values.remove(Mms.MBOX_TOTALS_TOKEN);\n        values.remove(Mms.QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS_TOKEN);\n        values.remove(Mms.MESSAGE_COUNT);\n        values.remove(Mms.START);\n        values.remove(Mms.DISTRIBUTION_INDICATOR);\n        values.remove(Mms.ELEMENT_DESCRIPTOR);\n        values.remove(Mms.LIMIT);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE_TEXT);\n        values.remove(Mms.STATUS_TEXT);\n        values.remove(Mms.APPLIC_ID);\n        values.remove(Mms.REPLY_APPLIC_ID);\n        values.remove(Mms.AUX_APPLIC_ID);\n        values.remove(Mms.DRM_CONTENT);\n        values.remove(Mms.ADAPTATION_ALLOWED);\n        values.remove(Mms.REPLACE_ID);\n        values.remove(Mms.CANCEL_ID);\n        values.remove(Mms.CANCEL_STATUS);\n\n        // Keys shouldn't be inserted or updated.\n        values.remove(Mms._ID);\n    }\n\n    private void notifyChange(final Uri uri, final Uri caseSpecificUri) {\n        final Context context = getContext();\n        if (caseSpecificUri != null) {\n            context.getContentResolver().notifyChange(\n                caseSpecificUri, null, true, UserHandle.USER_ALL);\n        }\n        context.getContentResolver().notifyChange(\n                MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        ProviderUtil.notifyIfNotDefaultSmsApp(caseSpecificUri == null ? uri : caseSpecificUri,\n                getCallingPackage(), context);\n    }\n\n    private final static String TAG = \"MmsProvider\";\n    private final static String VND_ANDROID_MMS = \"vnd.android/mms\";\n    private final static String VND_ANDROID_DIR_MMS = \"vnd.android-dir/mms\";\n    private final static boolean DEBUG = false;\n    private final static boolean LOCAL_LOGV = false;\n\n    private static final int MMS_ALL                      = 0;\n    private static final int MMS_ALL_ID                   = 1;\n    private static final int MMS_INBOX                    = 2;\n    private static final int MMS_INBOX_ID                 = 3;\n    private static final int MMS_SENT                     = 4;\n    private static final int MMS_SENT_ID                  = 5;\n    private static final int MMS_DRAFTS                   = 6;\n    private static final int MMS_DRAFTS_ID                = 7;\n    private static final int MMS_OUTBOX                   = 8;\n    private static final int MMS_OUTBOX_ID                = 9;\n    private static final int MMS_ALL_PART                 = 10;\n    private static final int MMS_MSG_PART                 = 11;\n    private static final int MMS_PART_ID                  = 12;\n    private static final int MMS_MSG_ADDR                 = 13;\n    private static final int MMS_SENDING_RATE             = 14;\n    private static final int MMS_REPORT_STATUS            = 15;\n    private static final int MMS_REPORT_REQUEST           = 16;\n    private static final int MMS_DRM_STORAGE              = 17;\n    private static final int MMS_DRM_STORAGE_ID           = 18;\n    private static final int MMS_THREADS                  = 19;\n    private static final int MMS_PART_RESET_FILE_PERMISSION = 20;\n\n    private static final UriMatcher\n            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         MMS_ALL);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"sent\",       MMS_SENT);\n        sURLMatcher.addURI(\"mms\", \"sent/#\",     MMS_SENT_ID);\n        sURLMatcher.addURI(\"mms\", \"drafts\",     MMS_DRAFTS);\n        sURLMatcher.addURI(\"mms\", \"drafts/#\",   MMS_DRAFTS_ID);\n        sURLMatcher.addURI(\"mms\", \"outbox\",     MMS_OUTBOX);\n        sURLMatcher.addURI(\"mms\", \"outbox/#\",   MMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"part\",       MMS_ALL_PART);\n        sURLMatcher.addURI(\"mms\", \"#/part\",     MMS_MSG_PART);\n        sURLMatcher.addURI(\"mms\", \"part/#\",     MMS_PART_ID);\n        sURLMatcher.addURI(\"mms\", \"#/addr\",     MMS_MSG_ADDR);\n        sURLMatcher.addURI(\"mms\", \"rate\",       MMS_SENDING_RATE);\n        sURLMatcher.addURI(\"mms\", \"report-status/#\",  MMS_REPORT_STATUS);\n        sURLMatcher.addURI(\"mms\", \"report-request/#\", MMS_REPORT_REQUEST);\n        sURLMatcher.addURI(\"mms\", \"drm\",        MMS_DRM_STORAGE);\n        sURLMatcher.addURI(\"mms\", \"drm/#\",      MMS_DRM_STORAGE_ID);\n        sURLMatcher.addURI(\"mms\", \"threads\",    MMS_THREADS);\n        sURLMatcher.addURI(\"mms\", \"resetFilePerm/*\",    MMS_PART_RESET_FILE_PERMISSION);\n    }\n\n    @VisibleForTesting\n    public SQLiteOpenHelper mOpenHelper;\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n}\n","lineNo":117}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyStatsLog;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                cursor = getFirstLockedMessage(projection, \"thread_id=\" + Long.toString(threadId),\n                        sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase() : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        if (matchIndex == URI_PENDING_MSG) {\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.TelephonyStatsLog;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        Cursor emptyCursor = new MatrixCursor((projection == null) ?\n                (new String[] {}) : projection);\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n                    selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return emptyCursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, (\"thread_id=\" + threadId));\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(projection, selection, sortOrder,\n                        smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase() : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        if (matchIndex == URI_PENDING_MSG) {\n            int subId;\n            if (values.containsKey(PendingMessages.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(PendingMessages.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(PendingMessages.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n                return null;\n            }\n\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","lineNo":336}
{"Smelly Sample":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg);\n\n            int match = sURLMatcher.match(url);\n            // Skip notifyChange() if insertUri is null for SMS_ALL_ICC or SMS_ALL_ICC_SUBID caused\n            // by failure of insertMessageToIcc()(e.g. SIM full).\n            if (insertUri != null || (match != SMS_ALL_ICC && match != SMS_ALL_ICC_SUBID)) {\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/*\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/*\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return emptyCursor;\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            int match = sURLMatcher.match(url);\n            // Skip notifyChange() if insertUri is null for SMS_ALL_ICC or SMS_ALL_ICC_SUBID caused\n            // by failure of insertMessageToIcc()(e.g. SIM full).\n            if (insertUri != null || (match != SMS_ALL_ICC && match != SMS_ALL_ICC_SUBID)) {\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                        callerUserHandle)) {\n                    // TODO(b/258629881): Display error dialog.\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final long token = Binder.clearCallingIdentity();\n        String selectionBySubIds;\n        try {\n            // Filter SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0;\n                return 0;\n            }\n            where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/*\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/*\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n}\n","lineNo":121}
{"Smelly Sample":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return emptyCursor;\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                    callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n        String selectionBySubIds;\n        try {\n            // Filter SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0;\n                return 0;\n            }\n            where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n               selectionByEmergencyNumbers = ProviderUtil\n                       .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergne return empty cursor.\n                return emptyCursor;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            selection = DatabaseUtils.concatenateWhere(selection, filter);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            String address = \"\";\n            if (values.containsKey(Sms.ADDRESS)) {\n                address = values.getAsString(Sms.ADDRESS);\n            }\n\n            if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle, address)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                        callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n\n        String selectionBySubIds;\n        String selectionByEmergencyNumbers;\n        try {\n            // Filter SMS based on subId and emergency numbers.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                    callerUserHandle);\n            selectionByEmergencyNumbers = ProviderUtil\n                    .getSelectionByEmergencyNumbers(getContext());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        String filter = \"\";\n        if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n            // No subscriptions associated with user and no emergency numbers\n            filter = null;\n        } else if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n            filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n        } else {\n            filter = selectionBySubIds == null ?\n                    selectionByEmergencyNumbers : selectionBySubIds;\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n                selectionByEmergencyNumbers = ProviderUtil\n                        .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergency numbers, return 0.\n                return 0;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            where = DatabaseUtils.concatenateWhere(where, filter);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","lineNo":359}
{"Smelly Sample":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return emptyCursor;\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                    callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n        String selectionBySubIds;\n        try {\n            // Filter SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0;\n                return 0;\n            }\n            where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n               selectionByEmergencyNumbers = ProviderUtil\n                       .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergne return empty cursor.\n                return emptyCursor;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            selection = DatabaseUtils.concatenateWhere(selection, filter);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            String address = \"\";\n            if (values.containsKey(Sms.ADDRESS)) {\n                address = values.getAsString(Sms.ADDRESS);\n            }\n\n            if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle, address)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                        callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n\n        String selectionBySubIds;\n        String selectionByEmergencyNumbers;\n        try {\n            // Filter SMS based on subId and emergency numbers.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                    callerUserHandle);\n            selectionByEmergencyNumbers = ProviderUtil\n                    .getSelectionByEmergencyNumbers(getContext());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        String filter = \"\";\n        if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n            // No subscriptions associated with user and no emergency numbers\n            filter = null;\n        } else if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n            filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n        } else {\n            filter = selectionBySubIds == null ?\n                    selectionByEmergencyNumbers : selectionBySubIds;\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n                selectionByEmergencyNumbers = ProviderUtil\n                        .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergency numbers, return 0.\n                return 0;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            where = DatabaseUtils.concatenateWhere(where, filter);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","lineNo":962}
{"Smelly Sample":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return emptyCursor;\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                    callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n        String selectionBySubIds;\n        try {\n            // Filter SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0;\n                return 0;\n            }\n            where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.util.TelephonyUtils;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n\n        // Creating intent broadcast receiver for user actions like Intent.ACTION_USER_REMOVED,\n        // where we would need to remove SMS related to removed user.\n        IntentFilter userIntentFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        getContext().registerReceiver(mUserIntentReceiver, userIntentFilter,\n                Context.RECEIVER_NOT_EXPORTED);\n\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n               selectionByEmergencyNumbers = ProviderUtil\n                       .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergne return empty cursor.\n                return emptyCursor;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            selection = DatabaseUtils.concatenateWhere(selection, filter);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            // Skip notifyChange() if insertUri is null\n            if (insertUri != null) {\n                int match = sURLMatcher.match(url);\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle)) {\n                    TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(),\n                        subId, callerUid, callerPkg);\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            String address = \"\";\n            if (values.containsKey(Sms.ADDRESS)) {\n                address = values.getAsString(Sms.ADDRESS);\n            }\n\n            if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                    callerUserHandle, address)) {\n                TelephonyUtils.showSwitchToManagedProfileDialogIfAppropriate(getContext(), subId,\n                        callerUid, callerPkg);\n                return null;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final int callerUid = Binder.getCallingUid();\n        final long token = Binder.clearCallingIdentity();\n\n        String selectionBySubIds;\n        String selectionByEmergencyNumbers;\n        try {\n            // Filter SMS based on subId and emergency numbers.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                    callerUserHandle);\n            selectionByEmergencyNumbers = ProviderUtil\n                    .getSelectionByEmergencyNumbers(getContext());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        String filter = \"\";\n        if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n            // No subscriptions associated with user and no emergency numbers\n            filter = null;\n        } else if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n            filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n        } else {\n            filter = selectionBySubIds == null ?\n                    selectionByEmergencyNumbers : selectionBySubIds;\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (filter == null) {\n                    // No subscriptions associated with user and no emergency numbers, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, filter);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            String selectionByEmergencyNumbers;\n            try {\n                // Filter SMS based on subId and emergency numbers.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n                selectionByEmergencyNumbers = ProviderUtil\n                        .getSelectionByEmergencyNumbers(getContext());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n\n            if (selectionBySubIds == null && selectionByEmergencyNumbers == null) {\n                // No subscriptions associated with user and no emergency numbers, return 0.\n                return 0;\n            }\n            String filter = \"\";\n            if (selectionBySubIds != null && selectionByEmergencyNumbers != null) {\n                filter = (selectionBySubIds + \" OR \" + selectionByEmergencyNumbers);\n            } else {\n                filter = selectionBySubIds == null ?\n                        selectionByEmergencyNumbers : selectionBySubIds;\n            }\n\n            where = DatabaseUtils.concatenateWhere(where, filter);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n\n    private BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            switch (intent.getAction()) {\n                case Intent.ACTION_USER_REMOVED:\n                    UserHandle userToBeRemoved  = intent.getParcelableExtra(Intent.EXTRA_USER,\n                            UserHandle.class);\n                    UserManager userManager = context.getSystemService(UserManager.class);\n                    if ((userToBeRemoved == null) || (userManager == null) ||\n                            (!userManager.isManagedProfile(userToBeRemoved.getIdentifier()))) {\n                        // Do not delete SMS if removed profile is not managed profile.\n                        return;\n                    }\n                    Log.d(TAG, \"Received ACTION_USER_REMOVED for managed profile - Deleting SMS.\");\n\n                    // Deleting SMS related to managed profile.\n                    Uri uri = Sms.CONTENT_URI;\n                    int match = sURLMatcher.match(uri);\n                    SQLiteDatabase db = getWritableDatabase(match);\n\n                    final long token = Binder.clearCallingIdentity();\n                    String selectionBySubIds;\n                    try {\n                        // Filter SMS based on subId.\n                        selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                                userToBeRemoved);\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return.\n                        return;\n                    }\n\n                    int count = db.delete(TABLE_SMS, selectionBySubIds, null);\n                    if (count != 0) {\n                        // Don't update threads unless something changed.\n                        MmsSmsDatabaseHelper.updateThreads(db, selectionBySubIds, null);\n                        notifyChange(true, uri, getCallingPackage());\n                    }\n                    break;\n            }\n        }\n    };\n}\n","lineNo":1271}
{"Smelly Sample":"/* //device/content/providers/telephony/TelephonyProvider.java\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n\npackage com.android.providers.telephony;\n\nimport static android.provider.Telephony.Carriers.ALWAYS_ON;\nimport static android.provider.Telephony.Carriers.APN;\nimport static android.provider.Telephony.Carriers.APN_SET_ID;\nimport static android.provider.Telephony.Carriers.AUTH_TYPE;\nimport static android.provider.Telephony.Carriers.BEARER;\nimport static android.provider.Telephony.Carriers.BEARER_BITMASK;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.CARRIER_EDITED;\nimport static android.provider.Telephony.Carriers.CARRIER_ENABLED;\nimport static android.provider.Telephony.Carriers.CARRIER_ID;\nimport static android.provider.Telephony.Carriers.CONTENT_URI;\nimport static android.provider.Telephony.Carriers.CURRENT;\nimport static android.provider.Telephony.Carriers.DEFAULT_SORT_ORDER;\nimport static android.provider.Telephony.Carriers.EDITED_STATUS;\nimport static android.provider.Telephony.Carriers.LINGERING_NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.MCC;\nimport static android.provider.Telephony.Carriers.MMSC;\nimport static android.provider.Telephony.Carriers.MMSPORT;\nimport static android.provider.Telephony.Carriers.MMSPROXY;\nimport static android.provider.Telephony.Carriers.MNC;\nimport static android.provider.Telephony.Carriers.MODEM_PERSIST;\nimport static android.provider.Telephony.Carriers.MTU;\nimport static android.provider.Telephony.Carriers.MTU_V4;\nimport static android.provider.Telephony.Carriers.MTU_V6;\nimport static android.provider.Telephony.Carriers.MVNO_MATCH_DATA;\nimport static android.provider.Telephony.Carriers.MVNO_TYPE;\nimport static android.provider.Telephony.Carriers.NAME;\nimport static android.provider.Telephony.Carriers.NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.NO_APN_SET_ID;\nimport static android.provider.Telephony.Carriers.NUMERIC;\nimport static android.provider.Telephony.Carriers.OWNED_BY;\nimport static android.provider.Telephony.Carriers.OWNED_BY_DPC;\nimport static android.provider.Telephony.Carriers.OWNED_BY_OTHERS;\nimport static android.provider.Telephony.Carriers.PASSWORD;\nimport static android.provider.Telephony.Carriers.PORT;\nimport static android.provider.Telephony.Carriers.PROFILE_ID;\nimport static android.provider.Telephony.Carriers.PROTOCOL;\nimport static android.provider.Telephony.Carriers.PROXY;\nimport static android.provider.Telephony.Carriers.ROAMING_PROTOCOL;\nimport static android.provider.Telephony.Carriers.SERVER;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT_DEFAULT;\nimport static android.provider.Telephony.Carriers.SUBSCRIPTION_ID;\nimport static android.provider.Telephony.Carriers.TIME_LIMIT_FOR_MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.TYPE;\nimport static android.provider.Telephony.Carriers.UNEDITED;\nimport static android.provider.Telephony.Carriers.USER;\nimport static android.provider.Telephony.Carriers.USER_DELETED;\nimport static android.provider.Telephony.Carriers.USER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.USER_EDITABLE;\nimport static android.provider.Telephony.Carriers.USER_EDITED;\nimport static android.provider.Telephony.Carriers.USER_VISIBLE;\nimport static android.provider.Telephony.Carriers.WAIT_TIME_RETRY;\nimport static android.provider.Telephony.Carriers._ID;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.compat.CompatChanges;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.content.res.XmlResourceParser;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.os.PersistableBundle;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.provider.Telephony;\nimport android.service.carrier.IApnSourceService;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.TelephonyProtoEnums;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.IndentingPrintWriter;\nimport android.util.LocalLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.util.XmlUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\nimport java.util.zip.CRC32;\nimport java.util.zip.CheckedInputStream;\n\npublic class TelephonyProvider extends ContentProvider\n{\n    private static final String DATABASE_NAME = \"telephony.db\";\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n    private static final boolean DBG = true;\n    private static final boolean VDBG = false; // STOPSHIP if true\n\n    private static final int DATABASE_VERSION = 62 << 16;\n    private static final int URL_UNKNOWN = 0;\n    private static final int URL_TELEPHONY = 1;\n    private static final int URL_CURRENT = 2;\n    private static final int URL_ID = 3;\n    private static final int URL_RESTOREAPN = 4;\n    private static final int URL_PREFERAPN = 5;\n    private static final int URL_PREFERAPN_NO_UPDATE = 6;\n    private static final int URL_SIMINFO = 7;\n    private static final int URL_TELEPHONY_USING_SUBID = 8;\n    private static final int URL_CURRENT_USING_SUBID = 9;\n    private static final int URL_RESTOREAPN_USING_SUBID = 10;\n    private static final int URL_PREFERAPN_USING_SUBID = 11;\n    private static final int URL_PREFERAPN_NO_UPDATE_USING_SUBID = 12;\n    private static final int URL_SIMINFO_USING_SUBID = 13;\n    private static final int URL_UPDATE_DB = 14;\n    private static final int URL_DELETE = 15;\n    private static final int URL_DPC = 16;\n    private static final int URL_DPC_ID = 17;\n    private static final int URL_FILTERED = 18;\n    private static final int URL_FILTERED_ID = 19;\n    private static final int URL_ENFORCE_MANAGED = 20;\n    // URL_PREFERAPNSET and URL_PREFERAPNSET_USING_SUBID return all APNs for the current\n    // carrier which have an apn_set_id equal to the preferred APN\n    // (if no preferred APN, or preferred APN has no set id, the query will return null)\n    private static final int URL_PREFERAPNSET = 21;\n    private static final int URL_PREFERAPNSET_USING_SUBID = 22;\n    private static final int URL_SIM_APN_LIST = 23;\n    private static final int URL_SIM_APN_LIST_ID = 24;\n    private static final int URL_FILTERED_USING_SUBID = 25;\n    private static final int URL_SIM_APN_LIST_FILTERED = 26;\n    private static final int URL_SIM_APN_LIST_FILTERED_ID = 27;\n    private static final int URL_SIMINFO_SUW_RESTORE = 28;\n    private static final int URL_SIMINFO_SIM_INSERTED_RESTORE = 29;\n\n    private static final String TAG = \"TelephonyProvider\";\n    private static final String CARRIERS_TABLE = \"carriers\";\n    private static final String CARRIERS_TABLE_TMP = \"carriers_tmp\";\n    private static final String SIMINFO_TABLE = \"siminfo\";\n    private static final String SIMINFO_TABLE_TMP = \"siminfo_tmp\";\n\n    private static final String PREF_FILE_APN = \"preferred-apn\";\n    private static final String COLUMN_APN_ID = \"apn_id\";\n    private static final String EXPLICIT_SET_CALLED = \"explicit_set_called\";\n\n    private static final String PREF_FILE_FULL_APN = \"preferred-full-apn\";\n    private static final String DB_VERSION_KEY = \"version\";\n\n    private static final String BUILD_ID_FILE = \"build-id\";\n    private static final String RO_BUILD_ID = \"ro_build_id\";\n\n    private static final String ENFORCED_FILE = \"dpc-apn-enforced\";\n    private static final String ENFORCED_KEY = \"enforced\";\n\n    private static final String PREF_FILE = \"telephonyprovider\";\n    private static final String APN_CONF_CHECKSUM = \"apn_conf_checksum\";\n\n    private static final String PARTNER_APNS_PATH = \"etc/apns-conf.xml\";\n    private static final String OEM_APNS_PATH = \"telephony/apns-conf.xml\";\n    private static final String OTA_UPDATED_APNS_PATH = \"misc/apns/apns-conf.xml\";\n    private static final String OLD_APNS_PATH = \"etc/old-apns-conf.xml\";\n\n    private static final String DEFAULT_PROTOCOL = \"IP\";\n    private static final String DEFAULT_ROAMING_PROTOCOL = \"IP\";\n\n    private static final UriMatcher s_urlMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    private static final ContentValues s_currentNullMap;\n    private static final ContentValues s_currentSetMap;\n\n    private static final String IS_UNEDITED = EDITED_STATUS + \"=\" + UNEDITED;\n    private static final String IS_EDITED = EDITED_STATUS + \"!=\" + UNEDITED;\n    private static final String IS_USER_EDITED = EDITED_STATUS + \"=\" + USER_EDITED;\n    private static final String IS_NOT_USER_EDITED = EDITED_STATUS + \"!=\" + USER_EDITED;\n    private static final String IS_USER_DELETED = EDITED_STATUS + \"=\" + USER_DELETED;\n    private static final String IS_NOT_USER_DELETED = EDITED_STATUS + \"!=\" + USER_DELETED;\n    private static final String IS_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_CARRIER_EDITED = EDITED_STATUS + \"=\" + CARRIER_EDITED;\n    private static final String IS_NOT_CARRIER_EDITED = EDITED_STATUS + \"!=\" + CARRIER_EDITED;\n    private static final String IS_CARRIER_DELETED = EDITED_STATUS + \"=\" + CARRIER_DELETED;\n    private static final String IS_NOT_CARRIER_DELETED = EDITED_STATUS + \"!=\" + CARRIER_DELETED;\n    private static final String IS_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_OWNED_BY_DPC = OWNED_BY + \"=\" + OWNED_BY_DPC;\n    private static final String IS_NOT_OWNED_BY_DPC = OWNED_BY + \"!=\" + OWNED_BY_DPC;\n\n    private static final String ORDER_BY_SUB_ID =\n            Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \" ASC\";\n\n    @VisibleForTesting\n    static final String BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE = \"sim_specific_settings_file\";\n    // Holds names and value types of SimInfoDb columns to backup.\n    private static final Map<String, Integer> SIM_INFO_COLUMNS_TO_BACKUP = new HashMap();\n    private static final String KEY_SIMINFO_DB_ROW_PREFIX = \"KEY_SIMINFO_DB_ROW_\";\n    private static final int DEFAULT_INT_COLUMN_VALUE = -111;\n    private static final String DEFAULT_STRING_COLUMN_VALUE = \"DEFAULT_STRING_COLUMN_VALUE\";\n    private static final String SIM_INSERTED_RESTORE_URI_SUFFIX = \"sim_inserted_restore\";\n    @VisibleForTesting\n    static final String KEY_BACKUP_DATA_FORMAT_VERSION = \"KEY_BACKUP_DATA_FORMAT_VERSION\";\n    @VisibleForTesting\n    static final String KEY_PREVIOUSLY_RESTORED_SUB_IDS = \"KEY_PREVIOUSLY_RESTORED_SUB_IDS\";\n\n    private static final int INVALID_APN_ID = -1;\n    private static final List<String> CARRIERS_UNIQUE_FIELDS = new ArrayList<String>();\n    private static final Set<String> CARRIERS_BOOLEAN_FIELDS = new HashSet<String>();\n    private static final Map<String, String> CARRIERS_UNIQUE_FIELDS_DEFAULTS = new HashMap();\n\n    @VisibleForTesting\n    static Boolean s_apnSourceServiceExists;\n\n    protected final Object mLock = new Object();\n    @GuardedBy(\"mLock\")\n    private IApnSourceService mIApnSourceService;\n    private Injector mInjector;\n\n    private boolean mManagedApnEnforced;\n\n    private final LocalLog mLocalLog = new LocalLog(128);\n\n    /**\n     * Mobile country codes where there is a high likelyhood that the MNC has 3 digits\n     * and need one more prefix zero to set correct mobile network code value.\n     *\n     * Please note! The best solution is to add the MCCMNC combo to carrier id\n     * carrier_list, this is just a best effort.\n     */\n    private static final String[] COUNTRY_MCC_WITH_THREE_DIGIT_MNC = {\n            \"302\" // Canada\n           ,\"310\" // Guam, USA\n           ,\"311\" // USA\n           ,\"312\" // USA\n           ,\"313\" // USA\n           ,\"316\" // USA\n           ,\"334\" // Mexico\n           ,\"338\" // Bermuda, Jamaica\n           ,\"342\" // Barbados\n           ,\"344\" // Antigua and Barbuda\n           ,\"346\" // Cayman Islands\n           ,\"348\" // British Virgin Islands\n           ,\"356\" // Saint Kitts and Nevis\n           ,\"358\" // Saint Lucia\n           ,\"360\" // Saint Vincent and the Grenadines\n           ,\"365\" // Anguilla\n           ,\"366\" // Dominica\n           ,\"376\" // Turks and Caicos Islands\n           ,\"405\" // India\n           ,\"708\" // Honduras\n           ,\"722\" // Argentina\n           ,\"732\" // Colombia\n           ,\"738\" // Guyana\n           ,\"750\" // Falkland Islands\n            };\n\n    /**\n     * Available radio technologies for GSM, UMTS and CDMA.\n     * Duplicates the constants from hardware/radio/include/ril.h\n     * This should only be used by agents working with the ril.  Others\n     * should use the equivalent TelephonyManager.NETWORK_TYPE_*\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_UNKNOWN = 0;\n    private static final int RIL_RADIO_TECHNOLOGY_GPRS = 1;\n    private static final int RIL_RADIO_TECHNOLOGY_EDGE = 2;\n    private static final int RIL_RADIO_TECHNOLOGY_UMTS = 3;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95A = 4;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95B = 5;\n    private static final int RIL_RADIO_TECHNOLOGY_1xRTT = 6;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_0 = 7;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_A = 8;\n    private static final int RIL_RADIO_TECHNOLOGY_HSDPA = 9;\n    private static final int RIL_RADIO_TECHNOLOGY_HSUPA = 10;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPA = 11;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_B = 12;\n    private static final int RIL_RADIO_TECHNOLOGY_EHRPD = 13;\n    private static final int RIL_RADIO_TECHNOLOGY_LTE = 14;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPAP = 15;\n\n    /**\n     * GSM radio technology only supports voice. It does not support data.\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_GSM = 16;\n    private static final int RIL_RADIO_TECHNOLOGY_TD_SCDMA = 17;\n\n    /**\n     * IWLAN\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;\n\n    /**\n     * LTE_CA\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_LTE_CA = 19;\n\n    /**\n     * NR(New Radio) 5G.\n     */\n    private static final int  RIL_RADIO_TECHNOLOGY_NR = 20;\n\n    /**\n     * The number of the radio technologies.\n     */\n    private static final int NEXT_RIL_RADIO_TECHNOLOGY = 21;\n\n    private static final Map<String, Integer> MVNO_TYPE_STRING_MAP;\n\n    static {\n        // Columns not included in UNIQUE constraint: name, current, edited, user, server, password,\n        // authtype, type, protocol, roaming_protocol, sub_id, modem_cognitive, max_conns,\n        // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n        // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(NUMERIC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MCC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MNC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ENABLED, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(BEARER, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_TYPE, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_MATCH_DATA, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROFILE_ID, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(ROAMING_PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(USER_EDITABLE, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(OWNED_BY, String.valueOf(OWNED_BY_OTHERS));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN_SET_ID, String.valueOf(NO_APN_SET_ID));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ID,\n                String.valueOf(TelephonyManager.UNKNOWN_CARRIER_ID));\n\n        CARRIERS_UNIQUE_FIELDS.addAll(CARRIERS_UNIQUE_FIELDS_DEFAULTS.keySet());\n\n        // SQLite databases store bools as ints but the ContentValues objects passed in through\n        // queries use bools. As a result there is some special handling of boolean fields within\n        // the TelephonyProvider.\n        CARRIERS_BOOLEAN_FIELDS.add(CARRIER_ENABLED);\n        CARRIERS_BOOLEAN_FIELDS.add(MODEM_PERSIST);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_VISIBLE);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_EDITABLE);\n\n        MVNO_TYPE_STRING_MAP = new ArrayMap<String, Integer>();\n        MVNO_TYPE_STRING_MAP.put(\"spn\", ApnSetting.MVNO_TYPE_SPN);\n        MVNO_TYPE_STRING_MAP.put(\"imsi\", ApnSetting.MVNO_TYPE_IMSI);\n        MVNO_TYPE_STRING_MAP.put(\"gid\", ApnSetting.MVNO_TYPE_GID);\n        MVNO_TYPE_STRING_MAP.put(\"iccid\", ApnSetting.MVNO_TYPE_ICCID);\n\n        // To B&R a new config, simply add the column name and its appropriate value type to\n        // SIM_INFO_COLUMNS_TO_BACKUP. To no longer B&R a column, simply remove it from\n        // SIM_INFO_COLUMNS_TO_BACKUP. For both cases, add appropriate versioning logic in\n        // convertBackedUpDataToContentValues(ContentValues contenValues)\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ICC_ID, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NUMBER, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_CARRIER_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_VT_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES, Cursor.FIELD_TYPE_STRING);\n    }\n\n    @VisibleForTesting\n    public static String getStringForCarrierTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName +\n                \"(_id INTEGER PRIMARY KEY,\" +\n                NAME + \" TEXT DEFAULT '',\" +\n                NUMERIC + \" TEXT DEFAULT '',\" +\n                MCC + \" TEXT DEFAULT '',\" +\n                MNC + \" TEXT DEFAULT '',\" +\n                CARRIER_ID + \" INTEGER DEFAULT \" + TelephonyManager.UNKNOWN_CARRIER_ID  + \",\" +\n                APN + \" TEXT DEFAULT '',\" +\n                USER + \" TEXT DEFAULT '',\" +\n                SERVER + \" TEXT DEFAULT '',\" +\n                PASSWORD + \" TEXT DEFAULT '',\" +\n                PROXY + \" TEXT DEFAULT '',\" +\n                PORT + \" TEXT DEFAULT '',\" +\n                MMSPROXY + \" TEXT DEFAULT '',\" +\n                MMSPORT + \" TEXT DEFAULT '',\" +\n                MMSC + \" TEXT DEFAULT '',\" +\n                AUTH_TYPE + \" INTEGER DEFAULT -1,\" +\n                TYPE + \" TEXT DEFAULT '',\" +\n                CURRENT + \" INTEGER,\" +\n                PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_PROTOCOL + \",\" +\n                ROAMING_PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_ROAMING_PROTOCOL + \",\" +\n                CARRIER_ENABLED + \" BOOLEAN DEFAULT 1,\" + // SQLite databases store bools as ints\n                BEARER + \" INTEGER DEFAULT 0,\" +\n                BEARER_BITMASK + \" INTEGER DEFAULT 0,\" +\n                NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                MVNO_TYPE + \" TEXT DEFAULT '',\" +\n                MVNO_MATCH_DATA + \" TEXT DEFAULT '',\" +\n                SUBSCRIPTION_ID + \" INTEGER DEFAULT \" +\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID + \",\" +\n                PROFILE_ID + \" INTEGER DEFAULT 0,\" +\n                MODEM_PERSIST + \" BOOLEAN DEFAULT 0,\" +\n                MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                WAIT_TIME_RETRY + \" INTEGER DEFAULT 0,\" +\n                TIME_LIMIT_FOR_MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                MTU + \" INTEGER DEFAULT 0,\" +\n                MTU_V4 + \" INTEGER DEFAULT 0,\" +\n                MTU_V6 + \" INTEGER DEFAULT 0,\" +\n                EDITED_STATUS + \" INTEGER DEFAULT \" + UNEDITED + \",\" +\n                USER_VISIBLE + \" BOOLEAN DEFAULT 1,\" +\n                USER_EDITABLE + \" BOOLEAN DEFAULT 1,\" +\n                OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \",\" +\n                APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \",\" +\n                SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \",\" +\n                ALWAYS_ON + \" INTEGER DEFAULT 0,\" +\n                // Uniqueness collisions are used to trigger merge code so if a field is listed\n                // here it means we will accept both (user edited + new apn_conf definition)\n                // Columns not included in UNIQUE constraint: name, current, edited,\n                // user, server, password, authtype, type, sub_id, modem_cognitive, max_conns,\n                // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n                // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on.\n                \"UNIQUE (\" + TextUtils.join(\", \", CARRIERS_UNIQUE_FIELDS) + \"));\";\n    }\n\n    @VisibleForTesting\n    public static String getStringForSimInfoTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName + \"(\"\n                + Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID\n                + \" INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                + Telephony.SimInfo.COLUMN_ICC_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_NOT_INSERTED + \",\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NAME_SOURCE\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.NAME_SOURCE_CARRIER_ID + \",\"\n                + Telephony.SimInfo.COLUMN_COLOR + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.COLOR_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_NUMBER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT\n                + \" INTEGER NOT NULL DEFAULT \" + Telephony.SimInfo.DISPLAY_NUMBER_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_DATA_ROAMING\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.DATA_ROAMING_DISABLE + \",\"\n                + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_PROVISIONED + \",\"\n                + Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CARD_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION + \" INTEGER DEFAULT 4,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.PROFILE_CLASS_UNSET + \",\"\n                + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \",\"\n                + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IMSI + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES + \" BIGINT DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_RCS_CONFIG + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PORT_INDEX + \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USAGE_SETTING + \" INTEGER DEFAULT \"\n                + SubscriptionManager.USAGE_SETTING_UNKNOWN + \",\"\n                + Telephony.SimInfo.COLUMN_TP_MESSAGE_REF +\n                \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USER_HANDLE + \" INTEGER DEFAULT \"\n                + UserHandle.USER_NULL + \",\"\n                + Telephony.SimInfo.COLUMN_SATELLITE_ENABLED + \" INTEGER DEFAULT -1\"\n                + \");\";\n    }\n\n    static {\n        s_urlMatcher.addURI(\"telephony\", \"carriers\", URL_TELEPHONY);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current\", URL_CURRENT);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/#\", URL_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore\", URL_RESTOREAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn\", URL_PREFERAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update\", URL_PREFERAPN_NO_UPDATE);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset\", URL_PREFERAPNSET);\n\n        s_urlMatcher.addURI(\"telephony\", \"siminfo\", URL_SIMINFO);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/#\", URL_SIMINFO_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/suw_restore\",\n                URL_SIMINFO_SUW_RESTORE);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/\" +\n                SIM_INSERTED_RESTORE_URI_SUFFIX,\n                URL_SIMINFO_SIM_INSERTED_RESTORE);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/subId/*\", URL_TELEPHONY_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current/subId/*\", URL_CURRENT_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore/subId/*\", URL_RESTOREAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn/subId/*\", URL_PREFERAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update/subId/*\",\n                URL_PREFERAPN_NO_UPDATE_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset/subId/*\",\n                URL_PREFERAPNSET_USING_SUBID);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/update_db\", URL_UPDATE_DB);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/delete\", URL_DELETE);\n\n        // Only called by DevicePolicyManager to manipulate DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc\", URL_DPC);\n        // Only called by DevicePolicyManager to manipulate a DPC record with certain _ID.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc/#\", URL_DPC_ID);\n        // Only called by Settings app, DcTracker and other telephony components to get APN list\n        // according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered\", URL_FILTERED);\n        // Only called by Settings app, DcTracker and other telephony components to get a\n        // single APN according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/#\", URL_FILTERED_ID);\n        // Used by DcTracker to pass a subId.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/subId/*\", URL_FILTERED_USING_SUBID);\n\n        // Only Called by DevicePolicyManager to enforce DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/enforce_managed\", URL_ENFORCE_MANAGED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list\", URL_SIM_APN_LIST);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/#\", URL_SIM_APN_LIST_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered\",\n            URL_SIM_APN_LIST_FILTERED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered/subId/*\",\n                URL_SIM_APN_LIST_FILTERED_ID);\n\n        s_currentNullMap = new ContentValues(1);\n        s_currentNullMap.put(CURRENT, \"0\");\n\n        s_currentSetMap = new ContentValues(1);\n        s_currentSetMap.put(CURRENT, \"1\");\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n    }\n\n    public TelephonyProvider() {\n        this(new Injector());\n    }\n\n    @VisibleForTesting\n    public TelephonyProvider(Injector injector) {\n        mInjector = injector;\n    }\n\n    @VisibleForTesting\n    public static int getVersion(Context context) {\n        if (VDBG) log(\"getVersion:+\");\n        // Get the database version, combining a static schema version and the XML version\n        Resources r = context.getResources();\n        if (r == null) {\n            loge(\"resources=null, return version=\" + Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        }\n        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n        try {\n            XmlUtils.beginDocument(parser, \"apns\");\n            int publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n            int version = DATABASE_VERSION | publicversion;\n            if (VDBG) log(\"getVersion:- version=0x\" + Integer.toHexString(version));\n            return version;\n        } catch (Exception e) {\n            loge(\"Can't get version of APN database\" + e + \" return version=\" +\n                    Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        } finally {\n            parser.close();\n        }\n    }\n\n    static public ContentValues setDefaultValue(ContentValues values) {\n        if (!values.containsKey(SUBSCRIPTION_ID)) {\n            int subId = SubscriptionManager.getDefaultSubscriptionId();\n            values.put(SUBSCRIPTION_ID, subId);\n        }\n\n        return values;\n    }\n\n    @VisibleForTesting\n    public class DatabaseHelper extends SQLiteOpenHelper {\n        // Context to access resources with\n        private Context mContext;\n\n        /**\n         * DatabaseHelper helper class for loading apns into a database.\n         *\n         * @param context of the user.\n         */\n        public DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n            setWriteAheadLoggingEnabled(false);\n        }\n\n        @Override\n        public void onCreate(SQLiteDatabase db) {\n            if (DBG) log(\"dbh.onCreate:+ db=\" + db);\n            createSimInfoTable(db, SIMINFO_TABLE);\n            createCarriersTable(db, CARRIERS_TABLE);\n            // if CarrierSettings app is installed, we expect it to do the initializiation instead\n            if (apnSourceServiceExists(mContext)) {\n                log(\"dbh.onCreate: Skipping apply APNs from xml.\");\n            } else {\n                log(\"dbh.onCreate: Apply apns from xml.\");\n                initDatabase(db);\n            }\n            if (DBG) log(\"dbh.onCreate:- db=\" + db);\n        }\n\n        @Override\n        public void onOpen(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.onOpen:+ db=\" + db);\n            try {\n                // Try to access the table and create it if \"no such table\"\n                db.query(SIMINFO_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + SIMINFO_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + SIMINFO_TABLE + \"e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createSimInfoTable(db, SIMINFO_TABLE);\n                }\n            }\n            try {\n                db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + CARRIERS_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + CARRIERS_TABLE + \" e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createCarriersTable(db, CARRIERS_TABLE);\n                }\n            }\n            if (VDBG) log(\"dbh.onOpen:- db=\" + db);\n        }\n\n        private void createSimInfoTable(SQLiteDatabase db, String tableName) {\n            if (DBG) log(\"dbh.createSimInfoTable:+ \" + tableName);\n            db.execSQL(getStringForSimInfoTableCreation(tableName));\n            if (DBG) log(\"dbh.createSimInfoTable:-\");\n        }\n\n        private void createCarriersTable(SQLiteDatabase db, String tableName) {\n            // Set up the database schema\n            if (DBG) log(\"dbh.createCarriersTable: \" + tableName);\n            db.execSQL(getStringForCarrierTableCreation(tableName));\n            if (DBG) log(\"dbh.createCarriersTable:-\");\n        }\n\n        private long getChecksum(File file) {\n            CRC32 checkSummer = new CRC32();\n            long checkSum = -1;\n            try (CheckedInputStream cis =\n                new CheckedInputStream(new FileInputStream(file), checkSummer)){\n                byte[] buf = new byte[128];\n                if(cis != null) {\n                    while(cis.read(buf) >= 0) {\n                        // Just read for checksum to get calculated.\n                    }\n                }\n                checkSum = checkSummer.getValue();\n                if (DBG) log(\"Checksum for \" + file.getAbsolutePath() + \" is \" + checkSum);\n            } catch (FileNotFoundException e) {\n                loge(\"FileNotFoundException for \" + file.getAbsolutePath() + \":\" + e);\n            } catch (IOException e) {\n                loge(\"IOException for \" + file.getAbsolutePath() + \":\" + e);\n            }\n\n            // The RRO may have been updated in a firmware upgrade. Add checksum for the\n            // resources to the total checksum so that apns in an RRO update is not missed.\n            try (InputStream inputStream = mContext.getResources().\n                        openRawResource(com.android.internal.R.xml.apns)) {\n                byte[] array = toByteArray(inputStream);\n                checkSummer.reset();\n                checkSummer.update(array);\n                checkSum += checkSummer.getValue();\n                if (DBG) log(\"Checksum after adding resource is \" + checkSummer.getValue());\n            } catch (IOException | Resources.NotFoundException e) {\n                loge(\"Exception when calculating checksum for internal apn resources: \" + e);\n            }\n            return checkSum;\n        }\n\n        private byte[] toByteArray(InputStream input) throws IOException {\n            byte[] buffer = new byte[128];\n            int bytesRead;\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            return output.toByteArray();\n        }\n\n        private long getApnConfChecksum() {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            return sp.getLong(APN_CONF_CHECKSUM, -1);\n        }\n\n        private void setApnConfChecksum(long checksum) {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.putLong(APN_CONF_CHECKSUM, checksum);\n            editor.apply();\n        }\n\n        private File getApnConfFile() {\n            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or \"/system\".\n            File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);\n            File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);\n            File updatedConfFile = new File(Environment.getDataDirectory(), OTA_UPDATED_APNS_PATH);\n            File productConfFile = new File(Environment.getProductDirectory(), PARTNER_APNS_PATH);\n            confFile = pickSecondIfExists(confFile, oemConfFile);\n            confFile = pickSecondIfExists(confFile, productConfFile);\n            confFile = pickSecondIfExists(confFile, updatedConfFile);\n            return confFile;\n        }\n\n        /**\n         * This function computes checksum for the file to be read and compares it against the\n         * last read file. DB needs to be updated only if checksum has changed, or old checksum does\n         * not exist.\n         * @return true if DB should be updated with new conf file, false otherwise\n         */\n        private boolean apnDbUpdateNeeded() {\n            File confFile = getApnConfFile();\n            long newChecksum = getChecksum(confFile);\n            long oldChecksum = getApnConfChecksum();\n            if (DBG) log(\"newChecksum: \" + newChecksum);\n            if (DBG) log(\"oldChecksum: \" + oldChecksum);\n            if (newChecksum == oldChecksum) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        /**\n         *  This function adds APNs from xml file(s) to db. The db may or may not be empty to begin\n         *  with.\n         */\n        private void initDatabase(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.initDatabase:+ db=\" + db);\n            // Read internal APNS data\n            Resources r = mContext.getResources();\n            int publicversion = -1;\n            if (r != null) {\n                XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n                try {\n                    XmlUtils.beginDocument(parser, \"apns\");\n                    publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n                    loadApns(db, parser, true);\n                } catch (Exception e) {\n                    loge(\"Got exception while loading APN database.\" + e);\n                } finally {\n                    parser.close();\n                }\n            } else {\n                loge(\"initDatabase: resources=null\");\n            }\n\n            // Read external APNS data (partner-provided)\n            XmlPullParser confparser = null;\n            File confFile = getApnConfFile();\n\n            FileReader confreader = null;\n            if (DBG) log(\"confFile = \" + confFile);\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                // Correctness check. Force internal version and confidential versions to agree\n                int confversion = Integer.parseInt(confparser.getAttributeValue(null, \"version\"));\n                if (publicversion != confversion) {\n                    log(\"initDatabase: throwing exception due to version mismatch\");\n                    throw new IllegalStateException(\"Internal APNS file version doesn't match \"\n                            + confFile.getAbsolutePath());\n                }\n\n                loadApns(db, confparser, false);\n            } catch (FileNotFoundException e) {\n                // It's ok if the file isn't found. It means there isn't a confidential file\n                // Log.e(TAG, \"File not found: '\" + confFile.getAbsolutePath() + \"'\");\n            } catch (Exception e) {\n                loge(\"initDatabase: Exception while parsing '\" + confFile.getAbsolutePath() + \"'\" +\n                        e);\n            } finally {\n                // Get rid of user/carrier deleted entries that are not present in apn xml file.\n                // Those entries have edited value USER_DELETED/CARRIER_DELETED.\n                if (VDBG) {\n                    log(\"initDatabase: deleting USER_DELETED and replacing \"\n                            + \"DELETED_BUT_PRESENT_IN_XML with DELETED\");\n                }\n\n                // Delete USER_DELETED\n                db.delete(CARRIERS_TABLE, IS_USER_DELETED + \" or \" + IS_CARRIER_DELETED, null);\n\n                // Change USER_DELETED_BUT_PRESENT_IN_XML to USER_DELETED\n                ContentValues cv = new ContentValues();\n                cv.put(EDITED_STATUS, USER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_USER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                // Change CARRIER_DELETED_BUT_PRESENT_IN_XML to CARRIER_DELETED\n                cv = new ContentValues();\n                cv.put(EDITED_STATUS, CARRIER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_CARRIER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n\n                // Update the stored checksum\n                setApnConfChecksum(getChecksum(confFile));\n            }\n            if (VDBG) log(\"dbh.initDatabase:- db=\" + db);\n\n        }\n\n        private File pickSecondIfExists(File sysApnFile, File altApnFile) {\n            if (altApnFile.exists()) {\n                if (DBG) log(\"Load APNs from \" + altApnFile.getPath() +\n                        \" instead of \" + sysApnFile.getPath());\n                return altApnFile;\n            } else {\n                if (DBG) log(\"Load APNs from \" + sysApnFile.getPath() +\n                        \" instead of \" + altApnFile.getPath());\n                return sysApnFile;\n            }\n        }\n\n        @Override\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n            if (DBG) {\n                log(\"dbh.onUpgrade:+ db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n\n            deletePreferredApnId(mContext);\n\n            if (oldVersion < (5 << 16 | 6)) {\n                // 5 << 16 is the Database version and 6 in the xml version.\n\n                // This change adds a new authtype column to the database.\n                // The auth type column can have 4 values: 0 (None), 1 (PAP), 2 (CHAP)\n                // 3 (PAP or CHAP). To avoid breaking compatibility, with already working\n                // APNs, the unset value (-1) will be used. If the value is -1.\n                // the authentication will default to 0 (if no user / password) is specified\n                // or to 3. Currently, there have been no reported problems with\n                // pre-configured APNs and hence it is set to -1 for them. Similarly,\n                // if the user, has added a new APN, we set the authentication type\n                // to -1.\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN authtype INTEGER DEFAULT -1;\");\n\n                oldVersion = 5 << 16 | 6;\n            }\n            if (oldVersion < (6 << 16 | 6)) {\n                // Add protcol fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN protocol TEXT DEFAULT IP;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN roaming_protocol TEXT DEFAULT IP;\");\n                oldVersion = 6 << 16 | 6;\n            }\n            if (oldVersion < (7 << 16 | 6)) {\n                // Add carrier_enabled, bearer fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN carrier_enabled BOOLEAN DEFAULT 1;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN bearer INTEGER DEFAULT 0;\");\n                oldVersion = 7 << 16 | 6;\n            }\n            if (oldVersion < (8 << 16 | 6)) {\n                // Add mvno_type, mvno_match_data fields to the APN.\n                // The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_type TEXT DEFAULT '';\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_match_data TEXT DEFAULT '';\");\n                oldVersion = 8 << 16 | 6;\n            }\n            if (oldVersion < (9 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN sub_id INTEGER DEFAULT \" +\n                        SubscriptionManager.INVALID_SUBSCRIPTION_ID + \";\");\n                oldVersion = 9 << 16 | 6;\n            }\n            if (oldVersion < (10 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN profile_id INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN modem_cognitive BOOLEAN DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN wait_time INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns_time INTEGER DEFAULT 0;\");\n                oldVersion = 10 << 16 | 6;\n            }\n            if (oldVersion < (11 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mtu INTEGER DEFAULT 0;\");\n                oldVersion = 11 << 16 | 6;\n            }\n            if (oldVersion < (12 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 12 << 16 | 6;\n            }\n            if (oldVersion < (13 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT DEFAULT '';\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 13 << 16 | 6;\n            }\n            if (oldVersion < (14 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for next version and that takes care of updates for this version as well.\n                // This version added a new column user_edited to carriers db.\n            }\n            if (oldVersion < (15 << 16 | 6)) {\n                // Most devices should be upgrading from version 13. On upgrade new db will be\n                // populated from the xml included in OTA but user and carrier edited/added entries\n                // need to be preserved. This new version also adds new columns EDITED and\n                // BEARER_BITMASK to the table. Upgrade steps from version 13 are:\n                // 1. preserve user and carrier added/edited APNs (by comparing against\n                // old-apns-conf.xml included in OTA) - done in preserveUserAndCarrierApns()\n                // 2. add new columns EDITED and BEARER_BITMASK (create a new table for that) - done\n                // in createCarriersTable()\n                // 3. copy over preserved APNs from old table to new table - done in\n                // copyPreservedApnsToNewTable()\n                // The only exception if upgrading from version 14 is that EDITED field is already\n                // present (but is called USER_EDITED)\n                /*********************************************************************************\n                 * IMPORTANT NOTE: SINCE CARRIERS TABLE IS RECREATED HERE, IT WILL BE THE LATEST\n                 * VERSION AFTER THIS. AS A RESULT ANY SUBSEQUENT UPDATES TO THE TABLE WILL FAIL\n                 * (DUE TO COLUMN-ALREADY-EXISTS KIND OF EXCEPTION). ALL SUBSEQUENT UPDATES SHOULD\n                 * HANDLE THAT GRACEFULLY.\n                 *********************************************************************************/\n                Cursor c;\n                String[] proj = {\"_id\"};\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                }\n\n                // Compare db with old apns xml file so that any user or carrier edited/added\n                // entries can be preserved across upgrade\n                preserveUserAndCarrierApns(db);\n\n                c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n                if (VDBG) {\n                    log(\"dbh.onUpgrade:- after preserveUserAndCarrierApns() total number of \" +\n                            \"rows: \" + ((c == null) ? 0 : c.getCount()));\n                }\n\n                createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n                copyPreservedApnsToNewTable(db, c);\n                c.close();\n\n                db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE +\n                        \";\");\n\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_UNEDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_UNEDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_EDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_EDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                }\n\n                oldVersion = 15 << 16 | 6;\n            }\n            if (oldVersion < (16 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    // These columns may already be present in which case execSQL will throw an\n                    // exception\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION\n                            + \" INTEGER DEFAULT 4;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL\n                            + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 16 << 16 | 6;\n            }\n            if (oldVersion < (17 << 16 | 6)) {\n                Cursor c = null;\n                try {\n                    c = db.query(CARRIERS_TABLE, null, null, null, null, null, null,\n                            String.valueOf(1));\n                    if (c == null || c.getColumnIndex(USER_VISIBLE) == -1) {\n                        db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                                USER_VISIBLE + \" BOOLEAN DEFAULT 1;\");\n                    } else {\n                        if (DBG) {\n                            log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade.  Column \" +\n                                    USER_VISIBLE + \" already exists.\");\n                        }\n                    }\n                } finally {\n                    if (c != null) {\n                        c.close();\n                    }\n                }\n                oldVersion = 17 << 16 | 6;\n            }\n            if (oldVersion < (18 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.SIM_PROVISIONED + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 18 << 16 | 6;\n            }\n            if (oldVersion < (19 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for version 24 and that takes care of updates for this version as well.\n                // This version added more fields protocol and roaming protocol to the primary key.\n            }\n            if (oldVersion < (20 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 20 << 16 | 6;\n            }\n            if (oldVersion < (21 << 16 | 6)) {\n                try {\n                    // Try to update the carriers table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            USER_EDITABLE + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    // This is possible if the column already exists which may be the case if the\n                    // table was just created as part of upgrade to version 19\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 21 << 16 | 6;\n            }\n            if (oldVersion < (22 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 22 << 16 | 6;\n            }\n            if (oldVersion < (23 << 16 | 6)) {\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 23 << 16 | 6;\n            }\n            if (oldVersion < (24 << 16 | 6)) {\n                Cursor c = null;\n                String[] proj = {\"_id\"};\n                recreateDB(db, proj, /* version */24);\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(\n                            CARRIERS_TABLE, proj, NETWORK_TYPE_BITMASK, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + NETWORK_TYPE_BITMASK + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 24 << 16 | 6;\n            }\n            if (oldVersion < (25 << 16 | 6)) {\n                // Add a new column SubscriptionManager.CARD_ID into the database and set the value\n                // to be the same as the existing column SubscriptionManager.ICC_ID. In order to do\n                // this, we need to first make a copy of the existing SIMINFO_TABLE, set the value\n                // of the new column SubscriptionManager.CARD_ID, and replace the SIMINFO_TABLE with\n                // the new table.\n                Cursor c = null;\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID};\n                recreateSimInfoDB(c, db, proj);\n                if (VDBG) {\n                    c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading \" + SIMINFO_TABLE\n                            + \" total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(SIMINFO_TABLE, proj, Telephony.SimInfo.COLUMN_CARD_ID\n                                    + \" IS NOT NULL\", null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + Telephony.SimInfo.COLUMN_CARD_ID + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 25 << 16 | 6;\n            }\n            if (oldVersion < (26 << 16 | 6)) {\n                // Add a new column Carriers.APN_SET_ID into the database and set the value to\n                // Carriers.NO_SET_SET by default.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 26 << 16 | 6;\n            }\n\n            if (oldVersion < (27 << 16 | 6)) {\n                // Add the new MCC_STRING and MNC_STRING columns into the subscription table,\n                // and attempt to populate them.\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                // Migrate the old integer values over to strings\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_MCC, Telephony.SimInfo.COLUMN_MNC};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInMccMncStringAtCursor(mContext, db, c);\n                    }\n                }\n                oldVersion = 27 << 16 | 6;\n            }\n\n            if (oldVersion < (28 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 28 << 16 | 6;\n            }\n\n            if (oldVersion < (29 << 16 | 6)) {\n                try {\n                    // Add a new column Telephony.CARRIER_ID into the database and add UNIQUE\n                    // constraint into table. However, sqlite cannot add constraints to an existing\n                    // table, so recreate the table.\n                    String[] proj = {\"_id\"};\n                    recreateDB(db, proj,  /* version */29);\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 29 << 16 | 6;\n            }\n\n            if (oldVersion < (30 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 30 << 16 | 6;\n            }\n\n            if (oldVersion < (31 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 31 << 16 | 6;\n            }\n\n            if (oldVersion < (32 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 32 << 16 | 6;\n            }\n\n            if (oldVersion < (33 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 33 << 16 | 6;\n            }\n\n            if (oldVersion < (34 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.PROFILE_CLASS_UNSET + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 34 << 16 | 6;\n            }\n\n            if (oldVersion < (35 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                        + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 35 << 16 | 6;\n            }\n\n            if (oldVersion < (36 << 16 | 6)) {\n                // Add a new column Carriers.SKIP_464XLAT into the database and set the value to\n                // SKIP_464XLAT_DEFAULT.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 36 << 16 | 6;\n            }\n\n            if (oldVersion < (37 << 16 | 6)) {\n                // Add new columns Telephony.SimInfo.EHPLMNS and Telephony.SimInfo.HPLMNS into\n                // the database.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade for ehplmns. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 37 << 16 | 6;\n            }\n\n            if (oldVersion < (39 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 39 << 16 | 6;\n            }\n\n            if (oldVersion < (40 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 40 << 16 | 6;\n            }\n\n            if (oldVersion < (41 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMSI + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 41 << 16 | 6;\n            }\n\n            if (oldVersion < (42 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n            }\n\n            if (oldVersion < (43 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED\n                            + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 43 << 16 | 6;\n            }\n\n            if (oldVersion < (44 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES\n                            + \" BIGINT DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 44 << 16 | 6;\n            }\n\n            if (oldVersion < (45 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 45 << 16 | 6;\n            }\n\n            if (oldVersion < (46 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 46 << 16 | 6;\n            }\n\n            if (oldVersion < (47 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_RCS_CONFIG\n                            + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 47 << 16 | 6;\n            }\n\n            if (oldVersion < (48 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                try {\n                    // Migrate the old Long values over to String\n                    String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                            Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES};\n                    try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                        while (c.moveToNext()) {\n                            fillInAllowedNetworkTypesStringAtCursor(db, c);\n                        }\n                    }\n\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_ALLOWED_NETWORK_TYPES to \"\n                                + \"COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON\");\n                    }\n                }\n                oldVersion = 48 << 16 | 6;\n            }\n\n            if (oldVersion < (49 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing column. \");\n                    }\n                }\n            }\n\n            if (oldVersion < (50 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 50 << 16 | 6;\n            }\n\n            if (oldVersion < (51 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALERT TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 51 << 16 | 6;\n            }\n\n            if (oldVersion < (52 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 52 << 16 | 6;\n            }\n\n            if (oldVersion < (53 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. Fix typo error in version 51.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 53 << 16 | 6;\n            }\n\n            if (oldVersion < (54 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER\n                            + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add phone numbers. \");\n                    }\n                }\n                oldVersion = 54 << 16 | 6;\n            }\n\n            if (oldVersion < (55 << 16 | 6)) {\n                try {\n                    // Try to add new fields LINGERING_NETWORK_TYPE_BITMASK, ALWAYS_ON,\n                    // MTU_V4, and MTU_V6\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + ALWAYS_ON + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V4 + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V6 + \" INTEGER DEFAULT 0;\");\n                    // Populate MTU_V4 with MTU values\n                    db.execSQL(\"UPDATE \" + CARRIERS_TABLE + \" SET \" + MTU_V4 + \" = \"\n                            + MTU + \" WHERE \" + MTU + \" != 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + CARRIERS_TABLE\n                                + \" to add lingering network type bitmask, always on flag,\"\n                                + \" and MTU v4 and v6 values.\");\n                    }\n                }\n                oldVersion = 55 << 16 | 6;\n            }\n\n            if (oldVersion < (56 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PORT_INDEX\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 56 << 16 | 6;\n            }\n\n            if (oldVersion < (57 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USAGE_SETTING\n                            + \" INTEGER DEFAULT \" + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                            + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add preferred usage setting\");\n                    }\n                }\n                oldVersion = 57 << 16 | 6;\n            }\n\n            if (oldVersion < (58 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_TP_MESSAGE_REF\n                            + \"  INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 58 << 16 | 6;\n            }\n\n            if (oldVersion < (59 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USER_HANDLE\n                            + \"  INTEGER DEFAULT \" + UserHandle.USER_NULL +\";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 59 << 16 | 6;\n            }\n            if (oldVersion < (60 << 16 | 6)) {\n                // Update the siminfo table with new column enabled_data_mobile_policies\n                // and set its value to be a copy of data_enabled_override_rules.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to insert \"\n                                +Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES +\" to \"\n                                + SIMINFO_TABLE);\n                    }\n                }\n                // Migrate the old Long values over to String\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInEnabledMobileDataPoliciesAtCursor(db, c);\n                    }\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_DATA_ENABLED_OVERRIDE_RULES to \"\n                                + \"COLUMN_ENABLED_MOBILE_DATA_POLICIES\");\n                    }\n                }\n                oldVersion = 60 << 16 | 6;\n            }\n\n            if (oldVersion < (61 << 16 | 6)) {\n                try {\n                    // If default value of USER_HANDLE column is set to -1, then update it to -10000\n                    db.execSQL(\"UPDATE \" + SIMINFO_TABLE + \" SET \"\n                            + Telephony.SimInfo.COLUMN_USER_HANDLE + \"=\" + UserHandle.USER_NULL\n                            + \"  WHERE \" + Telephony.SimInfo.COLUMN_USER_HANDLE + \"=-1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 61 << 16 | 6;\n            }\n\n            if (oldVersion < (62 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_SATELLITE_ENABLED\n                            + \"  INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add satellite enabled. \");\n                    }\n                }\n                oldVersion = 62 << 16 | 6;\n            }\n            if (DBG) {\n                log(\"dbh.onUpgrade:- db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n            // when adding fields to onUpgrade, also add a unit test to TelephonyDatabaseHelperTest\n            // and update the DATABASE_VERSION field and add a column in copyAllApnValues\n        }\n\n        private void recreateSimInfoDB(Cursor c, SQLiteDatabase db, String[] proj) {\n            if (VDBG) {\n                c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:+ before upgrading \" + SIMINFO_TABLE +\n                        \" total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            // Sort in ascending order by subscription id to make sure the rows do not get flipped\n            // during the query and added in the new sim info table in another order (sub id is\n            // stored in settings between migrations).\n            c = db.query(SIMINFO_TABLE, null, null, null, null, null, ORDER_BY_SUB_ID);\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE_TMP);\n\n            createSimInfoTable(db, SIMINFO_TABLE_TMP);\n\n            copySimInfoDataToTmpTable(db, c);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE_TMP + \" rename to \" + SIMINFO_TABLE + \";\");\n\n        }\n\n        private void copySimInfoDataToTmpTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from SIMINFO_TABLE to SIMINFO_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copySimInfoValuesV24(cv, c);\n                    // The card ID is supposed to be the ICCID of the profile for UICC card, and\n                    // the EID of the card for eUICC card. Since EID is unknown for old entries in\n                    // SIMINFO_TABLE, we use ICCID as the card ID for all the old entries while\n                    // upgrading the SIMINFO_TABLE. In UiccController, both the card ID and ICCID\n                    // will be checked when user queries the slot information using the card ID\n                    // from the database.\n                    getCardIdfromIccid(cv, c);\n                    try {\n                        db.insert(SIMINFO_TABLE_TMP, null, cv);\n                        if (VDBG) {\n                            log(\"dbh.copySimInfoDataToTmpTable: db.insert returned >= 0; \" +\n                                \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copySimInfoDataToTmpTable insertWithOnConflict exception \" +\n                                e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copySimInfoValuesV24(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ICC_ID);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CARRIER_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NUMBER);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NAME_SOURCE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_COLOR);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DATA_ROAMING);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MCC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MNC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_EMBEDDED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_REMOVABLE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_AMBER_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_VT_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED);\n\n            // Blob vals\n            getBlobValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ACCESS_RULES);\n        }\n\n        private void getCardIdfromIccid(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    cv.put(Telephony.SimInfo.COLUMN_CARD_ID, fromCursor);\n                }\n            }\n        }\n\n        private void recreateDB(SQLiteDatabase db, String[] proj, int version) {\n            // Upgrade steps are:\n            // 1. Create a temp table- done in createCarriersTable()\n            // 2. copy over APNs from old table to new table - done in copyDataToTmpTable()\n            // 3. Drop the existing table.\n            // 4. Copy over the tmp table.\n            Cursor c;\n            if (VDBG) {\n                c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n            if (VDBG) {\n                log(\"dbh.onUpgrade:- starting data copy of existing rows: \" +\n                        + ((c == null) ? 0 : c.getCount()));\n            }\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE_TMP);\n\n            createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n            copyDataToTmpTable(db, c, version);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE + \";\");\n        }\n\n        private void preserveUserAndCarrierApns(SQLiteDatabase db) {\n            if (VDBG) log(\"preserveUserAndCarrierApns\");\n            XmlPullParser confparser;\n            File confFile = new File(Environment.getRootDirectory(), OLD_APNS_PATH);\n            FileReader confreader = null;\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                deleteMatchingApns(db, confparser);\n            } catch (FileNotFoundException e) {\n                // This function is called only when upgrading db to version 15. Details about the\n                // upgrade are mentioned in onUpgrade(). This file missing means user/carrier added\n                // APNs cannot be preserved. Log an error message so that OEMs know they need to\n                // include old apns file for comparison.\n                loge(\"PRESERVEUSERANDCARRIERAPNS: \" + OLD_APNS_PATH +\n                        \" NOT FOUND. IT IS NEEDED TO UPGRADE FROM OLDER VERSIONS OF APN \" +\n                        \"DB WHILE PRESERVING USER/CARRIER ADDED/EDITED ENTRIES.\");\n            } catch (Exception e) {\n                loge(\"preserveUserAndCarrierApns: Exception while parsing '\" +\n                        confFile.getAbsolutePath() + \"'\" + e);\n            } finally {\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void deleteMatchingApns(SQLiteDatabase db, XmlPullParser parser) {\n            if (VDBG) log(\"deleteMatchingApns\");\n            if (parser != null) {\n                if (VDBG) log(\"deleteMatchingApns: parser != null\");\n                try {\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, false);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        deleteRow(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                } catch (XmlPullParserException e) {\n                    loge(\"deleteMatchingApns: Got XmlPullParserException while deleting apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"deleteMatchingApns: Got IOException while deleting apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"deleteMatchingApns: Got SQLException while deleting apns.\" + e);\n                }\n            }\n        }\n\n        private String queryValFirst(String field) {\n            return field + \"=?\";\n        }\n\n        private String queryVal(String field) {\n            return \" and \" + field + \"=?\";\n        }\n\n        private String queryValOrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private String queryVal2OrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private void deleteRow(SQLiteDatabase db, ContentValues values) {\n            if (VDBG) log(\"deleteRow\");\n            String where = queryValFirst(NUMERIC) +\n                    queryVal(MNC) +\n                    queryVal(MNC) +\n                    queryValOrNull(APN) +\n                    queryValOrNull(USER) +\n                    queryValOrNull(SERVER) +\n                    queryValOrNull(PASSWORD) +\n                    queryValOrNull(PROXY) +\n                    queryValOrNull(PORT) +\n                    queryValOrNull(MMSPROXY) +\n                    queryValOrNull(MMSPORT) +\n                    queryValOrNull(MMSC) +\n                    queryValOrNull(AUTH_TYPE) +\n                    queryValOrNull(TYPE) +\n                    queryValOrNull(PROTOCOL) +\n                    queryValOrNull(ROAMING_PROTOCOL) +\n                    queryVal2OrNull(CARRIER_ENABLED) +\n                    queryValOrNull(BEARER) +\n                    queryValOrNull(MVNO_TYPE) +\n                    queryValOrNull(MVNO_MATCH_DATA) +\n                    queryValOrNull(PROFILE_ID) +\n                    queryVal2OrNull(MODEM_PERSIST) +\n                    queryValOrNull(MAX_CONNECTIONS) +\n                    queryValOrNull(WAIT_TIME_RETRY) +\n                    queryValOrNull(TIME_LIMIT_FOR_MAX_CONNECTIONS) +\n                    queryValOrNull(MTU) +\n                    queryValOrNull(MTU_V4) +\n                    queryValOrNull(MTU_V6);\n            String[] whereArgs = new String[31];\n            int i = 0;\n            whereArgs[i++] = values.getAsString(NUMERIC);\n            whereArgs[i++] = values.getAsString(MCC);\n            whereArgs[i++] = values.getAsString(MNC);\n            whereArgs[i++] = values.getAsString(NAME);\n            whereArgs[i++] = values.containsKey(APN) ?\n                    values.getAsString(APN) : \"\";\n            whereArgs[i++] = values.containsKey(USER) ?\n                    values.getAsString(USER) : \"\";\n            whereArgs[i++] = values.containsKey(SERVER) ?\n                    values.getAsString(SERVER) : \"\";\n            whereArgs[i++] = values.containsKey(PASSWORD) ?\n                    values.getAsString(PASSWORD) : \"\";\n            whereArgs[i++] = values.containsKey(PROXY) ?\n                    values.getAsString(PROXY) : \"\";\n            whereArgs[i++] = values.containsKey(PORT) ?\n                    values.getAsString(PORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPROXY) ?\n                    values.getAsString(MMSPROXY) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPORT) ?\n                    values.getAsString(MMSPORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSC) ?\n                    values.getAsString(MMSC) : \"\";\n            whereArgs[i++] = values.containsKey(AUTH_TYPE) ?\n                    values.getAsString(AUTH_TYPE) : \"-1\";\n            whereArgs[i++] = values.containsKey(TYPE) ?\n                    values.getAsString(TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(PROTOCOL) ?\n                    values.getAsString(PROTOCOL) : DEFAULT_PROTOCOL;\n            whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ?\n                    values.getAsString(ROAMING_PROTOCOL) : DEFAULT_ROAMING_PROTOCOL;\n\n            if (values.containsKey(CARRIER_ENABLED)) {\n                whereArgs[i++] = convertStringToBoolString(values.getAsString(CARRIER_ENABLED));\n                whereArgs[i++] = convertStringToIntString(values.getAsString(CARRIER_ENABLED));\n            } else {\n                String defaultIntString = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(CARRIER_ENABLED);\n                whereArgs[i++] = convertStringToBoolString(defaultIntString);\n                whereArgs[i++] = defaultIntString;\n            }\n\n            whereArgs[i++] = values.containsKey(BEARER) ?\n                    values.getAsString(BEARER) : \"0\";\n            whereArgs[i++] = values.containsKey(MVNO_TYPE) ?\n                    values.getAsString(MVNO_TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ?\n                    values.getAsString(MVNO_MATCH_DATA) : \"\";\n            whereArgs[i++] = values.containsKey(PROFILE_ID) ?\n                    values.getAsString(PROFILE_ID) : \"0\";\n\n            if (values.containsKey(MODEM_PERSIST) &&\n                    (values.getAsString(MODEM_PERSIST).\n                            equalsIgnoreCase(\"true\") ||\n                            values.getAsString(MODEM_PERSIST).equals(\"1\"))) {\n                whereArgs[i++] = \"true\";\n                whereArgs[i++] = \"1\";\n            } else {\n                whereArgs[i++] = \"false\";\n                whereArgs[i++] = \"0\";\n            }\n\n            whereArgs[i++] = values.containsKey(MAX_CONNECTIONS) ?\n                    values.getAsString(MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(WAIT_TIME_RETRY) ?\n                    values.getAsString(WAIT_TIME_RETRY) : \"0\";\n            whereArgs[i++] = values.containsKey(TIME_LIMIT_FOR_MAX_CONNECTIONS) ?\n                    values.getAsString(TIME_LIMIT_FOR_MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU) ?\n                    values.getAsString(MTU) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V4) ?\n                    values.getAsString(MTU_V4) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V6) ?\n                    values.getAsString(MTU_V6) : \"0\";\n\n            if (VDBG) {\n                log(\"deleteRow: where: \" + where);\n\n                StringBuilder builder = new StringBuilder();\n                for (String s : whereArgs) {\n                    builder.append(s + \", \");\n                }\n\n                log(\"deleteRow: whereArgs: \" + builder.toString());\n            }\n            db.delete(CARRIERS_TABLE, where, whereArgs);\n        }\n\n        private void copyDataToTmpTable(SQLiteDatabase db, Cursor c, int version) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copyAllApnValues(cv, c);\n                    if (version == 24) {\n                        // Sync bearer bitmask and network type bitmask\n                        getNetworkTypeBitmaskFromCursor(cv, c);\n                    }\n                    try {\n                        db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                SQLiteDatabase.CONFLICT_ABORT);\n                        if (VDBG) {\n                            log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                    \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                    e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copyApnValuesV17(ContentValues cv, Cursor c) {\n            // Include only non-null values in cv so that null values can be replaced\n            // with default if there's a default value for the field\n\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n        }\n\n        private void copyAllApnValues(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, MTU_V4);\n            getIntValueFromCursor(cv, c, MTU_V6);\n            getIntValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, LINGERING_NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n            getIntValueFromCursor(cv, c, USER_EDITABLE);\n            getIntValueFromCursor(cv, c, OWNED_BY);\n            getIntValueFromCursor(cv, c, APN_SET_ID);\n            getIntValueFromCursor(cv, c, SKIP_464XLAT);\n            getIntValueFromCursor(cv, c, ALWAYS_ON);\n        }\n\n        private void copyPreservedApnsToNewTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null && mContext.getResources() != null) {\n                try {\n                    String[] persistApnsForPlmns = mContext.getResources().getStringArray(\n                            R.array.persist_apns_for_plmn);\n                    while (c.moveToNext()) {\n                        ContentValues cv = new ContentValues();\n                        String val;\n                        // Using V17 copy function for V15 upgrade. This should be fine since it\n                        // handles columns that may not exist properly (getStringValueFromCursor()\n                        // and getIntValueFromCursor() handle column index -1)\n                        copyApnValuesV17(cv, c);\n                        // Change bearer to a bitmask\n                        String bearerStr = c.getString(c.getColumnIndex(BEARER));\n                        if (!TextUtils.isEmpty(bearerStr)) {\n                            int bearer_bitmask = getBitmaskForTech(Integer.parseInt(bearerStr));\n                            cv.put(BEARER_BITMASK, bearer_bitmask);\n\n                            int networkTypeBitmask = rilRadioTechnologyToNetworkTypeBitmask(\n                                    Integer.parseInt(bearerStr));\n                            cv.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n                        }\n\n                        int userEditedColumnIdx = c.getColumnIndex(\"user_edited\");\n                        if (userEditedColumnIdx != -1) {\n                            String user_edited = c.getString(userEditedColumnIdx);\n                            if (!TextUtils.isEmpty(user_edited)) {\n                                cv.put(EDITED_STATUS, new Integer(user_edited));\n                            }\n                        } else {\n                            cv.put(EDITED_STATUS, CARRIER_EDITED);\n                        }\n\n                        // New EDITED column. Default value (UNEDITED) will\n                        // be used for all rows except for non-mvno entries for plmns indicated\n                        // by resource: those will be set to CARRIER_EDITED to preserve\n                        // their current values\n                        val = c.getString(c.getColumnIndex(NUMERIC));\n                        for (String s : persistApnsForPlmns) {\n                            if (!TextUtils.isEmpty(val) && val.equals(s) &&\n                                    (!cv.containsKey(MVNO_TYPE) ||\n                                            TextUtils.isEmpty(cv.getAsString(MVNO_TYPE)))) {\n                                if (userEditedColumnIdx == -1) {\n                                    cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                } else { // if (oldVersion == 14) -- if db had user_edited column\n                                    if (cv.getAsInteger(EDITED_STATUS) == USER_EDITED) {\n                                        cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n\n                        try {\n                            db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                    SQLiteDatabase.CONFLICT_ABORT);\n                            if (VDBG) {\n                                log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                        \"insert successful for cv \" + cv);\n                            }\n                        } catch (SQLException e) {\n                            if (VDBG)\n                                log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                        e + \" for cv \" + cv);\n                            // Insertion failed which could be due to a conflict. Check if that is\n                            // the case and merge the entries\n                            Cursor oldRow = selectConflictingRow(db,\n                                    CARRIERS_TABLE_TMP, cv);\n                            if (oldRow != null) {\n                                ContentValues mergedValues = new ContentValues();\n                                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE_TMP, oldRow, cv,\n                                        mergedValues, true, mContext);\n                                oldRow.close();\n                            }\n                        }\n                    }\n                } catch (Resources.NotFoundException e) {\n                    loge(\"array.persist_apns_for_plmn is not found\");\n                    return;\n                }\n            }\n        }\n\n        private void getStringValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * If NETWORK_TYPE_BITMASK does not exist (upgrade from version 23 to version 24), generate\n         * NETWORK_TYPE_BITMASK with the use of BEARER_BITMASK. If NETWORK_TYPE_BITMASK existed\n         * (upgrade from version 24 to forward), always map NETWORK_TYPE_BITMASK to BEARER_BITMASK.\n         */\n        private void getNetworkTypeBitmaskFromCursor(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(NETWORK_TYPE_BITMASK);\n            if (columnIndex != -1) {\n                getStringValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n                // Map NETWORK_TYPE_BITMASK to BEARER_BITMASK if NETWORK_TYPE_BITMASK existed;\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int networkBitmask = Integer.valueOf(fromCursor);\n                    int bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkBitmask);\n                    cv.put(BEARER_BITMASK, String.valueOf(bearerBitmask));\n                }\n                return;\n            }\n            columnIndex = c.getColumnIndex(BEARER_BITMASK);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int bearerBitmask = Integer.valueOf(fromCursor);\n                    int networkBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                    cv.put(NETWORK_TYPE_BITMASK, String.valueOf(networkBitmask));\n                }\n            }\n        }\n\n        private void getIntValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    try {\n                        cv.put(key, new Integer(fromCursor));\n                    } catch (NumberFormatException nfe) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void getBlobValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                byte[] fromCursor = c.getBlob(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * Gets the next row of apn values.\n         *\n         * @param parser the parser\n         * @param isOverlay If the xml file comes from an overlay MCC/MNC are treated as integers\n         * @return the row or null if it's not an apn\n         */\n        private ContentValues getRow(XmlPullParser parser, boolean isOverlay) {\n            if (!\"apn\".equals(parser.getName())) {\n                return null;\n            }\n\n            ContentValues map = new ContentValues();\n\n            String mcc = parser.getAttributeValue(null, \"mcc\");\n            String mnc = parser.getAttributeValue(null, \"mnc\");\n            String mccString = mcc;\n            String mncString = mnc;\n            // Since an mnc can have both two and three digits and it is hard to verify\n            // all OEM's Global APN lists we only do this for overlays.\n            if (isOverlay && mcc !=null && mnc != null) {\n                mccString = String.format(\"%03d\", Integer.parseInt(mcc));\n                // Looks up a two digit mnc in the carrier id DB\n                // if not found a three digit mnc value is chosen\n                mncString = getBestStringMnc(mContext, mccString, Integer.parseInt(mnc));\n            }\n            // Make sure to set default values for numeric, mcc and mnc. This is the empty string.\n            // If default is not set here, a duplicate of each carrier id APN will be created next\n            // time the apn list is read. This happens at OTA or at restore.\n            String numeric = (mccString == null | mncString == null) ? \"\" : mccString + mncString;\n            map.put(NUMERIC, numeric);\n            map.put(MCC, mccString != null ? mccString : \"\");\n            map.put(MNC, mncString != null ? mncString : \"\");\n            map.put(NAME, parser.getAttributeValue(null, \"carrier\"));\n\n            // do not add NULL to the map so that default values can be inserted in db\n            addStringAttribute(parser, \"apn\", map, APN);\n            addStringAttribute(parser, \"user\", map, USER);\n            addStringAttribute(parser, \"server\", map, SERVER);\n            addStringAttribute(parser, \"password\", map, PASSWORD);\n            addStringAttribute(parser, \"proxy\", map, PROXY);\n            addStringAttribute(parser, \"port\", map, PORT);\n            addStringAttribute(parser, \"mmsproxy\", map, MMSPROXY);\n            addStringAttribute(parser, \"mmsport\", map, MMSPORT);\n            addStringAttribute(parser, \"mmsc\", map, MMSC);\n\n            String apnType = parser.getAttributeValue(null, \"type\");\n            if (apnType != null) {\n                // Remove spaces before putting it in the map.\n                apnType = apnType.replaceAll(\"\\\\s+\", \"\");\n                map.put(TYPE, apnType);\n            }\n\n            addStringAttribute(parser, \"protocol\", map, PROTOCOL);\n            addStringAttribute(parser, \"roaming_protocol\", map, ROAMING_PROTOCOL);\n\n            addIntAttribute(parser, \"authtype\", map, AUTH_TYPE);\n            addIntAttribute(parser, \"bearer\", map, BEARER);\n            addIntAttribute(parser, \"profile_id\", map, PROFILE_ID);\n            addIntAttribute(parser, \"max_conns\", map, MAX_CONNECTIONS);\n            addIntAttribute(parser, \"wait_time\", map, WAIT_TIME_RETRY);\n            addIntAttribute(parser, \"max_conns_time\", map, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            addIntAttribute(parser, \"mtu\", map, MTU);\n            addIntAttribute(parser, \"mtu_v4\", map, MTU_V4);\n            addIntAttribute(parser, \"mtu_v6\", map, MTU_V6);\n            addIntAttribute(parser, \"apn_set_id\", map, APN_SET_ID);\n            addIntAttribute(parser, \"carrier_id\", map, CARRIER_ID);\n            addIntAttribute(parser, \"skip_464xlat\", map, SKIP_464XLAT);\n\n            addBoolAttribute(parser, \"carrier_enabled\", map, CARRIER_ENABLED);\n            addBoolAttribute(parser, \"modem_cognitive\", map, MODEM_PERSIST);\n            addBoolAttribute(parser, \"user_visible\", map, USER_VISIBLE);\n            addBoolAttribute(parser, \"user_editable\", map, USER_EDITABLE);\n            addBoolAttribute(parser, \"always_on\", map, ALWAYS_ON);\n\n            int networkTypeBitmask = 0;\n            String networkTypeList = parser.getAttributeValue(null, \"network_type_bitmask\");\n            if (networkTypeList != null) {\n                networkTypeBitmask = getBitmaskFromString(networkTypeList);\n            }\n            map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n\n            int lingeringNetworkTypeBitmask = 0;\n            String lingeringNetworkTypeList =\n                    parser.getAttributeValue(null, \"lingering_network_type_bitmask\");\n            if (lingeringNetworkTypeList != null) {\n                lingeringNetworkTypeBitmask = getBitmaskFromString(lingeringNetworkTypeList);\n            }\n            map.put(LINGERING_NETWORK_TYPE_BITMASK, lingeringNetworkTypeBitmask);\n\n            int bearerBitmask = 0;\n            if (networkTypeList != null) {\n                bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkTypeBitmask);\n            } else {\n                String bearerList = parser.getAttributeValue(null, \"bearer_bitmask\");\n                if (bearerList != null) {\n                    bearerBitmask = getBitmaskFromString(bearerList);\n                }\n                // Update the network type bitmask to keep them sync.\n                networkTypeBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n            }\n            map.put(BEARER_BITMASK, bearerBitmask);\n\n            String mvno_type = parser.getAttributeValue(null, \"mvno_type\");\n            if (mvno_type != null) {\n                String mvno_match_data = parser.getAttributeValue(null, \"mvno_match_data\");\n                if (mvno_match_data != null) {\n                    map.put(MVNO_TYPE, mvno_type);\n                    map.put(MVNO_MATCH_DATA, mvno_match_data);\n                }\n            }\n            return map;\n        }\n\n        private void addStringAttribute(XmlPullParser parser, String att,\n                                        ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, val);\n            }\n        }\n\n        private void addIntAttribute(XmlPullParser parser, String att,\n                                     ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Integer.parseInt(val));\n            }\n        }\n\n        private void addBoolAttribute(XmlPullParser parser, String att,\n                                      ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Boolean.parseBoolean(val));\n            }\n        }\n\n        /*\n         * Loads apns from xml file into the database\n         *\n         * @param db the sqlite database to write to\n         * @param parser the xml parser\n         * @param isOverlay, if we are parsing an xml in an overlay\n         */\n        private void loadApns(SQLiteDatabase db, XmlPullParser parser, boolean isOverlay) {\n            if (parser != null) {\n                try {\n                    db.beginTransaction();\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, isOverlay);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        insertAddingDefaults(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                    db.setTransactionSuccessful();\n                } catch (XmlPullParserException e) {\n                    loge(\"Got XmlPullParserException while loading apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"Got IOException while loading apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"Got SQLException while loading apns.\" + e);\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        }\n\n        private void insertAddingDefaults(SQLiteDatabase db, ContentValues row) {\n            row = setDefaultValue(row);\n            try {\n                db.insertWithOnConflict(CARRIERS_TABLE, null, row, SQLiteDatabase.CONFLICT_ABORT);\n                if (VDBG) log(\"dbh.insertAddingDefaults: db.insert returned >= 0; insert \" +\n                        \"successful for cv \" + row);\n            } catch (SQLException e) {\n                if (VDBG) log(\"dbh.insertAddingDefaults: exception \" + e);\n                // Insertion failed which could be due to a conflict. Check if that is the case and\n                // update edited field accordingly.\n                // Search for the exact same entry and update edited field.\n                // If it is USER_EDITED/CARRIER_EDITED change it to UNEDITED,\n                // and if USER/CARRIER_DELETED change it to USER/CARRIER_DELETED_BUT_PRESENT_IN_XML.\n                Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, row);\n                if (oldRow != null) {\n                    // Update the row\n                    ContentValues mergedValues = new ContentValues();\n                    int edited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                    int old_edited = edited;\n                    if (edited != UNEDITED) {\n                        if (edited == USER_DELETED) {\n                            // USER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = USER_DELETED_BUT_PRESENT_IN_XML;\n                        } else if (edited == CARRIER_DELETED) {\n                            // CARRIER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                        }\n                        mergedValues.put(EDITED_STATUS, edited);\n                    }\n\n                    mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, row, mergedValues, false,\n                            mContext);\n\n                    if (VDBG) log(\"dbh.insertAddingDefaults: old edited = \" + old_edited\n                            + \" new edited = \" + edited);\n\n                    oldRow.close();\n                }\n            }\n        }\n    }\n\n    public static void mergeFieldsAndUpdateDb(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, ContentValues mergedValues,\n            boolean onUpgrade, Context context) {\n        if (newRow.containsKey(TYPE)) {\n            // Merge the types\n            String oldType = oldRow.getString(oldRow.getColumnIndex(TYPE));\n            String newType = newRow.getAsString(TYPE);\n\n            if (!oldType.equalsIgnoreCase(newType)) {\n                if (oldType.equals(\"\") || newType.equals(\"\")) {\n                    newRow.put(TYPE, \"\");\n                } else {\n                    String[] oldTypes = oldType.toLowerCase(Locale.ROOT).split(\",\");\n                    String[] newTypes = newType.toLowerCase(Locale.ROOT).split(\",\");\n\n                    if (VDBG) {\n                        log(\"mergeFieldsAndUpdateDb: Calling separateRowsNeeded() oldType=\" +\n                                oldType + \" old bearer=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                BEARER_BITMASK)) +  \" old networkType=\" +\n                                oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK)) +\n                                \" old profile_id=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                PROFILE_ID)) + \" newRow \" + newRow);\n                    }\n\n                    // If separate rows are needed, do not need to merge any further\n                    if (separateRowsNeeded(db, table, oldRow, newRow, context, oldTypes,\n                            newTypes)) {\n                        if (VDBG) log(\"mergeFieldsAndUpdateDb: separateRowsNeeded() returned \" +\n                                \"true\");\n                        return;\n                    }\n\n                    // Merge the 2 types\n                    ArrayList<String> mergedTypes = new ArrayList<String>();\n                    mergedTypes.addAll(Arrays.asList(oldTypes));\n                    for (String s : newTypes) {\n                        if (!mergedTypes.contains(s.trim())) {\n                            mergedTypes.add(s);\n                        }\n                    }\n                    StringBuilder mergedType = new StringBuilder();\n                    for (int i = 0; i < mergedTypes.size(); i++) {\n                        mergedType.append((i == 0 ? \"\" : \",\") + mergedTypes.get(i));\n                    }\n                    newRow.put(TYPE, mergedType.toString());\n                }\n            }\n            mergedValues.put(TYPE, newRow.getAsString(TYPE));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)) {\n            int oldBearer = oldRow.getInt(oldRow.getColumnIndex(BEARER_BITMASK));\n            int newBearer = newRow.getAsInteger(BEARER_BITMASK);\n            if (oldBearer != newBearer) {\n                if (oldBearer == 0 || newBearer == 0) {\n                    newRow.put(BEARER_BITMASK, 0);\n                } else {\n                    newRow.put(BEARER_BITMASK, (oldBearer | newBearer));\n                }\n            }\n            mergedValues.put(BEARER_BITMASK, newRow.getAsInteger(BEARER_BITMASK));\n        }\n\n        if (newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            int oldBitmask = oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK));\n            int newBitmask = newRow.getAsInteger(NETWORK_TYPE_BITMASK);\n            if (oldBitmask != newBitmask) {\n                if (oldBitmask == 0 || newBitmask == 0) {\n                    newRow.put(NETWORK_TYPE_BITMASK, 0);\n                } else {\n                    newRow.put(NETWORK_TYPE_BITMASK, (oldBitmask | newBitmask));\n                }\n            }\n            mergedValues.put(NETWORK_TYPE_BITMASK, newRow.getAsInteger(NETWORK_TYPE_BITMASK));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)\n                && newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            syncBearerBitmaskAndNetworkTypeBitmask(mergedValues);\n        }\n\n        if (!onUpgrade) {\n            // Do not overwrite a carrier or user edit with EDITED=UNEDITED\n            if (newRow.containsKey(EDITED_STATUS)) {\n                int oldEdited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                int newEdited = newRow.getAsInteger(EDITED_STATUS);\n                if (newEdited == UNEDITED && (oldEdited == CARRIER_EDITED\n                        || oldEdited == CARRIER_DELETED\n                        || oldEdited == CARRIER_DELETED_BUT_PRESENT_IN_XML\n                        || oldEdited == USER_EDITED\n                        || oldEdited == USER_DELETED\n                        || oldEdited == USER_DELETED_BUT_PRESENT_IN_XML)) {\n                    newRow.remove(EDITED_STATUS);\n                }\n            }\n            mergedValues.putAll(newRow);\n        }\n\n        if (mergedValues.size() > 0) {\n            db.update(table, mergedValues, \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")),\n                    null);\n        }\n    }\n\n    private static boolean separateRowsNeeded(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, Context context,\n            String[] oldTypes, String[] newTypes) {\n        // If this APN falls under persist_apns_for_plmn, and the\n        // only difference between old type and new type is that one has dun, and\n        // the APNs have profile_id 0 or not set, then set the profile_id to 1 for\n        // the dun APN/remove dun from type. This will ensure both oldRow and newRow exist\n        // separately in db.\n\n        boolean match = false;\n\n        // Check if APN falls under persist_apns_for_plmn\n        if (context.getResources() != null) {\n            String[] persistApnsForPlmns = context.getResources().getStringArray(\n                    R.array.persist_apns_for_plmn);\n            for (String s : persistApnsForPlmns) {\n                if (s.equalsIgnoreCase(newRow.getAsString(NUMERIC))) {\n                    match = true;\n                    break;\n                }\n            }\n        } else {\n            loge(\"separateRowsNeeded: resources=null\");\n        }\n\n        if (!match) return false;\n\n        // APN falls under persist_apns_for_plmn\n        // Check if only difference between old type and new type is that\n        // one has dun\n        ArrayList<String> oldTypesAl = new ArrayList<String>(Arrays.asList(oldTypes));\n        ArrayList<String> newTypesAl = new ArrayList<String>(Arrays.asList(newTypes));\n        ArrayList<String> listWithDun = null;\n        ArrayList<String> listWithoutDun = null;\n        boolean dunInOld = false;\n        if (oldTypesAl.size() == newTypesAl.size() + 1) {\n            listWithDun = oldTypesAl;\n            listWithoutDun = newTypesAl;\n            dunInOld = true;\n        } else if (oldTypesAl.size() + 1 == newTypesAl.size()) {\n            listWithDun = newTypesAl;\n            listWithoutDun = oldTypesAl;\n        } else {\n            return false;\n        }\n\n        if (listWithDun.contains(\"dun\") && !listWithoutDun.contains(\"dun\")) {\n            listWithoutDun.add(\"dun\");\n            if (!listWithDun.containsAll(listWithoutDun)) {\n                return false;\n            }\n\n            // Only difference between old type and new type is that\n            // one has dun\n            // Check if profile_id is 0/not set\n            if (oldRow.getInt(oldRow.getColumnIndex(PROFILE_ID)) == 0) {\n                if (dunInOld) {\n                    // Update oldRow to remove dun from its type field\n                    ContentValues updateOldRow = new ContentValues();\n                    StringBuilder sb = new StringBuilder();\n                    boolean first = true;\n                    for (String s : listWithDun) {\n                        if (!s.equalsIgnoreCase(\"dun\")) {\n                            sb.append(first ? s : \",\" + s);\n                            first = false;\n                        }\n                    }\n                    String updatedType = sb.toString();\n                    if (VDBG) {\n                        log(\"separateRowsNeeded: updating type in oldRow to \" + updatedType);\n                    }\n                    updateOldRow.put(TYPE, updatedType);\n                    db.update(table, updateOldRow,\n                            \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")), null);\n                    return true;\n                } else {\n                    if (VDBG) log(\"separateRowsNeeded: adding profile id 1 to newRow\");\n                    // Update newRow to set profile_id to 1\n                    newRow.put(PROFILE_ID, new Integer(1));\n                }\n            } else {\n                return false;\n            }\n\n            // If match was found, both oldRow and newRow need to exist\n            // separately in db. Add newRow to db.\n            try {\n                db.insertWithOnConflict(table, null, newRow, SQLiteDatabase.CONFLICT_REPLACE);\n                if (VDBG) log(\"separateRowsNeeded: added newRow with profile id 1 to db\");\n                return true;\n            } catch (SQLException e) {\n                loge(\"Exception on trying to add new row after updating profile_id\");\n            }\n        }\n\n        return false;\n    }\n\n    public static Cursor selectConflictingRow(SQLiteDatabase db, String table,\n            ContentValues row) {\n        // Conflict is possible only when numeric, mcc, mnc (fields without any default value)\n        // are set in the new row\n        if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {\n            loge(\"dbh.selectConflictingRow: called for non-conflicting row: \" + row);\n            return null;\n        }\n\n        String[] columns = { \"_id\",\n                TYPE,\n                EDITED_STATUS,\n                BEARER_BITMASK,\n                NETWORK_TYPE_BITMASK,\n                PROFILE_ID };\n        String selection = TextUtils.join(\"=? AND \", CARRIERS_UNIQUE_FIELDS) + \"=?\";\n        int i = 0;\n        String[] selectionArgs = new String[CARRIERS_UNIQUE_FIELDS.size()];\n        for (String field : CARRIERS_UNIQUE_FIELDS) {\n            if (!row.containsKey(field)) {\n                selectionArgs[i++] = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(field);\n            } else {\n                if (CARRIERS_BOOLEAN_FIELDS.contains(field)) {\n                    // for boolean fields we overwrite the strings \"true\" and \"false\" with \"1\"\n                    // and \"0\"\n                    selectionArgs[i++] = convertStringToIntString(row.getAsString(field));\n                } else {\n                    selectionArgs[i++] = row.getAsString(field);\n                }\n            }\n        }\n\n        Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);\n\n        if (c != null) {\n            if (c.getCount() == 1) {\n                if (VDBG) log(\"dbh.selectConflictingRow: \" + c.getCount() + \" conflicting \" +\n                        \"row found\");\n                if (c.moveToFirst()) {\n                    return c;\n                } else {\n                    loge(\"dbh.selectConflictingRow: moveToFirst() failed\");\n                }\n            } else {\n                loge(\"dbh.selectConflictingRow: Expected 1 but found \" + c.getCount() +\n                        \" matching rows found for cv \" + row);\n            }\n            c.close();\n        } else {\n            loge(\"dbh.selectConflictingRow: Error - c is null; no matching row found for \" +\n                    \"cv \" + row);\n        }\n\n        return null;\n    }\n\n    /**\n     * Convert \"true\" and \"false\" to \"1\" and \"0\".\n     * If the passed in string is already \"1\" or \"0\" returns the passed in string.\n     */\n    private static String convertStringToIntString(String boolString) {\n        if (\"0\".equals(boolString) || \"false\".equalsIgnoreCase(boolString)) return \"0\";\n        return \"1\";\n    }\n\n    /**\n     * Convert \"1\" and \"0\" to \"true\" and \"false\".\n     * If the passed in string is already \"true\" or \"false\" returns the passed in string.\n     */\n    private static String convertStringToBoolString(String intString) {\n        if (\"0\".equals(intString) || \"false\".equalsIgnoreCase(intString)) return \"false\";\n        return \"true\";\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing TelephonyProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase() {\n        return mOpenHelper.getReadableDatabase();\n    }\n    SQLiteDatabase getWritableDatabase() {\n        return mOpenHelper.getWritableDatabase();\n    }\n    void initDatabaseWithDatabaseHelper(SQLiteDatabase db) {\n        mOpenHelper.initDatabase(db);\n    }\n    boolean needApnDbUpdate() {\n        return mOpenHelper.apnDbUpdateNeeded();\n    }\n\n    private static boolean apnSourceServiceExists(Context context) {\n        if (s_apnSourceServiceExists != null) {\n            return s_apnSourceServiceExists;\n        }\n        try {\n            String service = context.getResources().getString(R.string.apn_source_service);\n            if (TextUtils.isEmpty(service)) {\n                s_apnSourceServiceExists = false;\n            } else {\n                s_apnSourceServiceExists = context.getPackageManager().getServiceInfo(\n                        ComponentName.unflattenFromString(service), 0)\n                        != null;\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            s_apnSourceServiceExists = false;\n        }\n        return s_apnSourceServiceExists;\n    }\n\n    private void restoreApnsWithService(int subId) {\n        Context context = getContext();\n        Resources r = context.getResources();\n        AtomicBoolean connectionBindingInvalid = new AtomicBoolean(false);\n        ServiceConnection connection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className,\n                    IBinder service) {\n                log(\"restoreApnsWithService: onServiceConnected\");\n                synchronized (mLock) {\n                    mIApnSourceService = IApnSourceService.Stub.asInterface(service);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {\n                loge(\"mIApnSourceService has disconnected unexpectedly\");\n                synchronized (mLock) {\n                    mIApnSourceService = null;\n                }\n            }\n\n            @Override\n            public void onBindingDied(ComponentName name) {\n                loge(\"The binding to the apn service connection is dead: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onNullBinding(ComponentName name) {\n                loge(\"Null binding: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n        };\n\n        Intent intent = new Intent(IApnSourceService.class.getName());\n        intent.setComponent(ComponentName.unflattenFromString(\n                r.getString(R.string.apn_source_service)));\n        log(\"binding to service to restore apns, intent=\" + intent);\n        try {\n            if (context.bindService(intent,\n                    Context.BIND_IMPORTANT | Context.BIND_AUTO_CREATE,\n                    runnable -> new Thread(runnable).start(),\n                    connection)) {\n                synchronized (mLock) {\n                    while (mIApnSourceService == null && !connectionBindingInvalid.get()) {\n                        try {\n                            mLock.wait();\n                        } catch (InterruptedException e) {\n                            loge(\"Error while waiting for service connection: \" + e);\n                        }\n                    }\n                    if (connectionBindingInvalid.get()) {\n                        loge(\"The binding is invalid.\");\n                        return;\n                    }\n                    try {\n                        ContentValues[] values = mIApnSourceService.getApns(subId);\n                        if (values != null) {\n                            // we use the unsynchronized insert because this function is called\n                            // within the syncrhonized function delete()\n                            unsynchronizedBulkInsert(CONTENT_URI, values);\n                            log(\"restoreApnsWithService: restored\");\n                        }\n                    } catch (RemoteException e) {\n                        loge(\"Error applying apns from service: \" + e);\n                    }\n                }\n            } else {\n                loge(\"unable to bind to service from intent=\" + intent);\n            }\n        } catch (SecurityException e) {\n            loge(\"Error applying apns from service: \" + e);\n        } finally {\n            if (connection != null) {\n                context.unbindService(connection);\n            }\n            synchronized (mLock) {\n                mIApnSourceService = null;\n            }\n        }\n    }\n\n\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new DatabaseHelper(getContext());\n        boolean isNewBuild = false;\n        String newBuildId = SystemProperties.get(\"ro.build.id\", null);\n        SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE,\n                Context.MODE_PRIVATE);\n        if (!TextUtils.isEmpty(newBuildId)) {\n            // Check if build id has changed\n            String oldBuildId = sp.getString(RO_BUILD_ID, \"\");\n            if (!newBuildId.equals(oldBuildId)) {\n                localLog(\"onCreate: build id changed from \" + oldBuildId + \" to \" + newBuildId);\n                isNewBuild = true;\n            } else {\n                if (VDBG) log(\"onCreate: build id did not change: \" + oldBuildId);\n            }\n        } else {\n            if (VDBG) log(\"onCreate: newBuildId is empty\");\n        }\n\n        if (isNewBuild) {\n            if (!apnSourceServiceExists(getContext())) {\n                // Update APN DB\n                updateApnDb();\n            }\n\n            // Add all APN related shared prefs to local log for dumpsys\n            if (DBG) addAllApnSharedPrefToLocalLog();\n        }\n\n        // Write build id to SharedPreferences after APNs have been updated above by updateApnDb()\n        if (!TextUtils.isEmpty(newBuildId)) {\n            if (isNewBuild) log(\"onCreate: updating build id to \" + newBuildId);\n            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();\n        }\n\n        SharedPreferences spEnforcedFile = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        mManagedApnEnforced = spEnforcedFile.getBoolean(ENFORCED_KEY, false);\n\n        if (VDBG) log(\"onCreate:- ret true\");\n\n        return true;\n    }\n\n    private void addAllApnSharedPrefToLocalLog() {\n        localLog(\"addAllApnSharedPrefToLocalLog\");\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefApnId.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n\n        SharedPreferences spFullApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefFullApn = spFullApn.getAll();\n        for (String key : allPrefFullApn.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefFullApn.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n    }\n\n    private void localLog(String logMsg) {\n        Log.d(TAG, logMsg);\n        mLocalLog.log(logMsg);\n    }\n\n    private synchronized boolean isManagedApnEnforced() {\n        return mManagedApnEnforced;\n    }\n\n    private void setManagedApnEnforced(boolean enforced) {\n        SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putBoolean(ENFORCED_KEY, enforced);\n        editor.apply();\n        synchronized (this) {\n            mManagedApnEnforced = enforced;\n        }\n    }\n\n    private void setPreferredApnId(Long id, int subId, boolean saveApn) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putLong(COLUMN_APN_ID + subId, id != null ? id : INVALID_APN_ID);\n        localLog(\"setPreferredApnId: \" + COLUMN_APN_ID + subId + \":\"\n                + (id != null ? id : INVALID_APN_ID));\n        // This is for debug purposes. It indicates if this APN was set by DcTracker or user (true)\n        // or if this was restored from APN saved in PREF_FILE_FULL_APN (false).\n        editor.putBoolean(EXPLICIT_SET_CALLED + subId, saveApn);\n        localLog(\"setPreferredApnId: \" + EXPLICIT_SET_CALLED + subId + \":\" + saveApn);\n        editor.apply();\n        if (id == null || id.longValue() == INVALID_APN_ID) {\n            deletePreferredApn(subId);\n        } else {\n            // If id is not invalid, and saveApn is true, save the actual APN in PREF_FILE_FULL_APN\n            // too.\n            if (saveApn) {\n                setPreferredApn(id, subId);\n            }\n        }\n    }\n\n    private long getPreferredApnId(int subId, boolean checkApnSp) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        long apnId = sp.getLong(COLUMN_APN_ID + subId, INVALID_APN_ID);\n        if (apnId == INVALID_APN_ID && checkApnSp) {\n            apnId = getPreferredApnIdFromApn(subId);\n            if (apnId != INVALID_APN_ID) {\n                setPreferredApnId(apnId, subId, false);\n            }\n        }\n        return apnId;\n    }\n\n    private int getPreferredApnSetId(int subId) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        try {\n            return Integer.parseInt(sp.getString(APN_SET_ID + subId, null));\n        } catch (NumberFormatException e) {\n            return NO_APN_SET_ID;\n        }\n    }\n\n    private void deletePreferredApnId(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.clear();\n        editor.apply();\n    }\n\n    private void setPreferredApn(Long id, int subId) {\n        localLog(\"setPreferredApn: _id \" + id + \" subId \" + subId);\n        SQLiteDatabase db = getWritableDatabase();\n        // query all unique fields from id\n        String[] proj = CARRIERS_UNIQUE_FIELDS.toArray(new String[CARRIERS_UNIQUE_FIELDS.size()]);\n\n        Cursor c = db.query(CARRIERS_TABLE, proj, \"_id=\" + id, null, null, null, null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                        Context.MODE_PRIVATE);\n                SharedPreferences.Editor editor = sp.edit();\n                // store values of all unique fields to SP\n                for (String key : CARRIERS_UNIQUE_FIELDS) {\n                    editor.putString(key + subId, c.getString(c.getColumnIndex(key)));\n                    localLog(\"setPreferredApn: \" + key + subId + \":\"\n                            + c.getString(c.getColumnIndex(key)));\n                }\n                // also store the version number\n                editor.putString(DB_VERSION_KEY + subId, \"\" + DATABASE_VERSION);\n                localLog(\"setPreferredApn: \" + DB_VERSION_KEY + subId + \":\" + DATABASE_VERSION);\n                editor.apply();\n            } else {\n                log(\"setPreferredApn: # matching APNs found \" + c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"setPreferredApn: No matching APN found\");\n        }\n    }\n\n    private long getPreferredApnIdFromApn(int subId) {\n        log(\"getPreferredApnIdFromApn: for subId \" + subId);\n        SQLiteDatabase db = getReadableDatabase();\n\n        List<String> whereList = new ArrayList<>();\n        List<String> whereArgsList = new ArrayList<>();\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        for (String key : CARRIERS_UNIQUE_FIELDS) {\n            String value = sp.getString(key + subId, null);\n            if (value == null) {\n                continue;\n            } else {\n                whereList.add(key);\n                whereArgsList.add(value);\n            }\n        }\n        if (whereList.size() == 0) return INVALID_APN_ID;\n\n        String where = TextUtils.join(\"=? and \", whereList) + \"=?\";\n        String[] whereArgs = new String[whereArgsList.size()];\n        whereArgs = whereArgsList.toArray(whereArgs);\n\n        long apnId = INVALID_APN_ID;\n        Cursor c = db.query(CARRIERS_TABLE, new String[]{\"_id\"}, where, whereArgs, null, null,\n                null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                apnId = c.getInt(c.getColumnIndex(\"_id\"));\n            } else {\n                log(\"getPreferredApnIdFromApn: returning INVALID. # matching APNs found \" +\n                        c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"getPreferredApnIdFromApn: returning INVALID. No matching APN found\");\n        }\n        return apnId;\n    }\n\n    private void deletePreferredApn(int subId) {\n        log(\"deletePreferredApn: for subId \" + subId);\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        if (sp.contains(DB_VERSION_KEY + subId)) {\n            log(\"deletePreferredApn: apn is stored. Deleting it now for subId \" + subId);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.remove(DB_VERSION_KEY + subId);\n            for (String key : CARRIERS_UNIQUE_FIELDS) {\n                editor.remove(key + subId);\n            }\n            editor.apply();\n        }\n    }\n\n    boolean isCallingFromSystemOrPhoneUid() {\n        int callingUid = mInjector.binderGetCallingUid();\n        return callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID\n                // Allow ROOT for testing. ROOT can access underlying DB files anyways.\n                || callingUid == Process.ROOT_UID;\n    }\n\n    void ensureCallingFromSystemOrPhoneUid(String message) {\n        if (!isCallingFromSystemOrPhoneUid()) {\n            throw new SecurityException(message);\n        }\n    }\n\n    @Override\n    public synchronized Bundle call(String method, @Nullable String args, @Nullable Bundle bundle) {\n        if (SubscriptionManager.GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return retrieveSimSpecificSettings();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else if (SubscriptionManager.RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MODIFY_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                restoreSimSpecificSettings(bundle, args);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else {\n            loge(\"method is not recognized\");\n        }\n\n        return null;\n    }\n\n    /**\n     * See {@link SubscriptionController#GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME} for details\n     */\n    private Bundle retrieveSimSpecificSettings() {\n        Bundle resultBundle = new Bundle();\n        resultBundle.putByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA,\n                getSimSpecificDataToBackUp());\n\n        return resultBundle;\n    }\n\n    /**\n     * Attempts to restore the backed up sim-specific configs to device. End result is SimInfoDB is\n     * modified to match any backed up configs for the appropriate inserted sims.\n     *\n     * @param bundle containing the data to be restored. If {@code null}, then backed up\n     * data should already be in internal storage and will be retrieved from there.\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void restoreSimSpecificSettings(@Nullable Bundle bundle, @Nullable String iccId) {\n        int restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_UNDEFINED_USE_CASE;\n        if (bundle != null) {\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SUW;\n            if (!writeSimSettingsToInternalStorage(\n                    bundle.getByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA))) {\n                return;\n            }\n        } else if (iccId != null){\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED;\n        }\n        mergeBackedUpDataToSimInfoDb(restoreCase, iccId);\n    }\n\n    @VisibleForTesting\n    boolean writeSimSettingsToInternalStorage(byte[] data) {\n        AtomicFile atomicFile = new AtomicFile(\n                new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE));\n        FileOutputStream fos = null;\n        try {\n            fos = atomicFile.startWrite();\n            fos.write(data);\n            atomicFile.finishWrite(fos);\n        } catch (IOException e) {\n            if (fos != null) {\n                atomicFile.failWrite(fos);\n            }\n            loge(\"Not able to create internal file with per-sim configs. Failed with error \"\n                    + e);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Attempt to match any SimInfoDB entries to what is in the internal backup data file and\n     * update DB entry with the adequate backed up data.\n     *\n     * @param restoreCase one of the SimSpecificSettingsRestoreMatchingCriteria values defined in\n     * frameworks/proto_logging/stats/enums/telephony/enums.proto\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void mergeBackedUpDataToSimInfoDb(int restoreCase, @Nullable String iccId) {\n        // Get data stored in internal file\n        File file = new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE);\n        if (!file.exists()) {\n            loge(\"internal sim-specific settings backup data file does not exist. \"\n                + \"Aborting restore\");\n            return;\n        }\n\n        AtomicFile atomicFile = new AtomicFile(file);\n        PersistableBundle bundle = null;\n        try (FileInputStream fis = atomicFile.openRead()) {\n            bundle = PersistableBundle.readFromStream(fis);\n        } catch (IOException e) {\n            loge(\"Failed to convert backed up per-sim configs to bundle. Stopping restore. \"\n                + \"Failed with error \" + e);\n            return;\n        }\n\n        String selection = null;\n        String[] selectionArgs = null;\n        if (iccId != null) {\n            selection = Telephony.SimInfo.COLUMN_ICC_ID + \"=?\";\n            selectionArgs = new String[]{iccId};\n        }\n        try (Cursor cursor = query(\n                SubscriptionManager.CONTENT_URI,\n                new String[]{\n                        Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_ICC_ID,\n                        Telephony.SimInfo.COLUMN_NUMBER,\n                        Telephony.SimInfo.COLUMN_CARRIER_ID,\n                        Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE},\n                selection,\n                selectionArgs,\n                ORDER_BY_SUB_ID)) {\n            findAndRestoreAllMatches(bundle.deepCopy(), cursor, restoreCase);\n        }\n    }\n\n    // backedUpDataBundle must to be mutable\n    private void findAndRestoreAllMatches(PersistableBundle backedUpDataBundle, Cursor cursor,\n            int restoreCase) {\n        int[] previouslyRestoredSubIdsArray =\n                backedUpDataBundle.getIntArray(KEY_PREVIOUSLY_RESTORED_SUB_IDS);\n        List<Integer> previouslyRestoredSubIdsList = previouslyRestoredSubIdsArray != null\n                ? Arrays.stream(previouslyRestoredSubIdsArray).boxed().collect(Collectors.toList())\n                : new ArrayList<>();\n        List<Integer> newlyRestoredSubIds = new ArrayList<>();\n        int backupDataFormatVersion = backedUpDataBundle\n                .getInt(KEY_BACKUP_DATA_FORMAT_VERSION, -1);\n\n        Resources r = getContext().getResources();\n        List<String> wfcRestoreBlockedCountries = Arrays.asList(r.getStringArray(\n                    R.array.wfc_restore_blocked_countries));\n\n        while (cursor != null && cursor.moveToNext()) {\n            // Get all the possible matching criteria.\n            int subIdColumnIndex = cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID);\n            int currSubIdFromDb = cursor.getInt(subIdColumnIndex);\n\n            if (previouslyRestoredSubIdsList.contains(currSubIdFromDb)) {\n                // Abort restore for any sims that were previously restored.\n                continue;\n            }\n\n            int iccIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            String currIccIdFromDb = cursor.getString(iccIdColumnIndex);\n\n            int phoneNumberColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_NUMBER);\n            String currPhoneNumberFromDb = cursor.getString(phoneNumberColumnIndex);\n\n            int carrierIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_CARRIER_ID);\n            int currCarrierIdFromDb = cursor.getInt(carrierIdColumnIndex);\n\n            int isoCountryCodeColumnIndex= cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE);\n            String isoCountryCodeFromDb = cursor.getString(isoCountryCodeColumnIndex);\n\n\n            // Find the best match from backed up data.\n            SimRestoreMatch bestRestoreMatch = null;\n            for (int rowNum = 0; true; rowNum++) {\n                PersistableBundle currRow = backedUpDataBundle.getPersistableBundle(\n                        KEY_SIMINFO_DB_ROW_PREFIX + rowNum);\n                if (currRow == null) {\n                    break;\n                }\n\n                SimRestoreMatch currSimRestoreMatch = new SimRestoreMatch(\n                        currIccIdFromDb, currCarrierIdFromDb, currPhoneNumberFromDb,\n                        isoCountryCodeFromDb, wfcRestoreBlockedCountries, currRow,\n                        backupDataFormatVersion);\n\n                if (currSimRestoreMatch == null) {\n                    continue;\n                }\n\n                /*\n                 * The three following match cases are ordered by descending priority:\n                 *   - Match by iccId: If iccId of backup data matches iccId of any inserted sims,\n                 *       we confidently restore all configs.\n                 *   - Match phone number and carrierId: If both of these values match, we\n                 *       confidently restore all configs.\n                 *   - Match only carrierId: If only carrierId of backup data matches an inserted\n                 *       sim, we only restore non-sensitive configs.\n                 *\n                 * Having a matchScore value for each match allows us to control these priorities.\n                 */\n                if (bestRestoreMatch == null || (currSimRestoreMatch.getMatchScore()\n                        >= bestRestoreMatch.getMatchScore()\n                        && currSimRestoreMatch.getContentValues() != null)) {\n                    bestRestoreMatch = currSimRestoreMatch;\n                }\n            }\n\n            if (bestRestoreMatch != null) {\n                ContentValues newContentValues = bestRestoreMatch.getContentValues();\n                if (bestRestoreMatch.getMatchScore() != 0 && newContentValues != null) {\n                    if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SUW) {\n                        update(SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    } else if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED) {\n                        Uri simInsertedRestoreUri = Uri.withAppendedPath(\n                                SubscriptionManager.SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI,\n                                SIM_INSERTED_RESTORE_URI_SUFFIX);\n                        update(simInsertedRestoreUri,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    }\n                    log(\"Restore of inserterd SIM's sim-specific settings has been successfully \"\n                            + \"completed.\");\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_SUCCESS,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                    newlyRestoredSubIds.add(currSubIdFromDb);\n                } else {\n                    /* If this block was reached because ContentValues was null, that means the\n                    database schema was newer during backup than during restore. We consider this\n                    a no-match to avoid updating columns that don't exist */\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_NONE_MATCH,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                }\n            } else {\n                log(\"No matching SIM in backup data. SIM-specific settings not restored.\");\n                TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                        TelephonyProtoEnums.SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP,\n                        restoreCase, TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE);\n            }\n        }\n\n        // Update the internal file with subIds that we just restored.\n        previouslyRestoredSubIdsList.addAll(newlyRestoredSubIds);\n        backedUpDataBundle.putIntArray(\n                KEY_PREVIOUSLY_RESTORED_SUB_IDS,\n                previouslyRestoredSubIdsList.stream().mapToInt(i -> i).toArray());\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            backedUpDataBundle.writeToStream(outputStream);\n            writeSimSettingsToInternalStorage(outputStream.toByteArray());\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Not storing which subIds were \"\n                    + \"restored\");\n        }\n    }\n\n    private static class SimRestoreMatch {\n\n        private Set<Integer> matches = new ArraySet<>();\n        private int subId;\n        private ContentValues contentValues;\n        private int matchingCriteria;\n        private int matchScore;\n\n        private static final int ICCID_MATCH = 1;\n        private static final int PHONE_NUMBER_MATCH = 2;\n        private static final int CARRIER_ID_MATCH = 3;\n\n        public SimRestoreMatch(String iccIdFromDb, int carrierIdFromDb,\n                String phoneNumberFromDb, String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries,\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion) {\n            subId = backedUpSimInfoEntry.getInt(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                DEFAULT_INT_COLUMN_VALUE);\n            String iccIdFromBackup = backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_ICC_ID,\n                  \"\");\n            String phoneNumberFromBackup = backedUpSimInfoEntry.getString(\n                  Telephony.SimInfo.COLUMN_NUMBER, \"\");\n            int carrierIdFromBackup = backedUpSimInfoEntry.getInt(\n                  Telephony.SimInfo.COLUMN_CARRIER_ID,\n                  TelephonyManager.UNKNOWN_CARRIER_ID);\n\n\n            // find all matching fields\n            if (iccIdFromDb != null && iccIdFromDb.equals(iccIdFromBackup)\n                    && !iccIdFromBackup.isEmpty()) {\n                matches.add(ICCID_MATCH);\n            }\n            if (carrierIdFromDb == carrierIdFromBackup\n                    && carrierIdFromBackup != TelephonyManager.UNKNOWN_CARRIER_ID) {\n                matches.add(CARRIER_ID_MATCH);\n            }\n            if (phoneNumberFromDb != null && phoneNumberFromDb.equals(phoneNumberFromBackup)\n                    && !phoneNumberFromBackup.isEmpty()) {\n                matches.add(PHONE_NUMBER_MATCH);\n            }\n\n            contentValues = convertBackedUpDataToContentValues(\n                    backedUpSimInfoEntry, backupDataFormatVersion, isoCountryCodeFromDb,\n                    wfcRestoreBlockedCountries);\n            matchScore = calculateMatchScore();\n            matchingCriteria = calculateMatchingCriteria();\n        }\n\n        public int getSubId() {\n            return subId;\n        }\n\n        public ContentValues getContentValues() {\n            return contentValues;\n        }\n\n        public int getMatchScore() {\n            return matchScore;\n        }\n\n        private int calculateMatchScore() {\n            int score = 0;\n\n            if (matches.contains(ICCID_MATCH)) {\n                score += 100;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    score += 10;\n                } else {\n                    score += 1;\n                }\n            }\n\n            return score;\n        }\n\n        public int getMatchingCriteriaForLogging() {\n            return matchingCriteria;\n        }\n\n        private int calculateMatchingCriteria() {\n            if (matches.contains(ICCID_MATCH)) {\n                return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_ICCID;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    return TelephonyProtoEnums\n                        .SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER;\n                } else {\n                    return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY;\n                }\n            }\n            return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE;\n        }\n\n        private ContentValues convertBackedUpDataToContentValues(\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion,\n                String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries) {\n            if (DATABASE_VERSION != 62 << 16) {\n                throw new AssertionError(\"The database schema has been updated which might make \"\n                    + \"the format of #BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE outdated. Make sure to \"\n                    + \"1) review whether any of the columns in #SIM_INFO_COLUMNS_TO_BACKUP have \"\n                    + \"been migrated or deleted, 2) add the new column name into one of those \"\n                    + \"maps, 3) add migration code in this method as necessary, and 4) update the \"\n                    + \"version check in this if statement.\");\n            }\n            ContentValues contentValues = new ContentValues();\n            // Don't restore anything if restoring from a newer version of the current database.\n            if (backupDataFormatVersion > DATABASE_VERSION) {\n                return null;\n            }\n\n            /* Any migration logic should be placed under this comment block.\n             * ex:\n             *   if (backupDataFormatVersion >= 48 << 19) {\n             *     contentValues.put(NEW_COLUMN_NAME_2,\n             *         backedUpSimInfoEntry.getInt( OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else if (backupDataFormatVersion >= 48 << 17) {\n             *     contentValues.put(NEW_COLUMN_NAME_1,\n             *         backedUpSimInfoEntry.getInt(OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else {\n             *     // The values from the first format of backup ever available.\n             *     contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *         backedUpSimInfoEntry.getInt(\n             *             Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *             DEFAULT_INT_COLUMN_VALUE));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n             *         backedUpSimInfoEntry.getString(\n             *              Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, \"\"));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               \"\"));\n             *     ...\n             *   }\n             *\n             * Also make sure to add necessary removal of sensitive settings in\n             * polishContentValues(ContentValues contentValues).\n             */\n            if (backupDataFormatVersion >= 60 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 57 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                                SubscriptionManager.USAGE_SETTING_UNKNOWN));\n            }\n            if (backupDataFormatVersion >= 52 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 51 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 50 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            if (isoCountryCodeFromDb != null\n                    && !wfcRestoreBlockedCountries\n                            .contains(isoCountryCodeFromDb.toLowerCase(Locale.ROOT))) {\n                // Don't restore COLUMN_WFC_IMS_ENABLED if the sim is from one of the countries that\n                // requires WFC entitlement.\n                contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n\n            return polishContentValues(contentValues);\n        }\n\n        private ContentValues polishContentValues(ContentValues contentValues) {\n            /* Remove any values that weren't found in the backup file. These were set to defaults\n            in #convertBackedUpDataToContentValues(). */\n            for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n                String columnName = column.getKey();\n\n                if (!contentValues.containsKey(columnName)) {\n                    continue;\n                }\n\n                int columnType = column.getValue();\n                if (columnType == Cursor.FIELD_TYPE_INTEGER\n                        && DEFAULT_INT_COLUMN_VALUE == contentValues.getAsInteger(columnName)) {\n                    contentValues.remove(columnName);\n                } else if (columnType == Cursor.FIELD_TYPE_STRING && contentValues\n                        .getAsString(columnName).equals(DEFAULT_STRING_COLUMN_VALUE)) {\n                    contentValues.remove(columnName);\n                }\n            }\n\n            if (matches.contains(ICCID_MATCH)) {\n                return contentValues;\n            } else if (matches.contains(CARRIER_ID_MATCH)) {\n                if (!matches.contains(PHONE_NUMBER_MATCH)) {\n                    // Low confidence match should not restore sensitive configs.\n                    if (contentValues.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        contentValues.remove(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED);\n                    }\n                }\n                return contentValues;\n            }\n            return null;\n        }\n\n    }\n\n    /**\n     * Retrieves data from all columns in SimInfoDB of backup/restore interest.\n     *\n     * @return data of interest from SimInfoDB as a byte array.\n     */\n    private byte[] getSimSpecificDataToBackUp() {\n        String[] projection = SIM_INFO_COLUMNS_TO_BACKUP.keySet()\n                .toArray(new String[SIM_INFO_COLUMNS_TO_BACKUP.size()]);\n\n        try (Cursor cursor = query(SubscriptionManager.CONTENT_URI, projection, null, null, null);\n                ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            PersistableBundle topLevelBundle = new PersistableBundle();\n            topLevelBundle.putInt(KEY_BACKUP_DATA_FORMAT_VERSION, DATABASE_VERSION);\n            for (int rowNum = 0; cursor != null && cursor.moveToNext(); rowNum++) {\n                PersistableBundle rowBundle = convertSimInfoDbEntryToPersistableBundle(cursor);\n                topLevelBundle.putPersistableBundle(KEY_SIMINFO_DB_ROW_PREFIX + rowNum, rowBundle);\n            }\n            topLevelBundle.writeToStream(outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Returning empty byte array\");\n            return new byte[0];\n        }\n    }\n\n    private static PersistableBundle convertSimInfoDbEntryToPersistableBundle(Cursor cursor) {\n        PersistableBundle bundle = new PersistableBundle();\n        for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n            String columnName = column.getKey();\n            int columnType = column.getValue();\n            int columnIndex = cursor.getColumnIndex(columnName);\n            if (columnType == Cursor.FIELD_TYPE_INTEGER) {\n                bundle.putInt(columnName, cursor.getInt(columnIndex));\n            } else if (columnType == Cursor.FIELD_TYPE_STRING) {\n                bundle.putString(columnName, cursor.getString(columnIndex));\n            } else {\n                throw new AssertionError(\"SimInfoDB column to be backed up is not recognized. Make \"\n                    + \"sure to properly add the desired colum name and value type to \"\n                    + \"SIM_INFO_COLUMNS_TO_BACKUP.\");\n            }\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,  String[] selectionArgs,\n            String sort) {\n        if (VDBG) log(\"query: url=\" + url + \", projectionIn=\" + Arrays.toString(projectionIn)\n                + \", selection=\" + selection + \"selectionArgs=\" + Arrays.toString(selectionArgs)\n                + \", sort=\" + sort);\n        int match = s_urlMatcher.match(url);\n        checkPermissionCompat(match, projectionIn);\n\n        return queryInternal(url, projectionIn, selection, selectionArgs, sort);\n    }\n\n    private synchronized Cursor queryInternal(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String subIdString;\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true); // a little protection from injection attacks\n        qb.setTables(CARRIERS_TABLE);\n\n        List<String> constraints = new ArrayList<String>();\n\n        int match = s_urlMatcher.match(url);\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID: {\n                // The behaves exactly same as URL_SIM_APN_LIST_ID.\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            case URL_TELEPHONY: {\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_CURRENT: {\n                constraints.add(\"current IS NOT NULL\");\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                // do not ignore the selection since MMS may use it.\n                //selection = null;\n                break;\n            }\n\n            case URL_ID: {\n                constraints.add(\"_id = \" + url.getPathSegments().get(1));\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE: {\n                constraints.add(\"_id = \" + getPreferredApnId(subId, true));\n                break;\n            }\n\n            case URL_PREFERAPNSET_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            // intentional fall through from above case\n            case URL_PREFERAPNSET: {\n                final int set = getPreferredApnSetId(subId);\n                if (set == NO_APN_SET_ID) {\n                    return null;\n                }\n                constraints.add(APN_SET_ID + \"=\" + set);\n                qb.appendWhere(TextUtils.join(\" AND \", constraints));\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_DPC_ID: {\n                constraints.add(\"_id = \" + url.getLastPathSegment());\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_FILTERED_ID:\n            case URL_FILTERED_USING_SUBID: {\n                String idString = url.getLastPathSegment();\n                if (match == URL_FILTERED_ID) {\n                    constraints.add(\"_id = \" + idString);\n                } else {\n                    try {\n                        subId = Integer.parseInt(idString);\n                        // TODO b/74213956 turn this back on once insertion includes correct sub id\n                        // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n                    } catch (NumberFormatException e) {\n                        loge(\"NumberFormatException\" + e);\n                        return null;\n                    }\n                }\n            }\n            //intentional fall through from above case\n            case URL_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    constraints.add(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    constraints.add(IS_NOT_OWNED_BY_DPC);\n                }\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                MatrixCursor cursor = new MatrixCursor(new String[]{ENFORCED_KEY});\n                cursor.addRow(new Object[]{isManagedApnEnforced() ? 1 : 0});\n                return cursor;\n            }\n\n            case URL_SIMINFO: {\n                qb.setTables(SIMINFO_TABLE);\n                break;\n            }\n            case URL_SIM_APN_LIST_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST: {\n                qb.appendWhere(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_SIM_APN_LIST_FILTERED_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    qb.appendWhereStandalone(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                }\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            default: {\n                return null;\n            }\n        }\n\n        // appendWhere doesn't add ANDs so we do it ourselves\n        if (constraints.size() > 0) {\n            qb.appendWhere(TextUtils.join(\" AND \", constraints));\n        }\n\n        SQLiteDatabase db = getReadableDatabase();\n        Cursor ret = null;\n        try {\n            // Exclude entries marked deleted\n            if (CARRIERS_TABLE.equals(qb.getTables())) {\n                if (TextUtils.isEmpty(selection)) {\n                    selection = \"\";\n                } else {\n                    selection += \" and \";\n                }\n                selection += IS_NOT_USER_DELETED + \" and \" +\n                        IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                        IS_NOT_CARRIER_DELETED + \" and \" +\n                        IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                if (VDBG) log(\"query: selection modified to \" + selection);\n            }\n            ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);\n        } catch (SQLException e) {\n            loge(\"got exception when querying: \" + e);\n        }\n        if (ret != null)\n            ret.setNotificationUri(getContext().getContentResolver(), url);\n        return ret;\n    }\n\n    /**\n     * This method syncs PREF_FILE_FULL_APN with the db based on the current preferred apn ids.\n     */\n    private void updatePreferredApns() {\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            if (key.startsWith(COLUMN_APN_ID)) {\n                int subId;\n                try {\n                    subId = Integer.parseInt(key.substring(COLUMN_APN_ID.length()));\n                } catch (NumberFormatException e) {\n                    loge(\"updatePreferredApns: NumberFormatException for key=\" + key);\n                    continue;\n                }\n                long preferredApnId = getPreferredApnId(subId, false);\n                if (preferredApnId != INVALID_APN_ID) {\n                    setPreferredApn(preferredApnId, subId);\n                }\n            }\n        }\n    }\n\n    /**\n     * To find the current sim APN. Query APN based on {MCC, MNC, MVNO} and {Carrier_ID}.\n     *\n     * There has three steps:\n     * 1. Query the APN based on { MCC, MNC, MVNO } and if has results jump to step 3, else jump to\n     *    step 2.\n     * 2. Fallback to query the parent APN that query based on { MCC, MNC }.\n     * 3. Append the result with the APN that query based on { Carrier_ID }\n     */\n    private Cursor getSubscriptionMatchingAPNList(SQLiteQueryBuilder qb, String[] projectionIn,\n            String selection, String[] selectionArgs, String sort, int subId) {\n        Cursor ret;\n        Context context = getContext();\n        SubscriptionManager subscriptionManager = (SubscriptionManager) context\n                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);\n        if (!subscriptionManager.isActiveSubscriptionId(subId)) {\n            return null;\n        }\n\n        final TelephonyManager tm = ((TelephonyManager) context\n                .getSystemService(Context.TELEPHONY_SERVICE))\n                .createForSubscriptionId(subId);\n        SQLiteDatabase db = getReadableDatabase();\n        String mccmnc = tm.getSimOperator();\n        int carrierId = tm.getSimSpecificCarrierId();\n\n        qb.appendWhereStandalone(IS_NOT_USER_DELETED + \" and \" +\n                IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                IS_NOT_CARRIER_DELETED + \" and \" +\n                IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML);\n\n        // For query db one time, append all conditions in one selection and separate results after\n        // the query is completed. IMSI has special match rule, so just query the MCC / MNC and\n        // filter the MVNO by ourselves\n        qb.appendWhereStandalone(NUMERIC + \" = '\" + mccmnc + \"' OR \" +\n                CARRIER_ID + \" = '\" + carrierId + \"'\");\n\n        ret = qb.query(db, null, selection, selectionArgs, null, null, sort);\n        if (ret == null) {\n            loge(\"subId:\" + subId + \" query current APN but cursor is null.\");\n            return null;\n        }\n\n        if (DBG) log(\"subId:\" + subId + \" mccmnc=\" + mccmnc + \" carrierId=\" + carrierId +\n                \", match current APN size:  \" + ret.getCount());\n\n        String[] columnNames = projectionIn != null ? projectionIn : ret.getColumnNames();\n        MatrixCursor currentCursor = new MatrixCursor(columnNames);\n        MatrixCursor parentCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdNonMatchingMNOCursor = new MatrixCursor(columnNames);\n\n        int numericIndex = ret.getColumnIndex(NUMERIC);\n        int mvnoIndex = ret.getColumnIndex(MVNO_TYPE);\n        int mvnoDataIndex = ret.getColumnIndex(MVNO_MATCH_DATA);\n        int carrierIdIndex = ret.getColumnIndex(CARRIER_ID);\n\n        // Separate the result into MatrixCursor\n        while (ret.moveToNext()) {\n            List<String> data = new ArrayList<>();\n            for (String column : columnNames) {\n                data.add(ret.getString(ret.getColumnIndex(column)));\n            }\n\n            boolean isCurrentSimOperator = false;\n            if (!TextUtils.isEmpty(ret.getString(numericIndex))) {\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    isCurrentSimOperator = tm.matchesCurrentSimOperator(\n                            ret.getString(numericIndex),\n                            getMvnoTypeIntFromString(ret.getString(mvnoIndex)),\n                            ret.getString(mvnoDataIndex));\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n\n            boolean isMVNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && isCurrentSimOperator;\n            boolean isMNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && ret.getString(numericIndex).equals(mccmnc)\n                    && TextUtils.isEmpty(ret.getString(mvnoIndex));\n            boolean isCarrierIdAPN = !TextUtils.isEmpty(ret.getString(carrierIdIndex))\n                    && ret.getString(carrierIdIndex).equals(String.valueOf(carrierId))\n                    && carrierId != TelephonyManager.UNKNOWN_CARRIER_ID;\n\n            if (isMVNOAPN) {\n                // 1. The APN that query based on legacy SIM MCC/MCC and MVNO\n                currentCursor.addRow(data);\n            } else if (isMNOAPN) {\n                // 2. The APN that query based on SIM MCC/MNC\n                parentCursor.addRow(data);\n            } else if (isCarrierIdAPN) {\n                // The APN that query based on carrier Id (not include the MVNO or MNO APN)\n                if (TextUtils.isEmpty(ret.getString(numericIndex))) {\n                    carrierIdCursor.addRow(data);\n                } else {\n                    carrierIdNonMatchingMNOCursor.addRow(data);\n                }\n            }\n        }\n        ret.close();\n\n        MatrixCursor result;\n        if (currentCursor.getCount() > 0) {\n            if (DBG) log(\"match MVNO APN: \" + currentCursor.getCount());\n            result = currentCursor;\n        } else if (parentCursor.getCount() > 0) {\n            if (DBG) log(\"match MNO APN: \" + parentCursor.getCount());\n            result = parentCursor;\n        } else {\n            if (DBG) {\n                log(\"No MVNO, MNO and no MCC/MNC match, but we have match/matches with the \" +\n                        \"same carrier id, count: \" + carrierIdNonMatchingMNOCursor.getCount());\n            }\n            result = carrierIdNonMatchingMNOCursor;\n        }\n\n        if (DBG) log(\"match carrier id APN: \" + carrierIdCursor.getCount());\n        appendCursorData(result, carrierIdCursor);\n        return result;\n    }\n\n    private static void appendCursorData(@NonNull MatrixCursor from, @NonNull MatrixCursor to) {\n        while (to.moveToNext()) {\n            List<Object> data = new ArrayList<>();\n            for (String column : to.getColumnNames()) {\n                int index = to.getColumnIndex(column);\n                switch (to.getType(index)) {\n                    case Cursor.FIELD_TYPE_INTEGER:\n                        data.add(to.getInt(index));\n                        break;\n                    case Cursor.FIELD_TYPE_FLOAT:\n                        data.add(to.getFloat(index));\n                        break;\n                    case Cursor.FIELD_TYPE_BLOB:\n                        data.add(to.getBlob(index));\n                        break;\n                    case Cursor.FIELD_TYPE_STRING:\n                    case Cursor.FIELD_TYPE_NULL:\n                        data.add(to.getString(index));\n                        break;\n                }\n            }\n            from.addRow(data);\n        }\n    }\n\n    @Override\n    public String getType(Uri url)\n    {\n        switch (s_urlMatcher.match(url)) {\n        case URL_TELEPHONY:\n        case URL_TELEPHONY_USING_SUBID:\n            return \"vnd.android.cursor.dir/telephony-carrier\";\n\n        case URL_ID:\n        case URL_FILTERED_ID:\n        case URL_FILTERED_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        case URL_PREFERAPN_USING_SUBID:\n        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n        case URL_PREFERAPN:\n        case URL_PREFERAPN_NO_UPDATE:\n        case URL_PREFERAPNSET:\n        case URL_PREFERAPNSET_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        default:\n            throw new IllegalArgumentException(\"Unknown URL \" + url);\n        }\n    }\n\n    /**\n     * Insert an array of ContentValues and call notifyChange at the end.\n     */\n    @Override\n    public synchronized int bulkInsert(Uri url, ContentValues[] values) {\n        return unsynchronizedBulkInsert(url, values);\n    }\n\n    /**\n     * Do a bulk insert while inside a synchronized function. This is typically not safe and should\n     * only be done when you are sure there will be no conflict.\n     */\n    private int unsynchronizedBulkInsert(Uri url, ContentValues[] values) {\n        int count = 0;\n        boolean notify = false;\n        for (ContentValues value : values) {\n            Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, value);\n            if (rowAndNotify.first != null) {\n                count++;\n            }\n            if (rowAndNotify.second == true) {\n                notify = true;\n            }\n        }\n        if (notify) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return count;\n    }\n\n    @Override\n    public synchronized Uri insert(Uri url, ContentValues initialValues) {\n        Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, initialValues);\n        if (rowAndNotify.second) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return rowAndNotify.first;\n    }\n\n    /**\n     * Internal insert function to prevent code duplication for URL_TELEPHONY and URL_DPC.\n     *\n     * @param values the value that caller wants to insert\n     * @return a pair in which the first element refers to the Uri for the row inserted, the second\n     *         element refers to whether sends out nofitication.\n     */\n    private Pair<Uri, Boolean> insertRowWithValue(ContentValues values) {\n        Uri result = null;\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n\n        try {\n            // Abort on conflict of unique fields and attempt merge\n            long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                    SQLiteDatabase.CONFLICT_ABORT);\n            if (rowID >= 0) {\n                result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                notify = true;\n            }\n            if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n        } catch (SQLException e) {\n            log(\"insert: exception \" + e);\n            // Insertion failed which could be due to a conflict. Check if that is the case\n            // and merge the entries\n            Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n            if (oldRow != null) {\n                ContentValues mergedValues = new ContentValues();\n                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                        mergedValues, false, getContext());\n                oldRow.close();\n                notify = true;\n            }\n        }\n        return Pair.create(result, notify);\n    }\n\n    private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {\n        Uri result = null;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(initialValues);\n\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                values = setDefaultValue(values);\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Owned_by should be others if inserted via general uri.\n                values.put(OWNED_BY, OWNED_BY_OTHERS);\n\n                Pair<Uri, Boolean> ret = insertRowWithValue(values);\n                result = ret.first;\n                notify = ret.second;\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // zero out the previous operator\n                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + \"!=0\", null);\n\n                String numeric = initialValues.getAsString(NUMERIC);\n                int updated = db.update(CARRIERS_TABLE, s_currentSetMap,\n                        NUMERIC + \" = '\" + numeric + \"'\", null);\n\n                if (updated > 0)\n                {\n                    if (VDBG) log(\"Setting numeric '\" + numeric + \"' to be the current operator\");\n                }\n                else\n                {\n                    loge(\"Failed setting numeric '\" + numeric + \"' to the current operator\");\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (initialValues != null) {\n                    if(initialValues.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);\n                        notify = true;\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                // Owned_by should be DPC if inserted via URL_DPC.\n                values.put(OWNED_BY, OWNED_BY_DPC);\n                // DPC records should not be user editable.\n                values.put(USER_EDITABLE, false);\n\n                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                        SQLiteDatabase.CONFLICT_IGNORE);\n                if (rowID >= 0) {\n                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                    notify = true;\n                }\n                if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n\n                break;\n            }\n\n            case URL_SIMINFO: {\n               long id = db.insert(SIMINFO_TABLE, null, initialValues);\n               result = ContentUris.withAppendedId(Telephony.SimInfo.CONTENT_URI, id);\n               break;\n            }\n        }\n\n        return Pair.create(result, notify);\n    }\n\n    @Override\n    public synchronized int delete(Uri url, String where, String[] whereArgs) {\n        int count = 0;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String userOrCarrierEdited = \") and (\" +\n                IS_USER_EDITED +  \" or \" +\n                IS_CARRIER_EDITED + \")\";\n        String notUserOrCarrierEdited = \") and (\" +\n                IS_NOT_USER_EDITED +  \" and \" +\n                IS_NOT_CARRIER_EDITED + \")\";\n        String unedited = \") and \" + IS_UNEDITED;\n        ContentValues cv = new ContentValues();\n        cv.put(EDITED_STATUS, USER_DELETED);\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_DELETE:\n            {\n                // Delete preferred APN for all subIds\n                deletePreferredApnId(getContext());\n                // Delete unedited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + unedited + \" and \" +\n                        IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_ID:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE,\n                        \"(\" + _ID + \"=?\" + userOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv,\n                        \"(\" + _ID + \"=?\" + notUserOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[]{url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_RESTOREAPN_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            // intentional fall through from above case\n\n            case URL_RESTOREAPN: {\n                count = 1;\n                restoreDefaultAPN(subId);\n                getContext().getContentResolver().notifyChange(\n                        Uri.withAppendedPath(CONTENT_URI, \"restore/subId/\" + subId), null,\n                        true, UserHandle.USER_ALL);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                setPreferredApnId((long)INVALID_APN_ID, subId, true);\n                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) count = 1;\n                break;\n            }\n\n            case URL_DPC_ID: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                // Only delete if owned by DPC.\n                count = db.delete(CARRIERS_TABLE, \"(\" + _ID + \"=?)\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_SIMINFO: {\n                count = db.delete(SIMINFO_TABLE, where, whereArgs);\n                break;\n            }\n\n            case URL_UPDATE_DB: {\n                updateApnDb();\n                count = 1;\n                break;\n            }\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot delete that URL: \" + url);\n            }\n        }\n\n        if (count > 0) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n\n        return count;\n    }\n\n    @Override\n    public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs)\n    {\n        int count = 0;\n        int uriType = URL_UNKNOWN;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(values);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs,\n                        SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        whereArgs, SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_ID:\n            {\n                String rowID = url.getLastPathSegment();\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                try {\n                    count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + \"=?\" + \" and \" +\n                            IS_NOT_OWNED_BY_DPC, new String[] { rowID },\n                            SQLiteDatabase.CONFLICT_ABORT);\n                } catch (SQLException e) {\n                    // Update failed which could be due to a conflict. Check if that is\n                    // the case and merge the entries\n                    log(\"update: exception \" + e);\n                    Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n                    if (oldRow != null) {\n                        ContentValues mergedValues = new ContentValues();\n                        mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                                mergedValues, false, getContext());\n                        oldRow.close();\n                        db.delete(CARRIERS_TABLE, _ID + \"=?\" + \" and \" + IS_NOT_OWNED_BY_DPC,\n                                new String[] { rowID });\n                    }\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (values != null) {\n                    if (values.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);\n                        if ((match == URL_PREFERAPN) ||\n                                (match == URL_PREFERAPN_USING_SUBID)) {\n                            count = 1;\n                        }\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC_ID:\n            {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values,\n                        _ID + \"=?\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_IGNORE);\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                if (values != null) {\n                    if (values.containsKey(ENFORCED_KEY)) {\n                        setManagedApnEnforced(values.getAsBoolean(ENFORCED_KEY));\n                        count = 1;\n                    }\n                }\n                break;\n            }\n\n            case URL_SIMINFO_USING_SUBID:\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.update(SIMINFO_TABLE, values, _ID + \"=?\",\n                        new String[] { subIdString});\n                uriType = URL_SIMINFO_USING_SUBID;\n                break;\n\n            case URL_SIMINFO: {\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO;\n                break;\n            }\n\n            case URL_SIMINFO_SUW_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO_SUW_RESTORE;\n                break;\n\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                break;\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot update that URL: \" + url);\n            }\n        }\n\n        // if APNs (CARRIERS_TABLE) have been updated, some of them may be preferred APN for\n        // different subs. So update the APN field values saved in SharedPref for all subIds.\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID:\n            case URL_TELEPHONY:\n            case URL_CURRENT_USING_SUBID:\n            case URL_CURRENT:\n            case URL_ID:\n            case URL_DPC_ID:\n                updatePreferredApns();\n                break;\n        }\n\n        if (count > 0) {\n            boolean usingSubId = false;\n            switch (uriType) {\n                case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                    break;\n                case URL_SIMINFO_SUW_RESTORE:\n                    getContext().getContentResolver().notifyChange(\n                            SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI, null);\n                    // intentional fall through from above case\n                case URL_SIMINFO_USING_SUBID:\n                    usingSubId = true;\n                    // intentional fall through from above case\n                case URL_SIMINFO:\n                    // skip notifying descendant URLs to avoid unneccessary wake up.\n                    // If not set, any change to SIMINFO will notify observers which listens to\n                    // specific field of SIMINFO.\n                    getContext().getContentResolver().notifyChange(\n                        Telephony.SimInfo.CONTENT_URI, null,\n                            ContentResolver.NOTIFY_SYNC_TO_NETWORK\n                                    | ContentResolver.NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS,\n                            UserHandle.USER_ALL);\n                    // notify observers on specific user settings changes.\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager\n                                                .ADVANCED_CALLING_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.VT_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_MODE)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_MODE_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED), usingSubId, subId),\n                                null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_USAGE_SETTING)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_USAGE_SETTING),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    break;\n                default:\n                    getContext().getContentResolver().notifyChange(\n                            CONTENT_URI, null, true, UserHandle.USER_ALL);\n            }\n        }\n\n        return count;\n    }\n\n    private static Uri getNotifyContentUri(Uri uri, boolean usingSubId, int subId) {\n        return (usingSubId) ? Uri.withAppendedPath(uri, \"\" + subId) : uri;\n    }\n\n    /**\n     * Checks permission to query or insert/update/delete the database. The permissions required\n     * for APN DB and SIMINFO DB are different:\n     * <ul>\n     * <li>APN DB requires WRITE_APN_SETTINGS or carrier privileges\n     * <li>SIMINFO DB requires phone UID; it's for phone internal usage only\n     * <\/ul>\n     */\n    private void checkPermission(int match) {\n        switch (match) {\n            case URL_SIMINFO:\n            case URL_SIMINFO_USING_SUBID:\n            case URL_SIMINFO_SUW_RESTORE:\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                checkPermissionForSimInfoTable();\n                break;\n            default:\n                checkPermissionForApnTable();\n        }\n    }\n\n    private void checkPermissionForApnTable() {\n        int status = getContext().checkCallingOrSelfPermission(\n                \"android.permission.WRITE_APN_SETTINGS\");\n        if (status == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        PackageManager packageManager = getContext().getPackageManager();\n        String[] packages = packageManager.getPackagesForUid(Binder.getCallingUid());\n\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            for (String pkg : packages) {\n                if (telephonyManager.checkCarrierPrivilegesForPackageAnyPhone(pkg) ==\n                    TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {\n                    return;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        throw new SecurityException(\"No permission to access APN settings\");\n    }\n\n    /**\n     * Check permission to query the database based on PlatformCompat settings -- if the compat\n     * change is enabled, check WRITE_APN_SETTINGS or carrier privs for all queries. Otherwise,\n     * use the legacy checkQueryPermission method to see if the query should be allowed.\n     */\n    private void checkPermissionCompat(int match, String[] projectionIn) {\n        boolean useNewBehavior = CompatChanges.isChangeEnabled(\n                Telephony.Carriers.APN_READING_PERMISSION_CHANGE_ID,\n                Binder.getCallingUid());\n\n        if (!useNewBehavior) {\n            log(\"Using old permission behavior for telephony provider compat\");\n            checkQueryPermission(match, projectionIn);\n        } else {\n            checkPermission(match);\n        }\n    }\n\n    private void checkQueryPermission(int match, String[] projectionIn) {\n        if (match == URL_SIMINFO) {\n            checkPermissionForSimInfoTable();\n        } else {\n            if (projectionIn != null) {\n                for (String column : projectionIn) {\n                    if (TYPE.equals(column) ||\n                            MMSC.equals(column) ||\n                            MMSPROXY.equals(column) ||\n                            MMSPORT.equals(column) ||\n                            MVNO_TYPE.equals(column) ||\n                            MVNO_MATCH_DATA.equals(column) ||\n                            APN.equals(column)) {\n                        // noop\n                    } else {\n                        checkPermissionForApnTable();\n                        break;\n                    }\n                }\n            } else {\n                // null returns all columns, so need permission check\n                checkPermissionForApnTable();\n            }\n        }\n    }\n\n    private void checkPermissionForSimInfoTable() {\n        ensureCallingFromSystemOrPhoneUid(\"Access SIMINFO table from not phone/system UID\");\n        if (getContext().checkCallingOrSelfPermission(\n                    \"android.permission.ACCESS_TELEPHONY_SIMINFO_DB\")\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n        throw new SecurityException(\"No permission to access SIMINFO table\");\n    }\n\n    private DatabaseHelper mOpenHelper;\n\n    private void restoreDefaultAPN(int subId) {\n        SQLiteDatabase db = getWritableDatabase();\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        String where = null;\n        if (telephonyManager.getPhoneCount() > 1) {\n            where = getWhereClauseForRestoreDefaultApn(db, subId);\n        }\n        if (TextUtils.isEmpty(where)) {\n            where = IS_NOT_OWNED_BY_DPC;\n        }\n        log(\"restoreDefaultAPN: where: \" + where);\n\n        try {\n            db.delete(CARRIERS_TABLE, where, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to restore: \" + e);\n        }\n\n        // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all\n        // subIds\n        SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApnId = spApnId.edit();\n        editorApnId.clear();\n        editorApnId.apply();\n\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApn = spApn.edit();\n        editorApn.clear();\n        editorApn.apply();\n\n        if (apnSourceServiceExists(getContext())) {\n            restoreApnsWithService(subId);\n        } else {\n            initDatabaseWithDatabaseHelper(db);\n        }\n    }\n\n    private String getWhereClauseForRestoreDefaultApn(SQLiteDatabase db, int subId) {\n        TelephonyManager telephonyManager =\n            getContext().getSystemService(TelephonyManager.class).createForSubscriptionId(subId);\n        String simOperator = telephonyManager.getSimOperator();\n        int simCarrierId = telephonyManager.getSimSpecificCarrierId();\n        Cursor cursor = db.query(CARRIERS_TABLE, new String[] {MVNO_TYPE, MVNO_MATCH_DATA},\n                NUMERIC + \"='\" + simOperator + \"'\", null, null, null, DEFAULT_SORT_ORDER);\n        String where = null;\n\n        if (cursor != null) {\n            cursor.moveToFirst();\n            while (!cursor.isAfterLast()) {\n                String mvnoType = cursor.getString(0 /* MVNO_TYPE index */);\n                String mvnoMatchData = cursor.getString(1 /* MVNO_MATCH_DATA index */);\n                if (!TextUtils.isEmpty(mvnoType) && !TextUtils.isEmpty(mvnoMatchData)\n                        && telephonyManager.matchesCurrentSimOperator(simOperator,\n                            getMvnoTypeIntFromString(mvnoType), mvnoMatchData)) {\n                    where = NUMERIC + \"='\" + simOperator + \"'\"\n                            + \" AND \" + MVNO_TYPE + \"='\" + mvnoType + \"'\"\n                            + \" AND \" + MVNO_MATCH_DATA + \"='\" + mvnoMatchData + \"'\"\n                            + \" AND \" + IS_NOT_OWNED_BY_DPC;\n                    break;\n                }\n                cursor.moveToNext();\n            }\n            cursor.close();\n\n            if (TextUtils.isEmpty(where)) {\n                where = NUMERIC + \"='\" + simOperator + \"'\"\n                        + \" AND (\" + MVNO_TYPE + \"='' OR \" + MVNO_MATCH_DATA + \"='')\"\n                        + \" AND \" + IS_NOT_OWNED_BY_DPC;\n            }\n            // Add carrier id APNs\n            if (TelephonyManager.UNKNOWN_CARRIER_ID < simCarrierId) {\n                where = where.concat(\" OR \" + CARRIER_ID + \" = '\" + simCarrierId + \"'\" + \" AND \"\n                        + IS_NOT_OWNED_BY_DPC);\n            }\n\n        }\n        return where;\n    }\n\n    private synchronized void updateApnDb() {\n        if (apnSourceServiceExists(getContext())) {\n            loge(\"called updateApnDb when apn source service exists\");\n            return;\n        }\n\n        if (!needApnDbUpdate()) {\n            log(\"Skipping apn db update since apn-conf has not changed.\");\n            return;\n        }\n\n        SQLiteDatabase db = getWritableDatabase();\n\n        // Delete preferred APN for all subIds\n        deletePreferredApnId(getContext());\n\n        // Delete entries in db\n        try {\n            if (VDBG) log(\"updateApnDb: deleting edited=UNEDITED entries\");\n            db.delete(CARRIERS_TABLE, IS_UNEDITED + \" and \" + IS_NOT_OWNED_BY_DPC, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to update: \" + e);\n        }\n\n        initDatabaseWithDatabaseHelper(db);\n\n        // Notify listeners of DB change since DB has been updated\n        getContext().getContentResolver().notifyChange(\n                CONTENT_URI, null, true, UserHandle.USER_ALL);\n\n    }\n\n    public static void fillInMccMncStringAtCursor(Context context, SQLiteDatabase db, Cursor c) {\n        int mcc, mnc;\n        String subId;\n        try {\n            mcc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MCC));\n            mnc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MNC));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        String mccString = String.format(Locale.getDefault(), \"%03d\", mcc);\n        String mncString = getBestStringMnc(context, mccString, mnc);\n        ContentValues cv = new ContentValues(2);\n        cv.put(Telephony.SimInfo.COLUMN_MCC_STRING, mccString);\n        cv.put(Telephony.SimInfo.COLUMN_MNC_STRING, mncString);\n        db.update(SIMINFO_TABLE, cv,\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                new String[]{subId});\n    }\n\n    /*\n     * Find the best string-form mnc by looking up possibilities in the carrier id db.\n     * Default to the three-digit version if neither/both are valid.\n     */\n    private static String getBestStringMnc(Context context, String mcc, int mnc) {\n        if (mnc >= 100 && mnc <= 999) {\n            return String.valueOf(mnc);\n        }\n        String twoDigitMnc = String.format(Locale.getDefault(), \"%02d\", mnc);\n        String threeDigitMnc = \"0\" + twoDigitMnc;\n        boolean threeDigitNetworkCode =\n                Arrays.asList(COUNTRY_MCC_WITH_THREE_DIGIT_MNC).contains(mcc);\n        int twoDigitResult = countMccMncInCarrierList(context, mcc + twoDigitMnc);\n        int threeDigitResult = countMccMncInCarrierList(context, mcc + threeDigitMnc);\n\n        if ((threeDigitResult > twoDigitResult) ||\n                (threeDigitNetworkCode && (twoDigitResult == threeDigitResult))) {\n            return threeDigitMnc;\n        } else {\n            return twoDigitMnc;\n        }\n    }\n\n    /**\n     * Check carrier_list how many mcc mnc combo matches there are\n     */\n    private static int countMccMncInCarrierList(Context ctx, String mccMncCombo) {\n        try (\n            Cursor mccMncCursor = ctx.getContentResolver().query(\n                    Telephony.CarrierId.All.CONTENT_URI,\n                    /* projection */ null,\n                    /* selection */ Telephony.CarrierId.All.MCCMNC + \"=?\",\n                    /* selectionArgs */ new String[]{mccMncCombo}, null);\n        )\n        {\n            return mccMncCursor.getCount();\n        }\n    }\n\n    /**\n     * Sync the bearer bitmask and network type bitmask when inserting and updating.\n     * Since bearerBitmask is deprecating, map the networkTypeBitmask to bearerBitmask if\n     * networkTypeBitmask was provided. But if networkTypeBitmask was not provided, map the\n     * bearerBitmask to networkTypeBitmask.\n     */\n    private static void syncBearerBitmaskAndNetworkTypeBitmask(ContentValues values) {\n        if (values.containsKey(NETWORK_TYPE_BITMASK)) {\n            int convertedBitmask = convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK));\n            if (values.containsKey(BEARER_BITMASK)\n                    && convertedBitmask != values.getAsInteger(BEARER_BITMASK)) {\n                loge(\"Network type bitmask and bearer bitmask are not compatible.\");\n            }\n            values.put(BEARER_BITMASK, convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK)));\n        } else {\n            if (values.containsKey(BEARER_BITMASK)) {\n                int convertedBitmask = convertBearerBitmaskToNetworkTypeBitmask(\n                        values.getAsInteger(BEARER_BITMASK));\n                values.put(NETWORK_TYPE_BITMASK, convertedBitmask);\n            }\n        }\n    }\n\n    /**\n     * Log with debug\n     *\n     * @param s is string log\n     */\n    private static void log(String s) {\n        Log.d(TAG, s);\n    }\n\n    private static void loge(String s) {\n        Log.e(TAG, s);\n    }\n\n    private static int getMvnoTypeIntFromString(String mvnoType) {\n        String mvnoTypeString = TextUtils.isEmpty(mvnoType) ? mvnoType : mvnoType.toLowerCase(Locale.ROOT);\n        Integer mvnoTypeInt = MVNO_TYPE_STRING_MAP.get(mvnoTypeString);\n        return  mvnoTypeInt == null ? 0 : mvnoTypeInt;\n    }\n\n    private static int getBitmaskFromString(String bearerList) {\n        String[] bearers = bearerList.split(\"\\\\|\");\n        int bearerBitmask = 0;\n        for (String bearer : bearers) {\n            int bearerInt = 0;\n            try {\n                bearerInt = Integer.parseInt(bearer.trim());\n            } catch (NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (bearerInt == 0) {\n                return 0;\n            }\n            bearerBitmask |= getBitmaskForTech(bearerInt);\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Transform RIL radio technology value to Network\n     * type bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     *\n     * @param rat The RIL radio technology.\n     * @return The network type\n     * bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     */\n    private static int rilRadioTechnologyToNetworkTypeBitmask(int rat) {\n        switch (rat) {\n            case RIL_RADIO_TECHNOLOGY_GPRS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GPRS;\n            case RIL_RADIO_TECHNOLOGY_EDGE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EDGE;\n            case RIL_RADIO_TECHNOLOGY_UMTS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;\n            case RIL_RADIO_TECHNOLOGY_HSDPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSDPA;\n            case RIL_RADIO_TECHNOLOGY_HSUPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA;\n            case RIL_RADIO_TECHNOLOGY_HSPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPA;\n            case RIL_RADIO_TECHNOLOGY_IS95A:\n            case RIL_RADIO_TECHNOLOGY_IS95B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;\n            case RIL_RADIO_TECHNOLOGY_1xRTT:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT;\n            case RIL_RADIO_TECHNOLOGY_EVDO_0:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0;\n            case RIL_RADIO_TECHNOLOGY_EVDO_A:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A;\n            case RIL_RADIO_TECHNOLOGY_EVDO_B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B;\n            case RIL_RADIO_TECHNOLOGY_EHRPD:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD;\n            case RIL_RADIO_TECHNOLOGY_LTE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE;\n            case RIL_RADIO_TECHNOLOGY_HSPAP:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPAP;\n            case RIL_RADIO_TECHNOLOGY_GSM:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GSM;\n            case RIL_RADIO_TECHNOLOGY_TD_SCDMA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_TD_SCDMA;\n            case RIL_RADIO_TECHNOLOGY_IWLAN:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_IWLAN;\n            case RIL_RADIO_TECHNOLOGY_LTE_CA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;\n            case RIL_RADIO_TECHNOLOGY_NR:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_NR;\n            default:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UNKNOWN;\n        }\n    }\n\n    /**\n     * Convert network type bitmask to bearer bitmask.\n     *\n     * @param networkTypeBitmask The network type bitmask value\n     * @return The bearer bitmask value.\n     */\n    private static int convertNetworkTypeBitmaskToBearerBitmask(int networkTypeBitmask) {\n        if (networkTypeBitmask == 0) {\n            return 0;\n        }\n\n        int bearerBitmask = 0;\n        for (int bearerInt = 0; bearerInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerInt++) {\n            if (bitmaskHasTarget(networkTypeBitmask,\n                    rilRadioTechnologyToNetworkTypeBitmask(bearerInt))) {\n                bearerBitmask |= getBitmaskForTech(bearerInt);\n            }\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Convert bearer bitmask to network type bitmask.\n     *\n     * @param bearerBitmask The bearer bitmask value.\n     * @return The network type bitmask value.\n     */\n    private static int convertBearerBitmaskToNetworkTypeBitmask(int bearerBitmask) {\n        if (bearerBitmask == 0) {\n            return 0;\n        }\n\n        int networkTypeBitmask = 0;\n        for (int bearerUnitInt = 0; bearerUnitInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerUnitInt++) {\n            int bearerUnitBitmask = getBitmaskForTech(bearerUnitInt);\n            if (bitmaskHasTarget(bearerBitmask, bearerUnitBitmask)) {\n                networkTypeBitmask |= rilRadioTechnologyToNetworkTypeBitmask(bearerUnitInt);\n            }\n        }\n        return networkTypeBitmask;\n    }\n\n    private static boolean bitmaskHasTarget(int bearerBitmask, int targetBitmask) {\n        if (bearerBitmask == 0) {\n            return true;\n        } else if (targetBitmask != 0) {\n            return ((bearerBitmask & targetBitmask) != 0);\n        }\n        return false;\n    }\n\n    private static int getBitmaskForTech(int radioTech) {\n        if (radioTech >= 1) {\n            return (1 << (radioTech - 1));\n        }\n        return 0;\n    }\n\n    /**\n     * Migrate the old Long values{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} over to\n     * String{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} values in the sim info\n     *         table.\n     */\n    public static void fillInAllowedNetworkTypesStringAtCursor(SQLiteDatabase db, Cursor c) {\n        long allowedNetworkTypesReasonCarrier;\n        String subId;\n        try {\n            allowedNetworkTypesReasonCarrier = c.getLong(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        if (allowedNetworkTypesReasonCarrier != -1) {\n            ContentValues cv = new ContentValues(1);\n\n            cv.put(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS,\n                    \"carrier=\" + allowedNetworkTypesReasonCarrier);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n\n    /**\n     * Migrate the old values{@link Telephony.SimInfo#COLUMN_DATA_ENABLED_OVERRIDE_RULES} over to\n     * String{@link Telephony.SimInfo#COLUMN_ENABLED_MOBILE_DATA_POLICIES}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo#COLUMN_DATA_ENABLED_OVERRIDE_RULES} values in the sim info\n     *         table.\n     */\n    public static void fillInEnabledMobileDataPoliciesAtCursor(SQLiteDatabase db, Cursor c) {\n        String overrideRule;\n        String subId;\n        try {\n            overrideRule = c.getString(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"COLUMN_DATA_ENABLED_OVERRIDE_RULES not found.\");\n            return;\n        }\n\n        if (overrideRule != null) {\n            ContentValues cv = new ContentValues(1);\n\n            // convert override rule to its corresponding mobile data policy\n            overrideRule = overrideRule.contains(\"mms\") ?\n                    String.valueOf(TelephonyManager.MOBILE_DATA_POLICY_MMS_ALWAYS_ALLOWED): \"\";\n            cv.put(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES, overrideRule);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n\n    /**\n     * Dump the database table.\n     *\n     * @param tableName Table name.\n     * @param pw Print writer.\n     */\n    private void dumpTable(@NonNull String tableName, @NonNull IndentingPrintWriter pw) {\n        try (Cursor cursor = getReadableDatabase().query(false, tableName, null,\n                null, null, null, null, null, null)) {\n            pw.println(tableName + \" table:\");\n            pw.increaseIndent();\n            while (cursor != null && cursor.moveToNext()) {\n                List<String> columnStrings = new ArrayList<>();\n                String str = \"\";\n                for (int i = 0; i < cursor.getColumnCount(); i++) {\n                    str = cursor.getColumnName(i) + \"=\";\n                    int type = cursor.getType(i);\n                    try {\n                        switch (type) {\n                            case 0 /*FIELD_TYPE_NULL*/:\n                                str += \"null\";\n                                break;\n                            case 1 /*FIELD_TYPE_INTEGER*/:\n                                str += cursor.getInt(i);\n                                break;\n                            case 2 /*FIELD_TYPE_FLOAT*/:\n                                str += cursor.getFloat(i);\n                                break;\n                            case 3 /*FIELD_TYPE_STRING*/:\n                                str += cursor.getString(i);\n                                break;\n                            case 4 /*FIELD_TYPE_BLOB*/:\n                                str += \"[blob]\";\n                                break;\n                            default:\n                                str += \"unknown\";\n                                break;\n                        }\n                    } catch (Exception e) {\n                        str += \"exception\";\n                    }\n                    columnStrings.add(str);\n                }\n                pw.println(TextUtils.join(\", \", columnStrings));\n            }\n            pw.decreaseIndent();\n        } catch (Exception ex) {\n            pw.println(\"Exception while dumping the table \" + tableName + \", ex=\" + ex);\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {\n        IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, \"  \");\n        pw.println(TAG + \":\");\n        pw.increaseIndent();\n        pw.println(\"Database:\");\n        pw.increaseIndent();\n        dumpTable(SIMINFO_TABLE, pw);\n        dumpTable(CARRIERS_TABLE, pw);\n        pw.decreaseIndent();\n        pw.println(\"Local log:\");\n        pw.increaseIndent();\n        mLocalLog.dump(pw);\n        pw.decreaseIndent();\n        pw.decreaseIndent();\n    }\n}\n","Method after Refactoring":"/* //device/content/providers/telephony/TelephonyProvider.java\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n\npackage com.android.providers.telephony;\n\nimport static android.provider.Telephony.Carriers.ALWAYS_ON;\nimport static android.provider.Telephony.Carriers.APN;\nimport static android.provider.Telephony.Carriers.APN_SET_ID;\nimport static android.provider.Telephony.Carriers.AUTH_TYPE;\nimport static android.provider.Telephony.Carriers.BEARER;\nimport static android.provider.Telephony.Carriers.BEARER_BITMASK;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.CARRIER_EDITED;\nimport static android.provider.Telephony.Carriers.CARRIER_ENABLED;\nimport static android.provider.Telephony.Carriers.CARRIER_ID;\nimport static android.provider.Telephony.Carriers.CONTENT_URI;\nimport static android.provider.Telephony.Carriers.CURRENT;\nimport static android.provider.Telephony.Carriers.DEFAULT_SORT_ORDER;\nimport static android.provider.Telephony.Carriers.EDITED_STATUS;\nimport static android.provider.Telephony.Carriers.LINGERING_NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.MCC;\nimport static android.provider.Telephony.Carriers.MMSC;\nimport static android.provider.Telephony.Carriers.MMSPORT;\nimport static android.provider.Telephony.Carriers.MMSPROXY;\nimport static android.provider.Telephony.Carriers.MNC;\nimport static android.provider.Telephony.Carriers.MODEM_PERSIST;\nimport static android.provider.Telephony.Carriers.MTU;\nimport static android.provider.Telephony.Carriers.MTU_V4;\nimport static android.provider.Telephony.Carriers.MTU_V6;\nimport static android.provider.Telephony.Carriers.MVNO_MATCH_DATA;\nimport static android.provider.Telephony.Carriers.MVNO_TYPE;\nimport static android.provider.Telephony.Carriers.NAME;\nimport static android.provider.Telephony.Carriers.NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.NO_APN_SET_ID;\nimport static android.provider.Telephony.Carriers.NUMERIC;\nimport static android.provider.Telephony.Carriers.OWNED_BY;\nimport static android.provider.Telephony.Carriers.OWNED_BY_DPC;\nimport static android.provider.Telephony.Carriers.OWNED_BY_OTHERS;\nimport static android.provider.Telephony.Carriers.PASSWORD;\nimport static android.provider.Telephony.Carriers.PORT;\nimport static android.provider.Telephony.Carriers.PROFILE_ID;\nimport static android.provider.Telephony.Carriers.PROTOCOL;\nimport static android.provider.Telephony.Carriers.PROXY;\nimport static android.provider.Telephony.Carriers.ROAMING_PROTOCOL;\nimport static android.provider.Telephony.Carriers.SERVER;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT_DEFAULT;\nimport static android.provider.Telephony.Carriers.SUBSCRIPTION_ID;\nimport static android.provider.Telephony.Carriers.TIME_LIMIT_FOR_MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.TYPE;\nimport static android.provider.Telephony.Carriers.UNEDITED;\nimport static android.provider.Telephony.Carriers.USER;\nimport static android.provider.Telephony.Carriers.USER_DELETED;\nimport static android.provider.Telephony.Carriers.USER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.USER_EDITABLE;\nimport static android.provider.Telephony.Carriers.USER_EDITED;\nimport static android.provider.Telephony.Carriers.USER_VISIBLE;\nimport static android.provider.Telephony.Carriers.WAIT_TIME_RETRY;\nimport static android.provider.Telephony.Carriers._ID;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.compat.CompatChanges;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.content.res.XmlResourceParser;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.os.PersistableBundle;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.provider.Telephony;\nimport android.service.carrier.IApnSourceService;\nimport android.telephony.SubscriptionInfo;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.TelephonyProtoEnums;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.IndentingPrintWriter;\nimport android.util.LocalLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.util.XmlUtils;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\nimport java.util.zip.CRC32;\nimport java.util.zip.CheckedInputStream;\n\npublic class TelephonyProvider extends ContentProvider\n{\n    private static final String DATABASE_NAME = \"telephony.db\";\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n    private static final boolean DBG = true;\n    private static final boolean VDBG = false; // STOPSHIP if true\n\n    private static final int DATABASE_VERSION = 62 << 16;\n    private static final int URL_UNKNOWN = 0;\n    private static final int URL_TELEPHONY = 1;\n    private static final int URL_CURRENT = 2;\n    private static final int URL_ID = 3;\n    private static final int URL_RESTOREAPN = 4;\n    private static final int URL_PREFERAPN = 5;\n    private static final int URL_PREFERAPN_NO_UPDATE = 6;\n    private static final int URL_SIMINFO = 7;\n    private static final int URL_TELEPHONY_USING_SUBID = 8;\n    private static final int URL_CURRENT_USING_SUBID = 9;\n    private static final int URL_RESTOREAPN_USING_SUBID = 10;\n    private static final int URL_PREFERAPN_USING_SUBID = 11;\n    private static final int URL_PREFERAPN_NO_UPDATE_USING_SUBID = 12;\n    private static final int URL_SIMINFO_USING_SUBID = 13;\n    private static final int URL_UPDATE_DB = 14;\n    private static final int URL_DELETE = 15;\n    private static final int URL_DPC = 16;\n    private static final int URL_DPC_ID = 17;\n    private static final int URL_FILTERED = 18;\n    private static final int URL_FILTERED_ID = 19;\n    private static final int URL_ENFORCE_MANAGED = 20;\n    // URL_PREFERAPNSET and URL_PREFERAPNSET_USING_SUBID return all APNs for the current\n    // carrier which have an apn_set_id equal to the preferred APN\n    // (if no preferred APN, or preferred APN has no set id, the query will return null)\n    private static final int URL_PREFERAPNSET = 21;\n    private static final int URL_PREFERAPNSET_USING_SUBID = 22;\n    private static final int URL_SIM_APN_LIST = 23;\n    private static final int URL_SIM_APN_LIST_ID = 24;\n    private static final int URL_FILTERED_USING_SUBID = 25;\n    private static final int URL_SIM_APN_LIST_FILTERED = 26;\n    private static final int URL_SIM_APN_LIST_FILTERED_ID = 27;\n    private static final int URL_SIMINFO_SUW_RESTORE = 28;\n    private static final int URL_SIMINFO_SIM_INSERTED_RESTORE = 29;\n\n    private static final String TAG = \"TelephonyProvider\";\n    private static final String CARRIERS_TABLE = \"carriers\";\n    private static final String CARRIERS_TABLE_TMP = \"carriers_tmp\";\n    private static final String SIMINFO_TABLE = \"siminfo\";\n    private static final String SIMINFO_TABLE_TMP = \"siminfo_tmp\";\n\n    private static final String PREF_FILE_APN = \"preferred-apn\";\n    private static final String COLUMN_APN_ID = \"apn_id\";\n    private static final String EXPLICIT_SET_CALLED = \"explicit_set_called\";\n\n    private static final String PREF_FILE_FULL_APN = \"preferred-full-apn\";\n    private static final String DB_VERSION_KEY = \"version\";\n\n    private static final String BUILD_ID_FILE = \"build-id\";\n    private static final String RO_BUILD_ID = \"ro_build_id\";\n\n    private static final String ENFORCED_FILE = \"dpc-apn-enforced\";\n    private static final String ENFORCED_KEY = \"enforced\";\n\n    private static final String PREF_FILE = \"telephonyprovider\";\n    private static final String APN_CONF_CHECKSUM = \"apn_conf_checksum\";\n\n    private static final String PARTNER_APNS_PATH = \"etc/apns-conf.xml\";\n    private static final String OEM_APNS_PATH = \"telephony/apns-conf.xml\";\n    private static final String OTA_UPDATED_APNS_PATH = \"misc/apns/apns-conf.xml\";\n    private static final String OLD_APNS_PATH = \"etc/old-apns-conf.xml\";\n\n    private static final String DEFAULT_PROTOCOL = \"IP\";\n    private static final String DEFAULT_ROAMING_PROTOCOL = \"IP\";\n\n    private static final UriMatcher s_urlMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    private static final ContentValues s_currentNullMap;\n    private static final ContentValues s_currentSetMap;\n\n    private static final String IS_UNEDITED = EDITED_STATUS + \"=\" + UNEDITED;\n    private static final String IS_EDITED = EDITED_STATUS + \"!=\" + UNEDITED;\n    private static final String IS_USER_EDITED = EDITED_STATUS + \"=\" + USER_EDITED;\n    private static final String IS_NOT_USER_EDITED = EDITED_STATUS + \"!=\" + USER_EDITED;\n    private static final String IS_USER_DELETED = EDITED_STATUS + \"=\" + USER_DELETED;\n    private static final String IS_NOT_USER_DELETED = EDITED_STATUS + \"!=\" + USER_DELETED;\n    private static final String IS_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_CARRIER_EDITED = EDITED_STATUS + \"=\" + CARRIER_EDITED;\n    private static final String IS_NOT_CARRIER_EDITED = EDITED_STATUS + \"!=\" + CARRIER_EDITED;\n    private static final String IS_CARRIER_DELETED = EDITED_STATUS + \"=\" + CARRIER_DELETED;\n    private static final String IS_NOT_CARRIER_DELETED = EDITED_STATUS + \"!=\" + CARRIER_DELETED;\n    private static final String IS_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_OWNED_BY_DPC = OWNED_BY + \"=\" + OWNED_BY_DPC;\n    private static final String IS_NOT_OWNED_BY_DPC = OWNED_BY + \"!=\" + OWNED_BY_DPC;\n\n    private static final String ORDER_BY_SUB_ID =\n            Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \" ASC\";\n\n    @VisibleForTesting\n    static final String BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE = \"sim_specific_settings_file\";\n    // Holds names and value types of SimInfoDb columns to backup.\n    private static final Map<String, Integer> SIM_INFO_COLUMNS_TO_BACKUP = new HashMap();\n    private static final String KEY_SIMINFO_DB_ROW_PREFIX = \"KEY_SIMINFO_DB_ROW_\";\n    private static final int DEFAULT_INT_COLUMN_VALUE = -111;\n    private static final String DEFAULT_STRING_COLUMN_VALUE = \"DEFAULT_STRING_COLUMN_VALUE\";\n    private static final String SIM_INSERTED_RESTORE_URI_SUFFIX = \"sim_inserted_restore\";\n    @VisibleForTesting\n    static final String KEY_BACKUP_DATA_FORMAT_VERSION = \"KEY_BACKUP_DATA_FORMAT_VERSION\";\n    @VisibleForTesting\n    static final String KEY_PREVIOUSLY_RESTORED_SUB_IDS = \"KEY_PREVIOUSLY_RESTORED_SUB_IDS\";\n\n    private static final int INVALID_APN_ID = -1;\n    private static final List<String> CARRIERS_UNIQUE_FIELDS = new ArrayList<String>();\n    private static final Set<String> CARRIERS_BOOLEAN_FIELDS = new HashSet<String>();\n    private static final Map<String, String> CARRIERS_UNIQUE_FIELDS_DEFAULTS = new HashMap();\n\n    @VisibleForTesting\n    static Boolean s_apnSourceServiceExists;\n\n    protected final Object mLock = new Object();\n    @GuardedBy(\"mLock\")\n    private IApnSourceService mIApnSourceService;\n    private Injector mInjector;\n\n    private boolean mManagedApnEnforced;\n\n    private final LocalLog mLocalLog = new LocalLog(128);\n\n    /**\n     * Mobile country codes where there is a high likelyhood that the MNC has 3 digits\n     * and need one more prefix zero to set correct mobile network code value.\n     *\n     * Please note! The best solution is to add the MCCMNC combo to carrier id\n     * carrier_list, this is just a best effort.\n     */\n    private static final String[] COUNTRY_MCC_WITH_THREE_DIGIT_MNC = {\n            \"302\" // Canada\n           ,\"310\" // Guam, USA\n           ,\"311\" // USA\n           ,\"312\" // USA\n           ,\"313\" // USA\n           ,\"316\" // USA\n           ,\"334\" // Mexico\n           ,\"338\" // Bermuda, Jamaica\n           ,\"342\" // Barbados\n           ,\"344\" // Antigua and Barbuda\n           ,\"346\" // Cayman Islands\n           ,\"348\" // British Virgin Islands\n           ,\"356\" // Saint Kitts and Nevis\n           ,\"358\" // Saint Lucia\n           ,\"360\" // Saint Vincent and the Grenadines\n           ,\"365\" // Anguilla\n           ,\"366\" // Dominica\n           ,\"376\" // Turks and Caicos Islands\n           ,\"405\" // India\n           ,\"708\" // Honduras\n           ,\"722\" // Argentina\n           ,\"732\" // Colombia\n           ,\"738\" // Guyana\n           ,\"750\" // Falkland Islands\n            };\n\n    /**\n     * Available radio technologies for GSM, UMTS and CDMA.\n     * Duplicates the constants from hardware/radio/include/ril.h\n     * This should only be used by agents working with the ril.  Others\n     * should use the equivalent TelephonyManager.NETWORK_TYPE_*\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_UNKNOWN = 0;\n    private static final int RIL_RADIO_TECHNOLOGY_GPRS = 1;\n    private static final int RIL_RADIO_TECHNOLOGY_EDGE = 2;\n    private static final int RIL_RADIO_TECHNOLOGY_UMTS = 3;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95A = 4;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95B = 5;\n    private static final int RIL_RADIO_TECHNOLOGY_1xRTT = 6;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_0 = 7;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_A = 8;\n    private static final int RIL_RADIO_TECHNOLOGY_HSDPA = 9;\n    private static final int RIL_RADIO_TECHNOLOGY_HSUPA = 10;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPA = 11;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_B = 12;\n    private static final int RIL_RADIO_TECHNOLOGY_EHRPD = 13;\n    private static final int RIL_RADIO_TECHNOLOGY_LTE = 14;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPAP = 15;\n\n    /**\n     * GSM radio technology only supports voice. It does not support data.\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_GSM = 16;\n    private static final int RIL_RADIO_TECHNOLOGY_TD_SCDMA = 17;\n\n    /**\n     * IWLAN\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;\n\n    /**\n     * LTE_CA\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_LTE_CA = 19;\n\n    /**\n     * NR(New Radio) 5G.\n     */\n    private static final int  RIL_RADIO_TECHNOLOGY_NR = 20;\n\n    /**\n     * The number of the radio technologies.\n     */\n    private static final int NEXT_RIL_RADIO_TECHNOLOGY = 21;\n\n    private static final Map<String, Integer> MVNO_TYPE_STRING_MAP;\n\n    static {\n        // Columns not included in UNIQUE constraint: name, current, edited, user, server, password,\n        // authtype, type, protocol, roaming_protocol, sub_id, modem_cognitive, max_conns,\n        // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n        // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(NUMERIC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MCC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MNC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ENABLED, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(BEARER, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_TYPE, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_MATCH_DATA, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROFILE_ID, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(ROAMING_PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(USER_EDITABLE, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(OWNED_BY, String.valueOf(OWNED_BY_OTHERS));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN_SET_ID, String.valueOf(NO_APN_SET_ID));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ID,\n                String.valueOf(TelephonyManager.UNKNOWN_CARRIER_ID));\n\n        CARRIERS_UNIQUE_FIELDS.addAll(CARRIERS_UNIQUE_FIELDS_DEFAULTS.keySet());\n\n        // SQLite databases store bools as ints but the ContentValues objects passed in through\n        // queries use bools. As a result there is some special handling of boolean fields within\n        // the TelephonyProvider.\n        CARRIERS_BOOLEAN_FIELDS.add(CARRIER_ENABLED);\n        CARRIERS_BOOLEAN_FIELDS.add(MODEM_PERSIST);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_VISIBLE);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_EDITABLE);\n\n        MVNO_TYPE_STRING_MAP = new ArrayMap<String, Integer>();\n        MVNO_TYPE_STRING_MAP.put(\"spn\", ApnSetting.MVNO_TYPE_SPN);\n        MVNO_TYPE_STRING_MAP.put(\"imsi\", ApnSetting.MVNO_TYPE_IMSI);\n        MVNO_TYPE_STRING_MAP.put(\"gid\", ApnSetting.MVNO_TYPE_GID);\n        MVNO_TYPE_STRING_MAP.put(\"iccid\", ApnSetting.MVNO_TYPE_ICCID);\n\n        // To B&R a new config, simply add the column name and its appropriate value type to\n        // SIM_INFO_COLUMNS_TO_BACKUP. To no longer B&R a column, simply remove it from\n        // SIM_INFO_COLUMNS_TO_BACKUP. For both cases, add appropriate versioning logic in\n        // convertBackedUpDataToContentValues(ContentValues contenValues)\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ICC_ID, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NUMBER, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_CARRIER_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_VT_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES, Cursor.FIELD_TYPE_STRING);\n    }\n\n    @VisibleForTesting\n    public static String getStringForCarrierTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName +\n                \"(_id INTEGER PRIMARY KEY,\" +\n                NAME + \" TEXT DEFAULT '',\" +\n                NUMERIC + \" TEXT DEFAULT '',\" +\n                MCC + \" TEXT DEFAULT '',\" +\n                MNC + \" TEXT DEFAULT '',\" +\n                CARRIER_ID + \" INTEGER DEFAULT \" + TelephonyManager.UNKNOWN_CARRIER_ID  + \",\" +\n                APN + \" TEXT DEFAULT '',\" +\n                USER + \" TEXT DEFAULT '',\" +\n                SERVER + \" TEXT DEFAULT '',\" +\n                PASSWORD + \" TEXT DEFAULT '',\" +\n                PROXY + \" TEXT DEFAULT '',\" +\n                PORT + \" TEXT DEFAULT '',\" +\n                MMSPROXY + \" TEXT DEFAULT '',\" +\n                MMSPORT + \" TEXT DEFAULT '',\" +\n                MMSC + \" TEXT DEFAULT '',\" +\n                AUTH_TYPE + \" INTEGER DEFAULT -1,\" +\n                TYPE + \" TEXT DEFAULT '',\" +\n                CURRENT + \" INTEGER,\" +\n                PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_PROTOCOL + \",\" +\n                ROAMING_PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_ROAMING_PROTOCOL + \",\" +\n                CARRIER_ENABLED + \" BOOLEAN DEFAULT 1,\" + // SQLite databases store bools as ints\n                BEARER + \" INTEGER DEFAULT 0,\" +\n                BEARER_BITMASK + \" INTEGER DEFAULT 0,\" +\n                NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                MVNO_TYPE + \" TEXT DEFAULT '',\" +\n                MVNO_MATCH_DATA + \" TEXT DEFAULT '',\" +\n                SUBSCRIPTION_ID + \" INTEGER DEFAULT \" +\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID + \",\" +\n                PROFILE_ID + \" INTEGER DEFAULT 0,\" +\n                MODEM_PERSIST + \" BOOLEAN DEFAULT 0,\" +\n                MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                WAIT_TIME_RETRY + \" INTEGER DEFAULT 0,\" +\n                TIME_LIMIT_FOR_MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                MTU + \" INTEGER DEFAULT 0,\" +\n                MTU_V4 + \" INTEGER DEFAULT 0,\" +\n                MTU_V6 + \" INTEGER DEFAULT 0,\" +\n                EDITED_STATUS + \" INTEGER DEFAULT \" + UNEDITED + \",\" +\n                USER_VISIBLE + \" BOOLEAN DEFAULT 1,\" +\n                USER_EDITABLE + \" BOOLEAN DEFAULT 1,\" +\n                OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \",\" +\n                APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \",\" +\n                SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \",\" +\n                ALWAYS_ON + \" INTEGER DEFAULT 0,\" +\n                // Uniqueness collisions are used to trigger merge code so if a field is listed\n                // here it means we will accept both (user edited + new apn_conf definition)\n                // Columns not included in UNIQUE constraint: name, current, edited,\n                // user, server, password, authtype, type, sub_id, modem_cognitive, max_conns,\n                // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n                // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on.\n                \"UNIQUE (\" + TextUtils.join(\", \", CARRIERS_UNIQUE_FIELDS) + \"));\";\n    }\n\n    @VisibleForTesting\n    public static String getStringForSimInfoTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName + \"(\"\n                + Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID\n                + \" INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                + Telephony.SimInfo.COLUMN_ICC_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_NOT_INSERTED + \",\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NAME_SOURCE\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.NAME_SOURCE_CARRIER_ID + \",\"\n                + Telephony.SimInfo.COLUMN_COLOR + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.COLOR_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_NUMBER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT\n                + \" INTEGER NOT NULL DEFAULT \" + Telephony.SimInfo.DISPLAY_NUMBER_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_DATA_ROAMING\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.DATA_ROAMING_DISABLE + \",\"\n                + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_PROVISIONED + \",\"\n                + Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CARD_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION + \" INTEGER DEFAULT 4,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.PROFILE_CLASS_UNSET + \",\"\n                + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \",\"\n                + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IMSI + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES + \" BIGINT DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_RCS_CONFIG + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PORT_INDEX + \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USAGE_SETTING + \" INTEGER DEFAULT \"\n                + SubscriptionManager.USAGE_SETTING_UNKNOWN + \",\"\n                + Telephony.SimInfo.COLUMN_TP_MESSAGE_REF +\n                \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USER_HANDLE + \" INTEGER DEFAULT \"\n                + UserHandle.USER_NULL + \",\"\n                + Telephony.SimInfo.COLUMN_SATELLITE_ENABLED + \" INTEGER DEFAULT -1\"\n                + \");\";\n    }\n\n    static {\n        s_urlMatcher.addURI(\"telephony\", \"carriers\", URL_TELEPHONY);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current\", URL_CURRENT);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/#\", URL_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore\", URL_RESTOREAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn\", URL_PREFERAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update\", URL_PREFERAPN_NO_UPDATE);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset\", URL_PREFERAPNSET);\n\n        s_urlMatcher.addURI(\"telephony\", \"siminfo\", URL_SIMINFO);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/#\", URL_SIMINFO_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/suw_restore\",\n                URL_SIMINFO_SUW_RESTORE);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/\" +\n                SIM_INSERTED_RESTORE_URI_SUFFIX,\n                URL_SIMINFO_SIM_INSERTED_RESTORE);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/subId/*\", URL_TELEPHONY_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current/subId/*\", URL_CURRENT_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore/subId/*\", URL_RESTOREAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn/subId/*\", URL_PREFERAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update/subId/*\",\n                URL_PREFERAPN_NO_UPDATE_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset/subId/*\",\n                URL_PREFERAPNSET_USING_SUBID);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/update_db\", URL_UPDATE_DB);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/delete\", URL_DELETE);\n\n        // Only called by DevicePolicyManager to manipulate DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc\", URL_DPC);\n        // Only called by DevicePolicyManager to manipulate a DPC record with certain _ID.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc/#\", URL_DPC_ID);\n        // Only called by Settings app, DcTracker and other telephony components to get APN list\n        // according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered\", URL_FILTERED);\n        // Only called by Settings app, DcTracker and other telephony components to get a\n        // single APN according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/#\", URL_FILTERED_ID);\n        // Used by DcTracker to pass a subId.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/subId/*\", URL_FILTERED_USING_SUBID);\n\n        // Only Called by DevicePolicyManager to enforce DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/enforce_managed\", URL_ENFORCE_MANAGED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list\", URL_SIM_APN_LIST);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/#\", URL_SIM_APN_LIST_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered\",\n            URL_SIM_APN_LIST_FILTERED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered/subId/*\",\n                URL_SIM_APN_LIST_FILTERED_ID);\n\n        s_currentNullMap = new ContentValues(1);\n        s_currentNullMap.put(CURRENT, \"0\");\n\n        s_currentSetMap = new ContentValues(1);\n        s_currentSetMap.put(CURRENT, \"1\");\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n    }\n\n    public TelephonyProvider() {\n        this(new Injector());\n    }\n\n    @VisibleForTesting\n    public TelephonyProvider(Injector injector) {\n        mInjector = injector;\n    }\n\n    @VisibleForTesting\n    public static int getVersion(Context context) {\n        if (VDBG) log(\"getVersion:+\");\n        // Get the database version, combining a static schema version and the XML version\n        Resources r = context.getResources();\n        if (r == null) {\n            loge(\"resources=null, return version=\" + Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        }\n        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n        try {\n            XmlUtils.beginDocument(parser, \"apns\");\n            int publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n            int version = DATABASE_VERSION | publicversion;\n            if (VDBG) log(\"getVersion:- version=0x\" + Integer.toHexString(version));\n            return version;\n        } catch (Exception e) {\n            loge(\"Can't get version of APN database\" + e + \" return version=\" +\n                    Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        } finally {\n            parser.close();\n        }\n    }\n\n    static public ContentValues setDefaultValue(ContentValues values) {\n        if (!values.containsKey(SUBSCRIPTION_ID)) {\n            int subId = SubscriptionManager.getDefaultSubscriptionId();\n            values.put(SUBSCRIPTION_ID, subId);\n        }\n\n        return values;\n    }\n\n    @VisibleForTesting\n    public class DatabaseHelper extends SQLiteOpenHelper {\n        // Context to access resources with\n        private Context mContext;\n\n        /**\n         * DatabaseHelper helper class for loading apns into a database.\n         *\n         * @param context of the user.\n         */\n        public DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n            setWriteAheadLoggingEnabled(false);\n        }\n\n        @Override\n        public void onCreate(SQLiteDatabase db) {\n            if (DBG) log(\"dbh.onCreate:+ db=\" + db);\n            createSimInfoTable(db, SIMINFO_TABLE);\n            createCarriersTable(db, CARRIERS_TABLE);\n            // if CarrierSettings app is installed, we expect it to do the initializiation instead\n            if (apnSourceServiceExists(mContext)) {\n                log(\"dbh.onCreate: Skipping apply APNs from xml.\");\n            } else {\n                log(\"dbh.onCreate: Apply apns from xml.\");\n                initDatabase(db);\n            }\n            if (DBG) log(\"dbh.onCreate:- db=\" + db);\n        }\n\n        @Override\n        public void onOpen(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.onOpen:+ db=\" + db);\n            try {\n                // Try to access the table and create it if \"no such table\"\n                db.query(SIMINFO_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + SIMINFO_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + SIMINFO_TABLE + \"e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createSimInfoTable(db, SIMINFO_TABLE);\n                }\n            }\n            try {\n                db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + CARRIERS_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + CARRIERS_TABLE + \" e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createCarriersTable(db, CARRIERS_TABLE);\n                }\n            }\n            if (VDBG) log(\"dbh.onOpen:- db=\" + db);\n        }\n\n        private void createSimInfoTable(SQLiteDatabase db, String tableName) {\n            if (DBG) log(\"dbh.createSimInfoTable:+ \" + tableName);\n            db.execSQL(getStringForSimInfoTableCreation(tableName));\n            if (DBG) log(\"dbh.createSimInfoTable:-\");\n        }\n\n        private void createCarriersTable(SQLiteDatabase db, String tableName) {\n            // Set up the database schema\n            if (DBG) log(\"dbh.createCarriersTable: \" + tableName);\n            db.execSQL(getStringForCarrierTableCreation(tableName));\n            if (DBG) log(\"dbh.createCarriersTable:-\");\n        }\n\n        private long getChecksum(File file) {\n            CRC32 checkSummer = new CRC32();\n            long checkSum = -1;\n            try (CheckedInputStream cis =\n                new CheckedInputStream(new FileInputStream(file), checkSummer)){\n                byte[] buf = new byte[128];\n                if(cis != null) {\n                    while(cis.read(buf) >= 0) {\n                        // Just read for checksum to get calculated.\n                    }\n                }\n                checkSum = checkSummer.getValue();\n                if (DBG) log(\"Checksum for \" + file.getAbsolutePath() + \" is \" + checkSum);\n            } catch (FileNotFoundException e) {\n                loge(\"FileNotFoundException for \" + file.getAbsolutePath() + \":\" + e);\n            } catch (IOException e) {\n                loge(\"IOException for \" + file.getAbsolutePath() + \":\" + e);\n            }\n\n            // The RRO may have been updated in a firmware upgrade. Add checksum for the\n            // resources to the total checksum so that apns in an RRO update is not missed.\n            try (InputStream inputStream = mContext.getResources().\n                        openRawResource(com.android.internal.R.xml.apns)) {\n                byte[] array = toByteArray(inputStream);\n                checkSummer.reset();\n                checkSummer.update(array);\n                checkSum += checkSummer.getValue();\n                if (DBG) log(\"Checksum after adding resource is \" + checkSummer.getValue());\n            } catch (IOException | Resources.NotFoundException e) {\n                loge(\"Exception when calculating checksum for internal apn resources: \" + e);\n            }\n            return checkSum;\n        }\n\n        private byte[] toByteArray(InputStream input) throws IOException {\n            byte[] buffer = new byte[128];\n            int bytesRead;\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            return output.toByteArray();\n        }\n\n        private long getApnConfChecksum() {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            return sp.getLong(APN_CONF_CHECKSUM, -1);\n        }\n\n        private void setApnConfChecksum(long checksum) {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.putLong(APN_CONF_CHECKSUM, checksum);\n            editor.apply();\n        }\n\n        private File getApnConfFile() {\n            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or \"/system\".\n            File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);\n            File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);\n            File updatedConfFile = new File(Environment.getDataDirectory(), OTA_UPDATED_APNS_PATH);\n            File productConfFile = new File(Environment.getProductDirectory(), PARTNER_APNS_PATH);\n            confFile = pickSecondIfExists(confFile, oemConfFile);\n            confFile = pickSecondIfExists(confFile, productConfFile);\n            confFile = pickSecondIfExists(confFile, updatedConfFile);\n            return confFile;\n        }\n\n        /**\n         * This function computes checksum for the file to be read and compares it against the\n         * last read file. DB needs to be updated only if checksum has changed, or old checksum does\n         * not exist.\n         * @return true if DB should be updated with new conf file, false otherwise\n         */\n        private boolean apnDbUpdateNeeded() {\n            File confFile = getApnConfFile();\n            long newChecksum = getChecksum(confFile);\n            long oldChecksum = getApnConfChecksum();\n            if (DBG) log(\"newChecksum: \" + newChecksum);\n            if (DBG) log(\"oldChecksum: \" + oldChecksum);\n            if (newChecksum == oldChecksum) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        /**\n         *  This function adds APNs from xml file(s) to db. The db may or may not be empty to begin\n         *  with.\n         */\n        private void initDatabase(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.initDatabase:+ db=\" + db);\n            // Read internal APNS data\n            Resources r = mContext.getResources();\n            int publicversion = -1;\n            if (r != null) {\n                XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n                try {\n                    XmlUtils.beginDocument(parser, \"apns\");\n                    publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n                    loadApns(db, parser, true);\n                } catch (Exception e) {\n                    loge(\"Got exception while loading APN database.\" + e);\n                } finally {\n                    parser.close();\n                }\n            } else {\n                loge(\"initDatabase: resources=null\");\n            }\n\n            // Read external APNS data (partner-provided)\n            XmlPullParser confparser = null;\n            File confFile = getApnConfFile();\n\n            FileReader confreader = null;\n            if (DBG) log(\"confFile = \" + confFile);\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                // Correctness check. Force internal version and confidential versions to agree\n                int confversion = Integer.parseInt(confparser.getAttributeValue(null, \"version\"));\n                if (publicversion != confversion) {\n                    log(\"initDatabase: throwing exception due to version mismatch\");\n                    throw new IllegalStateException(\"Internal APNS file version doesn't match \"\n                            + confFile.getAbsolutePath());\n                }\n\n                loadApns(db, confparser, false);\n            } catch (FileNotFoundException e) {\n                // It's ok if the file isn't found. It means there isn't a confidential file\n                // Log.e(TAG, \"File not found: '\" + confFile.getAbsolutePath() + \"'\");\n            } catch (Exception e) {\n                loge(\"initDatabase: Exception while parsing '\" + confFile.getAbsolutePath() + \"'\" +\n                        e);\n            } finally {\n                // Get rid of user/carrier deleted entries that are not present in apn xml file.\n                // Those entries have edited value USER_DELETED/CARRIER_DELETED.\n                if (VDBG) {\n                    log(\"initDatabase: deleting USER_DELETED and replacing \"\n                            + \"DELETED_BUT_PRESENT_IN_XML with DELETED\");\n                }\n\n                // Delete USER_DELETED\n                db.delete(CARRIERS_TABLE, IS_USER_DELETED + \" or \" + IS_CARRIER_DELETED, null);\n\n                // Change USER_DELETED_BUT_PRESENT_IN_XML to USER_DELETED\n                ContentValues cv = new ContentValues();\n                cv.put(EDITED_STATUS, USER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_USER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                // Change CARRIER_DELETED_BUT_PRESENT_IN_XML to CARRIER_DELETED\n                cv = new ContentValues();\n                cv.put(EDITED_STATUS, CARRIER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_CARRIER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n\n                // Update the stored checksum\n                setApnConfChecksum(getChecksum(confFile));\n            }\n            if (VDBG) log(\"dbh.initDatabase:- db=\" + db);\n\n        }\n\n        private File pickSecondIfExists(File sysApnFile, File altApnFile) {\n            if (altApnFile.exists()) {\n                if (DBG) log(\"Load APNs from \" + altApnFile.getPath() +\n                        \" instead of \" + sysApnFile.getPath());\n                return altApnFile;\n            } else {\n                if (DBG) log(\"Load APNs from \" + sysApnFile.getPath() +\n                        \" instead of \" + altApnFile.getPath());\n                return sysApnFile;\n            }\n        }\n\n        @Override\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n            if (DBG) {\n                log(\"dbh.onUpgrade:+ db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n\n            deletePreferredApnId(mContext);\n\n            if (oldVersion < (5 << 16 | 6)) {\n                // 5 << 16 is the Database version and 6 in the xml version.\n\n                // This change adds a new authtype column to the database.\n                // The auth type column can have 4 values: 0 (None), 1 (PAP), 2 (CHAP)\n                // 3 (PAP or CHAP). To avoid breaking compatibility, with already working\n                // APNs, the unset value (-1) will be used. If the value is -1.\n                // the authentication will default to 0 (if no user / password) is specified\n                // or to 3. Currently, there have been no reported problems with\n                // pre-configured APNs and hence it is set to -1 for them. Similarly,\n                // if the user, has added a new APN, we set the authentication type\n                // to -1.\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN authtype INTEGER DEFAULT -1;\");\n\n                oldVersion = 5 << 16 | 6;\n            }\n            if (oldVersion < (6 << 16 | 6)) {\n                // Add protcol fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN protocol TEXT DEFAULT IP;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN roaming_protocol TEXT DEFAULT IP;\");\n                oldVersion = 6 << 16 | 6;\n            }\n            if (oldVersion < (7 << 16 | 6)) {\n                // Add carrier_enabled, bearer fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN carrier_enabled BOOLEAN DEFAULT 1;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN bearer INTEGER DEFAULT 0;\");\n                oldVersion = 7 << 16 | 6;\n            }\n            if (oldVersion < (8 << 16 | 6)) {\n                // Add mvno_type, mvno_match_data fields to the APN.\n                // The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_type TEXT DEFAULT '';\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_match_data TEXT DEFAULT '';\");\n                oldVersion = 8 << 16 | 6;\n            }\n            if (oldVersion < (9 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN sub_id INTEGER DEFAULT \" +\n                        SubscriptionManager.INVALID_SUBSCRIPTION_ID + \";\");\n                oldVersion = 9 << 16 | 6;\n            }\n            if (oldVersion < (10 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN profile_id INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN modem_cognitive BOOLEAN DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN wait_time INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns_time INTEGER DEFAULT 0;\");\n                oldVersion = 10 << 16 | 6;\n            }\n            if (oldVersion < (11 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mtu INTEGER DEFAULT 0;\");\n                oldVersion = 11 << 16 | 6;\n            }\n            if (oldVersion < (12 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 12 << 16 | 6;\n            }\n            if (oldVersion < (13 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT DEFAULT '';\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 13 << 16 | 6;\n            }\n            if (oldVersion < (14 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for next version and that takes care of updates for this version as well.\n                // This version added a new column user_edited to carriers db.\n            }\n            if (oldVersion < (15 << 16 | 6)) {\n                // Most devices should be upgrading from version 13. On upgrade new db will be\n                // populated from the xml included in OTA but user and carrier edited/added entries\n                // need to be preserved. This new version also adds new columns EDITED and\n                // BEARER_BITMASK to the table. Upgrade steps from version 13 are:\n                // 1. preserve user and carrier added/edited APNs (by comparing against\n                // old-apns-conf.xml included in OTA) - done in preserveUserAndCarrierApns()\n                // 2. add new columns EDITED and BEARER_BITMASK (create a new table for that) - done\n                // in createCarriersTable()\n                // 3. copy over preserved APNs from old table to new table - done in\n                // copyPreservedApnsToNewTable()\n                // The only exception if upgrading from version 14 is that EDITED field is already\n                // present (but is called USER_EDITED)\n                /*********************************************************************************\n                 * IMPORTANT NOTE: SINCE CARRIERS TABLE IS RECREATED HERE, IT WILL BE THE LATEST\n                 * VERSION AFTER THIS. AS A RESULT ANY SUBSEQUENT UPDATES TO THE TABLE WILL FAIL\n                 * (DUE TO COLUMN-ALREADY-EXISTS KIND OF EXCEPTION). ALL SUBSEQUENT UPDATES SHOULD\n                 * HANDLE THAT GRACEFULLY.\n                 *********************************************************************************/\n                Cursor c;\n                String[] proj = {\"_id\"};\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                }\n\n                // Compare db with old apns xml file so that any user or carrier edited/added\n                // entries can be preserved across upgrade\n                preserveUserAndCarrierApns(db);\n\n                c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n                if (VDBG) {\n                    log(\"dbh.onUpgrade:- after preserveUserAndCarrierApns() total number of \" +\n                            \"rows: \" + ((c == null) ? 0 : c.getCount()));\n                }\n\n                createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n                copyPreservedApnsToNewTable(db, c);\n                c.close();\n\n                db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE +\n                        \";\");\n\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_UNEDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_UNEDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_EDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_EDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                }\n\n                oldVersion = 15 << 16 | 6;\n            }\n            if (oldVersion < (16 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    // These columns may already be present in which case execSQL will throw an\n                    // exception\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION\n                            + \" INTEGER DEFAULT 4;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL\n                            + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 16 << 16 | 6;\n            }\n            if (oldVersion < (17 << 16 | 6)) {\n                Cursor c = null;\n                try {\n                    c = db.query(CARRIERS_TABLE, null, null, null, null, null, null,\n                            String.valueOf(1));\n                    if (c == null || c.getColumnIndex(USER_VISIBLE) == -1) {\n                        db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                                USER_VISIBLE + \" BOOLEAN DEFAULT 1;\");\n                    } else {\n                        if (DBG) {\n                            log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade.  Column \" +\n                                    USER_VISIBLE + \" already exists.\");\n                        }\n                    }\n                } finally {\n                    if (c != null) {\n                        c.close();\n                    }\n                }\n                oldVersion = 17 << 16 | 6;\n            }\n            if (oldVersion < (18 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.SIM_PROVISIONED + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 18 << 16 | 6;\n            }\n            if (oldVersion < (19 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for version 24 and that takes care of updates for this version as well.\n                // This version added more fields protocol and roaming protocol to the primary key.\n            }\n            if (oldVersion < (20 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 20 << 16 | 6;\n            }\n            if (oldVersion < (21 << 16 | 6)) {\n                try {\n                    // Try to update the carriers table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            USER_EDITABLE + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    // This is possible if the column already exists which may be the case if the\n                    // table was just created as part of upgrade to version 19\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 21 << 16 | 6;\n            }\n            if (oldVersion < (22 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 22 << 16 | 6;\n            }\n            if (oldVersion < (23 << 16 | 6)) {\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 23 << 16 | 6;\n            }\n            if (oldVersion < (24 << 16 | 6)) {\n                Cursor c = null;\n                String[] proj = {\"_id\"};\n                recreateDB(db, proj, /* version */24);\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(\n                            CARRIERS_TABLE, proj, NETWORK_TYPE_BITMASK, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + NETWORK_TYPE_BITMASK + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 24 << 16 | 6;\n            }\n            if (oldVersion < (25 << 16 | 6)) {\n                // Add a new column SubscriptionManager.CARD_ID into the database and set the value\n                // to be the same as the existing column SubscriptionManager.ICC_ID. In order to do\n                // this, we need to first make a copy of the existing SIMINFO_TABLE, set the value\n                // of the new column SubscriptionManager.CARD_ID, and replace the SIMINFO_TABLE with\n                // the new table.\n                Cursor c = null;\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID};\n                recreateSimInfoDB(c, db, proj);\n                if (VDBG) {\n                    c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading \" + SIMINFO_TABLE\n                            + \" total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(SIMINFO_TABLE, proj, Telephony.SimInfo.COLUMN_CARD_ID\n                                    + \" IS NOT NULL\", null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + Telephony.SimInfo.COLUMN_CARD_ID + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 25 << 16 | 6;\n            }\n            if (oldVersion < (26 << 16 | 6)) {\n                // Add a new column Carriers.APN_SET_ID into the database and set the value to\n                // Carriers.NO_SET_SET by default.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 26 << 16 | 6;\n            }\n\n            if (oldVersion < (27 << 16 | 6)) {\n                // Add the new MCC_STRING and MNC_STRING columns into the subscription table,\n                // and attempt to populate them.\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                // Migrate the old integer values over to strings\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_MCC, Telephony.SimInfo.COLUMN_MNC};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInMccMncStringAtCursor(mContext, db, c);\n                    }\n                }\n                oldVersion = 27 << 16 | 6;\n            }\n\n            if (oldVersion < (28 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 28 << 16 | 6;\n            }\n\n            if (oldVersion < (29 << 16 | 6)) {\n                try {\n                    // Add a new column Telephony.CARRIER_ID into the database and add UNIQUE\n                    // constraint into table. However, sqlite cannot add constraints to an existing\n                    // table, so recreate the table.\n                    String[] proj = {\"_id\"};\n                    recreateDB(db, proj,  /* version */29);\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 29 << 16 | 6;\n            }\n\n            if (oldVersion < (30 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 30 << 16 | 6;\n            }\n\n            if (oldVersion < (31 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 31 << 16 | 6;\n            }\n\n            if (oldVersion < (32 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 32 << 16 | 6;\n            }\n\n            if (oldVersion < (33 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 33 << 16 | 6;\n            }\n\n            if (oldVersion < (34 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.PROFILE_CLASS_UNSET + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 34 << 16 | 6;\n            }\n\n            if (oldVersion < (35 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                        + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 35 << 16 | 6;\n            }\n\n            if (oldVersion < (36 << 16 | 6)) {\n                // Add a new column Carriers.SKIP_464XLAT into the database and set the value to\n                // SKIP_464XLAT_DEFAULT.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 36 << 16 | 6;\n            }\n\n            if (oldVersion < (37 << 16 | 6)) {\n                // Add new columns Telephony.SimInfo.EHPLMNS and Telephony.SimInfo.HPLMNS into\n                // the database.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade for ehplmns. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 37 << 16 | 6;\n            }\n\n            if (oldVersion < (39 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 39 << 16 | 6;\n            }\n\n            if (oldVersion < (40 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 40 << 16 | 6;\n            }\n\n            if (oldVersion < (41 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMSI + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 41 << 16 | 6;\n            }\n\n            if (oldVersion < (42 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n            }\n\n            if (oldVersion < (43 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED\n                            + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 43 << 16 | 6;\n            }\n\n            if (oldVersion < (44 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES\n                            + \" BIGINT DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 44 << 16 | 6;\n            }\n\n            if (oldVersion < (45 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 45 << 16 | 6;\n            }\n\n            if (oldVersion < (46 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 46 << 16 | 6;\n            }\n\n            if (oldVersion < (47 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_RCS_CONFIG\n                            + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 47 << 16 | 6;\n            }\n\n            if (oldVersion < (48 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                try {\n                    // Migrate the old Long values over to String\n                    String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                            Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES};\n                    try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                        while (c.moveToNext()) {\n                            fillInAllowedNetworkTypesStringAtCursor(db, c);\n                        }\n                    }\n\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_ALLOWED_NETWORK_TYPES to \"\n                                + \"COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON\");\n                    }\n                }\n                oldVersion = 48 << 16 | 6;\n            }\n\n            if (oldVersion < (49 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing column. \");\n                    }\n                }\n            }\n\n            if (oldVersion < (50 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 50 << 16 | 6;\n            }\n\n            if (oldVersion < (51 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALERT TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 51 << 16 | 6;\n            }\n\n            if (oldVersion < (52 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 52 << 16 | 6;\n            }\n\n            if (oldVersion < (53 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. Fix typo error in version 51.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 53 << 16 | 6;\n            }\n\n            if (oldVersion < (54 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER\n                            + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add phone numbers. \");\n                    }\n                }\n                oldVersion = 54 << 16 | 6;\n            }\n\n            if (oldVersion < (55 << 16 | 6)) {\n                try {\n                    // Try to add new fields LINGERING_NETWORK_TYPE_BITMASK, ALWAYS_ON,\n                    // MTU_V4, and MTU_V6\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + ALWAYS_ON + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V4 + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V6 + \" INTEGER DEFAULT 0;\");\n                    // Populate MTU_V4 with MTU values\n                    db.execSQL(\"UPDATE \" + CARRIERS_TABLE + \" SET \" + MTU_V4 + \" = \"\n                            + MTU + \" WHERE \" + MTU + \" != 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + CARRIERS_TABLE\n                                + \" to add lingering network type bitmask, always on flag,\"\n                                + \" and MTU v4 and v6 values.\");\n                    }\n                }\n                oldVersion = 55 << 16 | 6;\n            }\n\n            if (oldVersion < (56 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PORT_INDEX\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 56 << 16 | 6;\n            }\n\n            if (oldVersion < (57 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USAGE_SETTING\n                            + \" INTEGER DEFAULT \" + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                            + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add preferred usage setting\");\n                    }\n                }\n                oldVersion = 57 << 16 | 6;\n            }\n\n            if (oldVersion < (58 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_TP_MESSAGE_REF\n                            + \"  INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 58 << 16 | 6;\n            }\n\n            if (oldVersion < (59 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USER_HANDLE\n                            + \"  INTEGER DEFAULT \" + UserHandle.USER_NULL +\";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 59 << 16 | 6;\n            }\n            if (oldVersion < (60 << 16 | 6)) {\n                // Update the siminfo table with new column enabled_data_mobile_policies\n                // and set its value to be a copy of data_enabled_override_rules.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to insert \"\n                                +Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES +\" to \"\n                                + SIMINFO_TABLE);\n                    }\n                }\n                // Migrate the old Long values over to String\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInEnabledMobileDataPoliciesAtCursor(db, c);\n                    }\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_DATA_ENABLED_OVERRIDE_RULES to \"\n                                + \"COLUMN_ENABLED_MOBILE_DATA_POLICIES\");\n                    }\n                }\n                oldVersion = 60 << 16 | 6;\n            }\n\n            if (oldVersion < (61 << 16 | 6)) {\n                try {\n                    // If default value of USER_HANDLE column is set to -1, then update it to -10000\n                    db.execSQL(\"UPDATE \" + SIMINFO_TABLE + \" SET \"\n                            + Telephony.SimInfo.COLUMN_USER_HANDLE + \"=\" + UserHandle.USER_NULL\n                            + \"  WHERE \" + Telephony.SimInfo.COLUMN_USER_HANDLE + \"=-1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add message Reference. \");\n                    }\n                }\n                oldVersion = 61 << 16 | 6;\n            }\n\n            if (oldVersion < (62 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_SATELLITE_ENABLED\n                            + \"  INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add satellite enabled. \");\n                    }\n                }\n                oldVersion = 62 << 16 | 6;\n            }\n            if (DBG) {\n                log(\"dbh.onUpgrade:- db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n            // when adding fields to onUpgrade, also add a unit test to TelephonyDatabaseHelperTest\n            // and update the DATABASE_VERSION field and add a column in copyAllApnValues\n        }\n\n        private void recreateSimInfoDB(Cursor c, SQLiteDatabase db, String[] proj) {\n            if (VDBG) {\n                c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:+ before upgrading \" + SIMINFO_TABLE +\n                        \" total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            // Sort in ascending order by subscription id to make sure the rows do not get flipped\n            // during the query and added in the new sim info table in another order (sub id is\n            // stored in settings between migrations).\n            c = db.query(SIMINFO_TABLE, null, null, null, null, null, ORDER_BY_SUB_ID);\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE_TMP);\n\n            createSimInfoTable(db, SIMINFO_TABLE_TMP);\n\n            copySimInfoDataToTmpTable(db, c);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE_TMP + \" rename to \" + SIMINFO_TABLE + \";\");\n\n        }\n\n        private void copySimInfoDataToTmpTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from SIMINFO_TABLE to SIMINFO_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copySimInfoValuesV24(cv, c);\n                    // The card ID is supposed to be the ICCID of the profile for UICC card, and\n                    // the EID of the card for eUICC card. Since EID is unknown for old entries in\n                    // SIMINFO_TABLE, we use ICCID as the card ID for all the old entries while\n                    // upgrading the SIMINFO_TABLE. In UiccController, both the card ID and ICCID\n                    // will be checked when user queries the slot information using the card ID\n                    // from the database.\n                    getCardIdfromIccid(cv, c);\n                    try {\n                        db.insert(SIMINFO_TABLE_TMP, null, cv);\n                        if (VDBG) {\n                            log(\"dbh.copySimInfoDataToTmpTable: db.insert returned >= 0; \" +\n                                \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copySimInfoDataToTmpTable insertWithOnConflict exception \" +\n                                e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copySimInfoValuesV24(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ICC_ID);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CARRIER_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NUMBER);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NAME_SOURCE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_COLOR);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DATA_ROAMING);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MCC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MNC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_EMBEDDED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_REMOVABLE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_AMBER_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_VT_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED);\n\n            // Blob vals\n            getBlobValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ACCESS_RULES);\n        }\n\n        private void getCardIdfromIccid(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    cv.put(Telephony.SimInfo.COLUMN_CARD_ID, fromCursor);\n                }\n            }\n        }\n\n        private void recreateDB(SQLiteDatabase db, String[] proj, int version) {\n            // Upgrade steps are:\n            // 1. Create a temp table- done in createCarriersTable()\n            // 2. copy over APNs from old table to new table - done in copyDataToTmpTable()\n            // 3. Drop the existing table.\n            // 4. Copy over the tmp table.\n            Cursor c;\n            if (VDBG) {\n                c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n            if (VDBG) {\n                log(\"dbh.onUpgrade:- starting data copy of existing rows: \" +\n                        + ((c == null) ? 0 : c.getCount()));\n            }\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE_TMP);\n\n            createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n            copyDataToTmpTable(db, c, version);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE + \";\");\n        }\n\n        private void preserveUserAndCarrierApns(SQLiteDatabase db) {\n            if (VDBG) log(\"preserveUserAndCarrierApns\");\n            XmlPullParser confparser;\n            File confFile = new File(Environment.getRootDirectory(), OLD_APNS_PATH);\n            FileReader confreader = null;\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                deleteMatchingApns(db, confparser);\n            } catch (FileNotFoundException e) {\n                // This function is called only when upgrading db to version 15. Details about the\n                // upgrade are mentioned in onUpgrade(). This file missing means user/carrier added\n                // APNs cannot be preserved. Log an error message so that OEMs know they need to\n                // include old apns file for comparison.\n                loge(\"PRESERVEUSERANDCARRIERAPNS: \" + OLD_APNS_PATH +\n                        \" NOT FOUND. IT IS NEEDED TO UPGRADE FROM OLDER VERSIONS OF APN \" +\n                        \"DB WHILE PRESERVING USER/CARRIER ADDED/EDITED ENTRIES.\");\n            } catch (Exception e) {\n                loge(\"preserveUserAndCarrierApns: Exception while parsing '\" +\n                        confFile.getAbsolutePath() + \"'\" + e);\n            } finally {\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void deleteMatchingApns(SQLiteDatabase db, XmlPullParser parser) {\n            if (VDBG) log(\"deleteMatchingApns\");\n            if (parser != null) {\n                if (VDBG) log(\"deleteMatchingApns: parser != null\");\n                try {\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, false);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        deleteRow(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                } catch (XmlPullParserException e) {\n                    loge(\"deleteMatchingApns: Got XmlPullParserException while deleting apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"deleteMatchingApns: Got IOException while deleting apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"deleteMatchingApns: Got SQLException while deleting apns.\" + e);\n                }\n            }\n        }\n\n        private String queryValFirst(String field) {\n            return field + \"=?\";\n        }\n\n        private String queryVal(String field) {\n            return \" and \" + field + \"=?\";\n        }\n\n        private String queryValOrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private String queryVal2OrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private void deleteRow(SQLiteDatabase db, ContentValues values) {\n            if (VDBG) log(\"deleteRow\");\n            String where = queryValFirst(NUMERIC) +\n                    queryVal(MNC) +\n                    queryVal(MNC) +\n                    queryValOrNull(APN) +\n                    queryValOrNull(USER) +\n                    queryValOrNull(SERVER) +\n                    queryValOrNull(PASSWORD) +\n                    queryValOrNull(PROXY) +\n                    queryValOrNull(PORT) +\n                    queryValOrNull(MMSPROXY) +\n                    queryValOrNull(MMSPORT) +\n                    queryValOrNull(MMSC) +\n                    queryValOrNull(AUTH_TYPE) +\n                    queryValOrNull(TYPE) +\n                    queryValOrNull(PROTOCOL) +\n                    queryValOrNull(ROAMING_PROTOCOL) +\n                    queryVal2OrNull(CARRIER_ENABLED) +\n                    queryValOrNull(BEARER) +\n                    queryValOrNull(MVNO_TYPE) +\n                    queryValOrNull(MVNO_MATCH_DATA) +\n                    queryValOrNull(PROFILE_ID) +\n                    queryVal2OrNull(MODEM_PERSIST) +\n                    queryValOrNull(MAX_CONNECTIONS) +\n                    queryValOrNull(WAIT_TIME_RETRY) +\n                    queryValOrNull(TIME_LIMIT_FOR_MAX_CONNECTIONS) +\n                    queryValOrNull(MTU) +\n                    queryValOrNull(MTU_V4) +\n                    queryValOrNull(MTU_V6);\n            String[] whereArgs = new String[31];\n            int i = 0;\n            whereArgs[i++] = values.getAsString(NUMERIC);\n            whereArgs[i++] = values.getAsString(MCC);\n            whereArgs[i++] = values.getAsString(MNC);\n            whereArgs[i++] = values.getAsString(NAME);\n            whereArgs[i++] = values.containsKey(APN) ?\n                    values.getAsString(APN) : \"\";\n            whereArgs[i++] = values.containsKey(USER) ?\n                    values.getAsString(USER) : \"\";\n            whereArgs[i++] = values.containsKey(SERVER) ?\n                    values.getAsString(SERVER) : \"\";\n            whereArgs[i++] = values.containsKey(PASSWORD) ?\n                    values.getAsString(PASSWORD) : \"\";\n            whereArgs[i++] = values.containsKey(PROXY) ?\n                    values.getAsString(PROXY) : \"\";\n            whereArgs[i++] = values.containsKey(PORT) ?\n                    values.getAsString(PORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPROXY) ?\n                    values.getAsString(MMSPROXY) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPORT) ?\n                    values.getAsString(MMSPORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSC) ?\n                    values.getAsString(MMSC) : \"\";\n            whereArgs[i++] = values.containsKey(AUTH_TYPE) ?\n                    values.getAsString(AUTH_TYPE) : \"-1\";\n            whereArgs[i++] = values.containsKey(TYPE) ?\n                    values.getAsString(TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(PROTOCOL) ?\n                    values.getAsString(PROTOCOL) : DEFAULT_PROTOCOL;\n            whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ?\n                    values.getAsString(ROAMING_PROTOCOL) : DEFAULT_ROAMING_PROTOCOL;\n\n            if (values.containsKey(CARRIER_ENABLED)) {\n                whereArgs[i++] = convertStringToBoolString(values.getAsString(CARRIER_ENABLED));\n                whereArgs[i++] = convertStringToIntString(values.getAsString(CARRIER_ENABLED));\n            } else {\n                String defaultIntString = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(CARRIER_ENABLED);\n                whereArgs[i++] = convertStringToBoolString(defaultIntString);\n                whereArgs[i++] = defaultIntString;\n            }\n\n            whereArgs[i++] = values.containsKey(BEARER) ?\n                    values.getAsString(BEARER) : \"0\";\n            whereArgs[i++] = values.containsKey(MVNO_TYPE) ?\n                    values.getAsString(MVNO_TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ?\n                    values.getAsString(MVNO_MATCH_DATA) : \"\";\n            whereArgs[i++] = values.containsKey(PROFILE_ID) ?\n                    values.getAsString(PROFILE_ID) : \"0\";\n\n            if (values.containsKey(MODEM_PERSIST) &&\n                    (values.getAsString(MODEM_PERSIST).\n                            equalsIgnoreCase(\"true\") ||\n                            values.getAsString(MODEM_PERSIST).equals(\"1\"))) {\n                whereArgs[i++] = \"true\";\n                whereArgs[i++] = \"1\";\n            } else {\n                whereArgs[i++] = \"false\";\n                whereArgs[i++] = \"0\";\n            }\n\n            whereArgs[i++] = values.containsKey(MAX_CONNECTIONS) ?\n                    values.getAsString(MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(WAIT_TIME_RETRY) ?\n                    values.getAsString(WAIT_TIME_RETRY) : \"0\";\n            whereArgs[i++] = values.containsKey(TIME_LIMIT_FOR_MAX_CONNECTIONS) ?\n                    values.getAsString(TIME_LIMIT_FOR_MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU) ?\n                    values.getAsString(MTU) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V4) ?\n                    values.getAsString(MTU_V4) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V6) ?\n                    values.getAsString(MTU_V6) : \"0\";\n\n            if (VDBG) {\n                log(\"deleteRow: where: \" + where);\n\n                StringBuilder builder = new StringBuilder();\n                for (String s : whereArgs) {\n                    builder.append(s + \", \");\n                }\n\n                log(\"deleteRow: whereArgs: \" + builder.toString());\n            }\n            db.delete(CARRIERS_TABLE, where, whereArgs);\n        }\n\n        private void copyDataToTmpTable(SQLiteDatabase db, Cursor c, int version) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copyAllApnValues(cv, c);\n                    if (version == 24) {\n                        // Sync bearer bitmask and network type bitmask\n                        getNetworkTypeBitmaskFromCursor(cv, c);\n                    }\n                    try {\n                        db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                SQLiteDatabase.CONFLICT_ABORT);\n                        if (VDBG) {\n                            log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                    \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                    e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copyApnValuesV17(ContentValues cv, Cursor c) {\n            // Include only non-null values in cv so that null values can be replaced\n            // with default if there's a default value for the field\n\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n        }\n\n        private void copyAllApnValues(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, MTU_V4);\n            getIntValueFromCursor(cv, c, MTU_V6);\n            getIntValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, LINGERING_NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n            getIntValueFromCursor(cv, c, USER_EDITABLE);\n            getIntValueFromCursor(cv, c, OWNED_BY);\n            getIntValueFromCursor(cv, c, APN_SET_ID);\n            getIntValueFromCursor(cv, c, SKIP_464XLAT);\n            getIntValueFromCursor(cv, c, ALWAYS_ON);\n        }\n\n        private void copyPreservedApnsToNewTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null && mContext.getResources() != null) {\n                try {\n                    String[] persistApnsForPlmns = mContext.getResources().getStringArray(\n                            R.array.persist_apns_for_plmn);\n                    while (c.moveToNext()) {\n                        ContentValues cv = new ContentValues();\n                        String val;\n                        // Using V17 copy function for V15 upgrade. This should be fine since it\n                        // handles columns that may not exist properly (getStringValueFromCursor()\n                        // and getIntValueFromCursor() handle column index -1)\n                        copyApnValuesV17(cv, c);\n                        // Change bearer to a bitmask\n                        String bearerStr = c.getString(c.getColumnIndex(BEARER));\n                        if (!TextUtils.isEmpty(bearerStr)) {\n                            int bearer_bitmask = getBitmaskForTech(Integer.parseInt(bearerStr));\n                            cv.put(BEARER_BITMASK, bearer_bitmask);\n\n                            int networkTypeBitmask = rilRadioTechnologyToNetworkTypeBitmask(\n                                    Integer.parseInt(bearerStr));\n                            cv.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n                        }\n\n                        int userEditedColumnIdx = c.getColumnIndex(\"user_edited\");\n                        if (userEditedColumnIdx != -1) {\n                            String user_edited = c.getString(userEditedColumnIdx);\n                            if (!TextUtils.isEmpty(user_edited)) {\n                                cv.put(EDITED_STATUS, new Integer(user_edited));\n                            }\n                        } else {\n                            cv.put(EDITED_STATUS, CARRIER_EDITED);\n                        }\n\n                        // New EDITED column. Default value (UNEDITED) will\n                        // be used for all rows except for non-mvno entries for plmns indicated\n                        // by resource: those will be set to CARRIER_EDITED to preserve\n                        // their current values\n                        val = c.getString(c.getColumnIndex(NUMERIC));\n                        for (String s : persistApnsForPlmns) {\n                            if (!TextUtils.isEmpty(val) && val.equals(s) &&\n                                    (!cv.containsKey(MVNO_TYPE) ||\n                                            TextUtils.isEmpty(cv.getAsString(MVNO_TYPE)))) {\n                                if (userEditedColumnIdx == -1) {\n                                    cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                } else { // if (oldVersion == 14) -- if db had user_edited column\n                                    if (cv.getAsInteger(EDITED_STATUS) == USER_EDITED) {\n                                        cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n\n                        try {\n                            db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                    SQLiteDatabase.CONFLICT_ABORT);\n                            if (VDBG) {\n                                log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                        \"insert successful for cv \" + cv);\n                            }\n                        } catch (SQLException e) {\n                            if (VDBG)\n                                log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                        e + \" for cv \" + cv);\n                            // Insertion failed which could be due to a conflict. Check if that is\n                            // the case and merge the entries\n                            Cursor oldRow = selectConflictingRow(db,\n                                    CARRIERS_TABLE_TMP, cv);\n                            if (oldRow != null) {\n                                ContentValues mergedValues = new ContentValues();\n                                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE_TMP, oldRow, cv,\n                                        mergedValues, true, mContext);\n                                oldRow.close();\n                            }\n                        }\n                    }\n                } catch (Resources.NotFoundException e) {\n                    loge(\"array.persist_apns_for_plmn is not found\");\n                    return;\n                }\n            }\n        }\n\n        private void getStringValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * If NETWORK_TYPE_BITMASK does not exist (upgrade from version 23 to version 24), generate\n         * NETWORK_TYPE_BITMASK with the use of BEARER_BITMASK. If NETWORK_TYPE_BITMASK existed\n         * (upgrade from version 24 to forward), always map NETWORK_TYPE_BITMASK to BEARER_BITMASK.\n         */\n        private void getNetworkTypeBitmaskFromCursor(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(NETWORK_TYPE_BITMASK);\n            if (columnIndex != -1) {\n                getStringValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n                // Map NETWORK_TYPE_BITMASK to BEARER_BITMASK if NETWORK_TYPE_BITMASK existed;\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int networkBitmask = Integer.valueOf(fromCursor);\n                    int bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkBitmask);\n                    cv.put(BEARER_BITMASK, String.valueOf(bearerBitmask));\n                }\n                return;\n            }\n            columnIndex = c.getColumnIndex(BEARER_BITMASK);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int bearerBitmask = Integer.valueOf(fromCursor);\n                    int networkBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                    cv.put(NETWORK_TYPE_BITMASK, String.valueOf(networkBitmask));\n                }\n            }\n        }\n\n        private void getIntValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    try {\n                        cv.put(key, new Integer(fromCursor));\n                    } catch (NumberFormatException nfe) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void getBlobValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                byte[] fromCursor = c.getBlob(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * Gets the next row of apn values.\n         *\n         * @param parser the parser\n         * @param isOverlay If the xml file comes from an overlay MCC/MNC are treated as integers\n         * @return the row or null if it's not an apn\n         */\n        private ContentValues getRow(XmlPullParser parser, boolean isOverlay) {\n            if (!\"apn\".equals(parser.getName())) {\n                return null;\n            }\n\n            ContentValues map = new ContentValues();\n\n            String mcc = parser.getAttributeValue(null, \"mcc\");\n            String mnc = parser.getAttributeValue(null, \"mnc\");\n            String mccString = mcc;\n            String mncString = mnc;\n            // Since an mnc can have both two and three digits and it is hard to verify\n            // all OEM's Global APN lists we only do this for overlays.\n            if (isOverlay && mcc !=null && mnc != null) {\n                mccString = String.format(\"%03d\", Integer.parseInt(mcc));\n                // Looks up a two digit mnc in the carrier id DB\n                // if not found a three digit mnc value is chosen\n                mncString = getBestStringMnc(mContext, mccString, Integer.parseInt(mnc));\n            }\n            // Make sure to set default values for numeric, mcc and mnc. This is the empty string.\n            // If default is not set here, a duplicate of each carrier id APN will be created next\n            // time the apn list is read. This happens at OTA or at restore.\n            String numeric = (mccString == null | mncString == null) ? \"\" : mccString + mncString;\n            map.put(NUMERIC, numeric);\n            map.put(MCC, mccString != null ? mccString : \"\");\n            map.put(MNC, mncString != null ? mncString : \"\");\n            map.put(NAME, parser.getAttributeValue(null, \"carrier\"));\n\n            // do not add NULL to the map so that default values can be inserted in db\n            addStringAttribute(parser, \"apn\", map, APN);\n            addStringAttribute(parser, \"user\", map, USER);\n            addStringAttribute(parser, \"server\", map, SERVER);\n            addStringAttribute(parser, \"password\", map, PASSWORD);\n            addStringAttribute(parser, \"proxy\", map, PROXY);\n            addStringAttribute(parser, \"port\", map, PORT);\n            addStringAttribute(parser, \"mmsproxy\", map, MMSPROXY);\n            addStringAttribute(parser, \"mmsport\", map, MMSPORT);\n            addStringAttribute(parser, \"mmsc\", map, MMSC);\n\n            String apnType = parser.getAttributeValue(null, \"type\");\n            if (apnType != null) {\n                // Remove spaces before putting it in the map.\n                apnType = apnType.replaceAll(\"\\\\s+\", \"\");\n                map.put(TYPE, apnType);\n            }\n\n            addStringAttribute(parser, \"protocol\", map, PROTOCOL);\n            addStringAttribute(parser, \"roaming_protocol\", map, ROAMING_PROTOCOL);\n\n            addIntAttribute(parser, \"authtype\", map, AUTH_TYPE);\n            addIntAttribute(parser, \"bearer\", map, BEARER);\n            addIntAttribute(parser, \"profile_id\", map, PROFILE_ID);\n            addIntAttribute(parser, \"max_conns\", map, MAX_CONNECTIONS);\n            addIntAttribute(parser, \"wait_time\", map, WAIT_TIME_RETRY);\n            addIntAttribute(parser, \"max_conns_time\", map, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            addIntAttribute(parser, \"mtu\", map, MTU);\n            addIntAttribute(parser, \"mtu_v4\", map, MTU_V4);\n            addIntAttribute(parser, \"mtu_v6\", map, MTU_V6);\n            addIntAttribute(parser, \"apn_set_id\", map, APN_SET_ID);\n            addIntAttribute(parser, \"carrier_id\", map, CARRIER_ID);\n            addIntAttribute(parser, \"skip_464xlat\", map, SKIP_464XLAT);\n\n            addBoolAttribute(parser, \"carrier_enabled\", map, CARRIER_ENABLED);\n            addBoolAttribute(parser, \"modem_cognitive\", map, MODEM_PERSIST);\n            addBoolAttribute(parser, \"user_visible\", map, USER_VISIBLE);\n            addBoolAttribute(parser, \"user_editable\", map, USER_EDITABLE);\n            addBoolAttribute(parser, \"always_on\", map, ALWAYS_ON);\n\n            int networkTypeBitmask = 0;\n            String networkTypeList = parser.getAttributeValue(null, \"network_type_bitmask\");\n            if (networkTypeList != null) {\n                networkTypeBitmask = getBitmaskFromString(networkTypeList);\n            }\n            map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n\n            int lingeringNetworkTypeBitmask = 0;\n            String lingeringNetworkTypeList =\n                    parser.getAttributeValue(null, \"lingering_network_type_bitmask\");\n            if (lingeringNetworkTypeList != null) {\n                lingeringNetworkTypeBitmask = getBitmaskFromString(lingeringNetworkTypeList);\n            }\n            map.put(LINGERING_NETWORK_TYPE_BITMASK, lingeringNetworkTypeBitmask);\n\n            int bearerBitmask = 0;\n            if (networkTypeList != null) {\n                bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkTypeBitmask);\n            } else {\n                String bearerList = parser.getAttributeValue(null, \"bearer_bitmask\");\n                if (bearerList != null) {\n                    bearerBitmask = getBitmaskFromString(bearerList);\n                }\n                // Update the network type bitmask to keep them sync.\n                networkTypeBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n            }\n            map.put(BEARER_BITMASK, bearerBitmask);\n\n            String mvno_type = parser.getAttributeValue(null, \"mvno_type\");\n            if (mvno_type != null) {\n                String mvno_match_data = parser.getAttributeValue(null, \"mvno_match_data\");\n                if (mvno_match_data != null) {\n                    map.put(MVNO_TYPE, mvno_type);\n                    map.put(MVNO_MATCH_DATA, mvno_match_data);\n                }\n            }\n            return map;\n        }\n\n        private void addStringAttribute(XmlPullParser parser, String att,\n                                        ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, val);\n            }\n        }\n\n        private void addIntAttribute(XmlPullParser parser, String att,\n                                     ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Integer.parseInt(val));\n            }\n        }\n\n        private void addBoolAttribute(XmlPullParser parser, String att,\n                                      ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Boolean.parseBoolean(val));\n            }\n        }\n\n        /*\n         * Loads apns from xml file into the database\n         *\n         * @param db the sqlite database to write to\n         * @param parser the xml parser\n         * @param isOverlay, if we are parsing an xml in an overlay\n         */\n        private void loadApns(SQLiteDatabase db, XmlPullParser parser, boolean isOverlay) {\n            if (parser != null) {\n                try {\n                    db.beginTransaction();\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, isOverlay);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        insertAddingDefaults(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                    db.setTransactionSuccessful();\n                } catch (XmlPullParserException e) {\n                    loge(\"Got XmlPullParserException while loading apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"Got IOException while loading apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"Got SQLException while loading apns.\" + e);\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        }\n\n        private void insertAddingDefaults(SQLiteDatabase db, ContentValues row) {\n            row = setDefaultValue(row);\n            try {\n                db.insertWithOnConflict(CARRIERS_TABLE, null, row, SQLiteDatabase.CONFLICT_ABORT);\n                if (VDBG) log(\"dbh.insertAddingDefaults: db.insert returned >= 0; insert \" +\n                        \"successful for cv \" + row);\n            } catch (SQLException e) {\n                if (VDBG) log(\"dbh.insertAddingDefaults: exception \" + e);\n                // Insertion failed which could be due to a conflict. Check if that is the case and\n                // update edited field accordingly.\n                // Search for the exact same entry and update edited field.\n                // If it is USER_EDITED/CARRIER_EDITED change it to UNEDITED,\n                // and if USER/CARRIER_DELETED change it to USER/CARRIER_DELETED_BUT_PRESENT_IN_XML.\n                Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, row);\n                if (oldRow != null) {\n                    // Update the row\n                    ContentValues mergedValues = new ContentValues();\n                    int edited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                    int old_edited = edited;\n                    if (edited != UNEDITED) {\n                        if (edited == USER_DELETED) {\n                            // USER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = USER_DELETED_BUT_PRESENT_IN_XML;\n                        } else if (edited == CARRIER_DELETED) {\n                            // CARRIER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                        }\n                        mergedValues.put(EDITED_STATUS, edited);\n                    }\n\n                    mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, row, mergedValues, false,\n                            mContext);\n\n                    if (VDBG) log(\"dbh.insertAddingDefaults: old edited = \" + old_edited\n                            + \" new edited = \" + edited);\n\n                    oldRow.close();\n                }\n            }\n        }\n    }\n\n    public static void mergeFieldsAndUpdateDb(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, ContentValues mergedValues,\n            boolean onUpgrade, Context context) {\n        if (newRow.containsKey(TYPE)) {\n            // Merge the types\n            String oldType = oldRow.getString(oldRow.getColumnIndex(TYPE));\n            String newType = newRow.getAsString(TYPE);\n\n            if (!oldType.equalsIgnoreCase(newType)) {\n                if (oldType.equals(\"\") || newType.equals(\"\")) {\n                    newRow.put(TYPE, \"\");\n                } else {\n                    String[] oldTypes = oldType.toLowerCase(Locale.ROOT).split(\",\");\n                    String[] newTypes = newType.toLowerCase(Locale.ROOT).split(\",\");\n\n                    if (VDBG) {\n                        log(\"mergeFieldsAndUpdateDb: Calling separateRowsNeeded() oldType=\" +\n                                oldType + \" old bearer=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                BEARER_BITMASK)) +  \" old networkType=\" +\n                                oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK)) +\n                                \" old profile_id=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                PROFILE_ID)) + \" newRow \" + newRow);\n                    }\n\n                    // If separate rows are needed, do not need to merge any further\n                    if (separateRowsNeeded(db, table, oldRow, newRow, context, oldTypes,\n                            newTypes)) {\n                        if (VDBG) log(\"mergeFieldsAndUpdateDb: separateRowsNeeded() returned \" +\n                                \"true\");\n                        return;\n                    }\n\n                    // Merge the 2 types\n                    ArrayList<String> mergedTypes = new ArrayList<String>();\n                    mergedTypes.addAll(Arrays.asList(oldTypes));\n                    for (String s : newTypes) {\n                        if (!mergedTypes.contains(s.trim())) {\n                            mergedTypes.add(s);\n                        }\n                    }\n                    StringBuilder mergedType = new StringBuilder();\n                    for (int i = 0; i < mergedTypes.size(); i++) {\n                        mergedType.append((i == 0 ? \"\" : \",\") + mergedTypes.get(i));\n                    }\n                    newRow.put(TYPE, mergedType.toString());\n                }\n            }\n            mergedValues.put(TYPE, newRow.getAsString(TYPE));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)) {\n            int oldBearer = oldRow.getInt(oldRow.getColumnIndex(BEARER_BITMASK));\n            int newBearer = newRow.getAsInteger(BEARER_BITMASK);\n            if (oldBearer != newBearer) {\n                if (oldBearer == 0 || newBearer == 0) {\n                    newRow.put(BEARER_BITMASK, 0);\n                } else {\n                    newRow.put(BEARER_BITMASK, (oldBearer | newBearer));\n                }\n            }\n            mergedValues.put(BEARER_BITMASK, newRow.getAsInteger(BEARER_BITMASK));\n        }\n\n        if (newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            int oldBitmask = oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK));\n            int newBitmask = newRow.getAsInteger(NETWORK_TYPE_BITMASK);\n            if (oldBitmask != newBitmask) {\n                if (oldBitmask == 0 || newBitmask == 0) {\n                    newRow.put(NETWORK_TYPE_BITMASK, 0);\n                } else {\n                    newRow.put(NETWORK_TYPE_BITMASK, (oldBitmask | newBitmask));\n                }\n            }\n            mergedValues.put(NETWORK_TYPE_BITMASK, newRow.getAsInteger(NETWORK_TYPE_BITMASK));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)\n                && newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            syncBearerBitmaskAndNetworkTypeBitmask(mergedValues);\n        }\n\n        if (!onUpgrade) {\n            // Do not overwrite a carrier or user edit with EDITED=UNEDITED\n            if (newRow.containsKey(EDITED_STATUS)) {\n                int oldEdited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                int newEdited = newRow.getAsInteger(EDITED_STATUS);\n                if (newEdited == UNEDITED && (oldEdited == CARRIER_EDITED\n                        || oldEdited == CARRIER_DELETED\n                        || oldEdited == CARRIER_DELETED_BUT_PRESENT_IN_XML\n                        || oldEdited == USER_EDITED\n                        || oldEdited == USER_DELETED\n                        || oldEdited == USER_DELETED_BUT_PRESENT_IN_XML)) {\n                    newRow.remove(EDITED_STATUS);\n                }\n            }\n            mergedValues.putAll(newRow);\n        }\n\n        if (mergedValues.size() > 0) {\n            db.update(table, mergedValues, \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")),\n                    null);\n        }\n    }\n\n    private static boolean separateRowsNeeded(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, Context context,\n            String[] oldTypes, String[] newTypes) {\n        // If this APN falls under persist_apns_for_plmn, and the\n        // only difference between old type and new type is that one has dun, and\n        // the APNs have profile_id 0 or not set, then set the profile_id to 1 for\n        // the dun APN/remove dun from type. This will ensure both oldRow and newRow exist\n        // separately in db.\n\n        boolean match = false;\n\n        // Check if APN falls under persist_apns_for_plmn\n        if (context.getResources() != null) {\n            String[] persistApnsForPlmns = context.getResources().getStringArray(\n                    R.array.persist_apns_for_plmn);\n            for (String s : persistApnsForPlmns) {\n                if (s.equalsIgnoreCase(newRow.getAsString(NUMERIC))) {\n                    match = true;\n                    break;\n                }\n            }\n        } else {\n            loge(\"separateRowsNeeded: resources=null\");\n        }\n\n        if (!match) return false;\n\n        // APN falls under persist_apns_for_plmn\n        // Check if only difference between old type and new type is that\n        // one has dun\n        ArrayList<String> oldTypesAl = new ArrayList<String>(Arrays.asList(oldTypes));\n        ArrayList<String> newTypesAl = new ArrayList<String>(Arrays.asList(newTypes));\n        ArrayList<String> listWithDun = null;\n        ArrayList<String> listWithoutDun = null;\n        boolean dunInOld = false;\n        if (oldTypesAl.size() == newTypesAl.size() + 1) {\n            listWithDun = oldTypesAl;\n            listWithoutDun = newTypesAl;\n            dunInOld = true;\n        } else if (oldTypesAl.size() + 1 == newTypesAl.size()) {\n            listWithDun = newTypesAl;\n            listWithoutDun = oldTypesAl;\n        } else {\n            return false;\n        }\n\n        if (listWithDun.contains(\"dun\") && !listWithoutDun.contains(\"dun\")) {\n            listWithoutDun.add(\"dun\");\n            if (!listWithDun.containsAll(listWithoutDun)) {\n                return false;\n            }\n\n            // Only difference between old type and new type is that\n            // one has dun\n            // Check if profile_id is 0/not set\n            if (oldRow.getInt(oldRow.getColumnIndex(PROFILE_ID)) == 0) {\n                if (dunInOld) {\n                    // Update oldRow to remove dun from its type field\n                    ContentValues updateOldRow = new ContentValues();\n                    StringBuilder sb = new StringBuilder();\n                    boolean first = true;\n                    for (String s : listWithDun) {\n                        if (!s.equalsIgnoreCase(\"dun\")) {\n                            sb.append(first ? s : \",\" + s);\n                            first = false;\n                        }\n                    }\n                    String updatedType = sb.toString();\n                    if (VDBG) {\n                        log(\"separateRowsNeeded: updating type in oldRow to \" + updatedType);\n                    }\n                    updateOldRow.put(TYPE, updatedType);\n                    db.update(table, updateOldRow,\n                            \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")), null);\n                    return true;\n                } else {\n                    if (VDBG) log(\"separateRowsNeeded: adding profile id 1 to newRow\");\n                    // Update newRow to set profile_id to 1\n                    newRow.put(PROFILE_ID, new Integer(1));\n                }\n            } else {\n                return false;\n            }\n\n            // If match was found, both oldRow and newRow need to exist\n            // separately in db. Add newRow to db.\n            try {\n                db.insertWithOnConflict(table, null, newRow, SQLiteDatabase.CONFLICT_REPLACE);\n                if (VDBG) log(\"separateRowsNeeded: added newRow with profile id 1 to db\");\n                return true;\n            } catch (SQLException e) {\n                loge(\"Exception on trying to add new row after updating profile_id\");\n            }\n        }\n\n        return false;\n    }\n\n    public static Cursor selectConflictingRow(SQLiteDatabase db, String table,\n            ContentValues row) {\n        // Conflict is possible only when numeric, mcc, mnc (fields without any default value)\n        // are set in the new row\n        if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {\n            loge(\"dbh.selectConflictingRow: called for non-conflicting row: \" + row);\n            return null;\n        }\n\n        String[] columns = { \"_id\",\n                TYPE,\n                EDITED_STATUS,\n                BEARER_BITMASK,\n                NETWORK_TYPE_BITMASK,\n                PROFILE_ID };\n        String selection = TextUtils.join(\"=? AND \", CARRIERS_UNIQUE_FIELDS) + \"=?\";\n        int i = 0;\n        String[] selectionArgs = new String[CARRIERS_UNIQUE_FIELDS.size()];\n        for (String field : CARRIERS_UNIQUE_FIELDS) {\n            if (!row.containsKey(field)) {\n                selectionArgs[i++] = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(field);\n            } else {\n                if (CARRIERS_BOOLEAN_FIELDS.contains(field)) {\n                    // for boolean fields we overwrite the strings \"true\" and \"false\" with \"1\"\n                    // and \"0\"\n                    selectionArgs[i++] = convertStringToIntString(row.getAsString(field));\n                } else {\n                    selectionArgs[i++] = row.getAsString(field);\n                }\n            }\n        }\n\n        Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);\n\n        if (c != null) {\n            if (c.getCount() == 1) {\n                if (VDBG) log(\"dbh.selectConflictingRow: \" + c.getCount() + \" conflicting \" +\n                        \"row found\");\n                if (c.moveToFirst()) {\n                    return c;\n                } else {\n                    loge(\"dbh.selectConflictingRow: moveToFirst() failed\");\n                }\n            } else {\n                loge(\"dbh.selectConflictingRow: Expected 1 but found \" + c.getCount() +\n                        \" matching rows found for cv \" + row);\n            }\n            c.close();\n        } else {\n            loge(\"dbh.selectConflictingRow: Error - c is null; no matching row found for \" +\n                    \"cv \" + row);\n        }\n\n        return null;\n    }\n\n    /**\n     * Convert \"true\" and \"false\" to \"1\" and \"0\".\n     * If the passed in string is already \"1\" or \"0\" returns the passed in string.\n     */\n    private static String convertStringToIntString(String boolString) {\n        if (\"0\".equals(boolString) || \"false\".equalsIgnoreCase(boolString)) return \"0\";\n        return \"1\";\n    }\n\n    /**\n     * Convert \"1\" and \"0\" to \"true\" and \"false\".\n     * If the passed in string is already \"true\" or \"false\" returns the passed in string.\n     */\n    private static String convertStringToBoolString(String intString) {\n        if (\"0\".equals(intString) || \"false\".equalsIgnoreCase(intString)) return \"false\";\n        return \"true\";\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing TelephonyProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase() {\n        return mOpenHelper.getReadableDatabase();\n    }\n    SQLiteDatabase getWritableDatabase() {\n        return mOpenHelper.getWritableDatabase();\n    }\n    void initDatabaseWithDatabaseHelper(SQLiteDatabase db) {\n        mOpenHelper.initDatabase(db);\n    }\n    boolean needApnDbUpdate() {\n        return mOpenHelper.apnDbUpdateNeeded();\n    }\n\n    private static boolean apnSourceServiceExists(Context context) {\n        if (s_apnSourceServiceExists != null) {\n            return s_apnSourceServiceExists;\n        }\n        try {\n            String service = context.getResources().getString(R.string.apn_source_service);\n            if (TextUtils.isEmpty(service)) {\n                s_apnSourceServiceExists = false;\n            } else {\n                s_apnSourceServiceExists = context.getPackageManager().getServiceInfo(\n                        ComponentName.unflattenFromString(service), 0)\n                        != null;\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            s_apnSourceServiceExists = false;\n        }\n        return s_apnSourceServiceExists;\n    }\n\n    private void restoreApnsWithService(int subId) {\n        Context context = getContext();\n        Resources r = context.getResources();\n        AtomicBoolean connectionBindingInvalid = new AtomicBoolean(false);\n        ServiceConnection connection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className,\n                    IBinder service) {\n                log(\"restoreApnsWithService: onServiceConnected\");\n                synchronized (mLock) {\n                    mIApnSourceService = IApnSourceService.Stub.asInterface(service);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {\n                loge(\"mIApnSourceService has disconnected unexpectedly\");\n                synchronized (mLock) {\n                    mIApnSourceService = null;\n                }\n            }\n\n            @Override\n            public void onBindingDied(ComponentName name) {\n                loge(\"The binding to the apn service connection is dead: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onNullBinding(ComponentName name) {\n                loge(\"Null binding: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n        };\n\n        Intent intent = new Intent(IApnSourceService.class.getName());\n        intent.setComponent(ComponentName.unflattenFromString(\n                r.getString(R.string.apn_source_service)));\n        log(\"binding to service to restore apns, intent=\" + intent);\n        try {\n            if (context.bindService(intent,\n                    Context.BIND_IMPORTANT | Context.BIND_AUTO_CREATE,\n                    runnable -> new Thread(runnable).start(),\n                    connection)) {\n                synchronized (mLock) {\n                    while (mIApnSourceService == null && !connectionBindingInvalid.get()) {\n                        try {\n                            mLock.wait();\n                        } catch (InterruptedException e) {\n                            loge(\"Error while waiting for service connection: \" + e);\n                        }\n                    }\n                    if (connectionBindingInvalid.get()) {\n                        loge(\"The binding is invalid.\");\n                        return;\n                    }\n                    try {\n                        ContentValues[] values = mIApnSourceService.getApns(subId);\n                        if (values != null) {\n                            // we use the unsynchronized insert because this function is called\n                            // within the syncrhonized function delete()\n                            unsynchronizedBulkInsert(CONTENT_URI, values);\n                            log(\"restoreApnsWithService: restored\");\n                        }\n                    } catch (RemoteException e) {\n                        loge(\"Error applying apns from service: \" + e);\n                    }\n                }\n            } else {\n                loge(\"unable to bind to service from intent=\" + intent);\n            }\n        } catch (SecurityException e) {\n            loge(\"Error applying apns from service: \" + e);\n        } finally {\n            if (connection != null) {\n                context.unbindService(connection);\n            }\n            synchronized (mLock) {\n                mIApnSourceService = null;\n            }\n        }\n    }\n\n\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new DatabaseHelper(getContext());\n        boolean isNewBuild = false;\n        String newBuildId = SystemProperties.get(\"ro.build.id\", null);\n        SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE,\n                Context.MODE_PRIVATE);\n        if (!TextUtils.isEmpty(newBuildId)) {\n            // Check if build id has changed\n            String oldBuildId = sp.getString(RO_BUILD_ID, \"\");\n            if (!newBuildId.equals(oldBuildId)) {\n                localLog(\"onCreate: build id changed from \" + oldBuildId + \" to \" + newBuildId);\n                isNewBuild = true;\n            } else {\n                if (VDBG) log(\"onCreate: build id did not change: \" + oldBuildId);\n            }\n        } else {\n            if (VDBG) log(\"onCreate: newBuildId is empty\");\n        }\n\n        if (isNewBuild) {\n            if (!apnSourceServiceExists(getContext())) {\n                // Update APN DB\n                updateApnDb();\n            }\n\n            // Add all APN related shared prefs to local log for dumpsys\n            if (DBG) addAllApnSharedPrefToLocalLog();\n        }\n\n        // Write build id to SharedPreferences after APNs have been updated above by updateApnDb()\n        if (!TextUtils.isEmpty(newBuildId)) {\n            if (isNewBuild) log(\"onCreate: updating build id to \" + newBuildId);\n            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();\n        }\n\n        SharedPreferences spEnforcedFile = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        mManagedApnEnforced = spEnforcedFile.getBoolean(ENFORCED_KEY, false);\n\n        if (VDBG) log(\"onCreate:- ret true\");\n\n        return true;\n    }\n\n    private void addAllApnSharedPrefToLocalLog() {\n        localLog(\"addAllApnSharedPrefToLocalLog\");\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefApnId.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n\n        SharedPreferences spFullApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefFullApn = spFullApn.getAll();\n        for (String key : allPrefFullApn.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefFullApn.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n    }\n\n    private void localLog(String logMsg) {\n        Log.d(TAG, logMsg);\n        mLocalLog.log(logMsg);\n    }\n\n    private synchronized boolean isManagedApnEnforced() {\n        return mManagedApnEnforced;\n    }\n\n    private void setManagedApnEnforced(boolean enforced) {\n        SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putBoolean(ENFORCED_KEY, enforced);\n        editor.apply();\n        synchronized (this) {\n            mManagedApnEnforced = enforced;\n        }\n    }\n\n    private void setPreferredApnId(Long id, int subId, boolean saveApn) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putLong(COLUMN_APN_ID + subId, id != null ? id : INVALID_APN_ID);\n        localLog(\"setPreferredApnId: \" + COLUMN_APN_ID + subId + \":\"\n                + (id != null ? id : INVALID_APN_ID));\n        // This is for debug purposes. It indicates if this APN was set by DcTracker or user (true)\n        // or if this was restored from APN saved in PREF_FILE_FULL_APN (false).\n        editor.putBoolean(EXPLICIT_SET_CALLED + subId, saveApn);\n        localLog(\"setPreferredApnId: \" + EXPLICIT_SET_CALLED + subId + \":\" + saveApn);\n        editor.apply();\n        if (id == null || id.longValue() == INVALID_APN_ID) {\n            deletePreferredApn(subId);\n        } else {\n            // If id is not invalid, and saveApn is true, save the actual APN in PREF_FILE_FULL_APN\n            // too.\n            if (saveApn) {\n                setPreferredApn(id, subId);\n            }\n        }\n    }\n\n    private long getPreferredApnId(int subId, boolean checkApnSp) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        long apnId = sp.getLong(COLUMN_APN_ID + subId, INVALID_APN_ID);\n        if (apnId == INVALID_APN_ID && checkApnSp) {\n            apnId = getPreferredApnIdFromApn(subId);\n            if (apnId != INVALID_APN_ID) {\n                setPreferredApnId(apnId, subId, false);\n            }\n        }\n        return apnId;\n    }\n\n    private int getPreferredApnSetId(int subId) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        try {\n            return Integer.parseInt(sp.getString(APN_SET_ID + subId, null));\n        } catch (NumberFormatException e) {\n            return NO_APN_SET_ID;\n        }\n    }\n\n    private void deletePreferredApnId(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.clear();\n        editor.apply();\n    }\n\n    private void setPreferredApn(Long id, int subId) {\n        localLog(\"setPreferredApn: _id \" + id + \" subId \" + subId);\n        SQLiteDatabase db = getWritableDatabase();\n        // query all unique fields from id\n        String[] proj = CARRIERS_UNIQUE_FIELDS.toArray(new String[CARRIERS_UNIQUE_FIELDS.size()]);\n\n        Cursor c = db.query(CARRIERS_TABLE, proj, \"_id=\" + id, null, null, null, null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                        Context.MODE_PRIVATE);\n                SharedPreferences.Editor editor = sp.edit();\n                // store values of all unique fields to SP\n                for (String key : CARRIERS_UNIQUE_FIELDS) {\n                    editor.putString(key + subId, c.getString(c.getColumnIndex(key)));\n                    localLog(\"setPreferredApn: \" + key + subId + \":\"\n                            + c.getString(c.getColumnIndex(key)));\n                }\n                // also store the version number\n                editor.putString(DB_VERSION_KEY + subId, \"\" + DATABASE_VERSION);\n                localLog(\"setPreferredApn: \" + DB_VERSION_KEY + subId + \":\" + DATABASE_VERSION);\n                editor.apply();\n            } else {\n                log(\"setPreferredApn: # matching APNs found \" + c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"setPreferredApn: No matching APN found\");\n        }\n    }\n\n    private long getPreferredApnIdFromApn(int subId) {\n        log(\"getPreferredApnIdFromApn: for subId \" + subId);\n        SQLiteDatabase db = getReadableDatabase();\n\n        List<String> whereList = new ArrayList<>();\n        List<String> whereArgsList = new ArrayList<>();\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        for (String key : CARRIERS_UNIQUE_FIELDS) {\n            String value = sp.getString(key + subId, null);\n            if (value == null) {\n                continue;\n            } else {\n                whereList.add(key);\n                whereArgsList.add(value);\n            }\n        }\n        if (whereList.size() == 0) return INVALID_APN_ID;\n\n        String where = TextUtils.join(\"=? and \", whereList) + \"=?\";\n        String[] whereArgs = new String[whereArgsList.size()];\n        whereArgs = whereArgsList.toArray(whereArgs);\n\n        long apnId = INVALID_APN_ID;\n        Cursor c = db.query(CARRIERS_TABLE, new String[]{\"_id\"}, where, whereArgs, null, null,\n                null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                apnId = c.getInt(c.getColumnIndex(\"_id\"));\n            } else {\n                log(\"getPreferredApnIdFromApn: returning INVALID. # matching APNs found \" +\n                        c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"getPreferredApnIdFromApn: returning INVALID. No matching APN found\");\n        }\n        return apnId;\n    }\n\n    private void deletePreferredApn(int subId) {\n        log(\"deletePreferredApn: for subId \" + subId);\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        if (sp.contains(DB_VERSION_KEY + subId)) {\n            log(\"deletePreferredApn: apn is stored. Deleting it now for subId \" + subId);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.remove(DB_VERSION_KEY + subId);\n            for (String key : CARRIERS_UNIQUE_FIELDS) {\n                editor.remove(key + subId);\n            }\n            editor.apply();\n        }\n    }\n\n    boolean isCallingFromSystemOrPhoneUid() {\n        int callingUid = mInjector.binderGetCallingUid();\n        return callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID\n                // Allow ROOT for testing. ROOT can access underlying DB files anyways.\n                || callingUid == Process.ROOT_UID;\n    }\n\n    void ensureCallingFromSystemOrPhoneUid(String message) {\n        if (!isCallingFromSystemOrPhoneUid()) {\n            throw new SecurityException(message);\n        }\n    }\n\n    @Override\n    public synchronized Bundle call(String method, @Nullable String args, @Nullable Bundle bundle) {\n        if (SubscriptionManager.GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return retrieveSimSpecificSettings();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else if (SubscriptionManager.RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MODIFY_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                restoreSimSpecificSettings(bundle, args);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else {\n            loge(\"method is not recognized\");\n        }\n\n        return null;\n    }\n\n    /**\n     * See {@link SubscriptionController#GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME} for details\n     */\n    private Bundle retrieveSimSpecificSettings() {\n        Bundle resultBundle = new Bundle();\n        resultBundle.putByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA,\n                getSimSpecificDataToBackUp());\n\n        return resultBundle;\n    }\n\n    /**\n     * Attempts to restore the backed up sim-specific configs to device. End result is SimInfoDB is\n     * modified to match any backed up configs for the appropriate inserted sims.\n     *\n     * @param bundle containing the data to be restored. If {@code null}, then backed up\n     * data should already be in internal storage and will be retrieved from there.\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void restoreSimSpecificSettings(@Nullable Bundle bundle, @Nullable String iccId) {\n        int restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_UNDEFINED_USE_CASE;\n        if (bundle != null) {\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SUW;\n            if (!writeSimSettingsToInternalStorage(\n                    bundle.getByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA))) {\n                return;\n            }\n        } else if (iccId != null){\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED;\n        }\n        mergeBackedUpDataToSimInfoDb(restoreCase, iccId);\n    }\n\n    @VisibleForTesting\n    boolean writeSimSettingsToInternalStorage(byte[] data) {\n        AtomicFile atomicFile = new AtomicFile(\n                new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE));\n        FileOutputStream fos = null;\n        try {\n            fos = atomicFile.startWrite();\n            fos.write(data);\n            atomicFile.finishWrite(fos);\n        } catch (IOException e) {\n            if (fos != null) {\n                atomicFile.failWrite(fos);\n            }\n            loge(\"Not able to create internal file with per-sim configs. Failed with error \"\n                    + e);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Attempt to match any SimInfoDB entries to what is in the internal backup data file and\n     * update DB entry with the adequate backed up data.\n     *\n     * @param restoreCase one of the SimSpecificSettingsRestoreMatchingCriteria values defined in\n     * frameworks/proto_logging/stats/enums/telephony/enums.proto\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void mergeBackedUpDataToSimInfoDb(int restoreCase, @Nullable String iccId) {\n        // Get data stored in internal file\n        File file = new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE);\n        if (!file.exists()) {\n            loge(\"internal sim-specific settings backup data file does not exist. \"\n                + \"Aborting restore\");\n            return;\n        }\n\n        AtomicFile atomicFile = new AtomicFile(file);\n        PersistableBundle bundle = null;\n        try (FileInputStream fis = atomicFile.openRead()) {\n            bundle = PersistableBundle.readFromStream(fis);\n        } catch (IOException e) {\n            loge(\"Failed to convert backed up per-sim configs to bundle. Stopping restore. \"\n                + \"Failed with error \" + e);\n            return;\n        }\n\n        String selection = null;\n        String[] selectionArgs = null;\n        if (iccId != null) {\n            selection = Telephony.SimInfo.COLUMN_ICC_ID + \"=?\";\n            selectionArgs = new String[]{iccId};\n        }\n        try (Cursor cursor = query(\n                SubscriptionManager.CONTENT_URI,\n                new String[]{\n                        Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_ICC_ID,\n                        Telephony.SimInfo.COLUMN_NUMBER,\n                        Telephony.SimInfo.COLUMN_CARRIER_ID,\n                        Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE},\n                selection,\n                selectionArgs,\n                ORDER_BY_SUB_ID)) {\n            findAndRestoreAllMatches(bundle.deepCopy(), cursor, restoreCase);\n        }\n    }\n\n    // backedUpDataBundle must to be mutable\n    private void findAndRestoreAllMatches(PersistableBundle backedUpDataBundle, Cursor cursor,\n            int restoreCase) {\n        int[] previouslyRestoredSubIdsArray =\n                backedUpDataBundle.getIntArray(KEY_PREVIOUSLY_RESTORED_SUB_IDS);\n        List<Integer> previouslyRestoredSubIdsList = previouslyRestoredSubIdsArray != null\n                ? Arrays.stream(previouslyRestoredSubIdsArray).boxed().collect(Collectors.toList())\n                : new ArrayList<>();\n        List<Integer> newlyRestoredSubIds = new ArrayList<>();\n        int backupDataFormatVersion = backedUpDataBundle\n                .getInt(KEY_BACKUP_DATA_FORMAT_VERSION, -1);\n\n        Resources r = getContext().getResources();\n        List<String> wfcRestoreBlockedCountries = Arrays.asList(r.getStringArray(\n                    R.array.wfc_restore_blocked_countries));\n\n        while (cursor != null && cursor.moveToNext()) {\n            // Get all the possible matching criteria.\n            int subIdColumnIndex = cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID);\n            int currSubIdFromDb = cursor.getInt(subIdColumnIndex);\n\n            if (previouslyRestoredSubIdsList.contains(currSubIdFromDb)) {\n                // Abort restore for any sims that were previously restored.\n                continue;\n            }\n\n            int iccIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            String currIccIdFromDb = cursor.getString(iccIdColumnIndex);\n\n            int phoneNumberColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_NUMBER);\n            String currPhoneNumberFromDb = cursor.getString(phoneNumberColumnIndex);\n\n            int carrierIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_CARRIER_ID);\n            int currCarrierIdFromDb = cursor.getInt(carrierIdColumnIndex);\n\n            int isoCountryCodeColumnIndex= cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE);\n            String isoCountryCodeFromDb = cursor.getString(isoCountryCodeColumnIndex);\n\n\n            // Find the best match from backed up data.\n            SimRestoreMatch bestRestoreMatch = null;\n            for (int rowNum = 0; true; rowNum++) {\n                PersistableBundle currRow = backedUpDataBundle.getPersistableBundle(\n                        KEY_SIMINFO_DB_ROW_PREFIX + rowNum);\n                if (currRow == null) {\n                    break;\n                }\n\n                SimRestoreMatch currSimRestoreMatch = new SimRestoreMatch(\n                        currIccIdFromDb, currCarrierIdFromDb, currPhoneNumberFromDb,\n                        isoCountryCodeFromDb, wfcRestoreBlockedCountries, currRow,\n                        backupDataFormatVersion);\n\n                if (currSimRestoreMatch == null) {\n                    continue;\n                }\n\n                /*\n                 * The three following match cases are ordered by descending priority:\n                 *   - Match by iccId: If iccId of backup data matches iccId of any inserted sims,\n                 *       we confidently restore all configs.\n                 *   - Match phone number and carrierId: If both of these values match, we\n                 *       confidently restore all configs.\n                 *   - Match only carrierId: If only carrierId of backup data matches an inserted\n                 *       sim, we only restore non-sensitive configs.\n                 *\n                 * Having a matchScore value for each match allows us to control these priorities.\n                 */\n                if (bestRestoreMatch == null || (currSimRestoreMatch.getMatchScore()\n                        >= bestRestoreMatch.getMatchScore()\n                        && currSimRestoreMatch.getContentValues() != null)) {\n                    bestRestoreMatch = currSimRestoreMatch;\n                }\n            }\n\n            if (bestRestoreMatch != null) {\n                ContentValues newContentValues = bestRestoreMatch.getContentValues();\n                if (bestRestoreMatch.getMatchScore() != 0 && newContentValues != null) {\n                    if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SUW) {\n                        update(SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    } else if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED) {\n                        Uri simInsertedRestoreUri = Uri.withAppendedPath(\n                                SubscriptionManager.SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI,\n                                SIM_INSERTED_RESTORE_URI_SUFFIX);\n                        update(simInsertedRestoreUri,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    }\n                    log(\"Restore of inserterd SIM's sim-specific settings has been successfully \"\n                            + \"completed.\");\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_SUCCESS,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                    newlyRestoredSubIds.add(currSubIdFromDb);\n                } else {\n                    /* If this block was reached because ContentValues was null, that means the\n                    database schema was newer during backup than during restore. We consider this\n                    a no-match to avoid updating columns that don't exist */\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_NONE_MATCH,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                }\n            } else {\n                log(\"No matching SIM in backup data. SIM-specific settings not restored.\");\n                TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                        TelephonyProtoEnums.SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP,\n                        restoreCase, TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE);\n            }\n        }\n\n        // Update the internal file with subIds that we just restored.\n        previouslyRestoredSubIdsList.addAll(newlyRestoredSubIds);\n        backedUpDataBundle.putIntArray(\n                KEY_PREVIOUSLY_RESTORED_SUB_IDS,\n                previouslyRestoredSubIdsList.stream().mapToInt(i -> i).toArray());\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            backedUpDataBundle.writeToStream(outputStream);\n            writeSimSettingsToInternalStorage(outputStream.toByteArray());\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Not storing which subIds were \"\n                    + \"restored\");\n        }\n    }\n\n    private static class SimRestoreMatch {\n\n        private Set<Integer> matches = new ArraySet<>();\n        private int subId;\n        private ContentValues contentValues;\n        private int matchingCriteria;\n        private int matchScore;\n\n        private static final int ICCID_MATCH = 1;\n        private static final int PHONE_NUMBER_MATCH = 2;\n        private static final int CARRIER_ID_MATCH = 3;\n\n        public SimRestoreMatch(String iccIdFromDb, int carrierIdFromDb,\n                String phoneNumberFromDb, String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries,\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion) {\n            subId = backedUpSimInfoEntry.getInt(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                DEFAULT_INT_COLUMN_VALUE);\n            String iccIdFromBackup = backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_ICC_ID,\n                  \"\");\n            String phoneNumberFromBackup = backedUpSimInfoEntry.getString(\n                  Telephony.SimInfo.COLUMN_NUMBER, \"\");\n            int carrierIdFromBackup = backedUpSimInfoEntry.getInt(\n                  Telephony.SimInfo.COLUMN_CARRIER_ID,\n                  TelephonyManager.UNKNOWN_CARRIER_ID);\n\n\n            // find all matching fields\n            if (iccIdFromDb != null && iccIdFromDb.equals(iccIdFromBackup)\n                    && !iccIdFromBackup.isEmpty()) {\n                matches.add(ICCID_MATCH);\n            }\n            if (carrierIdFromDb == carrierIdFromBackup\n                    && carrierIdFromBackup != TelephonyManager.UNKNOWN_CARRIER_ID) {\n                matches.add(CARRIER_ID_MATCH);\n            }\n            if (phoneNumberFromDb != null && phoneNumberFromDb.equals(phoneNumberFromBackup)\n                    && !phoneNumberFromBackup.isEmpty()) {\n                matches.add(PHONE_NUMBER_MATCH);\n            }\n\n            contentValues = convertBackedUpDataToContentValues(\n                    backedUpSimInfoEntry, backupDataFormatVersion, isoCountryCodeFromDb,\n                    wfcRestoreBlockedCountries);\n            matchScore = calculateMatchScore();\n            matchingCriteria = calculateMatchingCriteria();\n        }\n\n        public int getSubId() {\n            return subId;\n        }\n\n        public ContentValues getContentValues() {\n            return contentValues;\n        }\n\n        public int getMatchScore() {\n            return matchScore;\n        }\n\n        private int calculateMatchScore() {\n            int score = 0;\n\n            if (matches.contains(ICCID_MATCH)) {\n                score += 100;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    score += 10;\n                } else {\n                    score += 1;\n                }\n            }\n\n            return score;\n        }\n\n        public int getMatchingCriteriaForLogging() {\n            return matchingCriteria;\n        }\n\n        private int calculateMatchingCriteria() {\n            if (matches.contains(ICCID_MATCH)) {\n                return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_ICCID;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    return TelephonyProtoEnums\n                        .SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER;\n                } else {\n                    return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY;\n                }\n            }\n            return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE;\n        }\n\n        private ContentValues convertBackedUpDataToContentValues(\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion,\n                String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries) {\n            if (DATABASE_VERSION != 62 << 16) {\n                throw new AssertionError(\"The database schema has been updated which might make \"\n                    + \"the format of #BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE outdated. Make sure to \"\n                    + \"1) review whether any of the columns in #SIM_INFO_COLUMNS_TO_BACKUP have \"\n                    + \"been migrated or deleted, 2) add the new column name into one of those \"\n                    + \"maps, 3) add migration code in this method as necessary, and 4) update the \"\n                    + \"version check in this if statement.\");\n            }\n            ContentValues contentValues = new ContentValues();\n            // Don't restore anything if restoring from a newer version of the current database.\n            if (backupDataFormatVersion > DATABASE_VERSION) {\n                return null;\n            }\n\n            /* Any migration logic should be placed under this comment block.\n             * ex:\n             *   if (backupDataFormatVersion >= 48 << 19) {\n             *     contentValues.put(NEW_COLUMN_NAME_2,\n             *         backedUpSimInfoEntry.getInt( OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else if (backupDataFormatVersion >= 48 << 17) {\n             *     contentValues.put(NEW_COLUMN_NAME_1,\n             *         backedUpSimInfoEntry.getInt(OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else {\n             *     // The values from the first format of backup ever available.\n             *     contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *         backedUpSimInfoEntry.getInt(\n             *             Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *             DEFAULT_INT_COLUMN_VALUE));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n             *         backedUpSimInfoEntry.getString(\n             *              Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, \"\"));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               \"\"));\n             *     ...\n             *   }\n             *\n             * Also make sure to add necessary removal of sensitive settings in\n             * polishContentValues(ContentValues contentValues).\n             */\n            if (backupDataFormatVersion >= 60 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 57 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                                SubscriptionManager.USAGE_SETTING_UNKNOWN));\n            }\n            if (backupDataFormatVersion >= 52 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 51 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 50 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            if (isoCountryCodeFromDb != null\n                    && !wfcRestoreBlockedCountries\n                            .contains(isoCountryCodeFromDb.toLowerCase(Locale.ROOT))) {\n                // Don't restore COLUMN_WFC_IMS_ENABLED if the sim is from one of the countries that\n                // requires WFC entitlement.\n                contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n\n            return polishContentValues(contentValues);\n        }\n\n        private ContentValues polishContentValues(ContentValues contentValues) {\n            /* Remove any values that weren't found in the backup file. These were set to defaults\n            in #convertBackedUpDataToContentValues(). */\n            for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n                String columnName = column.getKey();\n\n                if (!contentValues.containsKey(columnName)) {\n                    continue;\n                }\n\n                int columnType = column.getValue();\n                if (columnType == Cursor.FIELD_TYPE_INTEGER\n                        && DEFAULT_INT_COLUMN_VALUE == contentValues.getAsInteger(columnName)) {\n                    contentValues.remove(columnName);\n                } else if (columnType == Cursor.FIELD_TYPE_STRING && contentValues\n                        .getAsString(columnName).equals(DEFAULT_STRING_COLUMN_VALUE)) {\n                    contentValues.remove(columnName);\n                }\n            }\n\n            if (matches.contains(ICCID_MATCH)) {\n                return contentValues;\n            } else if (matches.contains(CARRIER_ID_MATCH)) {\n                if (!matches.contains(PHONE_NUMBER_MATCH)) {\n                    // Low confidence match should not restore sensitive configs.\n                    if (contentValues.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        contentValues.remove(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED);\n                    }\n                }\n                return contentValues;\n            }\n            return null;\n        }\n\n    }\n\n    /**\n     * Retrieves data from all columns in SimInfoDB of backup/restore interest.\n     *\n     * @return data of interest from SimInfoDB as a byte array.\n     */\n    private byte[] getSimSpecificDataToBackUp() {\n        String[] projection = SIM_INFO_COLUMNS_TO_BACKUP.keySet()\n                .toArray(new String[SIM_INFO_COLUMNS_TO_BACKUP.size()]);\n\n        try (Cursor cursor = query(SubscriptionManager.CONTENT_URI, projection, null, null, null);\n                ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            PersistableBundle topLevelBundle = new PersistableBundle();\n            topLevelBundle.putInt(KEY_BACKUP_DATA_FORMAT_VERSION, DATABASE_VERSION);\n            for (int rowNum = 0; cursor != null && cursor.moveToNext(); rowNum++) {\n                PersistableBundle rowBundle = convertSimInfoDbEntryToPersistableBundle(cursor);\n                topLevelBundle.putPersistableBundle(KEY_SIMINFO_DB_ROW_PREFIX + rowNum, rowBundle);\n            }\n            topLevelBundle.writeToStream(outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Returning empty byte array\");\n            return new byte[0];\n        }\n    }\n\n    private static PersistableBundle convertSimInfoDbEntryToPersistableBundle(Cursor cursor) {\n        PersistableBundle bundle = new PersistableBundle();\n        for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n            String columnName = column.getKey();\n            int columnType = column.getValue();\n            int columnIndex = cursor.getColumnIndex(columnName);\n            if (columnType == Cursor.FIELD_TYPE_INTEGER) {\n                bundle.putInt(columnName, cursor.getInt(columnIndex));\n            } else if (columnType == Cursor.FIELD_TYPE_STRING) {\n                bundle.putString(columnName, cursor.getString(columnIndex));\n            } else {\n                throw new AssertionError(\"SimInfoDB column to be backed up is not recognized. Make \"\n                    + \"sure to properly add the desired colum name and value type to \"\n                    + \"SIM_INFO_COLUMNS_TO_BACKUP.\");\n            }\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,  String[] selectionArgs,\n            String sort) {\n        if (VDBG) log(\"query: url=\" + url + \", projectionIn=\" + Arrays.toString(projectionIn)\n                + \", selection=\" + selection + \"selectionArgs=\" + Arrays.toString(selectionArgs)\n                + \", sort=\" + sort);\n        int match = s_urlMatcher.match(url);\n        checkPermissionCompat(match, projectionIn);\n\n        return queryInternal(url, projectionIn, selection, selectionArgs, sort);\n    }\n\n    private synchronized Cursor queryInternal(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String subIdString;\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true); // a little protection from injection attacks\n        qb.setTables(CARRIERS_TABLE);\n\n        List<String> constraints = new ArrayList<String>();\n\n        int match = s_urlMatcher.match(url);\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID: {\n                // The behaves exactly same as URL_SIM_APN_LIST_ID.\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            case URL_TELEPHONY: {\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_CURRENT: {\n                constraints.add(\"current IS NOT NULL\");\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                // do not ignore the selection since MMS may use it.\n                //selection = null;\n                break;\n            }\n\n            case URL_ID: {\n                constraints.add(\"_id = \" + url.getPathSegments().get(1));\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE: {\n                constraints.add(\"_id = \" + getPreferredApnId(subId, true));\n                break;\n            }\n\n            case URL_PREFERAPNSET_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            // intentional fall through from above case\n            case URL_PREFERAPNSET: {\n                final int set = getPreferredApnSetId(subId);\n                if (set == NO_APN_SET_ID) {\n                    return null;\n                }\n                constraints.add(APN_SET_ID + \"=\" + set);\n                qb.appendWhere(TextUtils.join(\" AND \", constraints));\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_DPC_ID: {\n                constraints.add(\"_id = \" + url.getLastPathSegment());\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_FILTERED_ID:\n            case URL_FILTERED_USING_SUBID: {\n                String idString = url.getLastPathSegment();\n                if (match == URL_FILTERED_ID) {\n                    constraints.add(\"_id = \" + idString);\n                } else {\n                    try {\n                        subId = Integer.parseInt(idString);\n                        // TODO b/74213956 turn this back on once insertion includes correct sub id\n                        // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n                    } catch (NumberFormatException e) {\n                        loge(\"NumberFormatException\" + e);\n                        return null;\n                    }\n                }\n            }\n            //intentional fall through from above case\n            case URL_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    constraints.add(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    constraints.add(IS_NOT_OWNED_BY_DPC);\n                }\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                MatrixCursor cursor = new MatrixCursor(new String[]{ENFORCED_KEY});\n                cursor.addRow(new Object[]{isManagedApnEnforced() ? 1 : 0});\n                return cursor;\n            }\n\n            case URL_SIMINFO: {\n                qb.setTables(SIMINFO_TABLE);\n                break;\n            }\n            case URL_SIM_APN_LIST_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST: {\n                qb.appendWhere(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_SIM_APN_LIST_FILTERED_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    qb.appendWhereStandalone(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                }\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            default: {\n                return null;\n            }\n        }\n\n        // appendWhere doesn't add ANDs so we do it ourselves\n        if (constraints.size() > 0) {\n            qb.appendWhere(TextUtils.join(\" AND \", constraints));\n        }\n\n        SQLiteDatabase db = getReadableDatabase();\n        Cursor ret = null;\n        try {\n            // Exclude entries marked deleted\n            if (CARRIERS_TABLE.equals(qb.getTables())) {\n                if (TextUtils.isEmpty(selection)) {\n                    selection = \"\";\n                } else {\n                    selection += \" and \";\n                }\n                selection += IS_NOT_USER_DELETED + \" and \" +\n                        IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                        IS_NOT_CARRIER_DELETED + \" and \" +\n                        IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                if (VDBG) log(\"query: selection modified to \" + selection);\n            }\n            ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);\n        } catch (SQLException e) {\n            loge(\"got exception when querying: \" + e);\n        }\n        if (ret != null)\n            ret.setNotificationUri(getContext().getContentResolver(), url);\n        return ret;\n    }\n\n    /**\n     * This method syncs PREF_FILE_FULL_APN with the db based on the current preferred apn ids.\n     */\n    private void updatePreferredApns() {\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            if (key.startsWith(COLUMN_APN_ID)) {\n                int subId;\n                try {\n                    subId = Integer.parseInt(key.substring(COLUMN_APN_ID.length()));\n                } catch (NumberFormatException e) {\n                    loge(\"updatePreferredApns: NumberFormatException for key=\" + key);\n                    continue;\n                }\n                long preferredApnId = getPreferredApnId(subId, false);\n                if (preferredApnId != INVALID_APN_ID) {\n                    setPreferredApn(preferredApnId, subId);\n                }\n            }\n        }\n    }\n\n    /**\n     * To find the current sim APN. Query APN based on {MCC, MNC, MVNO} and {Carrier_ID}.\n     *\n     * There has three steps:\n     * 1. Query the APN based on { MCC, MNC, MVNO } and if has results jump to step 3, else jump to\n     *    step 2.\n     * 2. Fallback to query the parent APN that query based on { MCC, MNC }.\n     * 3. Append the result with the APN that query based on { Carrier_ID }\n     */\n    private Cursor getSubscriptionMatchingAPNList(SQLiteQueryBuilder qb, String[] projectionIn,\n            String selection, String[] selectionArgs, String sort, int subId) {\n        Cursor ret;\n        Context context = getContext();\n        SubscriptionManager subscriptionManager = (SubscriptionManager) context\n                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);\n        if (!subscriptionManager.isActiveSubscriptionId(subId)) {\n            return null;\n        }\n\n        final TelephonyManager tm = ((TelephonyManager) context\n                .getSystemService(Context.TELEPHONY_SERVICE))\n                .createForSubscriptionId(subId);\n        SQLiteDatabase db = getReadableDatabase();\n        String mccmnc = tm.getSimOperator();\n        int carrierId = tm.getSimSpecificCarrierId();\n\n        qb.appendWhereStandalone(IS_NOT_USER_DELETED + \" and \" +\n                IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                IS_NOT_CARRIER_DELETED + \" and \" +\n                IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML);\n\n        // For query db one time, append all conditions in one selection and separate results after\n        // the query is completed. IMSI has special match rule, so just query the MCC / MNC and\n        // filter the MVNO by ourselves\n        qb.appendWhereStandalone(NUMERIC + \" = '\" + mccmnc + \"' OR \" +\n                CARRIER_ID + \" = '\" + carrierId + \"'\");\n\n        ret = qb.query(db, null, selection, selectionArgs, null, null, sort);\n        if (ret == null) {\n            loge(\"subId:\" + subId + \" query current APN but cursor is null.\");\n            return null;\n        }\n\n        if (DBG) log(\"subId:\" + subId + \" mccmnc=\" + mccmnc + \" carrierId=\" + carrierId +\n                \", match current APN size:  \" + ret.getCount());\n\n        String[] columnNames = projectionIn != null ? projectionIn : ret.getColumnNames();\n        MatrixCursor currentCursor = new MatrixCursor(columnNames);\n        MatrixCursor parentCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdNonMatchingMNOCursor = new MatrixCursor(columnNames);\n\n        int numericIndex = ret.getColumnIndex(NUMERIC);\n        int mvnoIndex = ret.getColumnIndex(MVNO_TYPE);\n        int mvnoDataIndex = ret.getColumnIndex(MVNO_MATCH_DATA);\n        int carrierIdIndex = ret.getColumnIndex(CARRIER_ID);\n\n        // Separate the result into MatrixCursor\n        while (ret.moveToNext()) {\n            List<String> data = new ArrayList<>();\n            for (String column : columnNames) {\n                data.add(ret.getString(ret.getColumnIndex(column)));\n            }\n\n            boolean isCurrentSimOperator = false;\n            if (!TextUtils.isEmpty(ret.getString(numericIndex))) {\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    isCurrentSimOperator = tm.matchesCurrentSimOperator(\n                            ret.getString(numericIndex),\n                            getMvnoTypeIntFromString(ret.getString(mvnoIndex)),\n                            ret.getString(mvnoDataIndex));\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n\n            boolean isMVNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && isCurrentSimOperator;\n            boolean isMNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && ret.getString(numericIndex).equals(mccmnc)\n                    && TextUtils.isEmpty(ret.getString(mvnoIndex));\n            boolean isCarrierIdAPN = !TextUtils.isEmpty(ret.getString(carrierIdIndex))\n                    && ret.getString(carrierIdIndex).equals(String.valueOf(carrierId))\n                    && carrierId != TelephonyManager.UNKNOWN_CARRIER_ID;\n\n            if (isMVNOAPN) {\n                // 1. The APN that query based on legacy SIM MCC/MCC and MVNO\n                currentCursor.addRow(data);\n            } else if (isMNOAPN) {\n                // 2. The APN that query based on SIM MCC/MNC\n                parentCursor.addRow(data);\n            } else if (isCarrierIdAPN) {\n                // The APN that query based on carrier Id (not include the MVNO or MNO APN)\n                if (TextUtils.isEmpty(ret.getString(numericIndex))) {\n                    carrierIdCursor.addRow(data);\n                } else {\n                    carrierIdNonMatchingMNOCursor.addRow(data);\n                }\n            }\n        }\n        ret.close();\n\n        MatrixCursor result;\n        if (currentCursor.getCount() > 0) {\n            if (DBG) log(\"match MVNO APN: \" + currentCursor.getCount());\n            result = currentCursor;\n        } else if (parentCursor.getCount() > 0) {\n            if (DBG) log(\"match MNO APN: \" + parentCursor.getCount());\n            result = parentCursor;\n        } else {\n            if (DBG) {\n                log(\"No MVNO, MNO and no MCC/MNC match, but we have match/matches with the \" +\n                        \"same carrier id, count: \" + carrierIdNonMatchingMNOCursor.getCount());\n            }\n            result = carrierIdNonMatchingMNOCursor;\n        }\n\n        if (DBG) log(\"match carrier id APN: \" + carrierIdCursor.getCount());\n        appendCursorData(result, carrierIdCursor);\n        return result;\n    }\n\n    private static void appendCursorData(@NonNull MatrixCursor from, @NonNull MatrixCursor to) {\n        while (to.moveToNext()) {\n            List<Object> data = new ArrayList<>();\n            for (String column : to.getColumnNames()) {\n                int index = to.getColumnIndex(column);\n                switch (to.getType(index)) {\n                    case Cursor.FIELD_TYPE_INTEGER:\n                        data.add(to.getInt(index));\n                        break;\n                    case Cursor.FIELD_TYPE_FLOAT:\n                        data.add(to.getFloat(index));\n                        break;\n                    case Cursor.FIELD_TYPE_BLOB:\n                        data.add(to.getBlob(index));\n                        break;\n                    case Cursor.FIELD_TYPE_STRING:\n                    case Cursor.FIELD_TYPE_NULL:\n                        data.add(to.getString(index));\n                        break;\n                }\n            }\n            from.addRow(data);\n        }\n    }\n\n    @Override\n    public String getType(Uri url)\n    {\n        switch (s_urlMatcher.match(url)) {\n        case URL_TELEPHONY:\n        case URL_TELEPHONY_USING_SUBID:\n            return \"vnd.android.cursor.dir/telephony-carrier\";\n\n        case URL_ID:\n        case URL_FILTERED_ID:\n        case URL_FILTERED_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        case URL_PREFERAPN_USING_SUBID:\n        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n        case URL_PREFERAPN:\n        case URL_PREFERAPN_NO_UPDATE:\n        case URL_PREFERAPNSET:\n        case URL_PREFERAPNSET_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        default:\n            throw new IllegalArgumentException(\"Unknown URL \" + url);\n        }\n    }\n\n    /**\n     * Insert an array of ContentValues and call notifyChange at the end.\n     */\n    @Override\n    public synchronized int bulkInsert(Uri url, ContentValues[] values) {\n        return unsynchronizedBulkInsert(url, values);\n    }\n\n    /**\n     * Do a bulk insert while inside a synchronized function. This is typically not safe and should\n     * only be done when you are sure there will be no conflict.\n     */\n    private int unsynchronizedBulkInsert(Uri url, ContentValues[] values) {\n        int count = 0;\n        boolean notify = false;\n        for (ContentValues value : values) {\n            Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, value);\n            if (rowAndNotify.first != null) {\n                count++;\n            }\n            if (rowAndNotify.second == true) {\n                notify = true;\n            }\n        }\n        if (notify) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return count;\n    }\n\n    @Override\n    public synchronized Uri insert(Uri url, ContentValues initialValues) {\n        Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, initialValues);\n        if (rowAndNotify.second) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return rowAndNotify.first;\n    }\n\n    /**\n     * Internal insert function to prevent code duplication for URL_TELEPHONY and URL_DPC.\n     *\n     * @param values the value that caller wants to insert\n     * @return a pair in which the first element refers to the Uri for the row inserted, the second\n     *         element refers to whether sends out nofitication.\n     */\n    private Pair<Uri, Boolean> insertRowWithValue(ContentValues values) {\n        Uri result = null;\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n\n        try {\n            // Abort on conflict of unique fields and attempt merge\n            long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                    SQLiteDatabase.CONFLICT_ABORT);\n            if (rowID >= 0) {\n                result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                notify = true;\n            }\n            if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n        } catch (SQLException e) {\n            log(\"insert: exception \" + e);\n            // Insertion failed which could be due to a conflict. Check if that is the case\n            // and merge the entries\n            Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n            if (oldRow != null) {\n                ContentValues mergedValues = new ContentValues();\n                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                        mergedValues, false, getContext());\n                oldRow.close();\n                notify = true;\n            }\n        }\n        return Pair.create(result, notify);\n    }\n\n    private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {\n        Uri result = null;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(initialValues);\n\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                values = setDefaultValue(values);\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Owned_by should be others if inserted via general uri.\n                values.put(OWNED_BY, OWNED_BY_OTHERS);\n\n                Pair<Uri, Boolean> ret = insertRowWithValue(values);\n                result = ret.first;\n                notify = ret.second;\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // zero out the previous operator\n                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + \"!=0\", null);\n\n                String numeric = initialValues.getAsString(NUMERIC);\n                int updated = db.update(CARRIERS_TABLE, s_currentSetMap,\n                        NUMERIC + \" = '\" + numeric + \"'\", null);\n\n                if (updated > 0)\n                {\n                    if (VDBG) log(\"Setting numeric '\" + numeric + \"' to be the current operator\");\n                }\n                else\n                {\n                    loge(\"Failed setting numeric '\" + numeric + \"' to the current operator\");\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (initialValues != null) {\n                    if(initialValues.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);\n                        notify = true;\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                // Owned_by should be DPC if inserted via URL_DPC.\n                values.put(OWNED_BY, OWNED_BY_DPC);\n                // DPC records should not be user editable.\n                values.put(USER_EDITABLE, false);\n\n                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                        SQLiteDatabase.CONFLICT_IGNORE);\n                if (rowID >= 0) {\n                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                    notify = true;\n                }\n                if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n\n                break;\n            }\n\n            case URL_SIMINFO: {\n               long id = db.insert(SIMINFO_TABLE, null, initialValues);\n               result = ContentUris.withAppendedId(Telephony.SimInfo.CONTENT_URI, id);\n               break;\n            }\n        }\n\n        return Pair.create(result, notify);\n    }\n\n    @Override\n    public synchronized int delete(Uri url, String where, String[] whereArgs) {\n        int count = 0;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String userOrCarrierEdited = \") and (\" +\n                IS_USER_EDITED +  \" or \" +\n                IS_CARRIER_EDITED + \")\";\n        String notUserOrCarrierEdited = \") and (\" +\n                IS_NOT_USER_EDITED +  \" and \" +\n                IS_NOT_CARRIER_EDITED + \")\";\n        String unedited = \") and \" + IS_UNEDITED;\n        ContentValues cv = new ContentValues();\n        cv.put(EDITED_STATUS, USER_DELETED);\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_DELETE:\n            {\n                // Delete preferred APN for all subIds\n                deletePreferredApnId(getContext());\n                // Delete unedited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + unedited + \" and \" +\n                        IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_ID:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE,\n                        \"(\" + _ID + \"=?\" + userOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv,\n                        \"(\" + _ID + \"=?\" + notUserOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[]{url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_RESTOREAPN_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            // intentional fall through from above case\n\n            case URL_RESTOREAPN: {\n                count = 1;\n                restoreDefaultAPN(subId);\n                getContext().getContentResolver().notifyChange(\n                        Uri.withAppendedPath(CONTENT_URI, \"restore/subId/\" + subId), null,\n                        true, UserHandle.USER_ALL);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                setPreferredApnId((long)INVALID_APN_ID, subId, true);\n                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) count = 1;\n                break;\n            }\n\n            case URL_DPC_ID: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                // Only delete if owned by DPC.\n                count = db.delete(CARRIERS_TABLE, \"(\" + _ID + \"=?)\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_SIMINFO: {\n                count = db.delete(SIMINFO_TABLE, where, whereArgs);\n                break;\n            }\n\n            case URL_UPDATE_DB: {\n                updateApnDb();\n                count = 1;\n                break;\n            }\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot delete that URL: \" + url);\n            }\n        }\n\n        if (count > 0) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n\n        return count;\n    }\n\n    @Override\n    public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs)\n    {\n        int count = 0;\n        int uriType = URL_UNKNOWN;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(values);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs,\n                        SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        whereArgs, SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_ID:\n            {\n                String rowID = url.getLastPathSegment();\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                try {\n                    count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + \"=?\" + \" and \" +\n                            IS_NOT_OWNED_BY_DPC, new String[] { rowID },\n                            SQLiteDatabase.CONFLICT_ABORT);\n                } catch (SQLException e) {\n                    // Update failed which could be due to a conflict. Check if that is\n                    // the case and merge the entries\n                    log(\"update: exception \" + e);\n                    Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n                    if (oldRow != null) {\n                        ContentValues mergedValues = new ContentValues();\n                        mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                                mergedValues, false, getContext());\n                        oldRow.close();\n                        db.delete(CARRIERS_TABLE, _ID + \"=?\" + \" and \" + IS_NOT_OWNED_BY_DPC,\n                                new String[] { rowID });\n                    }\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (values != null) {\n                    if (values.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);\n                        if ((match == URL_PREFERAPN) ||\n                                (match == URL_PREFERAPN_USING_SUBID)) {\n                            count = 1;\n                        }\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC_ID:\n            {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values,\n                        _ID + \"=?\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_IGNORE);\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                if (values != null) {\n                    if (values.containsKey(ENFORCED_KEY)) {\n                        setManagedApnEnforced(values.getAsBoolean(ENFORCED_KEY));\n                        count = 1;\n                    }\n                }\n                break;\n            }\n\n            case URL_SIMINFO_USING_SUBID:\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.update(SIMINFO_TABLE, values, _ID + \"=?\",\n                        new String[] { subIdString});\n                uriType = URL_SIMINFO_USING_SUBID;\n                break;\n\n            case URL_SIMINFO: {\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO;\n                break;\n            }\n\n            case URL_SIMINFO_SUW_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO_SUW_RESTORE;\n                break;\n\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                break;\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot update that URL: \" + url);\n            }\n        }\n\n        // if APNs (CARRIERS_TABLE) have been updated, some of them may be preferred APN for\n        // different subs. So update the APN field values saved in SharedPref for all subIds.\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID:\n            case URL_TELEPHONY:\n            case URL_CURRENT_USING_SUBID:\n            case URL_CURRENT:\n            case URL_ID:\n            case URL_DPC_ID:\n                updatePreferredApns();\n                break;\n        }\n\n        if (count > 0) {\n            boolean usingSubId = false;\n            switch (uriType) {\n                case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                    break;\n                case URL_SIMINFO_SUW_RESTORE:\n                    getContext().getContentResolver().notifyChange(\n                            SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI, null);\n                    // intentional fall through from above case\n                case URL_SIMINFO_USING_SUBID:\n                    usingSubId = true;\n                    // intentional fall through from above case\n                case URL_SIMINFO:\n                    // skip notifying descendant URLs to avoid unneccessary wake up.\n                    // If not set, any change to SIMINFO will notify observers which listens to\n                    // specific field of SIMINFO.\n                    getContext().getContentResolver().notifyChange(\n                        Telephony.SimInfo.CONTENT_URI, null,\n                            ContentResolver.NOTIFY_SYNC_TO_NETWORK\n                                    | ContentResolver.NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS,\n                            UserHandle.USER_ALL);\n                    // notify observers on specific user settings changes.\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager\n                                                .ADVANCED_CALLING_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.VT_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_MODE)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_MODE_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED), usingSubId, subId),\n                                null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_USAGE_SETTING)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_USAGE_SETTING),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    break;\n                default:\n                    getContext().getContentResolver().notifyChange(\n                            CONTENT_URI, null, true, UserHandle.USER_ALL);\n            }\n        }\n\n        return count;\n    }\n\n    private static Uri getNotifyContentUri(Uri uri, boolean usingSubId, int subId) {\n        return (usingSubId) ? Uri.withAppendedPath(uri, \"\" + subId) : uri;\n    }\n\n    /**\n     * Checks permission to query or insert/update/delete the database. The permissions required\n     * for APN DB and SIMINFO DB are different:\n     * <ul>\n     * <li>APN DB requires WRITE_APN_SETTINGS or carrier privileges\n     * <li>SIMINFO DB requires phone UID; it's for phone internal usage only\n     * <\/ul>\n     */\n    private void checkPermission(int match) {\n        switch (match) {\n            case URL_SIMINFO:\n            case URL_SIMINFO_USING_SUBID:\n            case URL_SIMINFO_SUW_RESTORE:\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                checkPermissionForSimInfoTable();\n                break;\n            default:\n                checkPermissionForApnTable();\n        }\n    }\n\n    private void checkPermissionForApnTable() {\n        int status = getContext().checkCallingOrSelfPermission(\n                \"android.permission.WRITE_APN_SETTINGS\");\n        if (status == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        PackageManager packageManager = getContext().getPackageManager();\n        String[] packages = packageManager.getPackagesForUid(Binder.getCallingUid());\n\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            for (String pkg : packages) {\n                if (telephonyManager.checkCarrierPrivilegesForPackageAnyPhone(pkg) ==\n                    TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {\n                    return;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        throw new SecurityException(\"No permission to access APN settings\");\n    }\n\n    /**\n     * Check permission to query the database based on PlatformCompat settings -- if the compat\n     * change is enabled, check WRITE_APN_SETTINGS or carrier privs for all queries. Otherwise,\n     * use the legacy checkQueryPermission method to see if the query should be allowed.\n     */\n    private void checkPermissionCompat(int match, String[] projectionIn) {\n        boolean useNewBehavior = CompatChanges.isChangeEnabled(\n                Telephony.Carriers.APN_READING_PERMISSION_CHANGE_ID,\n                Binder.getCallingUid());\n\n        if (!useNewBehavior) {\n            log(\"Using old permission behavior for telephony provider compat\");\n            checkQueryPermission(match, projectionIn);\n        } else {\n            checkPermission(match);\n        }\n    }\n\n    private void checkQueryPermission(int match, String[] projectionIn) {\n        if (match == URL_SIMINFO) {\n            checkPermissionForSimInfoTable();\n        } else {\n            if (projectionIn != null) {\n                for (String column : projectionIn) {\n                    if (TYPE.equals(column) ||\n                            MMSC.equals(column) ||\n                            MMSPROXY.equals(column) ||\n                            MMSPORT.equals(column) ||\n                            MVNO_TYPE.equals(column) ||\n                            MVNO_MATCH_DATA.equals(column) ||\n                            APN.equals(column)) {\n                        // noop\n                    } else {\n                        checkPermissionForApnTable();\n                        break;\n                    }\n                }\n            } else {\n                // null returns all columns, so need permission check\n                checkPermissionForApnTable();\n            }\n        }\n    }\n\n    private void checkPermissionForSimInfoTable() {\n        ensureCallingFromSystemOrPhoneUid(\"Access SIMINFO table from not phone/system UID\");\n        if (getContext().checkCallingOrSelfPermission(\n                    \"android.permission.ACCESS_TELEPHONY_SIMINFO_DB\")\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n        throw new SecurityException(\"No permission to access SIMINFO table\");\n    }\n\n    private DatabaseHelper mOpenHelper;\n\n    private void restoreDefaultAPN(int subId) {\n        SQLiteDatabase db = getWritableDatabase();\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        String where = null;\n        if (telephonyManager.getPhoneCount() > 1) {\n            where = getWhereClauseForRestoreDefaultApn(db, subId);\n        }\n        if (TextUtils.isEmpty(where)) {\n            where = IS_NOT_OWNED_BY_DPC;\n        }\n        log(\"restoreDefaultAPN: where: \" + where);\n\n        try {\n            db.delete(CARRIERS_TABLE, where, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to restore: \" + e);\n        }\n\n        // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all\n        // subIds\n        SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApnId = spApnId.edit();\n        editorApnId.clear();\n        editorApnId.apply();\n\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApn = spApn.edit();\n        editorApn.clear();\n        editorApn.apply();\n\n        if (apnSourceServiceExists(getContext())) {\n            restoreApnsWithService(subId);\n        } else {\n            initDatabaseWithDatabaseHelper(db);\n        }\n    }\n\n    private String getWhereClauseForRestoreDefaultApn(SQLiteDatabase db, int subId) {\n        TelephonyManager telephonyManager =\n            getContext().getSystemService(TelephonyManager.class).createForSubscriptionId(subId);\n        String simOperator = telephonyManager.getSimOperator();\n        int simCarrierId = telephonyManager.getSimSpecificCarrierId();\n        Cursor cursor = db.query(CARRIERS_TABLE, new String[] {MVNO_TYPE, MVNO_MATCH_DATA},\n                NUMERIC + \"='\" + simOperator + \"'\", null, null, null, DEFAULT_SORT_ORDER);\n        String where = null;\n\n        if (cursor != null) {\n            cursor.moveToFirst();\n            while (!cursor.isAfterLast()) {\n                String mvnoType = cursor.getString(0 /* MVNO_TYPE index */);\n                String mvnoMatchData = cursor.getString(1 /* MVNO_MATCH_DATA index */);\n                if (!TextUtils.isEmpty(mvnoType) && !TextUtils.isEmpty(mvnoMatchData)\n                        && telephonyManager.matchesCurrentSimOperator(simOperator,\n                            getMvnoTypeIntFromString(mvnoType), mvnoMatchData)) {\n                    where = NUMERIC + \"='\" + simOperator + \"'\"\n                            + \" AND \" + MVNO_TYPE + \"='\" + mvnoType + \"'\"\n                            + \" AND \" + MVNO_MATCH_DATA + \"='\" + mvnoMatchData + \"'\"\n                            + \" AND \" + IS_NOT_OWNED_BY_DPC;\n                    break;\n                }\n                cursor.moveToNext();\n            }\n            cursor.close();\n\n            if (TextUtils.isEmpty(where)) {\n                where = NUMERIC + \"='\" + simOperator + \"'\"\n                        + \" AND (\" + MVNO_TYPE + \"='' OR \" + MVNO_MATCH_DATA + \"='')\"\n                        + \" AND \" + IS_NOT_OWNED_BY_DPC;\n            }\n            // Add carrier id APNs\n            if (TelephonyManager.UNKNOWN_CARRIER_ID < simCarrierId) {\n                where = where.concat(\" OR \" + CARRIER_ID + \" = '\" + simCarrierId + \"'\" + \" AND \"\n                        + IS_NOT_OWNED_BY_DPC);\n            }\n\n        }\n        return where;\n    }\n\n    private synchronized void updateApnDb() {\n        if (apnSourceServiceExists(getContext())) {\n            loge(\"called updateApnDb when apn source service exists\");\n            return;\n        }\n\n        if (!needApnDbUpdate()) {\n            log(\"Skipping apn db update since apn-conf has not changed.\");\n            return;\n        }\n\n        SQLiteDatabase db = getWritableDatabase();\n\n        // Delete preferred APN for all subIds\n        deletePreferredApnId(getContext());\n\n        // Delete entries in db\n        try {\n            if (VDBG) log(\"updateApnDb: deleting edited=UNEDITED entries\");\n            db.delete(CARRIERS_TABLE, IS_UNEDITED + \" and \" + IS_NOT_OWNED_BY_DPC, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to update: \" + e);\n        }\n\n        initDatabaseWithDatabaseHelper(db);\n\n        // Notify listeners of DB change since DB has been updated\n        getContext().getContentResolver().notifyChange(\n                CONTENT_URI, null, true, UserHandle.USER_ALL);\n\n    }\n\n    public static void fillInMccMncStringAtCursor(Context context, SQLiteDatabase db, Cursor c) {\n        int mcc, mnc;\n        String subId;\n        try {\n            mcc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MCC));\n            mnc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MNC));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        String mccString = String.format(Locale.getDefault(), \"%03d\", mcc);\n        String mncString = getBestStringMnc(context, mccString, mnc);\n        ContentValues cv = new ContentValues(2);\n        cv.put(Telephony.SimInfo.COLUMN_MCC_STRING, mccString);\n        cv.put(Telephony.SimInfo.COLUMN_MNC_STRING, mncString);\n        db.update(SIMINFO_TABLE, cv,\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                new String[]{subId});\n    }\n\n    /*\n     * Find the best string-form mnc by looking up possibilities in the carrier id db.\n     * Default to the three-digit version if neither/both are valid.\n     */\n    private static String getBestStringMnc(Context context, String mcc, int mnc) {\n        if (mnc >= 100 && mnc <= 999) {\n            return String.valueOf(mnc);\n        }\n        String twoDigitMnc = String.format(Locale.getDefault(), \"%02d\", mnc);\n        String threeDigitMnc = \"0\" + twoDigitMnc;\n        boolean threeDigitNetworkCode =\n                Arrays.asList(COUNTRY_MCC_WITH_THREE_DIGIT_MNC).contains(mcc);\n        int twoDigitResult = countMccMncInCarrierList(context, mcc + twoDigitMnc);\n        int threeDigitResult = countMccMncInCarrierList(context, mcc + threeDigitMnc);\n\n        if ((threeDigitResult > twoDigitResult) ||\n                (threeDigitNetworkCode && (twoDigitResult == threeDigitResult))) {\n            return threeDigitMnc;\n        } else {\n            return twoDigitMnc;\n        }\n    }\n\n    /**\n     * Check carrier_list how many mcc mnc combo matches there are\n     */\n    private static int countMccMncInCarrierList(Context ctx, String mccMncCombo) {\n        try (\n            Cursor mccMncCursor = ctx.getContentResolver().query(\n                    Telephony.CarrierId.All.CONTENT_URI,\n                    /* projection */ null,\n                    /* selection */ Telephony.CarrierId.All.MCCMNC + \"=?\",\n                    /* selectionArgs */ new String[]{mccMncCombo}, null);\n        )\n        {\n            return mccMncCursor.getCount();\n        }\n    }\n\n    /**\n     * Sync the bearer bitmask and network type bitmask when inserting and updating.\n     * Since bearerBitmask is deprecating, map the networkTypeBitmask to bearerBitmask if\n     * networkTypeBitmask was provided. But if networkTypeBitmask was not provided, map the\n     * bearerBitmask to networkTypeBitmask.\n     */\n    private static void syncBearerBitmaskAndNetworkTypeBitmask(ContentValues values) {\n        if (values.containsKey(NETWORK_TYPE_BITMASK)) {\n            int convertedBitmask = convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK));\n            if (values.containsKey(BEARER_BITMASK)\n                    && convertedBitmask != values.getAsInteger(BEARER_BITMASK)) {\n                loge(\"Network type bitmask and bearer bitmask are not compatible.\");\n            }\n            values.put(BEARER_BITMASK, convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK)));\n        } else {\n            if (values.containsKey(BEARER_BITMASK)) {\n                int convertedBitmask = convertBearerBitmaskToNetworkTypeBitmask(\n                        values.getAsInteger(BEARER_BITMASK));\n                values.put(NETWORK_TYPE_BITMASK, convertedBitmask);\n            }\n        }\n    }\n\n    /**\n     * Log with debug\n     *\n     * @param s is string log\n     */\n    private static void log(String s) {\n        Log.d(TAG, s);\n    }\n\n    private static void loge(String s) {\n        Log.e(TAG, s);\n    }\n\n    private static int getMvnoTypeIntFromString(String mvnoType) {\n        String mvnoTypeString = TextUtils.isEmpty(mvnoType) ? mvnoType : mvnoType.toLowerCase(Locale.ROOT);\n        Integer mvnoTypeInt = MVNO_TYPE_STRING_MAP.get(mvnoTypeString);\n        return  mvnoTypeInt == null ? 0 : mvnoTypeInt;\n    }\n\n    private static int getBitmaskFromString(String bearerList) {\n        String[] bearers = bearerList.split(\"\\\\|\");\n        int bearerBitmask = 0;\n        for (String bearer : bearers) {\n            int bearerInt = 0;\n            try {\n                bearerInt = Integer.parseInt(bearer.trim());\n            } catch (NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (bearerInt == 0) {\n                return 0;\n            }\n            bearerBitmask |= getBitmaskForTech(bearerInt);\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Transform RIL radio technology value to Network\n     * type bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     *\n     * @param rat The RIL radio technology.\n     * @return The network type\n     * bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     */\n    private static int rilRadioTechnologyToNetworkTypeBitmask(int rat) {\n        switch (rat) {\n            case RIL_RADIO_TECHNOLOGY_GPRS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GPRS;\n            case RIL_RADIO_TECHNOLOGY_EDGE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EDGE;\n            case RIL_RADIO_TECHNOLOGY_UMTS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;\n            case RIL_RADIO_TECHNOLOGY_HSDPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSDPA;\n            case RIL_RADIO_TECHNOLOGY_HSUPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA;\n            case RIL_RADIO_TECHNOLOGY_HSPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPA;\n            case RIL_RADIO_TECHNOLOGY_IS95A:\n            case RIL_RADIO_TECHNOLOGY_IS95B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;\n            case RIL_RADIO_TECHNOLOGY_1xRTT:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT;\n            case RIL_RADIO_TECHNOLOGY_EVDO_0:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0;\n            case RIL_RADIO_TECHNOLOGY_EVDO_A:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A;\n            case RIL_RADIO_TECHNOLOGY_EVDO_B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B;\n            case RIL_RADIO_TECHNOLOGY_EHRPD:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD;\n            case RIL_RADIO_TECHNOLOGY_LTE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE;\n            case RIL_RADIO_TECHNOLOGY_HSPAP:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPAP;\n            case RIL_RADIO_TECHNOLOGY_GSM:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GSM;\n            case RIL_RADIO_TECHNOLOGY_TD_SCDMA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_TD_SCDMA;\n            case RIL_RADIO_TECHNOLOGY_IWLAN:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_IWLAN;\n            case RIL_RADIO_TECHNOLOGY_LTE_CA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;\n            case RIL_RADIO_TECHNOLOGY_NR:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_NR;\n            default:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UNKNOWN;\n        }\n    }\n\n    /**\n     * Convert network type bitmask to bearer bitmask.\n     *\n     * @param networkTypeBitmask The network type bitmask value\n     * @return The bearer bitmask value.\n     */\n    private static int convertNetworkTypeBitmaskToBearerBitmask(int networkTypeBitmask) {\n        if (networkTypeBitmask == 0) {\n            return 0;\n        }\n\n        int bearerBitmask = 0;\n        for (int bearerInt = 0; bearerInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerInt++) {\n            if (bitmaskHasTarget(networkTypeBitmask,\n                    rilRadioTechnologyToNetworkTypeBitmask(bearerInt))) {\n                bearerBitmask |= getBitmaskForTech(bearerInt);\n            }\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Convert bearer bitmask to network type bitmask.\n     *\n     * @param bearerBitmask The bearer bitmask value.\n     * @return The network type bitmask value.\n     */\n    private static int convertBearerBitmaskToNetworkTypeBitmask(int bearerBitmask) {\n        if (bearerBitmask == 0) {\n            return 0;\n        }\n\n        int networkTypeBitmask = 0;\n        for (int bearerUnitInt = 0; bearerUnitInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerUnitInt++) {\n            int bearerUnitBitmask = getBitmaskForTech(bearerUnitInt);\n            if (bitmaskHasTarget(bearerBitmask, bearerUnitBitmask)) {\n                networkTypeBitmask |= rilRadioTechnologyToNetworkTypeBitmask(bearerUnitInt);\n            }\n        }\n        return networkTypeBitmask;\n    }\n\n    private static boolean bitmaskHasTarget(int bearerBitmask, int targetBitmask) {\n        if (bearerBitmask == 0) {\n            return true;\n        } else if (targetBitmask != 0) {\n            return ((bearerBitmask & targetBitmask) != 0);\n        }\n        return false;\n    }\n\n    private static int getBitmaskForTech(int radioTech) {\n        if (radioTech >= 1) {\n            return (1 << (radioTech - 1));\n        }\n        return 0;\n    }\n\n    /**\n     * Migrate the old Long values{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} over to\n     * String{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} values in the sim info\n     *         table.\n     */\n    public static void fillInAllowedNetworkTypesStringAtCursor(SQLiteDatabase db, Cursor c) {\n        long allowedNetworkTypesReasonCarrier;\n        String subId;\n        try {\n            allowedNetworkTypesReasonCarrier = c.getLong(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        if (allowedNetworkTypesReasonCarrier != -1) {\n            ContentValues cv = new ContentValues(1);\n\n            cv.put(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS,\n                    \"carrier=\" + allowedNetworkTypesReasonCarrier);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n\n    /**\n     * Migrate the old values{@link Telephony.SimInfo#COLUMN_DATA_ENABLED_OVERRIDE_RULES} over to\n     * String{@link Telephony.SimInfo#COLUMN_ENABLED_MOBILE_DATA_POLICIES}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo#COLUMN_DATA_ENABLED_OVERRIDE_RULES} values in the sim info\n     *         table.\n     */\n    public static void fillInEnabledMobileDataPoliciesAtCursor(SQLiteDatabase db, Cursor c) {\n        String overrideRule;\n        String subId;\n        try {\n            overrideRule = c.getString(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"COLUMN_DATA_ENABLED_OVERRIDE_RULES not found.\");\n            return;\n        }\n\n        if (overrideRule != null) {\n            ContentValues cv = new ContentValues(1);\n\n            // convert override rule to its corresponding mobile data policy\n            overrideRule = overrideRule.contains(\"mms\") ?\n                    String.valueOf(TelephonyManager.MOBILE_DATA_POLICY_MMS_ALWAYS_ALLOWED): \"\";\n            cv.put(Telephony.SimInfo.COLUMN_ENABLED_MOBILE_DATA_POLICIES, overrideRule);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n\n    /**\n     * Dump the database table.\n     *\n     * @param tableName Table name.\n     * @param pw Print writer.\n     */\n    private void dumpTable(@NonNull String tableName, @NonNull IndentingPrintWriter pw) {\n        try (Cursor cursor = getReadableDatabase().query(false, tableName, null,\n                null, null, null, null, null, null)) {\n            pw.println(tableName + \" table:\");\n            pw.increaseIndent();\n            while (cursor != null && cursor.moveToNext()) {\n                List<String> columnStrings = new ArrayList<>();\n                String str = \"\";\n                for (int i = 0; i < cursor.getColumnCount(); i++) {\n                    str = cursor.getColumnName(i) + \"=\";\n                    int type = cursor.getType(i);\n                    try {\n                        switch (type) {\n                            case 0 /*FIELD_TYPE_NULL*/:\n                                str += \"null\";\n                                break;\n                            case 1 /*FIELD_TYPE_INTEGER*/:\n                                str += cursor.getInt(i);\n                                break;\n                            case 2 /*FIELD_TYPE_FLOAT*/:\n                                str += cursor.getFloat(i);\n                                break;\n                            case 3 /*FIELD_TYPE_STRING*/:\n                                String columnValue = cursor.getString(i);\n                                // Redact icc_id and card_id\n                                if (SIMINFO_TABLE.equals(tableName)\n                                        && (Telephony.SimInfo.COLUMN_ICC_ID.equals(\n                                                cursor.getColumnName(i))\n                                        || Telephony.SimInfo.COLUMN_CARD_ID.equals(\n                                                cursor.getColumnName(i)))) {\n                                    columnValue = SubscriptionInfo.givePrintableIccid(columnValue);\n                                }\n                                str += columnValue;\n                                break;\n                            case 4 /*FIELD_TYPE_BLOB*/:\n                                str += \"[blob]\";\n                                break;\n                            default:\n                                str += \"unknown\";\n                                break;\n                        }\n                    } catch (Exception e) {\n                        str += \"exception\";\n                    }\n                    columnStrings.add(str);\n                }\n                pw.println(TextUtils.join(\", \", columnStrings));\n            }\n            pw.decreaseIndent();\n        } catch (Exception ex) {\n            pw.println(\"Exception while dumping the table \" + tableName + \", ex=\" + ex);\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {\n        IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, \"  \");\n        pw.println(TAG + \":\");\n        pw.increaseIndent();\n        pw.println(\"Database:\");\n        pw.increaseIndent();\n        dumpTable(SIMINFO_TABLE, pw);\n        dumpTable(CARRIERS_TABLE, pw);\n        pw.decreaseIndent();\n        pw.println(\"Local log:\");\n        pw.increaseIndent();\n        mLocalLog.dump(pw);\n        pw.decreaseIndent();\n        pw.decreaseIndent();\n    }\n}\n","lineNo":5617}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.Mms.Addr;\nimport android.provider.Telephony.Mms.Part;\nimport android.provider.Telephony.Mms.Rate;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Threads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\n\nimport com.google.android.mms.pdu.PduHeaders;\nimport com.google.android.mms.util.DownloadDrmHelper;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * The class to provide base facility to access MMS related content,\n * which is stored in a SQLite database and in the file system.\n */\npublic class MmsProvider extends ContentProvider {\n    static final String TABLE_PDU  = \"pdu\";\n    static final String TABLE_ADDR = \"addr\";\n    static final String TABLE_PART = \"part\";\n    static final String TABLE_RATE = \"rate\";\n    static final String TABLE_DRM  = \"drm\";\n    static final String TABLE_WORDS = \"words\";\n    static final String VIEW_PDU_RESTRICTED = \"pdu_restricted\";\n\n    // The name of parts directory. The full dir is \"app_parts\".\n    static final String PARTS_DIR_NAME = \"parts\";\n\n    private ProviderUtilWrapper providerUtilWrapper = new ProviderUtilWrapper();\n\n    @VisibleForTesting\n    public void setProviderUtilWrapper(ProviderUtilWrapper providerUtilWrapper) {\n        this.providerUtilWrapper = providerUtilWrapper;\n    }\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    // wrapper class to allow easier mocking of the static ProviderUtil in tests\n    @VisibleForTesting\n    public static class ProviderUtilWrapper {\n        public boolean isAccessRestricted(Context context, String packageName, int uid) {\n            return ProviderUtil.isAccessRestricted(context, packageName, uid);\n        }\n    }\n\n    /**\n     * Return the proper view of \"pdu\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the mms data\n     */\n    public static String getPduTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_PDU_RESTRICTED : TABLE_PDU;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        // First check if a restricted view of the \"pdu\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n\n        // If access is restricted, we don't allow subqueries in the query.\n        Log.v(TAG, \"accessRestricted=\" + accessRestricted);\n        if (accessRestricted) {\n            SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n        }\n\n        final String pduTable = getPduTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Query uri=\" + uri + \", match=\" + match);\n        }\n\n        switch (match) {\n            case MMS_ALL:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_ALL, pduTable);\n                break;\n            case MMS_INBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_INBOX, pduTable);\n                break;\n            case MMS_SENT:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_SENT, pduTable);\n                break;\n            case MMS_DRAFTS:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_DRAFTS, pduTable);\n                break;\n            case MMS_OUTBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_OUTBOX, pduTable);\n                break;\n            case MMS_ALL_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(1));\n                qb.appendWhere(\" AND \" + Mms.MESSAGE_BOX + \"=\"\n                        + getMessageBoxByMatch(match));\n                break;\n            case MMS_ALL_PART:\n                qb.setTables(TABLE_PART);\n                break;\n            case MMS_MSG_PART:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_PART_ID:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part._ID + \"=\" + uri.getPathSegments().get(1));\n                break;\n            case MMS_MSG_ADDR:\n                qb.setTables(TABLE_ADDR);\n                qb.appendWhere(Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_REPORT_STATUS:\n                /*\n                   SELECT DISTINCT address,\n                                   T.delivery_status AS delivery_status,\n                                   T.read_status AS read_status\n                   FROM addr\n                   INNER JOIN (SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134\n                               LEFT JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               UNION\n                               SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               LEFT JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134) T\n                   ON (msg_id = id2 AND type = 151)\n                   OR (msg_id = id3 AND type = 137)\n                   WHERE T.id1 = ?;\n                 */\n                qb.setTables(TABLE_ADDR + \" INNER JOIN \"\n                        + \"(SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134 \"\n                        + \"LEFT JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"UNION \"\n                        + \"SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"LEFT JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134) T \"\n                        + \"ON (msg_id=id2 AND type=151) OR (msg_id=id3 AND type=137)\");\n                qb.appendWhere(\"T.id1 = \" + uri.getLastPathSegment());\n                qb.setDistinct(true);\n                break;\n            case MMS_REPORT_REQUEST:\n                /*\n                   SELECT address, d_rpt, rr\n                   FROM addr join pdu on pdu._id = addr.msg_id\n                   WHERE pdu._id = messageId AND addr.type = 151\n                 */\n                qb.setTables(TABLE_ADDR + \" join \" +\n                        pduTable + \" on \" + pduTable + \"._id = addr.msg_id\");\n                qb.appendWhere(pduTable + \"._id = \" + uri.getLastPathSegment());\n                qb.appendWhere(\" AND \" + TABLE_ADDR + \".type = \" + PduHeaders.TO);\n                break;\n            case MMS_SENDING_RATE:\n                qb.setTables(TABLE_RATE);\n                break;\n            case MMS_DRM_STORAGE_ID:\n                qb.setTables(TABLE_DRM);\n                qb.appendWhere(BaseColumns._ID + \"=\" + uri.getLastPathSegment());\n                break;\n            case MMS_THREADS:\n                qb.setTables(pduTable + \" group by thread_id\");\n                break;\n            default:\n                Log.e(TAG, \"query: invalid request: \" + uri);\n                return null;\n        }\n\n        String finalSortOrder = null;\n        if (TextUtils.isEmpty(sortOrder)) {\n            if (qb.getTables().equals(pduTable)) {\n                finalSortOrder = Mms.DATE + \" DESC\";\n            } else if (qb.getTables().equals(TABLE_PART)) {\n                finalSortOrder = Part.SEQ;\n            }\n        } else {\n            finalSortOrder = sortOrder;\n        }\n\n        Cursor ret;\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            ret = qb.query(db, projection, selection,\n                    selectionArgs, null, null, finalSortOrder);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"returning NULL cursor, query: \" + uri, e);\n            return null;\n        }\n\n        // TODO: Does this need to be a URI for this provider.\n        ret.setNotificationUri(getContext().getContentResolver(), uri);\n        return ret;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int msgBox, String pduTable) {\n        qb.setTables(pduTable);\n\n        if (msgBox != Mms.MESSAGE_BOX_ALL) {\n            qb.appendWhere(Mms.MESSAGE_BOX + \"=\" + msgBox);\n        }\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        int match = sURLMatcher.match(uri);\n        switch (match) {\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                return VND_ANDROID_DIR_MMS;\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                return VND_ANDROID_MMS;\n            case MMS_PART_ID: {\n                Cursor cursor = mOpenHelper.getReadableDatabase().query(\n                        TABLE_PART, new String[] { Part.CONTENT_TYPE },\n                        Part._ID + \" = ?\", new String[] { uri.getLastPathSegment() },\n                        null, null, null);\n                if (cursor != null) {\n                    try {\n                        if ((cursor.getCount() == 1) && cursor.moveToFirst()) {\n                            return cursor.getString(0);\n                        } else {\n                            Log.e(TAG, \"cursor.count() != 1: \" + uri);\n                        }\n                    } finally {\n                        cursor.close();\n                    }\n                } else {\n                    Log.e(TAG, \"cursor == null: \" + uri);\n                }\n                return \"*/*\";\n            }\n            case MMS_ALL_PART:\n            case MMS_MSG_PART:\n            case MMS_MSG_ADDR:\n            default:\n                return \"*/*\";\n        }\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int msgBox = Mms.MESSAGE_BOX_ALL;\n        boolean notify = true;\n\n        boolean forceNoNotify = values.containsKey(TelephonyBackupAgent.NOTIFY)\n                && !values.getAsBoolean(TelephonyBackupAgent.NOTIFY);\n        values.remove(TelephonyBackupAgent.NOTIFY);\n        // check isAccessRestricted to prevent third parties from setting NOTIFY = false maliciously\n        if (forceNoNotify && !providerUtilWrapper.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            notify = false;\n        }\n\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Insert uri=\" + uri + \", match=\" + match);\n        }\n\n        String table = TABLE_PDU;\n        switch (match) {\n            case MMS_ALL:\n                Object msgBoxObj = values.getAsInteger(Mms.MESSAGE_BOX);\n                if (msgBoxObj != null) {\n                    msgBox = (Integer) msgBoxObj;\n                }\n                else {\n                    // default to inbox\n                    msgBox = Mms.MESSAGE_BOX_INBOX;\n                }\n                break;\n            case MMS_INBOX:\n                msgBox = Mms.MESSAGE_BOX_INBOX;\n                break;\n            case MMS_SENT:\n                msgBox = Mms.MESSAGE_BOX_SENT;\n                break;\n            case MMS_DRAFTS:\n                msgBox = Mms.MESSAGE_BOX_DRAFTS;\n                break;\n            case MMS_OUTBOX:\n                msgBox = Mms.MESSAGE_BOX_OUTBOX;\n                break;\n            case MMS_MSG_PART:\n                notify = false;\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_ADDR:\n                notify = false;\n                table = TABLE_ADDR;\n                break;\n            case MMS_SENDING_RATE:\n                notify = false;\n                table = TABLE_RATE;\n                break;\n            case MMS_DRM_STORAGE:\n                notify = false;\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.e(TAG, \"insert: invalid request: \" + uri);\n                return null;\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        ContentValues finalValues;\n        Uri res = Mms.CONTENT_URI;\n        Uri caseSpecificUri = null;\n        long rowId;\n\n        if (table.equals(TABLE_PDU)) {\n            boolean addDate = !values.containsKey(Mms.DATE);\n            boolean addMsgBox = !values.containsKey(Mms.MESSAGE_BOX);\n\n            // Filter keys we don't support yet.\n            filterUnsupportedKeys(values);\n\n            // TODO: Should initialValues be validated, e.g. if it\n            // missed some significant keys?\n            finalValues = new ContentValues(values);\n\n            long timeInMillis = System.currentTimeMillis();\n\n            if (addDate) {\n                finalValues.put(Mms.DATE, timeInMillis / 1000L);\n            }\n\n            if (addMsgBox && (msgBox != Mms.MESSAGE_BOX_ALL)) {\n                finalValues.put(Mms.MESSAGE_BOX, msgBox);\n            }\n\n            if (msgBox != Mms.MESSAGE_BOX_INBOX) {\n                // Mark all non-inbox messages read.\n                finalValues.put(Mms.READ, 1);\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Mms.THREAD_ID);\n            String address = values.getAsString(CanonicalAddressesColumns.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                finalValues.put(Mms.THREAD_ID, Threads.getOrCreateThreadId(getContext(), address));\n            }\n\n            if (ProviderUtil.shouldSetCreator(finalValues, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                finalValues.put(Telephony.Mms.CREATOR, callerPkg);\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            // Notify change when an MMS is received.\n            if (msgBox == Mms.MESSAGE_BOX_INBOX) {\n                caseSpecificUri = ContentUris.withAppendedId(Mms.Inbox.CONTENT_URI, rowId);\n            }\n\n            res = Uri.parse(res + \"/\" + rowId);\n        } else if (table.equals(TABLE_ADDR)) {\n            finalValues = new ContentValues(values);\n            finalValues.put(Addr.MSG_ID, uri.getPathSegments().get(0));\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"Failed to insert address\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/addr/\" + rowId);\n        } else if (table.equals(TABLE_PART)) {\n            boolean containsDataPath = values != null && values.containsKey(Part._DATA);\n            finalValues = new ContentValues(values);\n\n            if (match == MMS_MSG_PART) {\n                finalValues.put(Part.MSG_ID, uri.getPathSegments().get(0));\n            }\n\n            String contentType = values.getAsString(\"ct\");\n\n            // text/plain and app application/smil store their \"data\" inline in the\n            // table so there's no need to create the file\n            boolean plainText = false;\n            boolean smilText = false;\n            if (\"text/plain\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert text/plain with _data\");\n                    return null;\n                }\n                plainText = true;\n            } else if (\"application/smil\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert application/smil with _data\");\n                    return null;\n                }\n                smilText = true;\n            }\n            if (!plainText && !smilText) {\n                String path;\n                if (containsDataPath) {\n                    // The _data column is filled internally in MmsProvider or from the\n                    // TelephonyBackupAgent, so this check is just to avoid it from being\n                    // inadvertently set. This is not supposed to be a protection against malicious\n                    // attack, since sql injection could still be attempted to bypass the check.\n                    // On the other hand, the MmsProvider does verify that the _data column has an\n                    // allowed value before opening any uri/files.\n                    if (!\"com.android.providers.telephony\".equals(callerPkg)) {\n                        Log.e(TAG, \"insert: can't insert _data\");\n                        return null;\n                    }\n                    try {\n                        path = values.getAsString(Part._DATA);\n                        final String partsDirPath = getContext()\n                                .getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                        if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                            Log.e(TAG, \"insert: path \"\n                                    + path\n                                    + \" does not start with \"\n                                    + partsDirPath);\n                            // Don't care return value\n                            return null;\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"insert part: create path failed \" + e, e);\n                        return null;\n                    }\n                } else {\n                    // Use the filename if possible, otherwise use the current time as the name.\n                    String contentLocation = values.getAsString(\"cl\");\n                    if (!TextUtils.isEmpty(contentLocation)) {\n                        File f = new File(contentLocation);\n                        contentLocation = \"_\" + f.getName();\n                    } else {\n                        contentLocation = \"\";\n                    }\n\n                    // Generate the '_data' field of the part with default\n                    // permission settings.\n                    path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                            + \"/PART_\" + System.currentTimeMillis() + contentLocation;\n\n                    if (DownloadDrmHelper.isDrmConvertNeeded(contentType)) {\n                        // Adds the .fl extension to the filename if contentType is\n                        // \"application/vnd.oma.drm.message\"\n                        path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n                    }\n                }\n\n                finalValues.put(Part._DATA, path);\n\n                File partFile = new File(path);\n                if (!partFile.exists()) {\n                    try {\n                        if (!partFile.createNewFile()) {\n                            throw new IllegalStateException(\n                                    \"Unable to create new partFile: \" + path);\n                        }\n                        // Give everyone rw permission until we encrypt the file\n                        // (in PduPersister.persistData). Once the file is encrypted, the\n                        // permissions will be set to 0644.\n                        try {\n                            Os.chmod(path, 0666);\n                            if (LOCAL_LOGV) {\n                                Log.d(TAG, \"MmsProvider.insert chmod is successful\");\n                            }\n                        } catch (ErrnoException e) {\n                            Log.e(TAG, \"Exception in chmod: \" + e);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"createNewFile\", e);\n                        throw new IllegalStateException(\n                                \"Unable to create new partFile: \" + path);\n                    }\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/part/\" + rowId);\n\n            // Don't use a trigger for updating the words table because of a bug\n            // in FTS3.  The bug is such that the call to get the last inserted\n            // row is incorrect.\n            if (plainText) {\n                // Update the words table with a corresponding row.  The words table\n                // allows us to search for words quickly, without scanning the whole\n                // table;\n                ContentValues cv = new ContentValues();\n\n                // we're using the row id of the part table row but we're also using ids\n                // from the sms table so this divides the space into two large chunks.\n                // The row ids from the part table start at 2 << 32.\n                cv.put(Telephony.MmsSms.WordsTable.ID, (2L << 32) + rowId);\n                cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"text\"));\n                cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowId);\n                cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 2);\n                db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n            }\n\n        } else if (table.equals(TABLE_RATE)) {\n            long now = values.getAsLong(Rate.SENT_TIME);\n            long oneHourAgo = now - 1000 * 60 * 60;\n            // Delete all unused rows (time earlier than one hour ago).\n            db.delete(table, Rate.SENT_TIME + \"<=\" + oneHourAgo, null);\n            db.insert(table, null, values);\n        } else if (table.equals(TABLE_DRM)) {\n            String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                    + \"/PART_\" + System.currentTimeMillis();\n            finalValues = new ContentValues(1);\n            finalValues.put(\"_data\", path);\n\n            File partFile = new File(path);\n            if (!partFile.exists()) {\n                try {\n                    if (!partFile.createNewFile()) {\n                        throw new IllegalStateException(\n                                \"Unable to create new file: \" + path);\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"createNewFile\", e);\n                    throw new IllegalStateException(\n                            \"Unable to create new file: \" + path);\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n            res = Uri.parse(res + \"/drm/\" + rowId);\n        } else {\n            throw new AssertionError(\"Unknown table type: \" + table);\n        }\n\n        if (notify) {\n            notifyChange(res, caseSpecificUri);\n        }\n        return res;\n    }\n\n    private int getMessageBoxByMatch(int match) {\n        switch (match) {\n            case MMS_INBOX_ID:\n            case MMS_INBOX:\n                return Mms.MESSAGE_BOX_INBOX;\n            case MMS_SENT_ID:\n            case MMS_SENT:\n                return Mms.MESSAGE_BOX_SENT;\n            case MMS_DRAFTS_ID:\n            case MMS_DRAFTS:\n                return Mms.MESSAGE_BOX_DRAFTS;\n            case MMS_OUTBOX_ID:\n            case MMS_OUTBOX:\n                return Mms.MESSAGE_BOX_OUTBOX;\n            default:\n                throw new IllegalArgumentException(\"bad Arg: \" + match);\n        }\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Delete uri=\" + uri + \", match=\" + match);\n        }\n\n        String table, extraSelection = null;\n        boolean notify = false;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                notify = true;\n                table = TABLE_PDU;\n                extraSelection = Mms._ID + \"=\" + uri.getLastPathSegment();\n                break;\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                if (match != MMS_ALL) {\n                    int msgBox = getMessageBoxByMatch(match);\n                    extraSelection = Mms.MESSAGE_BOX + \"=\" + msgBox;\n                }\n                break;\n            case MMS_ALL_PART:\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_PART:\n                table = TABLE_PART;\n                extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                break;\n            case MMS_MSG_ADDR:\n                table = TABLE_ADDR;\n                extraSelection = Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_DRM_STORAGE:\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.w(TAG, \"No match for URI '\" + uri + \"'\");\n                return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int deletedRows = 0;\n\n        if (TABLE_PDU.equals(table)) {\n            deletedRows = deleteMessages(getContext(), db, finalSelection,\n                                         selectionArgs, uri);\n        } else if (TABLE_PART.equals(table)) {\n            deletedRows = deleteParts(db, finalSelection, selectionArgs);\n        } else if (TABLE_DRM.equals(table)) {\n            deletedRows = deleteTempDrmData(db, finalSelection, selectionArgs);\n        } else {\n            deletedRows = db.delete(table, finalSelection, selectionArgs);\n        }\n\n        if ((deletedRows > 0) && notify) {\n            notifyChange(uri, null);\n        }\n        return deletedRows;\n    }\n\n    static int deleteMessages(Context context, SQLiteDatabase db,\n            String selection, String[] selectionArgs, Uri uri) {\n        Cursor cursor = db.query(TABLE_PDU, new String[] { Mms._ID },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                deleteParts(db, Part.MSG_ID + \" = ?\",\n                        new String[] { String.valueOf(cursor.getLong(0)) });\n            }\n        } finally {\n            cursor.close();\n        }\n\n        int count = db.delete(TABLE_PDU, selection, selectionArgs);\n        if (count > 0) {\n            Intent intent = new Intent(Mms.Intents.CONTENT_CHANGED_ACTION);\n            intent.putExtra(Mms.Intents.DELETED_CONTENTS, uri);\n            if (LOCAL_LOGV) {\n                Log.v(TAG, \"Broadcasting intent: \" + intent);\n            }\n            context.sendBroadcast(intent);\n        }\n        return count;\n    }\n\n    private static int deleteParts(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_PART, selection, selectionArgs);\n    }\n\n    private static int deleteTempDrmData(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_DRM, selection, selectionArgs);\n    }\n\n    private static int deleteDataRows(SQLiteDatabase db, String table,\n            String selection, String[] selectionArgs) {\n        Cursor cursor = db.query(table, new String[] { \"_data\" },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            // FIXME: This might be an error, ignore it may cause\n            // unpredictable result.\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                try {\n                    // Delete the associated files saved on file-system.\n                    String path = cursor.getString(0);\n                    if (path != null) {\n                        new File(path).delete();\n                    }\n                } catch (Throwable ex) {\n                    Log.e(TAG, ex.getMessage(), ex);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return db.delete(table, selection, selectionArgs);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        // The _data column is filled internally in MmsProvider, so this check is just to avoid\n        // it from being inadvertently set. This is not supposed to be a protection against\n        // malicious attack, since sql injection could still be attempted to bypass the check. On\n        // the other hand, the MmsProvider does verify that the _data column has an allowed value\n        // before opening any uri/files.\n        if (values != null && values.containsKey(Part._DATA)) {\n            return 0;\n        }\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Update uri=\" + uri + \", match=\" + match);\n        }\n\n        boolean notify = false;\n        String msgId = null;\n        String table;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                msgId = uri.getLastPathSegment();\n            // fall-through\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                break;\n\n            case MMS_MSG_PART:\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                break;\n\n            case MMS_PART_RESET_FILE_PERMISSION:\n                String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath() + '/' +\n                        uri.getPathSegments().get(1);\n\n                try {\n                    String partsDirPath = getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                    if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                        EventLog.writeEvent(0x534e4554, \"240685104\",\n                                Binder.getCallingUid(), (TAG + \" update: path \" + path +\n                                        \" does not start with \" + partsDirPath));\n                        return 0;\n                    }\n                    // Reset the file permission back to read for everyone but me.\n                    Os.chmod(path, 0644);\n                    if (LOCAL_LOGV) {\n                        Log.d(TAG, \"MmsProvider.update chmod is successful for path: \" + path);\n                    }\n                } catch (ErrnoException | IOException e) {\n                    Log.e(TAG, \"Exception in chmod: \" + e);\n                }\n                return 0;\n\n            default:\n                Log.w(TAG, \"Update operation for '\" + uri + \"' not implemented.\");\n                return 0;\n        }\n\n        String extraSelection = null;\n        ContentValues finalValues;\n        if (table.equals(TABLE_PDU)) {\n            // Filter keys that we don't support yet.\n            filterUnsupportedKeys(values);\n            if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n                // CREATOR should not be changed by non-SYSTEM/PHONE apps\n                Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n                values.remove(Mms.CREATOR);\n            }\n            finalValues = new ContentValues(values);\n\n            if (msgId != null) {\n                extraSelection = Mms._ID + \"=\" + msgId;\n            }\n        } else if (table.equals(TABLE_PART)) {\n            finalValues = new ContentValues(values);\n\n            switch (match) {\n                case MMS_MSG_PART:\n                    extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                    break;\n                case MMS_PART_ID:\n                    extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count = db.update(table, finalValues, finalSelection, selectionArgs);\n        if (notify && (count > 0)) {\n            notifyChange(uri, null);\n        }\n        return count;\n    }\n\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        int match = sURLMatcher.match(uri);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"openFile: uri=\" + uri + \", mode=\" + mode + \", match=\" + match);\n        }\n\n        if (match != MMS_PART_ID) {\n            return null;\n        }\n\n        return safeOpenFileHelper(uri, mode);\n    }\n\n    @NonNull\n    private ParcelFileDescriptor safeOpenFileHelper(\n            @NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {\n        Cursor c = query(uri, new String[]{\"_data\"}, null, null, null);\n        int count = (c != null) ? c.getCount() : 0;\n        if (count != 1) {\n            // If there is not exactly one result, throw an appropriate\n            // exception.\n            if (c != null) {\n                c.close();\n            }\n            if (count == 0) {\n                throw new FileNotFoundException(\"No entry for \" + uri);\n            }\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        c.moveToFirst();\n        int i = c.getColumnIndex(\"_data\");\n        String path = (i >= 0 ? c.getString(i) : null);\n        c.close();\n\n        if (path == null) {\n            throw new FileNotFoundException(\"Column _data not found.\");\n        }\n\n        File filePath = new File(path);\n        try {\n            // The MmsProvider shouldn't open a file that isn't MMS data, so we verify that the\n            // _data path actually points to MMS data. That safeguards ourselves from callers who\n            // inserted or updated a URI (more specifically the _data column) with disallowed paths.\n            // TODO(afurtado): provide a more robust mechanism to avoid disallowed _data paths to\n            // be inserted/updated in the first place, including via SQL injection.\n            if (!filePath.getCanonicalPath()\n                    .startsWith(getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath())) {\n                Log.e(TAG, \"openFile: path \"\n                        + filePath.getCanonicalPath()\n                        + \" does not start with \"\n                        + getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath());\n                // Don't care return value\n                return null;\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"openFile: create path failed \" + e, e);\n            return null;\n        }\n\n        int modeBits = ParcelFileDescriptor.parseMode(mode);\n        return ParcelFileDescriptor.open(filePath, modeBits);\n    }\n\n    private void filterUnsupportedKeys(ContentValues values) {\n        // Some columns are unsupported.  They should therefore\n        // neither be inserted nor updated.  Filter them out.\n        values.remove(Mms.DELIVERY_TIME_TOKEN);\n        values.remove(Mms.SENDER_VISIBILITY);\n        values.remove(Mms.REPLY_CHARGING);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE_TOKEN);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE);\n        values.remove(Mms.REPLY_CHARGING_ID);\n        values.remove(Mms.REPLY_CHARGING_SIZE);\n        values.remove(Mms.PREVIOUSLY_SENT_BY);\n        values.remove(Mms.PREVIOUSLY_SENT_DATE);\n        values.remove(Mms.STORE);\n        values.remove(Mms.MM_STATE);\n        values.remove(Mms.MM_FLAGS_TOKEN);\n        values.remove(Mms.MM_FLAGS);\n        values.remove(Mms.STORE_STATUS);\n        values.remove(Mms.STORE_STATUS_TEXT);\n        values.remove(Mms.STORED);\n        values.remove(Mms.TOTALS);\n        values.remove(Mms.MBOX_TOTALS);\n        values.remove(Mms.MBOX_TOTALS_TOKEN);\n        values.remove(Mms.QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS_TOKEN);\n        values.remove(Mms.MESSAGE_COUNT);\n        values.remove(Mms.START);\n        values.remove(Mms.DISTRIBUTION_INDICATOR);\n        values.remove(Mms.ELEMENT_DESCRIPTOR);\n        values.remove(Mms.LIMIT);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE_TEXT);\n        values.remove(Mms.STATUS_TEXT);\n        values.remove(Mms.APPLIC_ID);\n        values.remove(Mms.REPLY_APPLIC_ID);\n        values.remove(Mms.AUX_APPLIC_ID);\n        values.remove(Mms.DRM_CONTENT);\n        values.remove(Mms.ADAPTATION_ALLOWED);\n        values.remove(Mms.REPLACE_ID);\n        values.remove(Mms.CANCEL_ID);\n        values.remove(Mms.CANCEL_STATUS);\n\n        // Keys shouldn't be inserted or updated.\n        values.remove(Mms._ID);\n    }\n\n    private void notifyChange(final Uri uri, final Uri caseSpecificUri) {\n        final Context context = getContext();\n        if (caseSpecificUri != null) {\n            context.getContentResolver().notifyChange(\n                caseSpecificUri, null, true, UserHandle.USER_ALL);\n        }\n        context.getContentResolver().notifyChange(\n                MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        ProviderUtil.notifyIfNotDefaultSmsApp(caseSpecificUri == null ? uri : caseSpecificUri,\n                getCallingPackage(), context);\n    }\n\n    private final static String TAG = \"MmsProvider\";\n    private final static String VND_ANDROID_MMS = \"vnd.android/mms\";\n    private final static String VND_ANDROID_DIR_MMS = \"vnd.android-dir/mms\";\n    private final static boolean DEBUG = false;\n    private final static boolean LOCAL_LOGV = false;\n\n    private static final int MMS_ALL                      = 0;\n    private static final int MMS_ALL_ID                   = 1;\n    private static final int MMS_INBOX                    = 2;\n    private static final int MMS_INBOX_ID                 = 3;\n    private static final int MMS_SENT                     = 4;\n    private static final int MMS_SENT_ID                  = 5;\n    private static final int MMS_DRAFTS                   = 6;\n    private static final int MMS_DRAFTS_ID                = 7;\n    private static final int MMS_OUTBOX                   = 8;\n    private static final int MMS_OUTBOX_ID                = 9;\n    private static final int MMS_ALL_PART                 = 10;\n    private static final int MMS_MSG_PART                 = 11;\n    private static final int MMS_PART_ID                  = 12;\n    private static final int MMS_MSG_ADDR                 = 13;\n    private static final int MMS_SENDING_RATE             = 14;\n    private static final int MMS_REPORT_STATUS            = 15;\n    private static final int MMS_REPORT_REQUEST           = 16;\n    private static final int MMS_DRM_STORAGE              = 17;\n    private static final int MMS_DRM_STORAGE_ID           = 18;\n    private static final int MMS_THREADS                  = 19;\n    private static final int MMS_PART_RESET_FILE_PERMISSION = 20;\n\n    private static final UriMatcher\n            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         MMS_ALL);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"sent\",       MMS_SENT);\n        sURLMatcher.addURI(\"mms\", \"sent/#\",     MMS_SENT_ID);\n        sURLMatcher.addURI(\"mms\", \"drafts\",     MMS_DRAFTS);\n        sURLMatcher.addURI(\"mms\", \"drafts/#\",   MMS_DRAFTS_ID);\n        sURLMatcher.addURI(\"mms\", \"outbox\",     MMS_OUTBOX);\n        sURLMatcher.addURI(\"mms\", \"outbox/#\",   MMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"part\",       MMS_ALL_PART);\n        sURLMatcher.addURI(\"mms\", \"#/part\",     MMS_MSG_PART);\n        sURLMatcher.addURI(\"mms\", \"part/#\",     MMS_PART_ID);\n        sURLMatcher.addURI(\"mms\", \"#/addr\",     MMS_MSG_ADDR);\n        sURLMatcher.addURI(\"mms\", \"rate\",       MMS_SENDING_RATE);\n        sURLMatcher.addURI(\"mms\", \"report-status/#\",  MMS_REPORT_STATUS);\n        sURLMatcher.addURI(\"mms\", \"report-request/#\", MMS_REPORT_REQUEST);\n        sURLMatcher.addURI(\"mms\", \"drm\",        MMS_DRM_STORAGE);\n        sURLMatcher.addURI(\"mms\", \"drm/#\",      MMS_DRM_STORAGE_ID);\n        sURLMatcher.addURI(\"mms\", \"threads\",    MMS_THREADS);\n        sURLMatcher.addURI(\"mms\", \"resetFilePerm/*\",    MMS_PART_RESET_FILE_PERMISSION);\n    }\n\n    @VisibleForTesting\n    public SQLiteOpenHelper mOpenHelper;\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.Mms.Addr;\nimport android.provider.Telephony.Mms.Part;\nimport android.provider.Telephony.Mms.Rate;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Threads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\n\nimport com.google.android.mms.pdu.PduHeaders;\nimport com.google.android.mms.util.DownloadDrmHelper;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * The class to provide base facility to access MMS related content,\n * which is stored in a SQLite database and in the file system.\n */\npublic class MmsProvider extends ContentProvider {\n    static final String TABLE_PDU  = \"pdu\";\n    static final String TABLE_ADDR = \"addr\";\n    static final String TABLE_PART = \"part\";\n    static final String TABLE_RATE = \"rate\";\n    static final String TABLE_DRM  = \"drm\";\n    static final String TABLE_WORDS = \"words\";\n    static final String VIEW_PDU_RESTRICTED = \"pdu_restricted\";\n\n    // The name of parts directory. The full dir is \"app_parts\".\n    static final String PARTS_DIR_NAME = \"parts\";\n\n    private ProviderUtilWrapper providerUtilWrapper = new ProviderUtilWrapper();\n\n    @VisibleForTesting\n    public void setProviderUtilWrapper(ProviderUtilWrapper providerUtilWrapper) {\n        this.providerUtilWrapper = providerUtilWrapper;\n    }\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    // wrapper class to allow easier mocking of the static ProviderUtil in tests\n    @VisibleForTesting\n    public static class ProviderUtilWrapper {\n        public boolean isAccessRestricted(Context context, String packageName, int uid) {\n            return ProviderUtil.isAccessRestricted(context, packageName, uid);\n        }\n    }\n\n    /**\n     * Return the proper view of \"pdu\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the mms data\n     */\n    public static String getPduTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_PDU_RESTRICTED : TABLE_PDU;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        // First check if a restricted view of the \"pdu\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        Log.v(TAG, \"accessRestricted=\" + accessRestricted);\n        if (accessRestricted) {\n            SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n        }\n\n        final String pduTable = getPduTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Query uri=\" + uri + \", match=\" + match);\n        }\n\n        switch (match) {\n            case MMS_ALL:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_ALL, pduTable);\n                break;\n            case MMS_INBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_INBOX, pduTable);\n                break;\n            case MMS_SENT:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_SENT, pduTable);\n                break;\n            case MMS_DRAFTS:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_DRAFTS, pduTable);\n                break;\n            case MMS_OUTBOX:\n                constructQueryForBox(qb, Mms.MESSAGE_BOX_OUTBOX, pduTable);\n                break;\n            case MMS_ALL_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                qb.setTables(pduTable);\n                qb.appendWhere(Mms._ID + \"=\" + uri.getPathSegments().get(1));\n                qb.appendWhere(\" AND \" + Mms.MESSAGE_BOX + \"=\"\n                        + getMessageBoxByMatch(match));\n                break;\n            case MMS_ALL_PART:\n                qb.setTables(TABLE_PART);\n                break;\n            case MMS_MSG_PART:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_PART_ID:\n                qb.setTables(TABLE_PART);\n                qb.appendWhere(Part._ID + \"=\" + uri.getPathSegments().get(1));\n                break;\n            case MMS_MSG_ADDR:\n                qb.setTables(TABLE_ADDR);\n                qb.appendWhere(Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0));\n                break;\n            case MMS_REPORT_STATUS:\n                /*\n                   SELECT DISTINCT address,\n                                   T.delivery_status AS delivery_status,\n                                   T.read_status AS read_status\n                   FROM addr\n                   INNER JOIN (SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134\n                               LEFT JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               UNION\n                               SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3,\n                                      ifnull(P2.st, 0) AS delivery_status,\n                                      ifnull(P3.read_status, 0) AS read_status\n                               FROM pdu P1\n                               INNER JOIN pdu P3\n                               ON P1.m_id = P3.m_id AND P3.m_type = 136\n                               LEFT JOIN pdu P2\n                               ON P1.m_id = P2.m_id AND P2.m_type = 134) T\n                   ON (msg_id = id2 AND type = 151)\n                   OR (msg_id = id3 AND type = 137)\n                   WHERE T.id1 = ?;\n                 */\n                qb.setTables(TABLE_ADDR + \" INNER JOIN \"\n                        + \"(SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134 \"\n                        + \"LEFT JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"UNION \"\n                        + \"SELECT P1._id AS id1, P2._id AS id2, P3._id AS id3, \"\n                        + \"ifnull(P2.st, 0) AS delivery_status, \"\n                        + \"ifnull(P3.read_status, 0) AS read_status \"\n                        + \"FROM \" + pduTable + \" P1 INNER JOIN \" + pduTable + \" P3 \"\n                        + \"ON P1.m_id=P3.m_id AND P3.m_type=136 \"\n                        + \"LEFT JOIN \" + pduTable + \" P2 \"\n                        + \"ON P1.m_id=P2.m_id AND P2.m_type=134) T \"\n                        + \"ON (msg_id=id2 AND type=151) OR (msg_id=id3 AND type=137)\");\n                qb.appendWhere(\"T.id1 = \" + uri.getLastPathSegment());\n                qb.setDistinct(true);\n                break;\n            case MMS_REPORT_REQUEST:\n                /*\n                   SELECT address, d_rpt, rr\n                   FROM addr join pdu on pdu._id = addr.msg_id\n                   WHERE pdu._id = messageId AND addr.type = 151\n                 */\n                qb.setTables(TABLE_ADDR + \" join \" +\n                        pduTable + \" on \" + pduTable + \"._id = addr.msg_id\");\n                qb.appendWhere(pduTable + \"._id = \" + uri.getLastPathSegment());\n                qb.appendWhere(\" AND \" + TABLE_ADDR + \".type = \" + PduHeaders.TO);\n                break;\n            case MMS_SENDING_RATE:\n                qb.setTables(TABLE_RATE);\n                break;\n            case MMS_DRM_STORAGE_ID:\n                qb.setTables(TABLE_DRM);\n                qb.appendWhere(BaseColumns._ID + \"=\" + uri.getLastPathSegment());\n                break;\n            case MMS_THREADS:\n                qb.setTables(pduTable + \" group by thread_id\");\n                break;\n            default:\n                Log.e(TAG, \"query: invalid request: \" + uri);\n                return null;\n        }\n\n        if (qb.getTables().equals(pduTable)) {\n            String selectionBySubIds;\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Filter MMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return new MatrixCursor((projection == null) ? (new String[] {}) : projection);\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String finalSortOrder = null;\n        if (TextUtils.isEmpty(sortOrder)) {\n            if (qb.getTables().equals(pduTable)) {\n                finalSortOrder = Mms.DATE + \" DESC\";\n            } else if (qb.getTables().equals(TABLE_PART)) {\n                finalSortOrder = Part.SEQ;\n            }\n        } else {\n            finalSortOrder = sortOrder;\n        }\n\n        Cursor ret;\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            ret = qb.query(db, projection, selection,\n                    selectionArgs, null, null, finalSortOrder);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"returning NULL cursor, query: \" + uri, e);\n            return null;\n        }\n\n        // TODO: Does this need to be a URI for this provider.\n        ret.setNotificationUri(getContext().getContentResolver(), uri);\n        return ret;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int msgBox, String pduTable) {\n        qb.setTables(pduTable);\n\n        if (msgBox != Mms.MESSAGE_BOX_ALL) {\n            qb.appendWhere(Mms.MESSAGE_BOX + \"=\" + msgBox);\n        }\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        int match = sURLMatcher.match(uri);\n        switch (match) {\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                return VND_ANDROID_DIR_MMS;\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                return VND_ANDROID_MMS;\n            case MMS_PART_ID: {\n                Cursor cursor = mOpenHelper.getReadableDatabase().query(\n                        TABLE_PART, new String[] { Part.CONTENT_TYPE },\n                        Part._ID + \" = ?\", new String[] { uri.getLastPathSegment() },\n                        null, null, null);\n                if (cursor != null) {\n                    try {\n                        if ((cursor.getCount() == 1) && cursor.moveToFirst()) {\n                            return cursor.getString(0);\n                        } else {\n                            Log.e(TAG, \"cursor.count() != 1: \" + uri);\n                        }\n                    } finally {\n                        cursor.close();\n                    }\n                } else {\n                    Log.e(TAG, \"cursor == null: \" + uri);\n                }\n                return \"*/*\";\n            }\n            case MMS_ALL_PART:\n            case MMS_MSG_PART:\n            case MMS_MSG_ADDR:\n            default:\n                return \"*/*\";\n        }\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int msgBox = Mms.MESSAGE_BOX_ALL;\n        boolean notify = true;\n\n        boolean forceNoNotify = values.containsKey(TelephonyBackupAgent.NOTIFY)\n                && !values.getAsBoolean(TelephonyBackupAgent.NOTIFY);\n        values.remove(TelephonyBackupAgent.NOTIFY);\n        // check isAccessRestricted to prevent third parties from setting NOTIFY = false maliciously\n        if (forceNoNotify && !providerUtilWrapper.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid)) {\n            notify = false;\n        }\n\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Insert uri=\" + uri + \", match=\" + match);\n        }\n\n        String table = TABLE_PDU;\n        switch (match) {\n            case MMS_ALL:\n                Object msgBoxObj = values.getAsInteger(Mms.MESSAGE_BOX);\n                if (msgBoxObj != null) {\n                    msgBox = (Integer) msgBoxObj;\n                }\n                else {\n                    // default to inbox\n                    msgBox = Mms.MESSAGE_BOX_INBOX;\n                }\n                break;\n            case MMS_INBOX:\n                msgBox = Mms.MESSAGE_BOX_INBOX;\n                break;\n            case MMS_SENT:\n                msgBox = Mms.MESSAGE_BOX_SENT;\n                break;\n            case MMS_DRAFTS:\n                msgBox = Mms.MESSAGE_BOX_DRAFTS;\n                break;\n            case MMS_OUTBOX:\n                msgBox = Mms.MESSAGE_BOX_OUTBOX;\n                break;\n            case MMS_MSG_PART:\n                notify = false;\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_ADDR:\n                notify = false;\n                table = TABLE_ADDR;\n                break;\n            case MMS_SENDING_RATE:\n                notify = false;\n                table = TABLE_RATE;\n                break;\n            case MMS_DRM_STORAGE:\n                notify = false;\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.e(TAG, \"insert: invalid request: \" + uri);\n                return null;\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        ContentValues finalValues;\n        Uri res = Mms.CONTENT_URI;\n        Uri caseSpecificUri = null;\n        long rowId;\n\n        if (table.equals(TABLE_PDU)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n                return null;\n            }\n\n            boolean addDate = !values.containsKey(Mms.DATE);\n            boolean addMsgBox = !values.containsKey(Mms.MESSAGE_BOX);\n\n            // Filter keys we don't support yet.\n            filterUnsupportedKeys(values);\n\n            // TODO: Should initialValues be validated, e.g. if it\n            // missed some significant keys?\n            finalValues = new ContentValues(values);\n\n            long timeInMillis = System.currentTimeMillis();\n\n            if (addDate) {\n                finalValues.put(Mms.DATE, timeInMillis / 1000L);\n            }\n\n            if (addMsgBox && (msgBox != Mms.MESSAGE_BOX_ALL)) {\n                finalValues.put(Mms.MESSAGE_BOX, msgBox);\n            }\n\n            if (msgBox != Mms.MESSAGE_BOX_INBOX) {\n                // Mark all non-inbox messages read.\n                finalValues.put(Mms.READ, 1);\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Mms.THREAD_ID);\n            String address = values.getAsString(CanonicalAddressesColumns.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                finalValues.put(Mms.THREAD_ID, Threads.getOrCreateThreadId(getContext(), address));\n            }\n\n            if (ProviderUtil.shouldSetCreator(finalValues, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                finalValues.put(Telephony.Mms.CREATOR, callerPkg);\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            // Notify change when an MMS is received.\n            if (msgBox == Mms.MESSAGE_BOX_INBOX) {\n                caseSpecificUri = ContentUris.withAppendedId(Mms.Inbox.CONTENT_URI, rowId);\n            }\n\n            res = Uri.parse(res + \"/\" + rowId);\n        } else if (table.equals(TABLE_ADDR)) {\n            finalValues = new ContentValues(values);\n            finalValues.put(Addr.MSG_ID, uri.getPathSegments().get(0));\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"Failed to insert address\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/addr/\" + rowId);\n        } else if (table.equals(TABLE_PART)) {\n            boolean containsDataPath = values != null && values.containsKey(Part._DATA);\n            finalValues = new ContentValues(values);\n\n            if (match == MMS_MSG_PART) {\n                finalValues.put(Part.MSG_ID, uri.getPathSegments().get(0));\n            }\n\n            String contentType = values.getAsString(\"ct\");\n\n            // text/plain and app application/smil store their \"data\" inline in the\n            // table so there's no need to create the file\n            boolean plainText = false;\n            boolean smilText = false;\n            if (\"text/plain\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert text/plain with _data\");\n                    return null;\n                }\n                plainText = true;\n            } else if (\"application/smil\".equals(contentType)) {\n                if (containsDataPath) {\n                    Log.e(TAG, \"insert: can't insert application/smil with _data\");\n                    return null;\n                }\n                smilText = true;\n            }\n            if (!plainText && !smilText) {\n                String path;\n                if (containsDataPath) {\n                    // The _data column is filled internally in MmsProvider or from the\n                    // TelephonyBackupAgent, so this check is just to avoid it from being\n                    // inadvertently set. This is not supposed to be a protection against malicious\n                    // attack, since sql injection could still be attempted to bypass the check.\n                    // On the other hand, the MmsProvider does verify that the _data column has an\n                    // allowed value before opening any uri/files.\n                    if (!\"com.android.providers.telephony\".equals(callerPkg)) {\n                        Log.e(TAG, \"insert: can't insert _data\");\n                        return null;\n                    }\n                    try {\n                        path = values.getAsString(Part._DATA);\n                        final String partsDirPath = getContext()\n                                .getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                        if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                            Log.e(TAG, \"insert: path \"\n                                    + path\n                                    + \" does not start with \"\n                                    + partsDirPath);\n                            // Don't care return value\n                            return null;\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"insert part: create path failed \" + e, e);\n                        return null;\n                    }\n                } else {\n                    // Use the filename if possible, otherwise use the current time as the name.\n                    String contentLocation = values.getAsString(\"cl\");\n                    if (!TextUtils.isEmpty(contentLocation)) {\n                        File f = new File(contentLocation);\n                        contentLocation = \"_\" + f.getName();\n                    } else {\n                        contentLocation = \"\";\n                    }\n\n                    // Generate the '_data' field of the part with default\n                    // permission settings.\n                    path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                            + \"/PART_\" + System.currentTimeMillis() + contentLocation;\n\n                    if (DownloadDrmHelper.isDrmConvertNeeded(contentType)) {\n                        // Adds the .fl extension to the filename if contentType is\n                        // \"application/vnd.oma.drm.message\"\n                        path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n                    }\n                }\n\n                finalValues.put(Part._DATA, path);\n\n                File partFile = new File(path);\n                if (!partFile.exists()) {\n                    try {\n                        if (!partFile.createNewFile()) {\n                            throw new IllegalStateException(\n                                    \"Unable to create new partFile: \" + path);\n                        }\n                        // Give everyone rw permission until we encrypt the file\n                        // (in PduPersister.persistData). Once the file is encrypted, the\n                        // permissions will be set to 0644.\n                        try {\n                            Os.chmod(path, 0666);\n                            if (LOCAL_LOGV) {\n                                Log.d(TAG, \"MmsProvider.insert chmod is successful\");\n                            }\n                        } catch (ErrnoException e) {\n                            Log.e(TAG, \"Exception in chmod: \" + e);\n                        }\n                    } catch (IOException e) {\n                        Log.e(TAG, \"createNewFile\", e);\n                        throw new IllegalStateException(\n                                \"Unable to create new partFile: \" + path);\n                    }\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n\n            res = Uri.parse(res + \"/part/\" + rowId);\n\n            // Don't use a trigger for updating the words table because of a bug\n            // in FTS3.  The bug is such that the call to get the last inserted\n            // row is incorrect.\n            if (plainText) {\n                // Update the words table with a corresponding row.  The words table\n                // allows us to search for words quickly, without scanning the whole\n                // table;\n                ContentValues cv = new ContentValues();\n\n                // we're using the row id of the part table row but we're also using ids\n                // from the sms table so this divides the space into two large chunks.\n                // The row ids from the part table start at 2 << 32.\n                cv.put(Telephony.MmsSms.WordsTable.ID, (2L << 32) + rowId);\n                cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"text\"));\n                cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowId);\n                cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 2);\n                db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n            }\n\n        } else if (table.equals(TABLE_RATE)) {\n            long now = values.getAsLong(Rate.SENT_TIME);\n            long oneHourAgo = now - 1000 * 60 * 60;\n            // Delete all unused rows (time earlier than one hour ago).\n            db.delete(table, Rate.SENT_TIME + \"<=\" + oneHourAgo, null);\n            db.insert(table, null, values);\n        } else if (table.equals(TABLE_DRM)) {\n            String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath()\n                    + \"/PART_\" + System.currentTimeMillis();\n            finalValues = new ContentValues(1);\n            finalValues.put(\"_data\", path);\n\n            File partFile = new File(path);\n            if (!partFile.exists()) {\n                try {\n                    if (!partFile.createNewFile()) {\n                        throw new IllegalStateException(\n                                \"Unable to create new file: \" + path);\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"createNewFile\", e);\n                    throw new IllegalStateException(\n                            \"Unable to create new file: \" + path);\n                }\n            }\n\n            if ((rowId = db.insert(table, null, finalValues)) <= 0) {\n                Log.e(TAG, \"MmsProvider.insert: failed!\");\n                return null;\n            }\n            res = Uri.parse(res + \"/drm/\" + rowId);\n        } else {\n            throw new AssertionError(\"Unknown table type: \" + table);\n        }\n\n        if (notify) {\n            notifyChange(res, caseSpecificUri);\n        }\n        return res;\n    }\n\n    private int getMessageBoxByMatch(int match) {\n        switch (match) {\n            case MMS_INBOX_ID:\n            case MMS_INBOX:\n                return Mms.MESSAGE_BOX_INBOX;\n            case MMS_SENT_ID:\n            case MMS_SENT:\n                return Mms.MESSAGE_BOX_SENT;\n            case MMS_DRAFTS_ID:\n            case MMS_DRAFTS:\n                return Mms.MESSAGE_BOX_DRAFTS;\n            case MMS_OUTBOX_ID:\n            case MMS_OUTBOX:\n                return Mms.MESSAGE_BOX_OUTBOX;\n            default:\n                throw new IllegalArgumentException(\"bad Arg: \" + match);\n        }\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Delete uri=\" + uri + \", match=\" + match);\n        }\n\n        String table, extraSelection = null;\n        boolean notify = false;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                notify = true;\n                table = TABLE_PDU;\n                extraSelection = Mms._ID + \"=\" + uri.getLastPathSegment();\n                break;\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                if (match != MMS_ALL) {\n                    int msgBox = getMessageBoxByMatch(match);\n                    extraSelection = Mms.MESSAGE_BOX + \"=\" + msgBox;\n                }\n                break;\n            case MMS_ALL_PART:\n                table = TABLE_PART;\n                break;\n            case MMS_MSG_PART:\n                table = TABLE_PART;\n                extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                break;\n            case MMS_MSG_ADDR:\n                table = TABLE_ADDR;\n                extraSelection = Addr.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                break;\n            case MMS_DRM_STORAGE:\n                table = TABLE_DRM;\n                break;\n            default:\n                Log.w(TAG, \"No match for URI '\" + uri + \"'\");\n                return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int deletedRows = 0;\n\n        if (TABLE_PDU.equals(table)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0.\n                return 0;\n            }\n            finalSelection = DatabaseUtils.concatenateWhere(finalSelection, selectionBySubIds);\n\n            deletedRows = deleteMessages(getContext(), db, finalSelection,\n                                         selectionArgs, uri);\n        } else if (TABLE_PART.equals(table)) {\n            deletedRows = deleteParts(db, finalSelection, selectionArgs);\n        } else if (TABLE_DRM.equals(table)) {\n            deletedRows = deleteTempDrmData(db, finalSelection, selectionArgs);\n        } else {\n            deletedRows = db.delete(table, finalSelection, selectionArgs);\n        }\n\n        if ((deletedRows > 0) && notify) {\n            notifyChange(uri, null);\n        }\n        return deletedRows;\n    }\n\n    static int deleteMessages(Context context, SQLiteDatabase db,\n            String selection, String[] selectionArgs, Uri uri) {\n        Cursor cursor = db.query(TABLE_PDU, new String[] { Mms._ID },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                deleteParts(db, Part.MSG_ID + \" = ?\",\n                        new String[] { String.valueOf(cursor.getLong(0)) });\n            }\n        } finally {\n            cursor.close();\n        }\n\n        int count = db.delete(TABLE_PDU, selection, selectionArgs);\n        if (count > 0) {\n            Intent intent = new Intent(Mms.Intents.CONTENT_CHANGED_ACTION);\n            intent.putExtra(Mms.Intents.DELETED_CONTENTS, uri);\n            if (LOCAL_LOGV) {\n                Log.v(TAG, \"Broadcasting intent: \" + intent);\n            }\n            context.sendBroadcast(intent);\n        }\n        return count;\n    }\n\n    private static int deleteParts(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_PART, selection, selectionArgs);\n    }\n\n    private static int deleteTempDrmData(SQLiteDatabase db, String selection,\n            String[] selectionArgs) {\n        return deleteDataRows(db, TABLE_DRM, selection, selectionArgs);\n    }\n\n    private static int deleteDataRows(SQLiteDatabase db, String table,\n            String selection, String[] selectionArgs) {\n        Cursor cursor = db.query(table, new String[] { \"_data\" },\n                selection, selectionArgs, null, null, null);\n        if (cursor == null) {\n            // FIXME: This might be an error, ignore it may cause\n            // unpredictable result.\n            return 0;\n        }\n\n        try {\n            if (cursor.getCount() == 0) {\n                return 0;\n            }\n\n            while (cursor.moveToNext()) {\n                try {\n                    // Delete the associated files saved on file-system.\n                    String path = cursor.getString(0);\n                    if (path != null) {\n                        new File(path).delete();\n                    }\n                } catch (Throwable ex) {\n                    Log.e(TAG, ex.getMessage(), ex);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return db.delete(table, selection, selectionArgs);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        // The _data column is filled internally in MmsProvider, so this check is just to avoid\n        // it from being inadvertently set. This is not supposed to be a protection against\n        // malicious attack, since sql injection could still be attempted to bypass the check. On\n        // the other hand, the MmsProvider does verify that the _data column has an allowed value\n        // before opening any uri/files.\n        if (values != null && values.containsKey(Part._DATA)) {\n            return 0;\n        }\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int match = sURLMatcher.match(uri);\n        if (LOCAL_LOGV) {\n            Log.v(TAG, \"Update uri=\" + uri + \", match=\" + match);\n        }\n\n        boolean notify = false;\n        String msgId = null;\n        String table;\n\n        switch (match) {\n            case MMS_ALL_ID:\n            case MMS_INBOX_ID:\n            case MMS_SENT_ID:\n            case MMS_DRAFTS_ID:\n            case MMS_OUTBOX_ID:\n                msgId = uri.getLastPathSegment();\n            // fall-through\n            case MMS_ALL:\n            case MMS_INBOX:\n            case MMS_SENT:\n            case MMS_DRAFTS:\n            case MMS_OUTBOX:\n                notify = true;\n                table = TABLE_PDU;\n                break;\n\n            case MMS_MSG_PART:\n            case MMS_PART_ID:\n                table = TABLE_PART;\n                break;\n\n            case MMS_PART_RESET_FILE_PERMISSION:\n                String path = getContext().getDir(PARTS_DIR_NAME, 0).getPath() + '/' +\n                        uri.getPathSegments().get(1);\n\n                try {\n                    String partsDirPath = getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath();\n                    if (!new File(path).getCanonicalPath().startsWith(partsDirPath)) {\n                        EventLog.writeEvent(0x534e4554, \"240685104\",\n                                callerUid, (TAG + \" update: path \" + path +\n                                        \" does not start with \" + partsDirPath));\n                        return 0;\n                    }\n                    // Reset the file permission back to read for everyone but me.\n                    Os.chmod(path, 0644);\n                    if (LOCAL_LOGV) {\n                        Log.d(TAG, \"MmsProvider.update chmod is successful for path: \" + path);\n                    }\n                } catch (ErrnoException | IOException e) {\n                    Log.e(TAG, \"Exception in chmod: \" + e);\n                }\n                return 0;\n\n            default:\n                Log.w(TAG, \"Update operation for '\" + uri + \"' not implemented.\");\n                return 0;\n        }\n\n        String extraSelection = null;\n        ContentValues finalValues;\n        if (table.equals(TABLE_PDU)) {\n            // Filter keys that we don't support yet.\n            filterUnsupportedKeys(values);\n            if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n                // CREATOR should not be changed by non-SYSTEM/PHONE apps\n                Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n                values.remove(Mms.CREATOR);\n            }\n            finalValues = new ContentValues(values);\n\n            if (msgId != null) {\n                extraSelection = Mms._ID + \"=\" + msgId;\n            }\n\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter MMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0.\n                return 0;\n            }\n            extraSelection = DatabaseUtils.concatenateWhere(extraSelection, selectionBySubIds);\n        } else if (table.equals(TABLE_PART)) {\n            finalValues = new ContentValues(values);\n\n            switch (match) {\n                case MMS_MSG_PART:\n                    extraSelection = Part.MSG_ID + \"=\" + uri.getPathSegments().get(0);\n                    break;\n                case MMS_PART_ID:\n                    extraSelection = Part._ID + \"=\" + uri.getPathSegments().get(1);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            return 0;\n        }\n\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count = db.update(table, finalValues, finalSelection, selectionArgs);\n        if (notify && (count > 0)) {\n            notifyChange(uri, null);\n        }\n        return count;\n    }\n\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        int match = sURLMatcher.match(uri);\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"openFile: uri=\" + uri + \", mode=\" + mode + \", match=\" + match);\n        }\n\n        if (match != MMS_PART_ID) {\n            return null;\n        }\n\n        return safeOpenFileHelper(uri, mode);\n    }\n\n    @NonNull\n    private ParcelFileDescriptor safeOpenFileHelper(\n            @NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {\n        Cursor c = query(uri, new String[]{\"_data\"}, null, null, null);\n        int count = (c != null) ? c.getCount() : 0;\n        if (count != 1) {\n            // If there is not exactly one result, throw an appropriate\n            // exception.\n            if (c != null) {\n                c.close();\n            }\n            if (count == 0) {\n                throw new FileNotFoundException(\"No entry for \" + uri);\n            }\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        c.moveToFirst();\n        int i = c.getColumnIndex(\"_data\");\n        String path = (i >= 0 ? c.getString(i) : null);\n        c.close();\n\n        if (path == null) {\n            throw new FileNotFoundException(\"Column _data not found.\");\n        }\n\n        File filePath = new File(path);\n        try {\n            // The MmsProvider shouldn't open a file that isn't MMS data, so we verify that the\n            // _data path actually points to MMS data. That safeguards ourselves from callers who\n            // inserted or updated a URI (more specifically the _data column) with disallowed paths.\n            // TODO(afurtado): provide a more robust mechanism to avoid disallowed _data paths to\n            // be inserted/updated in the first place, including via SQL injection.\n            if (!filePath.getCanonicalPath()\n                    .startsWith(getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath())) {\n                Log.e(TAG, \"openFile: path \"\n                        + filePath.getCanonicalPath()\n                        + \" does not start with \"\n                        + getContext().getDir(PARTS_DIR_NAME, 0).getCanonicalPath());\n                // Don't care return value\n                return null;\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"openFile: create path failed \" + e, e);\n            return null;\n        }\n\n        int modeBits = ParcelFileDescriptor.parseMode(mode);\n        return ParcelFileDescriptor.open(filePath, modeBits);\n    }\n\n    private void filterUnsupportedKeys(ContentValues values) {\n        // Some columns are unsupported.  They should therefore\n        // neither be inserted nor updated.  Filter them out.\n        values.remove(Mms.DELIVERY_TIME_TOKEN);\n        values.remove(Mms.SENDER_VISIBILITY);\n        values.remove(Mms.REPLY_CHARGING);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE_TOKEN);\n        values.remove(Mms.REPLY_CHARGING_DEADLINE);\n        values.remove(Mms.REPLY_CHARGING_ID);\n        values.remove(Mms.REPLY_CHARGING_SIZE);\n        values.remove(Mms.PREVIOUSLY_SENT_BY);\n        values.remove(Mms.PREVIOUSLY_SENT_DATE);\n        values.remove(Mms.STORE);\n        values.remove(Mms.MM_STATE);\n        values.remove(Mms.MM_FLAGS_TOKEN);\n        values.remove(Mms.MM_FLAGS);\n        values.remove(Mms.STORE_STATUS);\n        values.remove(Mms.STORE_STATUS_TEXT);\n        values.remove(Mms.STORED);\n        values.remove(Mms.TOTALS);\n        values.remove(Mms.MBOX_TOTALS);\n        values.remove(Mms.MBOX_TOTALS_TOKEN);\n        values.remove(Mms.QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS);\n        values.remove(Mms.MBOX_QUOTAS_TOKEN);\n        values.remove(Mms.MESSAGE_COUNT);\n        values.remove(Mms.START);\n        values.remove(Mms.DISTRIBUTION_INDICATOR);\n        values.remove(Mms.ELEMENT_DESCRIPTOR);\n        values.remove(Mms.LIMIT);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE);\n        values.remove(Mms.RECOMMENDED_RETRIEVAL_MODE_TEXT);\n        values.remove(Mms.STATUS_TEXT);\n        values.remove(Mms.APPLIC_ID);\n        values.remove(Mms.REPLY_APPLIC_ID);\n        values.remove(Mms.AUX_APPLIC_ID);\n        values.remove(Mms.DRM_CONTENT);\n        values.remove(Mms.ADAPTATION_ALLOWED);\n        values.remove(Mms.REPLACE_ID);\n        values.remove(Mms.CANCEL_ID);\n        values.remove(Mms.CANCEL_STATUS);\n\n        // Keys shouldn't be inserted or updated.\n        values.remove(Mms._ID);\n    }\n\n    private void notifyChange(final Uri uri, final Uri caseSpecificUri) {\n        final Context context = getContext();\n        if (caseSpecificUri != null) {\n            context.getContentResolver().notifyChange(\n                caseSpecificUri, null, true, UserHandle.USER_ALL);\n        }\n        context.getContentResolver().notifyChange(\n                MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        ProviderUtil.notifyIfNotDefaultSmsApp(caseSpecificUri == null ? uri : caseSpecificUri,\n                getCallingPackage(), context);\n    }\n\n    private final static String TAG = \"MmsProvider\";\n    private final static String VND_ANDROID_MMS = \"vnd.android/mms\";\n    private final static String VND_ANDROID_DIR_MMS = \"vnd.android-dir/mms\";\n    private final static boolean DEBUG = false;\n    private final static boolean LOCAL_LOGV = false;\n\n    private static final int MMS_ALL                      = 0;\n    private static final int MMS_ALL_ID                   = 1;\n    private static final int MMS_INBOX                    = 2;\n    private static final int MMS_INBOX_ID                 = 3;\n    private static final int MMS_SENT                     = 4;\n    private static final int MMS_SENT_ID                  = 5;\n    private static final int MMS_DRAFTS                   = 6;\n    private static final int MMS_DRAFTS_ID                = 7;\n    private static final int MMS_OUTBOX                   = 8;\n    private static final int MMS_OUTBOX_ID                = 9;\n    private static final int MMS_ALL_PART                 = 10;\n    private static final int MMS_MSG_PART                 = 11;\n    private static final int MMS_PART_ID                  = 12;\n    private static final int MMS_MSG_ADDR                 = 13;\n    private static final int MMS_SENDING_RATE             = 14;\n    private static final int MMS_REPORT_STATUS            = 15;\n    private static final int MMS_REPORT_REQUEST           = 16;\n    private static final int MMS_DRM_STORAGE              = 17;\n    private static final int MMS_DRM_STORAGE_ID           = 18;\n    private static final int MMS_THREADS                  = 19;\n    private static final int MMS_PART_RESET_FILE_PERMISSION = 20;\n\n    private static final UriMatcher\n            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         MMS_ALL);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"sent\",       MMS_SENT);\n        sURLMatcher.addURI(\"mms\", \"sent/#\",     MMS_SENT_ID);\n        sURLMatcher.addURI(\"mms\", \"drafts\",     MMS_DRAFTS);\n        sURLMatcher.addURI(\"mms\", \"drafts/#\",   MMS_DRAFTS_ID);\n        sURLMatcher.addURI(\"mms\", \"outbox\",     MMS_OUTBOX);\n        sURLMatcher.addURI(\"mms\", \"outbox/#\",   MMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"mms\", \"part\",       MMS_ALL_PART);\n        sURLMatcher.addURI(\"mms\", \"#/part\",     MMS_MSG_PART);\n        sURLMatcher.addURI(\"mms\", \"part/#\",     MMS_PART_ID);\n        sURLMatcher.addURI(\"mms\", \"#/addr\",     MMS_MSG_ADDR);\n        sURLMatcher.addURI(\"mms\", \"rate\",       MMS_SENDING_RATE);\n        sURLMatcher.addURI(\"mms\", \"report-status/#\",  MMS_REPORT_STATUS);\n        sURLMatcher.addURI(\"mms\", \"report-request/#\", MMS_REPORT_REQUEST);\n        sURLMatcher.addURI(\"mms\", \"drm\",        MMS_DRM_STORAGE);\n        sURLMatcher.addURI(\"mms\", \"drm/#\",      MMS_DRM_STORAGE_ID);\n        sURLMatcher.addURI(\"mms\", \"threads\",    MMS_THREADS);\n        sURLMatcher.addURI(\"mms\", \"resetFilePerm/*\",    MMS_PART_RESET_FILE_PERMISSION);\n    }\n\n    @VisibleForTesting\n    public SQLiteOpenHelper mOpenHelper;\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n}\n","lineNo":117}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyStatsLog;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    // Call() methods and parameters\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n    private static final String METHOD_GARBAGE_COLLECT = \"garbage_collect\";\n    private static final String DO_DELETE = \"delete\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                cursor = getFirstLockedMessage(projection, \"thread_id=\" + Long.toString(threadId),\n                        sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase(Locale.ROOT) : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        if (matchIndex == URI_PENDING_MSG) {\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            return null;\n        }\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        } else if (METHOD_GARBAGE_COLLECT.equals(method)) {\n            Bundle result = new Bundle();\n            boolean doDelete = TextUtils.equals(DO_DELETE, arg);\n            MmsPartsCleanup.cleanupDanglingParts(getContext(), doDelete, result);\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.provider.BaseColumns;\nimport android.provider.Telephony;\nimport android.provider.Telephony.CanonicalAddressesColumns;\nimport android.provider.Telephony.Mms;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.MmsSms.PendingMessages;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Sms.Conversations;\nimport android.provider.Telephony.Threads;\nimport android.provider.Telephony.ThreadsColumns;\nimport android.telephony.SmsManager;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.telephony.TelephonyPermissions;\nimport com.android.internal.telephony.TelephonyStatsLog;\n\nimport com.google.android.mms.pdu.PduHeaders;\n\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\n/**\n * This class provides the ability to query the MMS and SMS databases\n * at the same time, mixing messages from both in a single thread\n * (A.K.A. conversation).\n *\n * A virtual column, MmsSms.TYPE_DISCRIMINATOR_COLUMN, may be\n * requested in the projection for a query.  Its value is either \"mms\"\n * or \"sms\", depending on whether the message represented by the row\n * is an MMS message or an SMS message, respectively.\n *\n * This class also provides the ability to find out what addresses\n * participated in a particular thread.  It doesn't support updates\n * for either of these.\n *\n * This class provides a way to allocate and retrieve thread IDs.\n * This is done atomically through a query.  There is no insert URI\n * for this.\n *\n * Finally, this class provides a way to delete or update all messages\n * in a thread.\n */\npublic class MmsSmsProvider extends ContentProvider {\n    private static final UriMatcher URI_MATCHER =\n            new UriMatcher(UriMatcher.NO_MATCH);\n    private static final String LOG_TAG = \"MmsSmsProvider\";\n    private static final boolean DEBUG = false;\n    private static final int MULTIPLE_THREAD_IDS_FOUND = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_MULTIPLE_THREAD_IDS_FOUND;\n    private static final int FAILURE_FIND_OR_CREATE_THREAD_ID_SQL = TelephonyStatsLog\n        .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_FIND_OR_CREATE_THREAD_ID_SQL;\n\n    private static final String NO_DELETES_INSERTS_OR_UPDATES =\n            \"MmsSmsProvider does not support deletes, inserts, or updates for this URI.\";\n    private static final int URI_CONVERSATIONS                     = 0;\n    private static final int URI_CONVERSATIONS_MESSAGES            = 1;\n    private static final int URI_CONVERSATIONS_RECIPIENTS          = 2;\n    private static final int URI_MESSAGES_BY_PHONE                 = 3;\n    private static final int URI_THREAD_ID                         = 4;\n    private static final int URI_CANONICAL_ADDRESS                 = 5;\n    private static final int URI_PENDING_MSG                       = 6;\n    private static final int URI_COMPLETE_CONVERSATIONS            = 7;\n    private static final int URI_UNDELIVERED_MSG                   = 8;\n    private static final int URI_CONVERSATIONS_SUBJECT             = 9;\n    private static final int URI_NOTIFICATIONS                     = 10;\n    private static final int URI_OBSOLETE_THREADS                  = 11;\n    private static final int URI_DRAFT                             = 12;\n    private static final int URI_CANONICAL_ADDRESSES               = 13;\n    private static final int URI_SEARCH                            = 14;\n    private static final int URI_SEARCH_SUGGEST                    = 15;\n    private static final int URI_FIRST_LOCKED_MESSAGE_ALL          = 16;\n    private static final int URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID = 17;\n    private static final int URI_MESSAGE_ID_TO_THREAD              = 18;\n\n    /**\n     * the name of the table that is used to store the queue of\n     * messages(both MMS and SMS) to be sent/downloaded.\n     */\n    public static final String TABLE_PENDING_MSG = \"pending_msgs\";\n\n    /**\n     * the name of the table that is used to store the canonical addresses for both SMS and MMS.\n     */\n    static final String TABLE_CANONICAL_ADDRESSES = \"canonical_addresses\";\n\n    /**\n     * the name of the table that is used to store the conversation threads.\n     */\n    static final String TABLE_THREADS = \"threads\";\n\n    // These constants are used to construct union queries across the\n    // MMS and SMS base tables.\n\n    // These are the columns that appear in both the MMS (\"pdu\") and\n    // SMS (\"sms\") message tables.\n    private static final String[] MMS_SMS_COLUMNS =\n            { BaseColumns._ID, Mms.DATE, Mms.DATE_SENT, Mms.READ, Mms.THREAD_ID, Mms.LOCKED,\n                    Mms.SUBSCRIPTION_ID };\n\n    // These are the columns that appear only in the MMS message\n    // table.\n    private static final String[] MMS_ONLY_COLUMNS = {\n        Mms.CONTENT_CLASS, Mms.CONTENT_LOCATION, Mms.CONTENT_TYPE,\n        Mms.DELIVERY_REPORT, Mms.EXPIRY, Mms.MESSAGE_CLASS, Mms.MESSAGE_ID,\n        Mms.MESSAGE_SIZE, Mms.MESSAGE_TYPE, Mms.MESSAGE_BOX, Mms.PRIORITY,\n        Mms.READ_STATUS, Mms.RESPONSE_STATUS, Mms.RESPONSE_TEXT,\n        Mms.RETRIEVE_STATUS, Mms.RETRIEVE_TEXT_CHARSET, Mms.REPORT_ALLOWED,\n        Mms.READ_REPORT, Mms.STATUS, Mms.SUBJECT, Mms.SUBJECT_CHARSET,\n        Mms.TRANSACTION_ID, Mms.MMS_VERSION, Mms.TEXT_ONLY };\n\n    // These are the columns that appear only in the SMS message\n    // table.\n    private static final String[] SMS_ONLY_COLUMNS =\n            { \"address\", \"body\", \"person\", \"reply_path_present\",\n              \"service_center\", \"status\", \"subject\", \"type\", \"error_code\" };\n\n    // These are all the columns that appear in the \"threads\" table.\n    private static final String[] THREADS_COLUMNS = {\n        BaseColumns._ID,\n        ThreadsColumns.DATE,\n        ThreadsColumns.RECIPIENT_IDS,\n        ThreadsColumns.MESSAGE_COUNT\n    };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_1 =\n            new String[] { CanonicalAddressesColumns.ADDRESS };\n\n    private static final String[] CANONICAL_ADDRESSES_COLUMNS_2 =\n            new String[] { CanonicalAddressesColumns._ID,\n                    CanonicalAddressesColumns.ADDRESS };\n\n    // These are all the columns that appear in the MMS and SMS\n    // message tables.\n    private static final String[] UNION_COLUMNS =\n            new String[MMS_SMS_COLUMNS.length\n                       + MMS_ONLY_COLUMNS.length\n                       + SMS_ONLY_COLUMNS.length];\n\n    // These are all the columns that appear in the MMS table.\n    private static final Set<String> MMS_COLUMNS = new HashSet<String>();\n\n    // These are all the columns that appear in the SMS table.\n    private static final Set<String> SMS_COLUMNS = new HashSet<String>();\n\n    private static final String VND_ANDROID_DIR_MMS_SMS =\n            \"vnd.android-dir/mms-sms\";\n\n    private static final String[] ID_PROJECTION = { BaseColumns._ID };\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final String[] SEARCH_STRING = new String[1];\n    private static final String SEARCH_QUERY = \"SELECT snippet(words, '', ' ', '', 1, 1) as \" +\n            \"snippet FROM words WHERE index_text MATCH ? ORDER BY snippet LIMIT 50;\";\n\n    private static final String SMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Sms.TYPE + \" != \" + Sms.MESSAGE_TYPE_DRAFT + \")\";\n\n    private static final String MMS_CONVERSATION_CONSTRAINT = \"(\" +\n            Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS + \" AND (\" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_SEND_REQ + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF + \" OR \" +\n            Mms.MESSAGE_TYPE + \" = \" + PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND + \"))\";\n\n    private static String getTextSearchQuery(String smsTable, String pduTable) {\n        // Search on the words table but return the rows from the corresponding sms table\n        final String smsQuery = \"SELECT \"\n                + smsTable + \"._id AS _id,\"\n                + \"thread_id,\"\n                + \"address,\"\n                + \"body,\"\n                + \"date,\"\n                + \"date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + smsTable + \",words \"\n                + \"WHERE (index_text MATCH ? \"\n                + \"AND \" + smsTable + \"._id=words.source_id \"\n                + \"AND words.table_to_use=1)\";\n\n        // Search on the words table but return the rows from the corresponding parts table\n        final String mmsQuery = \"SELECT \"\n                + pduTable + \"._id,\"\n                + \"thread_id,\"\n                + \"addr.address,\"\n                + \"part.text AS body,\"\n                + pduTable + \".date,\"\n                + pduTable + \".date_sent,\"\n                + \"index_text,\"\n                + \"words._id \"\n                + \"FROM \" + pduTable + \",part,addr,words \"\n                + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                + \"AND (addr.msg_id=\" + pduTable + \"._id) \"\n                + \"AND (addr.type=\" + PduHeaders.TO + \") \"\n                + \"AND (part.ct='text/plain') \"\n                + \"AND (index_text MATCH ?) \"\n                + \"AND (part._id = words.source_id) \"\n                + \"AND (words.table_to_use=2))\";\n\n        // This code queries the sms and mms tables and returns a unified result set\n        // of text matches.  We query the sms table which is pretty simple.  We also\n        // query the pdu, part and addr table to get the mms result.  Note we're\n        // using a UNION so we have to have the same number of result columns from\n        // both queries.\n        return smsQuery + \" UNION \" + mmsQuery + \" \"\n                + \"GROUP BY thread_id \"\n                + \"ORDER BY thread_id ASC, date DESC\";\n    }\n\n    private static final String AUTHORITY = \"mms-sms\";\n\n    static {\n        URI_MATCHER.addURI(AUTHORITY, \"conversations\", URI_CONVERSATIONS);\n        URI_MATCHER.addURI(AUTHORITY, \"complete-conversations\", URI_COMPLETE_CONVERSATIONS);\n\n        // In these patterns, \"#\" is the thread ID.\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#\", URI_CONVERSATIONS_MESSAGES);\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/recipients\",\n                URI_CONVERSATIONS_RECIPIENTS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"conversations/#/subject\",\n                URI_CONVERSATIONS_SUBJECT);\n\n        // URI for deleting obsolete threads.\n        URI_MATCHER.addURI(AUTHORITY, \"conversations/obsolete\", URI_OBSOLETE_THREADS);\n\n        URI_MATCHER.addURI(\n                AUTHORITY, \"messages/byphone/*\",\n                URI_MESSAGES_BY_PHONE);\n\n        // In this pattern, two query parameter names are expected:\n        // \"subject\" and \"recipient.\"  Multiple \"recipient\" parameters\n        // may be present.\n        URI_MATCHER.addURI(AUTHORITY, \"threadID\", URI_THREAD_ID);\n\n        // Use this pattern to query the canonical address by given ID.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-address/#\", URI_CANONICAL_ADDRESS);\n\n        // Use this pattern to query all canonical addresses.\n        URI_MATCHER.addURI(AUTHORITY, \"canonical-addresses\", URI_CANONICAL_ADDRESSES);\n\n        URI_MATCHER.addURI(AUTHORITY, \"search\", URI_SEARCH);\n        URI_MATCHER.addURI(AUTHORITY, \"searchSuggest\", URI_SEARCH_SUGGEST);\n\n        // In this pattern, two query parameters may be supplied:\n        // \"protocol\" and \"message.\" For example:\n        //   content://mms-sms/pending?\n        //       -> Return all pending messages;\n        //   content://mms-sms/pending?protocol=sms\n        //       -> Only return pending SMs;\n        //   content://mms-sms/pending?protocol=mms&message=1\n        //       -> Return the the pending MM which ID equals '1'.\n        //\n        URI_MATCHER.addURI(AUTHORITY, \"pending\", URI_PENDING_MSG);\n\n        // Use this pattern to get a list of undelivered messages.\n        URI_MATCHER.addURI(AUTHORITY, \"undelivered\", URI_UNDELIVERED_MSG);\n\n        // Use this pattern to see what delivery status reports (for\n        // both MMS and SMS) have not been delivered to the user.\n        URI_MATCHER.addURI(AUTHORITY, \"notifications\", URI_NOTIFICATIONS);\n\n        URI_MATCHER.addURI(AUTHORITY, \"draft\", URI_DRAFT);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked\", URI_FIRST_LOCKED_MESSAGE_ALL);\n\n        URI_MATCHER.addURI(AUTHORITY, \"locked/#\", URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID);\n\n        URI_MATCHER.addURI(AUTHORITY, \"messageIdToThread\", URI_MESSAGE_ID_TO_THREAD);\n        initializeColumnSets();\n    }\n\n    private SQLiteOpenHelper mOpenHelper;\n\n    private boolean mUseStrictPhoneNumberComparation;\n\n    // Call() methods and parameters\n    private static final String METHOD_IS_RESTORING = \"is_restoring\";\n    private static final String IS_RESTORING_KEY = \"restoring\";\n    private static final String METHOD_GARBAGE_COLLECT = \"garbage_collect\";\n    private static final String DO_DELETE = \"delete\";\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        mOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        mUseStrictPhoneNumberComparation =\n            getContext().getResources().getBoolean(\n                    com.android.internal.R.bool.config_use_strict_phone_number_comparation);\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    @Override\n    public Cursor query(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if restricted views of the \"sms\" and \"pdu\" tables should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms/mms data. For other apps, we present a restricted view which only contains sent\n        // or received messages, without wap pushes.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callerUid);\n        final String pduTable = MmsProvider.getPduTable(accessRestricted);\n        final String smsTable = SmsProvider.getSmsTable(accessRestricted);\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projection, selection, sortOrder);\n            } catch (IllegalArgumentException e) {\n                Log.w(LOG_TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        Cursor cursor = null;\n        Cursor emptyCursor = new MatrixCursor((projection == null) ?\n                (new String[] {}) : projection);\n        final int match = URI_MATCHER.match(uri);\n        switch (match) {\n            case URI_COMPLETE_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getCompleteConversations(projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_CONVERSATIONS:\n                String simple = uri.getQueryParameter(\"simple\");\n                if ((simple != null) && simple.equals(\"true\")) {\n                    String threadType = uri.getQueryParameter(\"thread_type\");\n                    if (!TextUtils.isEmpty(threadType)) {\n                        try {\n                            Integer.parseInt(threadType);\n                            selection = concatSelections(\n                                    selection, Threads.TYPE + \"=\" + threadType);\n                        } catch (NumberFormatException ex) {\n                            Log.e(LOG_TAG, \"Thread type must be int\");\n                            // return empty cursor\n                            break;\n                        }\n                    }\n                    cursor = getSimpleConversations(\n                            projection, selection, selectionArgs, sortOrder);\n                } else {\n                    if (selectionBySubIds == null) {\n                        // No subscriptions associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n                    selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                    cursor = getConversations(\n                            projection, selection, sortOrder, smsTable, pduTable);\n                }\n                break;\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getConversationMessages(uri.getPathSegments().get(1), projection,\n                        selection, sortOrder, smsTable, pduTable);\n                break;\n            case URI_CONVERSATIONS_RECIPIENTS:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_CONVERSATIONS_SUBJECT:\n                cursor = getConversationById(\n                        uri.getPathSegments().get(1), projection, selection,\n                        selectionArgs, sortOrder);\n                break;\n            case URI_MESSAGES_BY_PHONE:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return emptyCursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getMessagesByPhoneNumber(\n                        uri.getPathSegments().get(2), projection, selection, sortOrder, smsTable,\n                        pduTable);\n                break;\n            case URI_THREAD_ID:\n                List<String> recipients = uri.getQueryParameters(\"recipient\");\n\n                cursor = getThreadId(recipients);\n                break;\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_1,\n                        finalSelection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            }\n            case URI_CANONICAL_ADDRESSES:\n                cursor = db.query(TABLE_CANONICAL_ADDRESSES,\n                        CANONICAL_ADDRESSES_COLUMNS_2,\n                        selection,\n                        selectionArgs,\n                        null, null,\n                        sortOrder);\n                break;\n            case URI_SEARCH_SUGGEST: {\n                SEARCH_STRING[0] = uri.getQueryParameter(\"pattern\") + '*' ;\n\n                // find the words which match the pattern using the snippet function.  The\n                // snippet function parameters mainly describe how to format the result.\n                // See http://www.sqlite.org/fts3.html#section_4_2 for details.\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                cursor = db.rawQuery(SEARCH_QUERY, SEARCH_STRING);\n                break;\n            }\n            case URI_MESSAGE_ID_TO_THREAD: {\n                // Given a message ID and an indicator for SMS vs. MMS return\n                // the thread id of the corresponding thread.\n                try {\n                    long id = Long.parseLong(uri.getQueryParameter(\"row_id\"));\n                    switch (Integer.parseInt(uri.getQueryParameter(\"table_to_use\"))) {\n                        case 1:  // sms\n                            cursor = db.query(\n                                smsTable,\n                                new String[] { \"thread_id\" },\n                                \"_id=?\",\n                                new String[] { String.valueOf(id) },\n                                null,\n                                null,\n                                null);\n                            break;\n                        case 2:  // mms\n                            String mmsQuery = \"SELECT thread_id \"\n                                    + \"FROM \" + pduTable + \",part \"\n                                    + \"WHERE ((part.mid=\" + pduTable + \"._id) \"\n                                    + \"AND \" + \"(part._id=?))\";\n                            cursor = db.rawQuery(mmsQuery, new String[] { String.valueOf(id) });\n                            break;\n                    }\n                } catch (NumberFormatException ex) {\n                    // ignore... return empty cursor\n                }\n                break;\n            }\n            case URI_SEARCH: {\n                if (       sortOrder != null\n                        || selection != null\n                        || selectionArgs != null\n                        || projection != null) {\n                    throw new IllegalArgumentException(\n                            \"do not specify sortOrder, selection, selectionArgs, or projection\" +\n                            \"with this query\");\n                }\n\n                String searchString = uri.getQueryParameter(\"pattern\") + \"*\";\n\n                try {\n                    cursor = db.rawQuery(getTextSearchQuery(smsTable, pduTable),\n                            new String[] { searchString, searchString });\n                } catch (Exception ex) {\n                    Log.e(LOG_TAG, \"got exception: \" + ex.toString());\n                }\n                break;\n            }\n            case URI_PENDING_MSG: {\n                String protoName = uri.getQueryParameter(\"protocol\");\n                String msgId = uri.getQueryParameter(\"message\");\n                int proto = TextUtils.isEmpty(protoName) ? -1\n                        : (protoName.equals(\"sms\") ? MmsSms.SMS_PROTO : MmsSms.MMS_PROTO);\n\n                String extraSelection = (proto != -1) ?\n                        (PendingMessages.PROTO_TYPE + \"=\" + proto) : \" 0=0 \";\n                if (!TextUtils.isEmpty(msgId)) {\n                    try {\n                        Long.parseLong(msgId);\n                        extraSelection += \" AND \" + PendingMessages.MSG_ID + \"=\" + msgId;\n                    } catch(NumberFormatException ex) {\n                        Log.e(LOG_TAG, \"MSG ID must be a Long.\");\n                        // return empty cursor\n                        break;\n                    }\n                }\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : (\"(\" + extraSelection + \") AND \" + selection);\n                String finalOrder = TextUtils.isEmpty(sortOrder)\n                        ? PendingMessages.DUE_TIME : sortOrder;\n                cursor = db.query(TABLE_PENDING_MSG, null,\n                        finalSelection, selectionArgs, null, null, finalOrder);\n                break;\n            }\n            case URI_UNDELIVERED_MSG: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getUndeliveredMessages(projection, selection,\n                        selectionArgs, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_DRAFT: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getDraftThread(projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_BY_THREAD_ID: {\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, (\"thread_id=\" + threadId));\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(projection, selection, sortOrder,\n                        smsTable, pduTable);\n                break;\n            }\n            case URI_FIRST_LOCKED_MESSAGE_ALL: {\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return empty cursor.\n                    return emptyCursor;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                cursor = getFirstLockedMessage(\n                        projection, selection, sortOrder, smsTable, pduTable);\n                break;\n            }\n            default:\n                throw new IllegalStateException(\"Unrecognized URI:\" + uri);\n        }\n\n        if (cursor != null) {\n            cursor.setNotificationUri(getContext().getContentResolver(), MmsSms.CONTENT_URI);\n        }\n        return cursor;\n    }\n\n    /**\n     * Return the canonical address ID for this address.\n     */\n    private long getSingleAddressId(String address) {\n        boolean isEmail = Mms.isEmailAddress(address);\n        boolean isPhoneNumber = Mms.isPhoneNumber(address);\n\n        // We lowercase all email addresses, but not addresses that aren't numbers, because\n        // that would incorrectly turn an address such as \"My Vodafone\" into \"my vodafone\"\n        // and the thread title would be incorrect when displayed in the UI.\n        String refinedAddress = isEmail ? address.toLowerCase(Locale.ROOT) : address;\n\n        String selection = \"address=?\";\n        String[] selectionArgs;\n        long retVal = -1L;\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n\n        if (!isPhoneNumber) {\n            selectionArgs = new String[] { refinedAddress };\n        } else {\n            selection += \" OR PHONE_NUMBERS_EQUAL(address, ?, \" +\n                        (mUseStrictPhoneNumberComparation ? \"1)\" : \"0, \" + minMatch + \")\");\n            selectionArgs = new String[] { refinedAddress, refinedAddress };\n        }\n\n        Cursor cursor = null;\n\n        try {\n            SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n            cursor = db.query(\n                    \"canonical_addresses\", ID_PROJECTION,\n                    selection, selectionArgs, null, null, null);\n\n            if (cursor.getCount() == 0) {\n                ContentValues contentValues = new ContentValues(1);\n                contentValues.put(CanonicalAddressesColumns.ADDRESS, refinedAddress);\n\n                db = mOpenHelper.getWritableDatabase();\n                retVal = db.insert(\"canonical_addresses\",\n                        CanonicalAddressesColumns.ADDRESS, contentValues);\n\n                Log.d(LOG_TAG, \"getSingleAddressId: insert new canonical_address for \" +\n                        /*address*/ \"xxxxxx\" + \", _id=\" + retVal);\n\n                return retVal;\n            }\n\n            if (cursor.moveToFirst()) {\n                retVal = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        return retVal;\n    }\n\n    /**\n     * Return the canonical address IDs for these addresses.\n     */\n    private Set<Long> getAddressIds(List<String> addresses) {\n        Set<Long> result = new HashSet<Long>(addresses.size());\n\n        for (String address : addresses) {\n            if (!address.equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {\n                long id = getSingleAddressId(address);\n                if (id != -1L) {\n                    result.add(id);\n                } else {\n                    Log.e(LOG_TAG, \"getAddressIds: address ID not found for \" + address);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Return a sorted array of the given Set of Longs.\n     */\n    private long[] getSortedSet(Set<Long> numbers) {\n        int size = numbers.size();\n        long[] result = new long[size];\n        int i = 0;\n\n        for (Long number : numbers) {\n            result[i++] = number;\n        }\n\n        if (size > 1) {\n            Arrays.sort(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Return a String of the numbers in the given array, in order,\n     * separated by spaces.\n     */\n    private String getSpaceSeparatedNumbers(long[] numbers) {\n        int size = numbers.length;\n        StringBuilder buffer = new StringBuilder();\n\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                buffer.append(' ');\n            }\n            buffer.append(numbers[i]);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Insert a record for a new thread.\n     */\n    private void insertThread(String recipientIds, int numberOfRecipients) {\n        ContentValues values = new ContentValues(4);\n\n        long date = System.currentTimeMillis();\n        values.put(ThreadsColumns.DATE, date - date % 1000);\n        values.put(ThreadsColumns.RECIPIENT_IDS, recipientIds);\n        if (numberOfRecipients > 1) {\n            values.put(Threads.TYPE, Threads.BROADCAST_THREAD);\n        }\n        values.put(ThreadsColumns.MESSAGE_COUNT, 0);\n\n        long result = mOpenHelper.getWritableDatabase().insert(TABLE_THREADS, null, values);\n        Log.d(LOG_TAG, \"insertThread: created new thread_id \" + result +\n                \" for recipientIds \" + /*recipientIds*/ \"xxxxxxx\");\n\n        getContext().getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                UserHandle.USER_ALL);\n    }\n\n    private static final String THREAD_QUERY =\n            \"SELECT _id FROM threads \" + \"WHERE recipient_ids=?\";\n\n    /**\n     * Return the thread ID for this list of\n     * recipients IDs.  If no thread exists with this ID, create\n     * one and return it.  Callers should always use\n     * Threads.getThreadId to access this information.\n     */\n    private synchronized Cursor getThreadId(List<String> recipients) {\n        Set<Long> addressIds = getAddressIds(recipients);\n        String recipientIds = \"\";\n\n        if (addressIds.size() == 0) {\n            Log.e(LOG_TAG, \"getThreadId: NO receipients specified -- NOT creating thread\",\n                    new Exception());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                TelephonyStatsLog\n                    .MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED__FAILURE_CODE__FAILURE_NO_RECIPIENTS);\n            return null;\n        } else if (addressIds.size() == 1) {\n            // optimize for size==1, which should be most of the cases\n            for (Long addressId : addressIds) {\n                recipientIds = Long.toString(addressId);\n            }\n        } else {\n            recipientIds = getSpaceSeparatedNumbers(getSortedSet(addressIds));\n        }\n\n        if (Log.isLoggable(LOG_TAG, Log.VERBOSE)) {\n            Log.d(LOG_TAG, \"getThreadId: recipientIds (selectionArgs) =\" +\n                    /*recipientIds*/ \"xxxxxxx\");\n        }\n\n        String[] selectionArgs = new String[] { recipientIds };\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        db.beginTransaction();\n        Cursor cursor = null;\n        try {\n            // Find the thread with the given recipients\n            cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n\n            if (cursor.getCount() == 0) {\n                // No thread with those recipients exists, so create the thread.\n                cursor.close();\n\n                Log.d(LOG_TAG, \"getThreadId: create new thread_id for recipients \" +\n                        /*recipients*/ \"xxxxxxxx\");\n                insertThread(recipientIds, recipients.size());\n\n                // The thread was just created, now find it and return it.\n                cursor = db.rawQuery(THREAD_QUERY, selectionArgs);\n            }\n            db.setTransactionSuccessful();\n        } catch (Throwable ex) {\n            Log.e(LOG_TAG, ex.getMessage(), ex);\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                FAILURE_FIND_OR_CREATE_THREAD_ID_SQL);\n        } finally {\n            db.endTransaction();\n        }\n\n        if (cursor != null && cursor.getCount() > 1) {\n            Log.w(LOG_TAG, \"getThreadId: why is cursorCount=\" + cursor.getCount());\n            TelephonyStatsLog.write(\n                TelephonyStatsLog.MMS_SMS_PROVIDER_GET_THREAD_ID_FAILED,\n                MULTIPLE_THREAD_IDS_FOUND);\n        }\n        return cursor;\n    }\n\n    private static String concatSelections(String selection1, String selection2) {\n        if (TextUtils.isEmpty(selection1)) {\n            return selection2;\n        } else if (TextUtils.isEmpty(selection2)) {\n            return selection1;\n        } else {\n            return selection1 + \" AND \" + selection2;\n        }\n    }\n\n    /**\n     * If a null projection is given, return the union of all columns\n     * in both the MMS and SMS messages tables.  Otherwise, return the\n     * given projection.\n     */\n    private static String[] handleNullMessageProjection(\n            String[] projection) {\n        return projection == null ? UNION_COLUMNS : projection;\n    }\n\n    /**\n     * If a null projection is given, return the set of all columns in\n     * the threads table.  Otherwise, return the given projection.\n     */\n    private static String[] handleNullThreadsProjection(\n            String[] projection) {\n        return projection == null ? THREADS_COLUMNS : projection;\n    }\n\n    /**\n     * If a null sort order is given, return \"normalized_date ASC\".\n     * Otherwise, return the given sort order.\n     */\n    private static String handleNullSortOrder (String sortOrder) {\n        return sortOrder == null ? \"normalized_date ASC\" : sortOrder;\n    }\n\n    /**\n     * Return existing threads in the database.\n     */\n    private Cursor getSimpleConversations(String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        return mOpenHelper.getReadableDatabase().query(TABLE_THREADS, projection,\n                selection, selectionArgs, null, null, \" date DESC\");\n    }\n\n    /**\n     * Return the thread which has draft in both MMS and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT _id, thread_id, ...\n     *             FROM pdu\n     *             WHERE msg_box = 3 AND ...\n     *           UNION\n     *           SELECT _id, thread_id, ...\n     *             FROM sms\n     *             WHERE type = 3 AND ...\n     *          )\n     *   ;\n     */\n    private Cursor getDraftThread(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] innerProjection = new String[] {BaseColumns._ID, Conversations.THREAD_ID};\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, Mms.MESSAGE_BOX + \"=\" + Mms.MESSAGE_BOX_DRAFTS),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, Sms.TYPE + \"=\" + Sms.MESSAGE_TYPE_DRAFT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                projection, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the most recent message in each conversation in both MMS\n     * and SMS.\n     *\n     * Use this query:\n     *\n     *   SELECT ...\n     *     FROM (SELECT thread_id AS tid, date * 1000 AS normalized_date, ...\n     *             FROM pdu\n     *             WHERE msg_box != 3 AND ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date)\n     *           UNION\n     *           SELECT thread_id AS tid, date AS normalized_date, ...\n     *             FROM sms\n     *             WHERE ...\n     *             GROUP BY thread_id\n     *             HAVING date = MAX(date))\n     *     GROUP BY tid\n     *     HAVING normalized_date = MAX(normalized_date);\n     *\n     * The msg_box != 3 comparisons ensure that we don't include draft\n     * messages.\n     */\n    private Cursor getConversations(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                UNION_COLUMNS, 1);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                MMS_COLUMNS, 1, \"mms\",\n                concatSelections(selection, MMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\",\n                concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                \"thread_id\", \"date = MAX(date)\");\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                columns, null, \"tid\",\n                \"normalized_date = MAX(normalized_date)\", sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the first locked message found in the union of MMS\n     * and SMS messages.\n     *\n     * Use this query:\n     *\n     *  SELECT _id FROM pdu GROUP BY _id HAVING locked=1 UNION SELECT _id FROM sms GROUP\n     *      BY _id HAVING locked=1 LIMIT 1\n     *\n     * We limit by 1 because we're only interested in knowing if\n     * there is *any* locked message, not the actual messages themselves.\n     */\n    private Cursor getFirstLockedMessage(String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(pduTable);\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] idColumn = new String[] { BaseColumns._ID };\n\n        // NOTE: buildUnionSubQuery *ignores* selectionArgs\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"mms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, idColumn,\n                null, 1, \"sms\",\n                selection,\n                BaseColumns._ID, \"locked=1\");\n\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, null, \"1\");\n\n        Cursor cursor = mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n\n        if (DEBUG) {\n            Log.v(\"MmsSmsProvider\", \"getFirstLockedMessage query: \" + unionQuery);\n            Log.v(\"MmsSmsProvider\", \"cursor count: \" + cursor.getCount());\n        }\n        return cursor;\n    }\n\n    /**\n     * Return every message in each conversation in both MMS\n     * and SMS.\n     */\n    private Cursor getCompleteConversations(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String unionQuery = buildConversationQuery(projection, selection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date and thread_id to the list of columns for an\n     * inner projection.  This is necessary so that the outer query\n     * can have access to these columns even if the caller hasn't\n     * requested them in the result.\n     */\n    private String[] makeProjectionWithDateAndThreadId(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 2];\n\n        result[0] = \"thread_id AS tid\";\n        result[1] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        for (int i = 0; i < projectionSize; i++) {\n            result[i + 2] = projection[i];\n        }\n        return result;\n    }\n\n    /**\n     * Return the union of MMS and SMS messages for this thread ID.\n     */\n    private Cursor getConversationMessages(\n            String threadIdString, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String finalSelection = concatSelections(\n                selection, \"thread_id = \" + threadIdString);\n        String unionQuery = buildConversationQuery(projection, finalSelection, sortOrder, smsTable,\n                pduTable);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Return the union of MMS and SMS messages whose recipients\n     * included this phone number.\n     *\n     * Use this query:\n     *\n     * SELECT ...\n     *   FROM pdu, (SELECT msg_id AS address_msg_id\n     *              FROM addr\n     *              WHERE (address='<phoneNumber>' OR\n     *              PHONE_NUMBERS_EQUAL(addr.address, '<phoneNumber>', 1/0, none/minMatch)))\n     *             AS matching_addresses\n     *   WHERE pdu._id = matching_addresses.address_msg_id\n     * UNION\n     * SELECT ...\n     *   FROM sms\n     *   WHERE (address='<phoneNumber>' OR\n     *          PHONE_NUMBERS_EQUAL(sms.address, '<phoneNumber>', 1/0, none/minMatch));\n     */\n    private Cursor getMessagesByPhoneNumber(\n            String phoneNumber, String[] projection, String selection,\n            String sortOrder, String smsTable, String pduTable) {\n        int minMatch =\n            getContext().getResources().getInteger(\n                    com.android.internal.R.integer.config_phonenumber_compare_min_match);\n        String finalMmsSelection =\n                concatSelections(\n                        selection,\n                        pduTable + \"._id = matching_addresses.address_msg_id\");\n        String finalSmsSelection =\n                concatSelections(\n                        selection,\n                        \"(address=? OR PHONE_NUMBERS_EQUAL(address, ?\" +\n                        (mUseStrictPhoneNumberComparation ? \", 1))\" : \", 0, \" + minMatch + \"))\"));\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(\n                pduTable +\n                \", (SELECT msg_id AS address_msg_id \" +\n                \"FROM addr WHERE (address=?\" +\n                \" OR PHONE_NUMBERS_EQUAL(addr.address, ?\" +\n                (mUseStrictPhoneNumberComparation ? \", 1))) \" : \", 0, \" + minMatch + \"))) \") +\n                \"AS matching_addresses\");\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] columns = handleNullMessageProjection(projection);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, MMS_COLUMNS,\n                0, \"mms\", finalMmsSelection, null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, columns, SMS_COLUMNS,\n                0, \"sms\", finalSmsSelection, null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { mmsSubQuery, smsSubQuery }, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(unionQuery,\n                new String[] { phoneNumber, phoneNumber, phoneNumber, phoneNumber });\n    }\n\n    /**\n     * Return the conversation of certain thread ID.\n     */\n    private Cursor getConversationById(\n            String threadIdString, String[] projection, String selection,\n            String[] selectionArgs, String sortOrder) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return null;\n        }\n\n        String extraSelection = \"_id=\" + threadIdString;\n        String finalSelection = concatSelections(selection, extraSelection);\n        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\n        String[] columns = handleNullThreadsProjection(projection);\n\n        queryBuilder.setDistinct(true);\n        queryBuilder.setTables(TABLE_THREADS);\n        return queryBuilder.query(\n                mOpenHelper.getReadableDatabase(), columns, finalSelection,\n                selectionArgs, sortOrder, null, null);\n    }\n\n    private static String joinPduAndPendingMsgTables(String pduTable) {\n        return pduTable + \" LEFT JOIN \" + TABLE_PENDING_MSG\n                + \" ON \" + pduTable + \"._id = pending_msgs.msg_id\";\n    }\n\n    private static String[] createMmsProjection(String[] old, String pduTable) {\n        String[] newProjection = new String[old.length];\n        for (int i = 0; i < old.length; i++) {\n            if (old[i].equals(BaseColumns._ID)) {\n                newProjection[i] = pduTable + \"._id\";\n            } else {\n                newProjection[i] = old[i];\n            }\n        }\n        return newProjection;\n    }\n\n    private Cursor getUndeliveredMessages(\n            String[] projection, String selection, String[] selectionArgs,\n            String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String finalMmsSelection = concatSelections(\n                selection, Mms.MESSAGE_BOX + \" = \" + Mms.MESSAGE_BOX_OUTBOX);\n        String finalSmsSelection = concatSelections(\n                selection, \"(\" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_OUTBOX\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_FAILED\n                + \" OR \" + Sms.TYPE + \" = \" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithDateAndThreadId(\n                mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithDateAndThreadId(\n                smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 1, \"mms\", finalMmsSelection,\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection,\n                SMS_COLUMNS, 1, \"sms\", finalSmsSelection,\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery }, null, null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        String outerQuery = outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n\n        return mOpenHelper.getReadableDatabase().rawQuery(outerQuery, EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Add normalized date to the list of columns for an inner\n     * projection.\n     */\n    private static String[] makeProjectionWithNormalizedDate(\n            String[] projection, int dateMultiple) {\n        int projectionSize = projection.length;\n        String[] result = new String[projectionSize + 1];\n\n        result[0] = \"date * \" + dateMultiple + \" AS normalized_date\";\n        System.arraycopy(projection, 0, result, 1, projectionSize);\n        return result;\n    }\n\n    private static String buildConversationQuery(String[] projection,\n            String selection, String sortOrder, String smsTable, String pduTable) {\n        String[] mmsProjection = createMmsProjection(projection, pduTable);\n\n        SQLiteQueryBuilder mmsQueryBuilder = new SQLiteQueryBuilder();\n        SQLiteQueryBuilder smsQueryBuilder = new SQLiteQueryBuilder();\n\n        mmsQueryBuilder.setDistinct(true);\n        smsQueryBuilder.setDistinct(true);\n        mmsQueryBuilder.setTables(joinPduAndPendingMsgTables(pduTable));\n        smsQueryBuilder.setTables(smsTable);\n\n        String[] smsColumns = handleNullMessageProjection(projection);\n        String[] mmsColumns = handleNullMessageProjection(mmsProjection);\n        String[] innerMmsProjection = makeProjectionWithNormalizedDate(mmsColumns, 1000);\n        String[] innerSmsProjection = makeProjectionWithNormalizedDate(smsColumns, 1);\n\n        Set<String> columnsPresentInTable = new HashSet<String>(MMS_COLUMNS);\n        columnsPresentInTable.add(pduTable + \"._id\");\n        columnsPresentInTable.add(PendingMessages.ERROR_TYPE);\n\n        String mmsSelection = concatSelections(selection,\n                                Mms.MESSAGE_BOX + \" != \" + Mms.MESSAGE_BOX_DRAFTS);\n        String mmsSubQuery = mmsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerMmsProjection,\n                columnsPresentInTable, 0, \"mms\",\n                concatSelections(mmsSelection, MMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        String smsSubQuery = smsQueryBuilder.buildUnionSubQuery(\n                MmsSms.TYPE_DISCRIMINATOR_COLUMN, innerSmsProjection, SMS_COLUMNS,\n                0, \"sms\", concatSelections(selection, SMS_CONVERSATION_CONSTRAINT),\n                null, null);\n        SQLiteQueryBuilder unionQueryBuilder = new SQLiteQueryBuilder();\n\n        unionQueryBuilder.setDistinct(true);\n\n        String unionQuery = unionQueryBuilder.buildUnionQuery(\n                new String[] { smsSubQuery, mmsSubQuery },\n                handleNullSortOrder(sortOrder), null);\n\n        SQLiteQueryBuilder outerQueryBuilder = new SQLiteQueryBuilder();\n\n        outerQueryBuilder.setTables(\"(\" + unionQuery + \")\");\n\n        return outerQueryBuilder.buildQuery(\n                smsColumns, null, null, null, sortOrder, null);\n    }\n\n    @Override\n    public String getType(Uri uri) {\n        return VND_ANDROID_DIR_MMS_SMS;\n    }\n\n    @Override\n    public int delete(Uri uri, String selection,\n            String[] selectionArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        Context context = getContext();\n        int affectedRows = 0;\n\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                long threadId;\n                try {\n                    threadId = Long.parseLong(uri.getLastPathSegment());\n                } catch (NumberFormatException e) {\n                    Log.e(LOG_TAG, \"Thread ID must be a long.\");\n                    break;\n                }\n\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = deleteConversation(uri, selection, selectionArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadId);\n                break;\n            case URI_CONVERSATIONS:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selectionBySubIds, selection);\n\n                affectedRows = MmsProvider.deleteMessages(context, db,\n                                        selection, selectionArgs, uri)\n                        + db.delete(\"sms\", selection, selectionArgs);\n                // Intentionally don't pass the selection variable to updateThreads.\n                // When we pass in \"locked=0\" there, the thread will get excluded from\n                // the selection and not get updated.\n                MmsSmsDatabaseHelper.updateThreads(db, null, null);\n                break;\n            case URI_OBSOLETE_THREADS:\n                affectedRows = db.delete(TABLE_THREADS,\n                        \"_id NOT IN (SELECT DISTINCT thread_id FROM sms where thread_id NOT NULL \" +\n                        \"UNION SELECT DISTINCT thread_id FROM pdu where thread_id NOT NULL)\", null);\n                break;\n            default:\n                throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            context.getContentResolver().notifyChange(MmsSms.CONTENT_URI, null, true,\n                    UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    /**\n     * Delete the conversation with the given thread ID.\n     */\n    private int deleteConversation(Uri uri, String selection, String[] selectionArgs) {\n        String threadId = uri.getLastPathSegment();\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id = \" + threadId);\n        return MmsProvider.deleteMessages(getContext(), db, finalSelection,\n                                          selectionArgs, uri)\n                + db.delete(\"sms\", finalSelection, selectionArgs);\n    }\n\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int matchIndex = URI_MATCHER.match(uri);\n\n        if (matchIndex == URI_PENDING_MSG) {\n            int subId;\n            if (values.containsKey(PendingMessages.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(PendingMessages.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(PendingMessages.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n                return null;\n            }\n\n            long rowId = db.insert(TABLE_PENDING_MSG, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        } else if (matchIndex == URI_CANONICAL_ADDRESS) {\n            long rowId = db.insert(TABLE_CANONICAL_ADDRESSES, null, values);\n            return uri.buildUpon().appendPath(Long.toString(rowId)).build();\n        }\n        throw new UnsupportedOperationException(NO_DELETES_INSERTS_OR_UPDATES + uri);\n    }\n\n    @Override\n    public int update(Uri uri, ContentValues values,\n            String selection, String[] selectionArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n\n        String selectionBySubIds;\n        final long token = Binder.clearCallingIdentity();\n        try {\n            // Filter MMS/SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int affectedRows = 0;\n        switch(URI_MATCHER.match(uri)) {\n            case URI_CONVERSATIONS_MESSAGES:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                String threadIdString = uri.getPathSegments().get(1);\n                affectedRows = updateConversation(threadIdString, values,\n                        selection, selectionArgs, callerUid, callerPkg);\n                break;\n\n            case URI_PENDING_MSG:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                // In PendingMessages table, SUBSCRIPTION_ID column name is pending_sub_id.\n                selectionBySubIds = \"pending_\" + selectionBySubIds;\n                selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n\n                affectedRows = db.update(TABLE_PENDING_MSG, values, selection, null);\n                break;\n\n            case URI_CANONICAL_ADDRESS: {\n                String extraSelection = \"_id=\" + uri.getPathSegments().get(1);\n                String finalSelection = TextUtils.isEmpty(selection)\n                        ? extraSelection : extraSelection + \" AND \" + selection;\n\n                affectedRows = db.update(TABLE_CANONICAL_ADDRESSES, values, finalSelection, null);\n                break;\n            }\n\n            case URI_CONVERSATIONS: {\n                final ContentValues finalValues = new ContentValues(1);\n                if (values.containsKey(Threads.ARCHIVED)) {\n                    // Only allow update archived\n                    finalValues.put(Threads.ARCHIVED, values.getAsBoolean(Threads.ARCHIVED));\n                }\n                affectedRows = db.update(TABLE_THREADS, finalValues, selection, selectionArgs);\n                break;\n            }\n\n            default:\n                throw new UnsupportedOperationException(\n                        NO_DELETES_INSERTS_OR_UPDATES + uri);\n        }\n\n        if (affectedRows > 0) {\n            getContext().getContentResolver().notifyChange(\n                    MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        }\n        return affectedRows;\n    }\n\n    private int updateConversation(String threadIdString, ContentValues values, String selection,\n            String[] selectionArgs, int callerUid, String callerPkg) {\n        try {\n            Long.parseLong(threadIdString);\n        } catch (NumberFormatException exception) {\n            Log.e(LOG_TAG, \"Thread ID must be a Long.\");\n            return 0;\n\n        }\n        if (ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(LOG_TAG, callerPkg + \" tries to update CREATOR\");\n            // Sms.CREATOR and Mms.CREATOR are same. But let's do this\n            // twice in case the names may differ in the future\n            values.remove(Sms.CREATOR);\n            values.remove(Mms.CREATOR);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        String finalSelection = concatSelections(selection, \"thread_id=\" + threadIdString);\n        return db.update(MmsProvider.TABLE_PDU, values, finalSelection, selectionArgs)\n                + db.update(\"sms\", values, finalSelection, selectionArgs);\n    }\n\n    /**\n     * Construct Sets of Strings containing exactly the columns\n     * present in each table.  We will use this when constructing\n     * UNION queries across the MMS and SMS tables.\n     */\n    private static void initializeColumnSets() {\n        int commonColumnCount = MMS_SMS_COLUMNS.length;\n        int mmsOnlyColumnCount = MMS_ONLY_COLUMNS.length;\n        int smsOnlyColumnCount = SMS_ONLY_COLUMNS.length;\n        Set<String> unionColumns = new HashSet<String>();\n\n        for (int i = 0; i < commonColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            SMS_COLUMNS.add(MMS_SMS_COLUMNS[i]);\n            unionColumns.add(MMS_SMS_COLUMNS[i]);\n        }\n        for (int i = 0; i < mmsOnlyColumnCount; i++) {\n            MMS_COLUMNS.add(MMS_ONLY_COLUMNS[i]);\n            unionColumns.add(MMS_ONLY_COLUMNS[i]);\n        }\n        for (int i = 0; i < smsOnlyColumnCount; i++) {\n            SMS_COLUMNS.add(SMS_ONLY_COLUMNS[i]);\n            unionColumns.add(SMS_ONLY_COLUMNS[i]);\n        }\n\n        int i = 0;\n        for (String columnName : unionColumns) {\n            UNION_COLUMNS[i++] = columnName;\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        // Dump default SMS app\n        String defaultSmsApp = Telephony.Sms.getDefaultSmsPackage(getContext());\n        if (TextUtils.isEmpty(defaultSmsApp)) {\n            defaultSmsApp = \"None\";\n        }\n        writer.println(\"Default SMS app: \" + defaultSmsApp);\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid())) {\n            return null;\n        }\n        if (METHOD_IS_RESTORING.equals(method)) {\n            Bundle result = new Bundle();\n            result.putBoolean(IS_RESTORING_KEY, TelephonyBackupAgent.getIsRestoring());\n            return result;\n        } else if (METHOD_GARBAGE_COLLECT.equals(method)) {\n            Bundle result = new Bundle();\n            boolean doDelete = TextUtils.equals(DO_DELETE, arg);\n            MmsPartsCleanup.cleanupDanglingParts(getContext(), doDelete, result);\n            return result;\n        }\n        Log.w(LOG_TAG, \"Ignored unsupported \" + method + \" call\");\n        return null;\n    }\n}\n","lineNo":340}
{"Smelly Sample":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), Binder.getCallingUid());\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg);\n\n            int match = sURLMatcher.match(url);\n            // Skip notifyChange() if insertUri is null for SMS_ALL_ICC or SMS_ALL_ICC_SUBID caused\n            // by failure of insertMessageToIcc()(e.g. SIM full).\n            if (insertUri != null || (match != SMS_ALL_ICC && match != SMS_ALL_ICC_SUBID)) {\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.telephony;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.UriMatcher;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.MatrixCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.UserHandle;\nimport android.provider.Contacts;\nimport android.provider.Telephony;\nimport android.provider.Telephony.MmsSms;\nimport android.provider.Telephony.Sms;\nimport android.provider.Telephony.Threads;\nimport android.telephony.SmsManager;\nimport android.telephony.SmsMessage;\nimport android.telephony.SubscriptionManager;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.TelephonyPermissions;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class SmsProvider extends ContentProvider {\n    /* No response constant from SmsResponse */\n    static final int NO_ERROR_CODE = -1;\n\n    private static final Uri NOTIFICATION_URI = Uri.parse(\"content://sms\");\n    private static final Uri ICC_URI = Uri.parse(\"content://sms/icc\");\n    private static final Uri ICC_SUBID_URI = Uri.parse(\"content://sms/icc_subId\");\n    static final String TABLE_SMS = \"sms\";\n    static final String TABLE_RAW = \"raw\";\n    private static final String TABLE_SR_PENDING = \"sr_pending\";\n    private static final String TABLE_WORDS = \"words\";\n    static final String VIEW_SMS_RESTRICTED = \"sms_restricted\";\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final String[] CONTACT_QUERY_PROJECTION =\n            new String[] { Contacts.Phones.PERSON_ID };\n    private static final int PERSON_ID_COLUMN = 0;\n\n    /** Delete any raw messages or message segments marked deleted that are older than an hour. */\n    static final long RAW_MESSAGE_EXPIRE_AGE_MS = (long) (60 * 60 * 1000);\n\n    /**\n     * These are the columns that are available when reading SMS\n     * messages from the ICC.  Columns whose names begin with \"is_\"\n     * have either \"true\" or \"false\" as their values.\n     */\n    private final static String[] ICC_COLUMNS = new String[] {\n        // N.B.: These columns must appear in the same order as the\n        // calls to add appear in convertIccToSms.\n        \"service_center_address\",       // getServiceCenterAddress\n        \"address\",                      // getDisplayOriginatingAddress or getRecipientAddress\n        \"message_class\",                // getMessageClass\n        \"body\",                         // getDisplayMessageBody\n        \"date\",                         // getTimestampMillis\n        \"status\",                       // getStatusOnIcc\n        \"index_on_icc\",                 // getIndexOnIcc (1-based index)\n        \"is_status_report\",             // isStatusReportMessage\n        \"transport_type\",               // Always \"sms\".\n        \"type\",                         // depend on getStatusOnIcc\n        \"locked\",                       // Always 0 (false).\n        \"error_code\",                   // Always -1 (NO_ERROR_CODE), previously it was 0 always.\n        \"_id\"\n    };\n\n    @Override\n    public boolean onCreate() {\n        setAppOps(AppOpsManager.OP_READ_SMS, AppOpsManager.OP_WRITE_SMS);\n        // So we have two database files. One in de, one in ce. Here only \"raw\" table is in\n        // mDeOpenHelper, other tables are all in mCeOpenHelper.\n        mDeOpenHelper = MmsSmsDatabaseHelper.getInstanceForDe(getContext());\n        mCeOpenHelper = MmsSmsDatabaseHelper.getInstanceForCe(getContext());\n        TelephonyBackupAgent.DeferredSmsMmsRestoreService.startIfFilesExist(getContext());\n        return true;\n    }\n\n    /**\n     * Return the proper view of \"sms\" table for the current access status.\n     *\n     * @param accessRestricted If the access is restricted\n     * @return the table/view name of the \"sms\" data\n     */\n    public static String getSmsTable(boolean accessRestricted) {\n        return accessRestricted ? VIEW_SMS_RESTRICTED : TABLE_SMS;\n    }\n\n    @Override\n    public Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        final int callingUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n\n        // First check if a restricted view of the \"sms\" table should be used based on the\n        // caller's identity. Only system, phone or the default sms app can have full access\n        // of sms data. For other apps, we present a restricted view which only contains sent\n        // or received messages.\n        final boolean accessRestricted = ProviderUtil.isAccessRestricted(\n                getContext(), getCallingPackage(), callingUid);\n        final String smsTable = getSmsTable(accessRestricted);\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n\n        // If access is restricted, we don't allow subqueries in the query.\n        if (accessRestricted) {\n            try {\n                SqlQueryChecker.checkQueryParametersForSubqueries(projectionIn, selection, sort);\n            } catch (IllegalArgumentException e) {\n                Log.w(TAG, \"Query rejected: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        Cursor emptyCursor = new MatrixCursor((projectionIn == null) ?\n                (new String[] {}) : projectionIn);\n\n\n        // Generate the body of the query.\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getReadableDatabase(match);\n        switch (match) {\n            case SMS_ALL:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_ALL, smsTable);\n                break;\n\n            case SMS_UNDELIVERED:\n                constructQueryForUndelivered(qb, smsTable);\n                break;\n\n            case SMS_FAILED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_FAILED, smsTable);\n                break;\n\n            case SMS_QUEUED:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_QUEUED, smsTable);\n                break;\n\n            case SMS_INBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_INBOX, smsTable);\n                break;\n\n            case SMS_SENT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_SENT, smsTable);\n                break;\n\n            case SMS_DRAFT:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_DRAFT, smsTable);\n                break;\n\n            case SMS_OUTBOX:\n                constructQueryForBox(qb, Sms.MESSAGE_TYPE_OUTBOX, smsTable);\n                break;\n\n            case SMS_ALL_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(0) + \")\");\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.d(TAG, \"query conversations: threadID=\" + threadID);\n                    }\n                }\n                catch (Exception ex) {\n                    Log.e(TAG,\n                          \"Bad conversation thread id: \"\n                          + url.getPathSegments().get(1));\n                    return null;\n                }\n\n                qb.setTables(smsTable);\n                qb.appendWhere(\"thread_id = \" + threadID);\n                break;\n\n            case SMS_CONVERSATIONS:\n                qb.setTables(smsTable + \", \"\n                        + \"(SELECT thread_id AS group_thread_id, \"\n                        + \"MAX(date) AS group_date, \"\n                        + \"COUNT(*) AS msg_count \"\n                        + \"FROM \" + smsTable + \" \"\n                        + \"GROUP BY thread_id) AS groups\");\n                qb.appendWhere(smsTable + \".thread_id=groups.group_thread_id\"\n                        + \" AND \" + smsTable + \".date=groups.group_date\");\n                final HashMap<String, String> projectionMap = new HashMap<>();\n                projectionMap.put(Sms.Conversations.SNIPPET,\n                        smsTable + \".body AS snippet\");\n                projectionMap.put(Sms.Conversations.THREAD_ID,\n                        smsTable + \".thread_id AS thread_id\");\n                projectionMap.put(Sms.Conversations.MESSAGE_COUNT,\n                        \"groups.msg_count AS msg_count\");\n                projectionMap.put(\"delta\", null);\n                qb.setProjectionMap(projectionMap);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                // before querying purge old entries with deleted = 1\n                purgeDeletedMessagesInRawTable(db);\n                qb.setTables(\"raw\");\n                break;\n\n            case SMS_STATUS_PENDING:\n                qb.setTables(\"sr_pending\");\n                break;\n\n            case SMS_ATTACHMENT:\n                qb.setTables(\"attachments\");\n                break;\n\n            case SMS_ATTACHMENT_ID:\n                qb.setTables(\"attachments\");\n                qb.appendWhere(\n                        \"(sms_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_QUERY_THREAD_ID:\n                qb.setTables(\"canonical_addresses\");\n                if (projectionIn == null) {\n                    projectionIn = sIDProjection;\n                }\n                break;\n\n            case SMS_STATUS_ID:\n                qb.setTables(smsTable);\n                qb.appendWhere(\"(_id = \" + url.getPathSegments().get(1) + \")\");\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getAllMessagesFromIcc(subId);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return empty cursor.\n                        return emptyCursor;\n                    }\n\n                    Cursor ret = getSingleMessageFromIcc(subId, messageIndex);\n                    ret.setNotificationUri(getContext().getContentResolver(),\n                            match == SMS_ICC ? ICC_URI : ICC_SUBID_URI);\n                    return ret;\n                }\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        if (qb.getTables().equals(smsTable)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n               selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                       callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return empty cursor.\n                return emptyCursor;\n            }\n            selection = DatabaseUtils.concatenateWhere(selection, selectionBySubIds);\n        }\n\n        String orderBy = null;\n\n        if (!TextUtils.isEmpty(sort)) {\n            orderBy = sort;\n        } else if (qb.getTables().equals(smsTable)) {\n            orderBy = Sms.DEFAULT_SORT_ORDER;\n        }\n\n        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,\n                              null, null, orderBy);\n        // TODO: Since the URLs are a mess, always use content://sms\n        ret.setNotificationUri(getContext().getContentResolver(),\n                NOTIFICATION_URI);\n        return ret;\n    }\n\n    private void purgeDeletedMessagesInRawTable(SQLiteDatabase db) {\n        long oldTimestamp = System.currentTimeMillis() - RAW_MESSAGE_EXPIRE_AGE_MS;\n        int num = db.delete(TABLE_RAW, \"deleted = 1 AND date < \" + oldTimestamp, null);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.d(TAG, \"purgeDeletedMessagesInRawTable: num rows older than \" + oldTimestamp +\n                    \" purged: \" + num);\n        }\n    }\n\n    private SQLiteOpenHelper getDBOpenHelper(int match) {\n        // Raw table is stored on de database. Other tables are stored in ce database.\n        if (match == SMS_RAW_MESSAGE || match == SMS_RAW_MESSAGE_PERMANENT_DELETE) {\n            return mDeOpenHelper;\n        }\n        return mCeOpenHelper;\n    }\n\n    private Object[] convertIccToSms(SmsMessage message, int id) {\n        int statusOnIcc = message.getStatusOnIcc();\n        int type = Sms.MESSAGE_TYPE_ALL;\n        switch (statusOnIcc) {\n            case SmsManager.STATUS_ON_ICC_READ:\n            case SmsManager.STATUS_ON_ICC_UNREAD:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n            case SmsManager.STATUS_ON_ICC_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n            case SmsManager.STATUS_ON_ICC_UNSENT:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n        }\n\n        String address = (type == Sms.MESSAGE_TYPE_INBOX)\n                ? message.getDisplayOriginatingAddress()\n                : message.getRecipientAddress();\n\n        int index = message.getIndexOnIcc();\n        if (address == null) {\n            // The status byte of an EF_SMS record may not be correct. try to read other address\n            // type again.\n            Log.e(TAG, \"convertIccToSms: EF_SMS(\" + index + \")=> address=null, type=\" + type\n                    + \", status=\" + statusOnIcc + \"(may not be correct). fallback to other type.\");\n            address = (type == Sms.MESSAGE_TYPE_INBOX)\n                    ? message.getRecipientAddress()\n                    : message.getDisplayOriginatingAddress();\n\n            if (address != null) {\n                // Rely on actual PDU(address) to set type again.\n                type = (type == Sms.MESSAGE_TYPE_INBOX)\n                        ? Sms.MESSAGE_TYPE_SENT\n                        : Sms.MESSAGE_TYPE_INBOX;\n                Log.d(TAG, \"convertIccToSms: new type=\" + type + \", address=xxxxxx\");\n            } else {\n                Log.e(TAG, \"convertIccToSms: no change\");\n            }\n        }\n\n        // N.B.: These calls must appear in the same order as the\n        // columns appear in ICC_COLUMNS.\n        Object[] row = new Object[13];\n        row[0] = message.getServiceCenterAddress();\n        row[1] = address;\n        row[2] = String.valueOf(message.getMessageClass());\n        row[3] = message.getDisplayMessageBody();\n        row[4] = message.getTimestampMillis();\n        row[5] = statusOnIcc;\n        row[6] = index;\n        row[7] = message.isStatusReportMessage();\n        row[8] = \"sms\";\n        row[9] = type;\n        row[10] = 0;      // locked\n        row[11] = NO_ERROR_CODE;\n        row[12] = id;\n        return row;\n    }\n\n    /**\n     * Gets single message from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the messaage in the ICC (1-based index).\n     * @return a cursor containing just one message from the ICC for the subscription ID.\n     */\n    private Cursor getSingleMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null && message.getIndexOnIcc() == messageIndex) {\n                MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, 1);\n                cursor.addRow(convertIccToSms(message, 0));\n                return cursor;\n            }\n        }\n\n        throw new IllegalArgumentException(\n                \"No message in index \" + messageIndex + \" for subId \" + subId);\n    }\n\n    /**\n     * Gets all the messages in the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return a cursor listing all the message in the ICC for the subscription ID.\n     */\n    private Cursor getAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n        List<SmsMessage> messages;\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call\n        long token = Binder.clearCallingIdentity();\n        try {\n            // getMessagesFromIcc() returns a zero-based list of valid messages in the ICC.\n            messages = smsManager.getMessagesFromIcc();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final int count = messages.size();\n        MatrixCursor cursor = new MatrixCursor(ICC_COLUMNS, count);\n        for (int i = 0; i < count; i++) {\n            SmsMessage message = messages.get(i);\n            if (message != null) {\n                cursor.addRow(convertIccToSms(message, i));\n            }\n        }\n        return cursor;\n    }\n\n    private void constructQueryForBox(SQLiteQueryBuilder qb, int type, String smsTable) {\n        qb.setTables(smsTable);\n\n        if (type != Sms.MESSAGE_TYPE_ALL) {\n            qb.appendWhere(\"type=\" + type);\n        }\n    }\n\n    private void constructQueryForUndelivered(SQLiteQueryBuilder qb, String smsTable) {\n        qb.setTables(smsTable);\n\n        qb.appendWhere(\"(type=\" + Sms.MESSAGE_TYPE_OUTBOX +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_FAILED +\n                       \" OR type=\" + Sms.MESSAGE_TYPE_QUEUED + \")\");\n    }\n\n    @Override\n    public String getType(Uri url) {\n        switch (url.getPathSegments().size()) {\n        case 0:\n            return VND_ANDROID_DIR_SMS;\n            case 1:\n                try {\n                    Integer.parseInt(url.getPathSegments().get(0));\n                    return VND_ANDROID_SMS;\n                } catch (NumberFormatException ex) {\n                    return VND_ANDROID_DIR_SMS;\n                }\n            case 2:\n                // TODO: What about \"threadID\"?\n                if (url.getPathSegments().get(0).equals(\"conversations\")) {\n                    return VND_ANDROID_SMSCHAT;\n                } else {\n                    return VND_ANDROID_SMS;\n                }\n        }\n        return null;\n    }\n\n    @Override\n    public int bulkInsert(@NonNull Uri url, @NonNull ContentValues[] values) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int messagesInserted = 0;\n            for (ContentValues initialValues : values) {\n                Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg,\n                        callerUserHandle);\n                if (insertUri != null) {\n                    messagesInserted++;\n                }\n            }\n\n            // The raw table is used by the telephony layer for storing an sms before\n            // sending out a notification that an sms has arrived. We don't want to notify\n            // the default sms app of changes to this table.\n            final boolean notifyIfNotDefault = sURLMatcher.match(url) != SMS_RAW_MESSAGE;\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n            return messagesInserted;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Uri insert(Uri url, ContentValues initialValues) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        long token = Binder.clearCallingIdentity();\n        try {\n            Uri insertUri = insertInner(url, initialValues, callerUid, callerPkg, callerUserHandle);\n\n            int match = sURLMatcher.match(url);\n            // Skip notifyChange() if insertUri is null for SMS_ALL_ICC or SMS_ALL_ICC_SUBID caused\n            // by failure of insertMessageToIcc()(e.g. SIM full).\n            if (insertUri != null || (match != SMS_ALL_ICC && match != SMS_ALL_ICC_SUBID)) {\n                // The raw table is used by the telephony layer for storing an sms before sending\n                // out a notification that an sms has arrived. We don't want to notify the default\n                // sms app of changes to this table.\n                final boolean notifyIfNotDefault = match != SMS_RAW_MESSAGE;\n                notifyChange(notifyIfNotDefault, insertUri, callerPkg);\n            }\n            return insertUri;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Uri insertInner(Uri url, ContentValues initialValues, int callerUid, String callerPkg,\n            UserHandle callerUserHandle) {\n        ContentValues values;\n        long rowID;\n        int type = Sms.MESSAGE_TYPE_ALL;\n\n        int match = sURLMatcher.match(url);\n        String table = TABLE_SMS;\n\n        switch (match) {\n            case SMS_ALL:\n                Integer typeObj = initialValues.getAsInteger(Sms.TYPE);\n                if (typeObj != null) {\n                    type = typeObj.intValue();\n                } else {\n                    // default to inbox\n                    type = Sms.MESSAGE_TYPE_INBOX;\n                }\n                break;\n\n            case SMS_INBOX:\n                type = Sms.MESSAGE_TYPE_INBOX;\n                break;\n\n            case SMS_FAILED:\n                type = Sms.MESSAGE_TYPE_FAILED;\n                break;\n\n            case SMS_QUEUED:\n                type = Sms.MESSAGE_TYPE_QUEUED;\n                break;\n\n            case SMS_SENT:\n                type = Sms.MESSAGE_TYPE_SENT;\n                break;\n\n            case SMS_DRAFT:\n                type = Sms.MESSAGE_TYPE_DRAFT;\n                break;\n\n            case SMS_OUTBOX:\n                type = Sms.MESSAGE_TYPE_OUTBOX;\n                break;\n\n            case SMS_RAW_MESSAGE:\n                table = \"raw\";\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = \"sr_pending\";\n                break;\n\n            case SMS_ATTACHMENT:\n                table = \"attachments\";\n                break;\n\n            case SMS_NEW_THREAD_ID:\n                table = \"canonical_addresses\";\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                int subId;\n                if (match == SMS_ALL_ICC) {\n                    subId = SmsManager.getDefaultSmsSubscriptionId();\n                } else {\n                    try {\n                        subId = Integer.parseInt(url.getPathSegments().get(1));\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\n                                \"Wrong path segements for SMS_ALL_ICC_SUBID, uri= \" + url);\n                    }\n                }\n\n                if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(), subId,\n                        callerUserHandle)) {\n                    // TODO(b/258629881): Display error dialog.\n                    return null;\n                }\n\n                if (initialValues == null) {\n                    throw new IllegalArgumentException(\"ContentValues is null\");\n                }\n\n                String scAddress = initialValues.getAsString(Sms.SERVICE_CENTER);\n                String address = initialValues.getAsString(Sms.ADDRESS);\n                String message = initialValues.getAsString(Sms.BODY);\n                boolean isRead = true;\n                Integer obj = initialValues.getAsInteger(Sms.TYPE);\n\n                if (obj == null || address == null || message == null) {\n                    throw new IllegalArgumentException(\"Missing SMS data\");\n                }\n\n                type = obj.intValue();\n                if (!isSupportedType(type)) {\n                    throw new IllegalArgumentException(\"Unsupported message type= \" + type);\n                }\n                obj = initialValues.getAsInteger(Sms.READ); // 0: Unread, 1: Read\n                if (obj != null && obj.intValue() == 0) {\n                    isRead = false;\n                }\n\n                Long date = initialValues.getAsLong(Sms.DATE);\n                return insertMessageToIcc(subId, scAddress, address, message, type, isRead,\n                        date != null ? date : 0) ? url : null;\n\n            default:\n                Log.e(TAG, \"Invalid request: \" + url);\n                return null;\n        }\n\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        if (table.equals(TABLE_SMS)) {\n            boolean addDate = false;\n            boolean addType = false;\n\n            // Make sure that the date and type are set\n            if (initialValues == null) {\n                values = new ContentValues(1);\n                addDate = true;\n                addType = true;\n            } else {\n                values = new ContentValues(initialValues);\n\n                if (!initialValues.containsKey(Sms.DATE)) {\n                    addDate = true;\n                }\n\n                if (!initialValues.containsKey(Sms.TYPE)) {\n                    addType = true;\n                }\n            }\n\n            if (addDate) {\n                values.put(Sms.DATE, new Long(System.currentTimeMillis()));\n            }\n\n            if (addType && (type != Sms.MESSAGE_TYPE_ALL)) {\n                values.put(Sms.TYPE, Integer.valueOf(type));\n            }\n\n            // thread_id\n            Long threadId = values.getAsLong(Sms.THREAD_ID);\n            String address = values.getAsString(Sms.ADDRESS);\n\n            if (((threadId == null) || (threadId == 0)) && (!TextUtils.isEmpty(address))) {\n                values.put(Sms.THREAD_ID, Threads.getOrCreateThreadId(\n                                   getContext(), address));\n            }\n\n            // If this message is going in as a draft, it should replace any\n            // other draft messages in the thread.  Just delete all draft\n            // messages with this thread ID.  We could add an OR REPLACE to\n            // the insert below, but we'd have to query to find the old _id\n            // to produce a conflict anyway.\n            if (values.getAsInteger(Sms.TYPE) == Sms.MESSAGE_TYPE_DRAFT) {\n                db.delete(TABLE_SMS, \"thread_id=? AND type=?\",\n                        new String[] { values.getAsString(Sms.THREAD_ID),\n                                       Integer.toString(Sms.MESSAGE_TYPE_DRAFT) });\n            }\n\n            if (type == Sms.MESSAGE_TYPE_INBOX) {\n                // Look up the person if not already filled in.\n                if ((values.getAsLong(Sms.PERSON) == null) && (!TextUtils.isEmpty(address))) {\n                    Cursor cursor = null;\n                    Uri uri = Uri.withAppendedPath(Contacts.Phones.CONTENT_FILTER_URL,\n                            Uri.encode(address));\n                    try {\n                        cursor = getContext().getContentResolver().query(\n                                uri,\n                                CONTACT_QUERY_PROJECTION,\n                                null, null, null);\n\n                        if (cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {\n                        Log.e(TAG, \"insert: query contact uri \" + uri + \" caught \", ex);\n                    } finally {\n                        if (cursor != null) {\n                            cursor.close();\n                        }\n                    }\n                }\n            } else {\n                // Mark all non-inbox messages read.\n                values.put(Sms.READ, ONE);\n            }\n            if (ProviderUtil.shouldSetCreator(values, callerUid)) {\n                // Only SYSTEM or PHONE can set CREATOR\n                // If caller is not SYSTEM or PHONE, or SYSTEM or PHONE does not set CREATOR\n                // set CREATOR using the truth on caller.\n                // Note: Inferring package name from UID may include unrelated package names\n                values.put(Sms.CREATOR, callerPkg);\n            }\n        } else {\n            if (initialValues == null) {\n                values = new ContentValues(1);\n            } else {\n                values = initialValues;\n            }\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            int subId;\n            if (values.containsKey(Telephony.Sms.SUBSCRIPTION_ID)) {\n                subId = values.getAsInteger(Telephony.Sms.SUBSCRIPTION_ID);\n            } else {\n                subId = SmsManager.getDefaultSmsSubscriptionId();\n                if (SubscriptionManager.isValidSubscriptionId(subId)) {\n                    values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);\n                }\n            }\n            if (!TelephonyPermissions\n                    .checkSubscriptionAssociatedWithUser(getContext(), subId, callerUserHandle)) {\n                // TODO(b/258629881): Display error dialog.\n            }\n        }\n\n        rowID = db.insert(table, \"body\", values);\n\n        // Don't use a trigger for updating the words table because of a bug\n        // in FTS3.  The bug is such that the call to get the last inserted\n        // row is incorrect.\n        if (table == TABLE_SMS) {\n            // Update the words table with a corresponding row.  The words table\n            // allows us to search for words quickly, without scanning the whole\n            // table;\n            ContentValues cv = new ContentValues();\n            cv.put(Telephony.MmsSms.WordsTable.ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.INDEXED_TEXT, values.getAsString(\"body\"));\n            cv.put(Telephony.MmsSms.WordsTable.SOURCE_ROW_ID, rowID);\n            cv.put(Telephony.MmsSms.WordsTable.TABLE_ID, 1);\n            db.insert(TABLE_WORDS, Telephony.MmsSms.WordsTable.INDEXED_TEXT, cv);\n        }\n        if (rowID > 0) {\n            Uri uri = null;\n            if (table == TABLE_SMS) {\n                uri = Uri.withAppendedPath(Sms.CONTENT_URI, String.valueOf(rowID));\n            } else {\n                uri = Uri.withAppendedPath(url, String.valueOf(rowID));\n            }\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"insert \" + uri + \" succeeded\");\n            }\n            return uri;\n        } else {\n            Log.e(TAG, \"insert: failed!\");\n        }\n\n        return null;\n    }\n\n    private boolean isSupportedType(int messageType) {\n        return (messageType == Sms.MESSAGE_TYPE_INBOX)\n                || (messageType == Sms.MESSAGE_TYPE_OUTBOX)\n                || (messageType == Sms.MESSAGE_TYPE_SENT);\n    }\n\n    private int getMessageStatusForIcc(int messageType, boolean isRead) {\n        if (messageType == Sms.MESSAGE_TYPE_SENT) {\n            return SmsManager.STATUS_ON_ICC_SENT;\n        } else if (messageType == Sms.MESSAGE_TYPE_OUTBOX) {\n            return SmsManager.STATUS_ON_ICC_UNSENT;\n        } else { // Sms.MESSAGE_BOX_INBOX\n            if (isRead) {\n                return SmsManager.STATUS_ON_ICC_READ;\n            } else {\n                return SmsManager.STATUS_ON_ICC_UNREAD;\n            }\n        }\n    }\n\n    /**\n     * Inserts new message to the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param scAddress the SMSC for this message.\n     * @param address destination or originating address.\n     * @param message the message text.\n     * @param messageType type of the message.\n     * @param isRead ture if the message has been read. Otherwise false.\n     * @param date the date the message was received.\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean insertMessageToIcc(int subId, String scAddress, String address, String message,\n            int messageType, boolean isRead, long date) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        int status = getMessageStatusForIcc(messageType, isRead);\n        SmsMessage.SubmitPdu smsPdu =\n                SmsMessage.getSmsPdu(subId, status, scAddress, address, message, date);\n\n        if (smsPdu == null) {\n            throw new IllegalArgumentException(\"Failed to create SMS PDU\");\n        }\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.copyMessageToIcc(\n                    smsPdu.encodedScAddress, smsPdu.encodedMessage, status);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int delete(Uri url, String where, String[] whereArgs) {\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final long token = Binder.clearCallingIdentity();\n        String selectionBySubIds;\n        try {\n            // Filter SMS based on subId.\n            selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(), callerUserHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int count;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n        boolean notifyIfNotDefault = true;\n        switch (match) {\n            case SMS_ALL:\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                if (count != 0) {\n                    // Don't update threads unless something changed.\n                    MmsSmsDatabaseHelper.updateThreads(db, where, whereArgs);\n                }\n                break;\n\n            case SMS_ALL_ID:\n                try {\n                    int message_id = Integer.parseInt(url.getPathSegments().get(0));\n                    count = MmsSmsDatabaseHelper.deleteOneSms(db, message_id);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\n                        \"Bad message id: \" + url.getPathSegments().get(0));\n                }\n                break;\n\n            case SMS_CONVERSATIONS_ID:\n                int threadID;\n\n                try {\n                    threadID = Integer.parseInt(url.getPathSegments().get(1));\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\n                            \"Bad conversation thread id: \"\n                            + url.getPathSegments().get(1));\n                }\n\n                // delete the messages from the sms table\n                where = DatabaseUtils.concatenateWhere(\"thread_id=\" + threadID, where);\n                if (selectionBySubIds == null) {\n                    // No subscriptions associated with user, return 0.\n                    return 0;\n                }\n                where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n                count = db.delete(TABLE_SMS, where, whereArgs);\n                MmsSmsDatabaseHelper.updateThread(db, threadID);\n                break;\n\n            case SMS_RAW_MESSAGE:\n                ContentValues cv = new ContentValues();\n                cv.put(\"deleted\", 1);\n                count = db.update(TABLE_RAW, cv, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows marked deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_RAW_MESSAGE_PERMANENT_DELETE:\n                count = db.delete(TABLE_RAW, where, whereArgs);\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.d(TAG, \"delete: num rows permanently deleted in raw table: \" + count);\n                }\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                count = db.delete(\"sr_pending\", where, whereArgs);\n                break;\n\n            case SMS_ALL_ICC:\n            case SMS_ALL_ICC_SUBID:\n                {\n                    int subId;\n                    int deletedCnt;\n                    if (match == SMS_ALL_ICC) {\n                        subId = SmsManager.getDefaultSmsSubscriptionId();\n                    } else {\n                        try {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                        }\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    deletedCnt = deleteAllMessagesFromIcc(subId);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ALL_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return deletedCnt;\n                }\n\n            case SMS_ICC:\n            case SMS_ICC_SUBID:\n                {\n                    int subId;\n                    int messageIndex;\n                    boolean success;\n                    try {\n                        if (match == SMS_ICC) {\n                            subId = SmsManager.getDefaultSmsSubscriptionId();\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(1));\n                        } else {\n                            subId = Integer.parseInt(url.getPathSegments().get(1));\n                            messageIndex = Integer.parseInt(url.getPathSegments().get(2));\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new IllegalArgumentException(\"Wrong path segements, uri= \" + url);\n                    }\n\n                    if (!TelephonyPermissions.checkSubscriptionAssociatedWithUser(getContext(),\n                            subId, callerUserHandle)) {\n                        // If subId is not associated with user, return 0.\n                        return 0;\n                    }\n\n                    success = deleteMessageFromIcc(subId, messageIndex);\n                    // Notify changes even failure case since there might be some changes should be\n                    // known.\n                    getContext()\n                            .getContentResolver()\n                            .notifyChange(\n                                    match == SMS_ICC ? ICC_URI : ICC_SUBID_URI,\n                                    null,\n                                    true,\n                                    UserHandle.USER_ALL);\n                    return success ? 1 : 0; // return deleted count\n                }\n\n            default:\n                throw new IllegalArgumentException(\"Unknown URL\");\n        }\n\n        if (count > 0) {\n            notifyChange(notifyIfNotDefault, url, getCallingPackage());\n        }\n        return count;\n    }\n\n    /**\n     * Deletes the message at index from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @param messageIndex the message index of the message in the ICC (1-based index).\n     * @return true for succeess. Otherwise false.\n     */\n    private boolean deleteMessageFromIcc(int subId, int messageIndex) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            return smsManager.deleteMessageFromIcc(messageIndex);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Deletes all the messages from the ICC for a subscription ID.\n     *\n     * @param subId the subscription ID.\n     * @return return deleted messaegs count.\n     */\n    private int deleteAllMessagesFromIcc(int subId) {\n        if (!SubscriptionManager.isValidSubscriptionId(subId)) {\n            throw new IllegalArgumentException(\"Invalid Subscription ID \" + subId);\n        }\n        SmsManager smsManager = SmsManager.getSmsManagerForSubscriptionId(subId);\n\n        // Use phone app permissions to avoid UID mismatch in AppOpsManager.noteOp() call.\n        long token = Binder.clearCallingIdentity();\n        try {\n            int deletedCnt = 0;\n            int maxIndex = smsManager.getSmsCapacityOnIcc();\n            // messageIndex is 1-based index of the message in the ICC.\n            for (int messageIndex = 1; messageIndex <= maxIndex; messageIndex++) {\n                if (smsManager.deleteMessageFromIcc(messageIndex)) {\n                    deletedCnt++;\n                } else {\n                    Log.e(TAG, \"Fail to delete SMS at index \" + messageIndex\n                            + \" for subId \" + subId);\n                }\n            }\n            return deletedCnt;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {\n        final int callerUid = Binder.getCallingUid();\n        final UserHandle callerUserHandle = Binder.getCallingUserHandle();\n        final String callerPkg = getCallingPackage();\n        int count = 0;\n        String table = TABLE_SMS;\n        String extraWhere = null;\n        boolean notifyIfNotDefault = true;\n        int match = sURLMatcher.match(url);\n        SQLiteDatabase db = getWritableDatabase(match);\n\n        switch (match) {\n            case SMS_RAW_MESSAGE:\n                table = TABLE_RAW;\n                notifyIfNotDefault = false;\n                break;\n\n            case SMS_STATUS_PENDING:\n                table = TABLE_SR_PENDING;\n                break;\n\n            case SMS_ALL:\n            case SMS_FAILED:\n            case SMS_QUEUED:\n            case SMS_INBOX:\n            case SMS_SENT:\n            case SMS_DRAFT:\n            case SMS_OUTBOX:\n            case SMS_CONVERSATIONS:\n                break;\n\n            case SMS_ALL_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(0);\n                break;\n\n            case SMS_INBOX_ID:\n            case SMS_FAILED_ID:\n            case SMS_SENT_ID:\n            case SMS_DRAFT_ID:\n            case SMS_OUTBOX_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            case SMS_CONVERSATIONS_ID: {\n                String threadId = url.getPathSegments().get(1);\n\n                try {\n                    Integer.parseInt(threadId);\n                } catch (Exception ex) {\n                    Log.e(TAG, \"Bad conversation thread id: \" + threadId);\n                    break;\n                }\n\n                extraWhere = \"thread_id=\" + threadId;\n                break;\n            }\n\n            case SMS_STATUS_ID:\n                extraWhere = \"_id=\" + url.getPathSegments().get(1);\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\n                        \"URI \" + url + \" not supported\");\n        }\n\n        if (table.equals(TABLE_SMS) && ProviderUtil.shouldRemoveCreator(values, callerUid)) {\n            // CREATOR should not be changed by non-SYSTEM/PHONE apps\n            Log.w(TAG, callerPkg + \" tries to update CREATOR\");\n            values.remove(Sms.CREATOR);\n        }\n\n        if (table.equals(TABLE_SMS)) {\n            final long token = Binder.clearCallingIdentity();\n            String selectionBySubIds;\n            try {\n                // Filter SMS based on subId.\n                selectionBySubIds = ProviderUtil.getSelectionBySubIds(getContext(),\n                        callerUserHandle);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (selectionBySubIds == null) {\n                // No subscriptions associated with user, return 0;\n                return 0;\n            }\n            where = DatabaseUtils.concatenateWhere(where, selectionBySubIds);\n        }\n\n        where = DatabaseUtils.concatenateWhere(where, extraWhere);\n        count = db.update(table, values, where, whereArgs);\n\n        if (count > 0) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.d(TAG, \"update \" + url + \" succeeded\");\n            }\n            notifyChange(notifyIfNotDefault, url, callerPkg);\n        }\n        return count;\n    }\n\n    private void notifyChange(boolean notifyIfNotDefault, Uri uri, final String callingPackage) {\n        final Context context = getContext();\n        ContentResolver cr = context.getContentResolver();\n        cr.notifyChange(uri, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(MmsSms.CONTENT_URI, null, true, UserHandle.USER_ALL);\n        cr.notifyChange(Uri.parse(\"content://mms-sms/conversations/\"), null, true,\n                UserHandle.USER_ALL);\n        if (notifyIfNotDefault) {\n            ProviderUtil.notifyIfNotDefaultSmsApp(uri, callingPackage, context);\n        }\n    }\n\n    // Db open helper for tables stored in CE(Credential Encrypted) storage.\n    @VisibleForTesting\n    public SQLiteOpenHelper mCeOpenHelper;\n    // Db open helper for tables stored in DE(Device Encrypted) storage. It's currently only used\n    // to store raw table.\n    @VisibleForTesting\n    public SQLiteOpenHelper mDeOpenHelper;\n\n    private final static String TAG = \"SmsProvider\";\n    private final static String VND_ANDROID_SMS = \"vnd.android.cursor.item/sms\";\n    private final static String VND_ANDROID_SMSCHAT =\n            \"vnd.android.cursor.item/sms-chat\";\n    private final static String VND_ANDROID_DIR_SMS =\n            \"vnd.android.cursor.dir/sms\";\n\n    private static final String[] sIDProjection = new String[] { \"_id\" };\n\n    private static final int SMS_ALL = 0;\n    private static final int SMS_ALL_ID = 1;\n    private static final int SMS_INBOX = 2;\n    private static final int SMS_INBOX_ID = 3;\n    private static final int SMS_SENT = 4;\n    private static final int SMS_SENT_ID = 5;\n    private static final int SMS_DRAFT = 6;\n    private static final int SMS_DRAFT_ID = 7;\n    private static final int SMS_OUTBOX = 8;\n    private static final int SMS_OUTBOX_ID = 9;\n    private static final int SMS_CONVERSATIONS = 10;\n    private static final int SMS_CONVERSATIONS_ID = 11;\n    private static final int SMS_RAW_MESSAGE = 15;\n    private static final int SMS_ATTACHMENT = 16;\n    private static final int SMS_ATTACHMENT_ID = 17;\n    private static final int SMS_NEW_THREAD_ID = 18;\n    private static final int SMS_QUERY_THREAD_ID = 19;\n    private static final int SMS_STATUS_ID = 20;\n    private static final int SMS_STATUS_PENDING = 21;\n    private static final int SMS_ALL_ICC = 22;\n    private static final int SMS_ICC = 23;\n    private static final int SMS_FAILED = 24;\n    private static final int SMS_FAILED_ID = 25;\n    private static final int SMS_QUEUED = 26;\n    private static final int SMS_UNDELIVERED = 27;\n    private static final int SMS_RAW_MESSAGE_PERMANENT_DELETE = 28;\n    private static final int SMS_ALL_ICC_SUBID = 29;\n    private static final int SMS_ICC_SUBID = 30;\n\n    private static final UriMatcher sURLMatcher =\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms\", null, SMS_ALL);\n        sURLMatcher.addURI(\"sms\", \"#\", SMS_ALL_ID);\n        sURLMatcher.addURI(\"sms\", \"inbox\", SMS_INBOX);\n        sURLMatcher.addURI(\"sms\", \"inbox/#\", SMS_INBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"sent\", SMS_SENT);\n        sURLMatcher.addURI(\"sms\", \"sent/#\", SMS_SENT_ID);\n        sURLMatcher.addURI(\"sms\", \"draft\", SMS_DRAFT);\n        sURLMatcher.addURI(\"sms\", \"draft/#\", SMS_DRAFT_ID);\n        sURLMatcher.addURI(\"sms\", \"outbox\", SMS_OUTBOX);\n        sURLMatcher.addURI(\"sms\", \"outbox/#\", SMS_OUTBOX_ID);\n        sURLMatcher.addURI(\"sms\", \"undelivered\", SMS_UNDELIVERED);\n        sURLMatcher.addURI(\"sms\", \"failed\", SMS_FAILED);\n        sURLMatcher.addURI(\"sms\", \"failed/#\", SMS_FAILED_ID);\n        sURLMatcher.addURI(\"sms\", \"queued\", SMS_QUEUED);\n        sURLMatcher.addURI(\"sms\", \"conversations\", SMS_CONVERSATIONS);\n        sURLMatcher.addURI(\"sms\", \"conversations/#\", SMS_CONVERSATIONS_ID);\n        sURLMatcher.addURI(\"sms\", \"raw\", SMS_RAW_MESSAGE);\n        sURLMatcher.addURI(\"sms\", \"raw/permanentDelete\", SMS_RAW_MESSAGE_PERMANENT_DELETE);\n        sURLMatcher.addURI(\"sms\", \"attachments\", SMS_ATTACHMENT);\n        sURLMatcher.addURI(\"sms\", \"attachments/#\", SMS_ATTACHMENT_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID\", SMS_NEW_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"threadID/#\", SMS_QUERY_THREAD_ID);\n        sURLMatcher.addURI(\"sms\", \"status/#\", SMS_STATUS_ID);\n        sURLMatcher.addURI(\"sms\", \"sr_pending\", SMS_STATUS_PENDING);\n        sURLMatcher.addURI(\"sms\", \"icc\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc/#\", SMS_ICC);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#\", SMS_ALL_ICC_SUBID);\n        sURLMatcher.addURI(\"sms\", \"icc_subId/#/#\", SMS_ICC_SUBID);\n        //we keep these for not breaking old applications\n        sURLMatcher.addURI(\"sms\", \"sim\", SMS_ALL_ICC);\n        sURLMatcher.addURI(\"sms\", \"sim/#\", SMS_ICC);\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing SmsProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase(int match) {\n        return getDBOpenHelper(match).getReadableDatabase();\n    }\n\n    SQLiteDatabase getWritableDatabase(int match) {\n        return  getDBOpenHelper(match).getWritableDatabase();\n    }\n}\n","lineNo":121}
{"Smelly Sample":"/* //device/content/providers/telephony/TelephonyProvider.java\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n\npackage com.android.providers.telephony;\n\nimport static android.provider.Telephony.Carriers.ALWAYS_ON;\nimport static android.provider.Telephony.Carriers.APN;\nimport static android.provider.Telephony.Carriers.APN_SET_ID;\nimport static android.provider.Telephony.Carriers.AUTH_TYPE;\nimport static android.provider.Telephony.Carriers.BEARER;\nimport static android.provider.Telephony.Carriers.BEARER_BITMASK;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.CARRIER_EDITED;\nimport static android.provider.Telephony.Carriers.CARRIER_ENABLED;\nimport static android.provider.Telephony.Carriers.CARRIER_ID;\nimport static android.provider.Telephony.Carriers.CONTENT_URI;\nimport static android.provider.Telephony.Carriers.CURRENT;\nimport static android.provider.Telephony.Carriers.DEFAULT_SORT_ORDER;\nimport static android.provider.Telephony.Carriers.EDITED_STATUS;\nimport static android.provider.Telephony.Carriers.LINGERING_NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.MCC;\nimport static android.provider.Telephony.Carriers.MMSC;\nimport static android.provider.Telephony.Carriers.MMSPORT;\nimport static android.provider.Telephony.Carriers.MMSPROXY;\nimport static android.provider.Telephony.Carriers.MNC;\nimport static android.provider.Telephony.Carriers.MODEM_PERSIST;\nimport static android.provider.Telephony.Carriers.MTU;\nimport static android.provider.Telephony.Carriers.MTU_V4;\nimport static android.provider.Telephony.Carriers.MTU_V6;\nimport static android.provider.Telephony.Carriers.MVNO_MATCH_DATA;\nimport static android.provider.Telephony.Carriers.MVNO_TYPE;\nimport static android.provider.Telephony.Carriers.NAME;\nimport static android.provider.Telephony.Carriers.NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.NO_APN_SET_ID;\nimport static android.provider.Telephony.Carriers.NUMERIC;\nimport static android.provider.Telephony.Carriers.OWNED_BY;\nimport static android.provider.Telephony.Carriers.OWNED_BY_DPC;\nimport static android.provider.Telephony.Carriers.OWNED_BY_OTHERS;\nimport static android.provider.Telephony.Carriers.PASSWORD;\nimport static android.provider.Telephony.Carriers.PORT;\nimport static android.provider.Telephony.Carriers.PROFILE_ID;\nimport static android.provider.Telephony.Carriers.PROTOCOL;\nimport static android.provider.Telephony.Carriers.PROXY;\nimport static android.provider.Telephony.Carriers.ROAMING_PROTOCOL;\nimport static android.provider.Telephony.Carriers.SERVER;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT_DEFAULT;\nimport static android.provider.Telephony.Carriers.SUBSCRIPTION_ID;\nimport static android.provider.Telephony.Carriers.TIME_LIMIT_FOR_MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.TYPE;\nimport static android.provider.Telephony.Carriers.UNEDITED;\nimport static android.provider.Telephony.Carriers.USER;\nimport static android.provider.Telephony.Carriers.USER_DELETED;\nimport static android.provider.Telephony.Carriers.USER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.USER_EDITABLE;\nimport static android.provider.Telephony.Carriers.USER_EDITED;\nimport static android.provider.Telephony.Carriers.USER_VISIBLE;\nimport static android.provider.Telephony.Carriers.WAIT_TIME_RETRY;\nimport static android.provider.Telephony.Carriers._ID;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.compat.CompatChanges;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.content.res.XmlResourceParser;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.os.PersistableBundle;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.provider.Telephony;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.TelephonyProtoEnums;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.PhoneFactory;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.util.XmlUtils;\nimport android.service.carrier.IApnSourceService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.Integer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CRC32;\n\npublic class TelephonyProvider extends ContentProvider\n{\n    private static final String DATABASE_NAME = \"telephony.db\";\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n    private static final boolean DBG = true;\n    private static final boolean VDBG = false; // STOPSHIP if true\n\n    private static final int DATABASE_VERSION = 57 << 16;\n    private static final int URL_UNKNOWN = 0;\n    private static final int URL_TELEPHONY = 1;\n    private static final int URL_CURRENT = 2;\n    private static final int URL_ID = 3;\n    private static final int URL_RESTOREAPN = 4;\n    private static final int URL_PREFERAPN = 5;\n    private static final int URL_PREFERAPN_NO_UPDATE = 6;\n    private static final int URL_SIMINFO = 7;\n    private static final int URL_TELEPHONY_USING_SUBID = 8;\n    private static final int URL_CURRENT_USING_SUBID = 9;\n    private static final int URL_RESTOREAPN_USING_SUBID = 10;\n    private static final int URL_PREFERAPN_USING_SUBID = 11;\n    private static final int URL_PREFERAPN_NO_UPDATE_USING_SUBID = 12;\n    private static final int URL_SIMINFO_USING_SUBID = 13;\n    private static final int URL_UPDATE_DB = 14;\n    private static final int URL_DELETE = 15;\n    private static final int URL_DPC = 16;\n    private static final int URL_DPC_ID = 17;\n    private static final int URL_FILTERED = 18;\n    private static final int URL_FILTERED_ID = 19;\n    private static final int URL_ENFORCE_MANAGED = 20;\n    // URL_PREFERAPNSET and URL_PREFERAPNSET_USING_SUBID return all APNs for the current\n    // carrier which have an apn_set_id equal to the preferred APN\n    // (if no preferred APN, or preferred APN has no set id, the query will return null)\n    private static final int URL_PREFERAPNSET = 21;\n    private static final int URL_PREFERAPNSET_USING_SUBID = 22;\n    private static final int URL_SIM_APN_LIST = 23;\n    private static final int URL_SIM_APN_LIST_ID = 24;\n    private static final int URL_FILTERED_USING_SUBID = 25;\n    private static final int URL_SIM_APN_LIST_FILTERED = 26;\n    private static final int URL_SIM_APN_LIST_FILTERED_ID = 27;\n    private static final int URL_SIMINFO_SUW_RESTORE = 28;\n    private static final int URL_SIMINFO_SIM_INSERTED_RESTORE = 29;\n\n    /**\n     * Default value for mtu_v4 and mtu_v6 if it's not set. Moved from PhoneConstants.\n     */\n    private static final int UNSPECIFIED_INT = -1;\n\n    private static final String TAG = \"TelephonyProvider\";\n    private static final String CARRIERS_TABLE = \"carriers\";\n    private static final String CARRIERS_TABLE_TMP = \"carriers_tmp\";\n    private static final String SIMINFO_TABLE = \"siminfo\";\n    private static final String SIMINFO_TABLE_TMP = \"siminfo_tmp\";\n\n    private static final String PREF_FILE_APN = \"preferred-apn\";\n    private static final String COLUMN_APN_ID = \"apn_id\";\n    private static final String EXPLICIT_SET_CALLED = \"explicit_set_called\";\n\n    private static final String PREF_FILE_FULL_APN = \"preferred-full-apn\";\n    private static final String DB_VERSION_KEY = \"version\";\n\n    private static final String BUILD_ID_FILE = \"build-id\";\n    private static final String RO_BUILD_ID = \"ro_build_id\";\n\n    private static final String ENFORCED_FILE = \"dpc-apn-enforced\";\n    private static final String ENFORCED_KEY = \"enforced\";\n\n    private static final String PREF_FILE = \"telephonyprovider\";\n    private static final String APN_CONF_CHECKSUM = \"apn_conf_checksum\";\n\n    private static final String PARTNER_APNS_PATH = \"etc/apns-conf.xml\";\n    private static final String OEM_APNS_PATH = \"telephony/apns-conf.xml\";\n    private static final String OTA_UPDATED_APNS_PATH = \"misc/apns/apns-conf.xml\";\n    private static final String OLD_APNS_PATH = \"etc/old-apns-conf.xml\";\n\n    private static final String DEFAULT_PROTOCOL = \"IP\";\n    private static final String DEFAULT_ROAMING_PROTOCOL = \"IP\";\n\n    private static final UriMatcher s_urlMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    private static final ContentValues s_currentNullMap;\n    private static final ContentValues s_currentSetMap;\n\n    private static final String IS_UNEDITED = EDITED_STATUS + \"=\" + UNEDITED;\n    private static final String IS_EDITED = EDITED_STATUS + \"!=\" + UNEDITED;\n    private static final String IS_USER_EDITED = EDITED_STATUS + \"=\" + USER_EDITED;\n    private static final String IS_NOT_USER_EDITED = EDITED_STATUS + \"!=\" + USER_EDITED;\n    private static final String IS_USER_DELETED = EDITED_STATUS + \"=\" + USER_DELETED;\n    private static final String IS_NOT_USER_DELETED = EDITED_STATUS + \"!=\" + USER_DELETED;\n    private static final String IS_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_CARRIER_EDITED = EDITED_STATUS + \"=\" + CARRIER_EDITED;\n    private static final String IS_NOT_CARRIER_EDITED = EDITED_STATUS + \"!=\" + CARRIER_EDITED;\n    private static final String IS_CARRIER_DELETED = EDITED_STATUS + \"=\" + CARRIER_DELETED;\n    private static final String IS_NOT_CARRIER_DELETED = EDITED_STATUS + \"!=\" + CARRIER_DELETED;\n    private static final String IS_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_OWNED_BY_DPC = OWNED_BY + \"=\" + OWNED_BY_DPC;\n    private static final String IS_NOT_OWNED_BY_DPC = OWNED_BY + \"!=\" + OWNED_BY_DPC;\n\n    private static final String ORDER_BY_SUB_ID =\n            Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \" ASC\";\n\n    @VisibleForTesting\n    static final String BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE = \"sim_specific_settings_file\";\n    // Holds names and value types of SimInfoDb columns to backup.\n    private static final Map<String, Integer> SIM_INFO_COLUMNS_TO_BACKUP = new HashMap();\n    private static final String KEY_SIMINFO_DB_ROW_PREFIX = \"KEY_SIMINFO_DB_ROW_\";\n    private static final int DEFAULT_INT_COLUMN_VALUE = -111;\n    private static final String DEFAULT_STRING_COLUMN_VALUE = \"DEFAULT_STRING_COLUMN_VALUE\";\n    private static final String SIM_INSERTED_RESTORE_URI_SUFFIX = \"sim_inserted_restore\";\n    @VisibleForTesting\n    static final String KEY_BACKUP_DATA_FORMAT_VERSION = \"KEY_BACKUP_DATA_FORMAT_VERSION\";\n    @VisibleForTesting\n    static final String KEY_PREVIOUSLY_RESTORED_SUB_IDS = \"KEY_PREVIOUSLY_RESTORED_SUB_IDS\";\n\n    private static final int INVALID_APN_ID = -1;\n    private static final List<String> CARRIERS_UNIQUE_FIELDS = new ArrayList<String>();\n    private static final Set<String> CARRIERS_BOOLEAN_FIELDS = new HashSet<String>();\n    private static final Map<String, String> CARRIERS_UNIQUE_FIELDS_DEFAULTS = new HashMap();\n\n    @VisibleForTesting\n    static Boolean s_apnSourceServiceExists;\n\n    protected final Object mLock = new Object();\n    @GuardedBy(\"mLock\")\n    private IApnSourceService mIApnSourceService;\n    private Injector mInjector;\n\n    private boolean mManagedApnEnforced;\n\n    /**\n     * Mobile country codes where there is a high likelyhood that the MNC has 3 digits\n     * and need one more prefix zero to set correct mobile network code value.\n     *\n     * Please note! The best solution is to add the MCCMNC combo to carrier id\n     * carrier_list, this is just a best effort.\n     */\n    private static final String[] COUNTRY_MCC_WITH_THREE_DIGIT_MNC = {\n            \"302\" // Canada\n           ,\"310\" // Guam, USA\n           ,\"311\" // USA\n           ,\"312\" // USA\n           ,\"313\" // USA\n           ,\"316\" // USA\n           ,\"334\" // Mexico\n           ,\"338\" // Bermuda, Jamaica\n           ,\"342\" // Barbados\n           ,\"344\" // Antigua and Barbuda\n           ,\"346\" // Cayman Islands\n           ,\"348\" // British Virgin Islands\n           ,\"356\" // Saint Kitts and Nevis\n           ,\"358\" // Saint Lucia\n           ,\"360\" // Saint Vincent and the Grenadines\n           ,\"365\" // Anguilla\n           ,\"366\" // Dominica\n           ,\"376\" // Turks and Caicos Islands\n           ,\"405\" // India\n           ,\"708\" // Honduras\n           ,\"722\" // Argentina\n           ,\"732\" // Colombia\n           ,\"738\" // Guyana\n           ,\"750\" // Falkland Islands\n            };\n\n    /**\n     * Available radio technologies for GSM, UMTS and CDMA.\n     * Duplicates the constants from hardware/radio/include/ril.h\n     * This should only be used by agents working with the ril.  Others\n     * should use the equivalent TelephonyManager.NETWORK_TYPE_*\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_UNKNOWN = 0;\n    private static final int RIL_RADIO_TECHNOLOGY_GPRS = 1;\n    private static final int RIL_RADIO_TECHNOLOGY_EDGE = 2;\n    private static final int RIL_RADIO_TECHNOLOGY_UMTS = 3;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95A = 4;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95B = 5;\n    private static final int RIL_RADIO_TECHNOLOGY_1xRTT = 6;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_0 = 7;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_A = 8;\n    private static final int RIL_RADIO_TECHNOLOGY_HSDPA = 9;\n    private static final int RIL_RADIO_TECHNOLOGY_HSUPA = 10;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPA = 11;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_B = 12;\n    private static final int RIL_RADIO_TECHNOLOGY_EHRPD = 13;\n    private static final int RIL_RADIO_TECHNOLOGY_LTE = 14;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPAP = 15;\n\n    /**\n     * GSM radio technology only supports voice. It does not support data.\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_GSM = 16;\n    private static final int RIL_RADIO_TECHNOLOGY_TD_SCDMA = 17;\n\n    /**\n     * IWLAN\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;\n\n    /**\n     * LTE_CA\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_LTE_CA = 19;\n\n    /**\n     * NR(New Radio) 5G.\n     */\n    private static final int  RIL_RADIO_TECHNOLOGY_NR = 20;\n\n    /**\n     * The number of the radio technologies.\n     */\n    private static final int NEXT_RIL_RADIO_TECHNOLOGY = 21;\n\n    private static final Map<String, Integer> MVNO_TYPE_STRING_MAP;\n\n    static {\n        // Columns not included in UNIQUE constraint: name, current, edited, user, server, password,\n        // authtype, type, protocol, roaming_protocol, sub_id, modem_cognitive, max_conns,\n        // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n        // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(NUMERIC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MCC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MNC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ENABLED, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(BEARER, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_TYPE, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_MATCH_DATA, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROFILE_ID, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(ROAMING_PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(USER_EDITABLE, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(OWNED_BY, String.valueOf(OWNED_BY_OTHERS));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN_SET_ID, String.valueOf(NO_APN_SET_ID));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ID,\n                String.valueOf(TelephonyManager.UNKNOWN_CARRIER_ID));\n\n        CARRIERS_UNIQUE_FIELDS.addAll(CARRIERS_UNIQUE_FIELDS_DEFAULTS.keySet());\n\n        // SQLite databases store bools as ints but the ContentValues objects passed in through\n        // queries use bools. As a result there is some special handling of boolean fields within\n        // the TelephonyProvider.\n        CARRIERS_BOOLEAN_FIELDS.add(CARRIER_ENABLED);\n        CARRIERS_BOOLEAN_FIELDS.add(MODEM_PERSIST);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_VISIBLE);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_EDITABLE);\n\n        MVNO_TYPE_STRING_MAP = new ArrayMap<String, Integer>();\n        MVNO_TYPE_STRING_MAP.put(\"spn\", ApnSetting.MVNO_TYPE_SPN);\n        MVNO_TYPE_STRING_MAP.put(\"imsi\", ApnSetting.MVNO_TYPE_IMSI);\n        MVNO_TYPE_STRING_MAP.put(\"gid\", ApnSetting.MVNO_TYPE_GID);\n        MVNO_TYPE_STRING_MAP.put(\"iccid\", ApnSetting.MVNO_TYPE_ICCID);\n\n        // To B&R a new config, simply add the column name and its appropriate value type to\n        // SIM_INFO_COLUMNS_TO_BACKUP. To no longer B&R a column, simply remove it from\n        // SIM_INFO_COLUMNS_TO_BACKUP. For both cases, add appropriate versioning logic in\n        // convertBackedUpDataToContentValues(ContentValues contenValues)\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ICC_ID, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NUMBER, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_CARRIER_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_VT_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                Cursor.FIELD_TYPE_INTEGER);\n    }\n\n    @VisibleForTesting\n    public static String getStringForCarrierTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName +\n                \"(_id INTEGER PRIMARY KEY,\" +\n                NAME + \" TEXT DEFAULT '',\" +\n                NUMERIC + \" TEXT DEFAULT '',\" +\n                MCC + \" TEXT DEFAULT '',\" +\n                MNC + \" TEXT DEFAULT '',\" +\n                CARRIER_ID + \" INTEGER DEFAULT \" + TelephonyManager.UNKNOWN_CARRIER_ID  + \",\" +\n                APN + \" TEXT DEFAULT '',\" +\n                USER + \" TEXT DEFAULT '',\" +\n                SERVER + \" TEXT DEFAULT '',\" +\n                PASSWORD + \" TEXT DEFAULT '',\" +\n                PROXY + \" TEXT DEFAULT '',\" +\n                PORT + \" TEXT DEFAULT '',\" +\n                MMSPROXY + \" TEXT DEFAULT '',\" +\n                MMSPORT + \" TEXT DEFAULT '',\" +\n                MMSC + \" TEXT DEFAULT '',\" +\n                AUTH_TYPE + \" INTEGER DEFAULT -1,\" +\n                TYPE + \" TEXT DEFAULT '',\" +\n                CURRENT + \" INTEGER,\" +\n                PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_PROTOCOL + \",\" +\n                ROAMING_PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_ROAMING_PROTOCOL + \",\" +\n                CARRIER_ENABLED + \" BOOLEAN DEFAULT 1,\" + // SQLite databases store bools as ints\n                BEARER + \" INTEGER DEFAULT 0,\" +\n                BEARER_BITMASK + \" INTEGER DEFAULT 0,\" +\n                NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                MVNO_TYPE + \" TEXT DEFAULT '',\" +\n                MVNO_MATCH_DATA + \" TEXT DEFAULT '',\" +\n                SUBSCRIPTION_ID + \" INTEGER DEFAULT \" +\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID + \",\" +\n                PROFILE_ID + \" INTEGER DEFAULT 0,\" +\n                MODEM_PERSIST + \" BOOLEAN DEFAULT 0,\" +\n                MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                WAIT_TIME_RETRY + \" INTEGER DEFAULT 0,\" +\n                TIME_LIMIT_FOR_MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                MTU + \" INTEGER DEFAULT 0,\" +\n                MTU_V4 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \",\" +\n                MTU_V6 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \",\" +\n                EDITED_STATUS + \" INTEGER DEFAULT \" + UNEDITED + \",\" +\n                USER_VISIBLE + \" BOOLEAN DEFAULT 1,\" +\n                USER_EDITABLE + \" BOOLEAN DEFAULT 1,\" +\n                OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \",\" +\n                APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \",\" +\n                SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \",\" +\n                ALWAYS_ON + \" INTEGER DEFAULT 0,\" +\n                // Uniqueness collisions are used to trigger merge code so if a field is listed\n                // here it means we will accept both (user edited + new apn_conf definition)\n                // Columns not included in UNIQUE constraint: name, current, edited,\n                // user, server, password, authtype, type, sub_id, modem_cognitive, max_conns,\n                // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n                // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on.\n                \"UNIQUE (\" + TextUtils.join(\", \", CARRIERS_UNIQUE_FIELDS) + \"));\";\n    }\n\n    @VisibleForTesting\n    public static String getStringForSimInfoTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName + \"(\"\n                + Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID\n                + \" INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                + Telephony.SimInfo.COLUMN_ICC_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_NOT_INSERTED + \",\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NAME_SOURCE\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.NAME_SOURCE_CARRIER_ID + \",\"\n                + Telephony.SimInfo.COLUMN_COLOR + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.COLOR_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_NUMBER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT\n                + \" INTEGER NOT NULL DEFAULT \" + Telephony.SimInfo.DISPLAY_NUMBER_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_DATA_ROAMING\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.DATA_ROAMING_DISABLE + \",\"\n                + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_PROVISIONED + \",\"\n                + Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CARD_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION + \" INTEGER DEFAULT 4,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.PROFILE_CLASS_UNSET + \",\"\n                + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \",\"\n                + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IMSI + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES + \" BIGINT DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_RCS_CONFIG + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PORT_INDEX + \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USAGE_SETTING + \" INTEGER DEFAULT \"\n                + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                + \");\";\n    }\n\n    static {\n        s_urlMatcher.addURI(\"telephony\", \"carriers\", URL_TELEPHONY);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current\", URL_CURRENT);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/#\", URL_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore\", URL_RESTOREAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn\", URL_PREFERAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update\", URL_PREFERAPN_NO_UPDATE);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset\", URL_PREFERAPNSET);\n\n        s_urlMatcher.addURI(\"telephony\", \"siminfo\", URL_SIMINFO);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/#\", URL_SIMINFO_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/suw_restore\",\n                URL_SIMINFO_SUW_RESTORE);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/\" +\n                SIM_INSERTED_RESTORE_URI_SUFFIX,\n                URL_SIMINFO_SIM_INSERTED_RESTORE);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/subId/*\", URL_TELEPHONY_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current/subId/*\", URL_CURRENT_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore/subId/*\", URL_RESTOREAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn/subId/*\", URL_PREFERAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update/subId/*\",\n                URL_PREFERAPN_NO_UPDATE_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset/subId/*\",\n                URL_PREFERAPNSET_USING_SUBID);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/update_db\", URL_UPDATE_DB);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/delete\", URL_DELETE);\n\n        // Only called by DevicePolicyManager to manipulate DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc\", URL_DPC);\n        // Only called by DevicePolicyManager to manipulate a DPC record with certain _ID.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc/#\", URL_DPC_ID);\n        // Only called by Settings app, DcTracker and other telephony components to get APN list\n        // according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered\", URL_FILTERED);\n        // Only called by Settings app, DcTracker and other telephony components to get a\n        // single APN according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/#\", URL_FILTERED_ID);\n        // Used by DcTracker to pass a subId.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/subId/*\", URL_FILTERED_USING_SUBID);\n\n        // Only Called by DevicePolicyManager to enforce DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/enforce_managed\", URL_ENFORCE_MANAGED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list\", URL_SIM_APN_LIST);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/#\", URL_SIM_APN_LIST_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered\",\n            URL_SIM_APN_LIST_FILTERED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered/subId/*\",\n                URL_SIM_APN_LIST_FILTERED_ID);\n\n        s_currentNullMap = new ContentValues(1);\n        s_currentNullMap.put(CURRENT, \"0\");\n\n        s_currentSetMap = new ContentValues(1);\n        s_currentSetMap.put(CURRENT, \"1\");\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n    }\n\n    public TelephonyProvider() {\n        this(new Injector());\n    }\n\n    @VisibleForTesting\n    public TelephonyProvider(Injector injector) {\n        mInjector = injector;\n    }\n\n    @VisibleForTesting\n    public static int getVersion(Context context) {\n        if (VDBG) log(\"getVersion:+\");\n        // Get the database version, combining a static schema version and the XML version\n        Resources r = context.getResources();\n        if (r == null) {\n            loge(\"resources=null, return version=\" + Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        }\n        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n        try {\n            XmlUtils.beginDocument(parser, \"apns\");\n            int publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n            int version = DATABASE_VERSION | publicversion;\n            if (VDBG) log(\"getVersion:- version=0x\" + Integer.toHexString(version));\n            return version;\n        } catch (Exception e) {\n            loge(\"Can't get version of APN database\" + e + \" return version=\" +\n                    Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        } finally {\n            parser.close();\n        }\n    }\n\n    static public ContentValues setDefaultValue(ContentValues values) {\n        if (!values.containsKey(SUBSCRIPTION_ID)) {\n            int subId = SubscriptionManager.getDefaultSubscriptionId();\n            values.put(SUBSCRIPTION_ID, subId);\n        }\n\n        return values;\n    }\n\n    @VisibleForTesting\n    public class DatabaseHelper extends SQLiteOpenHelper {\n        // Context to access resources with\n        private Context mContext;\n\n        /**\n         * DatabaseHelper helper class for loading apns into a database.\n         *\n         * @param context of the user.\n         */\n        public DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n            setWriteAheadLoggingEnabled(false);\n        }\n\n        @Override\n        public void onCreate(SQLiteDatabase db) {\n            if (DBG) log(\"dbh.onCreate:+ db=\" + db);\n            createSimInfoTable(db, SIMINFO_TABLE);\n            createCarriersTable(db, CARRIERS_TABLE);\n            // if CarrierSettings app is installed, we expect it to do the initializiation instead\n            if (apnSourceServiceExists(mContext)) {\n                log(\"dbh.onCreate: Skipping apply APNs from xml.\");\n            } else {\n                log(\"dbh.onCreate: Apply apns from xml.\");\n                initDatabase(db);\n            }\n            if (DBG) log(\"dbh.onCreate:- db=\" + db);\n        }\n\n        @Override\n        public void onOpen(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.onOpen:+ db=\" + db);\n            try {\n                // Try to access the table and create it if \"no such table\"\n                db.query(SIMINFO_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + SIMINFO_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + SIMINFO_TABLE + \"e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createSimInfoTable(db, SIMINFO_TABLE);\n                }\n            }\n            try {\n                db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + CARRIERS_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + CARRIERS_TABLE + \" e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createCarriersTable(db, CARRIERS_TABLE);\n                }\n            }\n            if (VDBG) log(\"dbh.onOpen:- db=\" + db);\n        }\n\n        private void createSimInfoTable(SQLiteDatabase db, String tableName) {\n            if (DBG) log(\"dbh.createSimInfoTable:+ \" + tableName);\n            db.execSQL(getStringForSimInfoTableCreation(tableName));\n            if (DBG) log(\"dbh.createSimInfoTable:-\");\n        }\n\n        private void createCarriersTable(SQLiteDatabase db, String tableName) {\n            // Set up the database schema\n            if (DBG) log(\"dbh.createCarriersTable: \" + tableName);\n            db.execSQL(getStringForCarrierTableCreation(tableName));\n            if (DBG) log(\"dbh.createCarriersTable:-\");\n        }\n\n        private long getChecksum(File file) {\n            CRC32 checkSummer = new CRC32();\n            long checkSum = -1;\n            try (CheckedInputStream cis =\n                new CheckedInputStream(new FileInputStream(file), checkSummer)){\n                byte[] buf = new byte[128];\n                if(cis != null) {\n                    while(cis.read(buf) >= 0) {\n                        // Just read for checksum to get calculated.\n                    }\n                }\n                checkSum = checkSummer.getValue();\n                if (DBG) log(\"Checksum for \" + file.getAbsolutePath() + \" is \" + checkSum);\n            } catch (FileNotFoundException e) {\n                loge(\"FileNotFoundException for \" + file.getAbsolutePath() + \":\" + e);\n            } catch (IOException e) {\n                loge(\"IOException for \" + file.getAbsolutePath() + \":\" + e);\n            }\n\n            // The RRO may have been updated in a firmware upgrade. Add checksum for the\n            // resources to the total checksum so that apns in an RRO update is not missed.\n            try (InputStream inputStream = mContext.getResources().\n                        openRawResource(com.android.internal.R.xml.apns)) {\n                byte[] array = toByteArray(inputStream);\n                checkSummer.reset();\n                checkSummer.update(array);\n                checkSum += checkSummer.getValue();\n                if (DBG) log(\"Checksum after adding resource is \" + checkSummer.getValue());\n            } catch (IOException | Resources.NotFoundException e) {\n                loge(\"Exception when calculating checksum for internal apn resources: \" + e);\n            }\n            return checkSum;\n        }\n\n        private byte[] toByteArray(InputStream input) throws IOException {\n            byte[] buffer = new byte[128];\n            int bytesRead;\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            return output.toByteArray();\n        }\n\n        private long getApnConfChecksum() {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            return sp.getLong(APN_CONF_CHECKSUM, -1);\n        }\n\n        private void setApnConfChecksum(long checksum) {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.putLong(APN_CONF_CHECKSUM, checksum);\n            editor.apply();\n        }\n\n        private File getApnConfFile() {\n            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or \"/system\".\n            File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);\n            File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);\n            File updatedConfFile = new File(Environment.getDataDirectory(), OTA_UPDATED_APNS_PATH);\n            File productConfFile = new File(Environment.getProductDirectory(), PARTNER_APNS_PATH);\n            confFile = pickSecondIfExists(confFile, oemConfFile);\n            confFile = pickSecondIfExists(confFile, productConfFile);\n            confFile = pickSecondIfExists(confFile, updatedConfFile);\n            return confFile;\n        }\n\n        /**\n         * This function computes checksum for the file to be read and compares it against the\n         * last read file. DB needs to be updated only if checksum has changed, or old checksum does\n         * not exist.\n         * @return true if DB should be updated with new conf file, false otherwise\n         */\n        private boolean apnDbUpdateNeeded() {\n            File confFile = getApnConfFile();\n            long newChecksum = getChecksum(confFile);\n            long oldChecksum = getApnConfChecksum();\n            if (DBG) log(\"newChecksum: \" + newChecksum);\n            if (DBG) log(\"oldChecksum: \" + oldChecksum);\n            if (newChecksum == oldChecksum) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        /**\n         *  This function adds APNs from xml file(s) to db. The db may or may not be empty to begin\n         *  with.\n         */\n        private void initDatabase(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.initDatabase:+ db=\" + db);\n            // Read internal APNS data\n            Resources r = mContext.getResources();\n            int publicversion = -1;\n            if (r != null) {\n                XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n                try {\n                    XmlUtils.beginDocument(parser, \"apns\");\n                    publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n                    loadApns(db, parser, true);\n                } catch (Exception e) {\n                    loge(\"Got exception while loading APN database.\" + e);\n                } finally {\n                    parser.close();\n                }\n            } else {\n                loge(\"initDatabase: resources=null\");\n            }\n\n            // Read external APNS data (partner-provided)\n            XmlPullParser confparser = null;\n            File confFile = getApnConfFile();\n\n            FileReader confreader = null;\n            if (DBG) log(\"confFile = \" + confFile);\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                // Correctness check. Force internal version and confidential versions to agree\n                int confversion = Integer.parseInt(confparser.getAttributeValue(null, \"version\"));\n                if (publicversion != confversion) {\n                    log(\"initDatabase: throwing exception due to version mismatch\");\n                    throw new IllegalStateException(\"Internal APNS file version doesn't match \"\n                            + confFile.getAbsolutePath());\n                }\n\n                loadApns(db, confparser, false);\n            } catch (FileNotFoundException e) {\n                // It's ok if the file isn't found. It means there isn't a confidential file\n                // Log.e(TAG, \"File not found: '\" + confFile.getAbsolutePath() + \"'\");\n            } catch (Exception e) {\n                loge(\"initDatabase: Exception while parsing '\" + confFile.getAbsolutePath() + \"'\" +\n                        e);\n            } finally {\n                // Get rid of user/carrier deleted entries that are not present in apn xml file.\n                // Those entries have edited value USER_DELETED/CARRIER_DELETED.\n                if (VDBG) {\n                    log(\"initDatabase: deleting USER_DELETED and replacing \"\n                            + \"DELETED_BUT_PRESENT_IN_XML with DELETED\");\n                }\n\n                // Delete USER_DELETED\n                db.delete(CARRIERS_TABLE, IS_USER_DELETED + \" or \" + IS_CARRIER_DELETED, null);\n\n                // Change USER_DELETED_BUT_PRESENT_IN_XML to USER_DELETED\n                ContentValues cv = new ContentValues();\n                cv.put(EDITED_STATUS, USER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_USER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                // Change CARRIER_DELETED_BUT_PRESENT_IN_XML to CARRIER_DELETED\n                cv = new ContentValues();\n                cv.put(EDITED_STATUS, CARRIER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_CARRIER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n\n                // Update the stored checksum\n                setApnConfChecksum(getChecksum(confFile));\n            }\n            if (VDBG) log(\"dbh.initDatabase:- db=\" + db);\n\n        }\n\n        private File pickSecondIfExists(File sysApnFile, File altApnFile) {\n            if (altApnFile.exists()) {\n                if (DBG) log(\"Load APNs from \" + altApnFile.getPath() +\n                        \" instead of \" + sysApnFile.getPath());\n                return altApnFile;\n            } else {\n                if (DBG) log(\"Load APNs from \" + sysApnFile.getPath() +\n                        \" instead of \" + altApnFile.getPath());\n                return sysApnFile;\n            }\n        }\n\n        @Override\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n            if (DBG) {\n                log(\"dbh.onUpgrade:+ db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n\n            deletePreferredApnId(mContext);\n\n            if (oldVersion < (5 << 16 | 6)) {\n                // 5 << 16 is the Database version and 6 in the xml version.\n\n                // This change adds a new authtype column to the database.\n                // The auth type column can have 4 values: 0 (None), 1 (PAP), 2 (CHAP)\n                // 3 (PAP or CHAP). To avoid breaking compatibility, with already working\n                // APNs, the unset value (-1) will be used. If the value is -1.\n                // the authentication will default to 0 (if no user / password) is specified\n                // or to 3. Currently, there have been no reported problems with\n                // pre-configured APNs and hence it is set to -1 for them. Similarly,\n                // if the user, has added a new APN, we set the authentication type\n                // to -1.\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN authtype INTEGER DEFAULT -1;\");\n\n                oldVersion = 5 << 16 | 6;\n            }\n            if (oldVersion < (6 << 16 | 6)) {\n                // Add protcol fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN protocol TEXT DEFAULT IP;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN roaming_protocol TEXT DEFAULT IP;\");\n                oldVersion = 6 << 16 | 6;\n            }\n            if (oldVersion < (7 << 16 | 6)) {\n                // Add carrier_enabled, bearer fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN carrier_enabled BOOLEAN DEFAULT 1;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN bearer INTEGER DEFAULT 0;\");\n                oldVersion = 7 << 16 | 6;\n            }\n            if (oldVersion < (8 << 16 | 6)) {\n                // Add mvno_type, mvno_match_data fields to the APN.\n                // The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_type TEXT DEFAULT '';\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_match_data TEXT DEFAULT '';\");\n                oldVersion = 8 << 16 | 6;\n            }\n            if (oldVersion < (9 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN sub_id INTEGER DEFAULT \" +\n                        SubscriptionManager.INVALID_SUBSCRIPTION_ID + \";\");\n                oldVersion = 9 << 16 | 6;\n            }\n            if (oldVersion < (10 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN profile_id INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN modem_cognitive BOOLEAN DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN wait_time INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns_time INTEGER DEFAULT 0;\");\n                oldVersion = 10 << 16 | 6;\n            }\n            if (oldVersion < (11 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mtu INTEGER DEFAULT 0;\");\n                oldVersion = 11 << 16 | 6;\n            }\n            if (oldVersion < (12 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 12 << 16 | 6;\n            }\n            if (oldVersion < (13 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT DEFAULT '';\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 13 << 16 | 6;\n            }\n            if (oldVersion < (14 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for next version and that takes care of updates for this version as well.\n                // This version added a new column user_edited to carriers db.\n            }\n            if (oldVersion < (15 << 16 | 6)) {\n                // Most devices should be upgrading from version 13. On upgrade new db will be\n                // populated from the xml included in OTA but user and carrier edited/added entries\n                // need to be preserved. This new version also adds new columns EDITED and\n                // BEARER_BITMASK to the table. Upgrade steps from version 13 are:\n                // 1. preserve user and carrier added/edited APNs (by comparing against\n                // old-apns-conf.xml included in OTA) - done in preserveUserAndCarrierApns()\n                // 2. add new columns EDITED and BEARER_BITMASK (create a new table for that) - done\n                // in createCarriersTable()\n                // 3. copy over preserved APNs from old table to new table - done in\n                // copyPreservedApnsToNewTable()\n                // The only exception if upgrading from version 14 is that EDITED field is already\n                // present (but is called USER_EDITED)\n                /*********************************************************************************\n                 * IMPORTANT NOTE: SINCE CARRIERS TABLE IS RECREATED HERE, IT WILL BE THE LATEST\n                 * VERSION AFTER THIS. AS A RESULT ANY SUBSEQUENT UPDATES TO THE TABLE WILL FAIL\n                 * (DUE TO COLUMN-ALREADY-EXISTS KIND OF EXCEPTION). ALL SUBSEQUENT UPDATES SHOULD\n                 * HANDLE THAT GRACEFULLY.\n                 *********************************************************************************/\n                Cursor c;\n                String[] proj = {\"_id\"};\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                }\n\n                // Compare db with old apns xml file so that any user or carrier edited/added\n                // entries can be preserved across upgrade\n                preserveUserAndCarrierApns(db);\n\n                c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n                if (VDBG) {\n                    log(\"dbh.onUpgrade:- after preserveUserAndCarrierApns() total number of \" +\n                            \"rows: \" + ((c == null) ? 0 : c.getCount()));\n                }\n\n                createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n                copyPreservedApnsToNewTable(db, c);\n                c.close();\n\n                db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE +\n                        \";\");\n\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_UNEDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_UNEDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_EDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_EDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                }\n\n                oldVersion = 15 << 16 | 6;\n            }\n            if (oldVersion < (16 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    // These columns may already be present in which case execSQL will throw an\n                    // exception\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION\n                            + \" INTEGER DEFAULT 4;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL\n                            + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 16 << 16 | 6;\n            }\n            if (oldVersion < (17 << 16 | 6)) {\n                Cursor c = null;\n                try {\n                    c = db.query(CARRIERS_TABLE, null, null, null, null, null, null,\n                            String.valueOf(1));\n                    if (c == null || c.getColumnIndex(USER_VISIBLE) == -1) {\n                        db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                                USER_VISIBLE + \" BOOLEAN DEFAULT 1;\");\n                    } else {\n                        if (DBG) {\n                            log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade.  Column \" +\n                                    USER_VISIBLE + \" already exists.\");\n                        }\n                    }\n                } finally {\n                    if (c != null) {\n                        c.close();\n                    }\n                }\n                oldVersion = 17 << 16 | 6;\n            }\n            if (oldVersion < (18 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.SIM_PROVISIONED + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 18 << 16 | 6;\n            }\n            if (oldVersion < (19 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for version 24 and that takes care of updates for this version as well.\n                // This version added more fields protocol and roaming protocol to the primary key.\n            }\n            if (oldVersion < (20 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 20 << 16 | 6;\n            }\n            if (oldVersion < (21 << 16 | 6)) {\n                try {\n                    // Try to update the carriers table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            USER_EDITABLE + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    // This is possible if the column already exists which may be the case if the\n                    // table was just created as part of upgrade to version 19\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 21 << 16 | 6;\n            }\n            if (oldVersion < (22 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 22 << 16 | 6;\n            }\n            if (oldVersion < (23 << 16 | 6)) {\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 23 << 16 | 6;\n            }\n            if (oldVersion < (24 << 16 | 6)) {\n                Cursor c = null;\n                String[] proj = {\"_id\"};\n                recreateDB(db, proj, /* version */24);\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(\n                            CARRIERS_TABLE, proj, NETWORK_TYPE_BITMASK, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + NETWORK_TYPE_BITMASK + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 24 << 16 | 6;\n            }\n            if (oldVersion < (25 << 16 | 6)) {\n                // Add a new column SubscriptionManager.CARD_ID into the database and set the value\n                // to be the same as the existing column SubscriptionManager.ICC_ID. In order to do\n                // this, we need to first make a copy of the existing SIMINFO_TABLE, set the value\n                // of the new column SubscriptionManager.CARD_ID, and replace the SIMINFO_TABLE with\n                // the new table.\n                Cursor c = null;\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID};\n                recreateSimInfoDB(c, db, proj);\n                if (VDBG) {\n                    c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading \" + SIMINFO_TABLE\n                            + \" total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(SIMINFO_TABLE, proj, Telephony.SimInfo.COLUMN_CARD_ID\n                                    + \" IS NOT NULL\", null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + Telephony.SimInfo.COLUMN_CARD_ID + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 25 << 16 | 6;\n            }\n            if (oldVersion < (26 << 16 | 6)) {\n                // Add a new column Carriers.APN_SET_ID into the database and set the value to\n                // Carriers.NO_SET_SET by default.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 26 << 16 | 6;\n            }\n\n            if (oldVersion < (27 << 16 | 6)) {\n                // Add the new MCC_STRING and MNC_STRING columns into the subscription table,\n                // and attempt to populate them.\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                // Migrate the old integer values over to strings\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_MCC, Telephony.SimInfo.COLUMN_MNC};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInMccMncStringAtCursor(mContext, db, c);\n                    }\n                }\n                oldVersion = 27 << 16 | 6;\n            }\n\n            if (oldVersion < (28 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 28 << 16 | 6;\n            }\n\n            if (oldVersion < (29 << 16 | 6)) {\n                try {\n                    // Add a new column Telephony.CARRIER_ID into the database and add UNIQUE\n                    // constraint into table. However, sqlite cannot add constraints to an existing\n                    // table, so recreate the table.\n                    String[] proj = {\"_id\"};\n                    recreateDB(db, proj,  /* version */29);\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 29 << 16 | 6;\n            }\n\n            if (oldVersion < (30 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 30 << 16 | 6;\n            }\n\n            if (oldVersion < (31 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 31 << 16 | 6;\n            }\n\n            if (oldVersion < (32 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 32 << 16 | 6;\n            }\n\n            if (oldVersion < (33 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 33 << 16 | 6;\n            }\n\n            if (oldVersion < (34 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.PROFILE_CLASS_UNSET + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 34 << 16 | 6;\n            }\n\n            if (oldVersion < (35 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                        + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 35 << 16 | 6;\n            }\n\n            if (oldVersion < (36 << 16 | 6)) {\n                // Add a new column Carriers.SKIP_464XLAT into the database and set the value to\n                // SKIP_464XLAT_DEFAULT.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 36 << 16 | 6;\n            }\n\n            if (oldVersion < (37 << 16 | 6)) {\n                // Add new columns Telephony.SimInfo.EHPLMNS and Telephony.SimInfo.HPLMNS into\n                // the database.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade for ehplmns. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 37 << 16 | 6;\n            }\n\n            if (oldVersion < (39 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 39 << 16 | 6;\n            }\n\n            if (oldVersion < (40 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 40 << 16 | 6;\n            }\n\n            if (oldVersion < (41 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMSI + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 41 << 16 | 6;\n            }\n\n            if (oldVersion < (42 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n            }\n\n            if (oldVersion < (43 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED\n                            + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 43 << 16 | 6;\n            }\n\n            if (oldVersion < (44 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES\n                            + \" BIGINT DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 44 << 16 | 6;\n            }\n\n            if (oldVersion < (45 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 45 << 16 | 6;\n            }\n\n            if (oldVersion < (46 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 46 << 16 | 6;\n            }\n\n            if (oldVersion < (47 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_RCS_CONFIG\n                            + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 47 << 16 | 6;\n            }\n\n            if (oldVersion < (48 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                try {\n                    // Migrate the old Long values over to String\n                    String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                            Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES};\n                    try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                        while (c.moveToNext()) {\n                            fillInAllowedNetworkTypesStringAtCursor(db, c);\n                        }\n                    }\n\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_ALLOWED_NETWORK_TYPES to \"\n                                + \"COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON\");\n                    }\n                }\n                oldVersion = 48 << 16 | 6;\n            }\n\n            if (oldVersion < (49 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing column. \");\n                    }\n                }\n            }\n\n            if (oldVersion < (50 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 50 << 16 | 6;\n            }\n\n            if (oldVersion < (51 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALERT TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 51 << 16 | 6;\n            }\n\n            if (oldVersion < (52 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 52 << 16 | 6;\n            }\n\n            if (oldVersion < (53 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. Fix typo error in version 51.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 53 << 16 | 6;\n            }\n\n            if (oldVersion < (54 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER\n                            + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add phone numbers. \");\n                    }\n                }\n                oldVersion = 54 << 16 | 6;\n            }\n\n            if (oldVersion < (55 << 16 | 6)) {\n                try {\n                    // Try to add new fields LINGERING_NETWORK_TYPE_BITMASK, ALWAYS_ON,\n                    // MTU_V4, and MTU_V6\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + ALWAYS_ON + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V4 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \";\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V6 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \";\");\n                    // Populate MTU_V4 with MTU values, using default value -1 instead of 0\n                    db.execSQL(\"UPDATE \" + CARRIERS_TABLE + \" SET \" + MTU_V4 + \" = \"\n                            + MTU + \" WHERE \" + MTU + \" != 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + CARRIERS_TABLE\n                                + \" to add lingering network type bitmask, always on flag,\"\n                                + \" and MTU v4 and v6 values.\");\n                    }\n                }\n                oldVersion = 55 << 16 | 6;\n            }\n\n            if (oldVersion < (56 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PORT_INDEX\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 56 << 16 | 6;\n            }\n\n            if (oldVersion < (57 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USAGE_SETTING\n                            + \" INTEGER DEFAULT \" + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                            + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add preferred usage setting\");\n                    }\n                }\n                oldVersion = 57 << 16 | 6;\n            }\n\n            if (DBG) {\n                log(\"dbh.onUpgrade:- db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n            // when adding fields to onUpgrade, also add a unit test to TelephonyDatabaseHelperTest\n            // and update the DATABASE_VERSION field and add a column in copyAllApnValues\n        }\n\n        private void recreateSimInfoDB(Cursor c, SQLiteDatabase db, String[] proj) {\n            if (VDBG) {\n                c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:+ before upgrading \" + SIMINFO_TABLE +\n                        \" total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            // Sort in ascending order by subscription id to make sure the rows do not get flipped\n            // during the query and added in the new sim info table in another order (sub id is\n            // stored in settings between migrations).\n            c = db.query(SIMINFO_TABLE, null, null, null, null, null, ORDER_BY_SUB_ID);\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE_TMP);\n\n            createSimInfoTable(db, SIMINFO_TABLE_TMP);\n\n            copySimInfoDataToTmpTable(db, c);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE_TMP + \" rename to \" + SIMINFO_TABLE + \";\");\n\n        }\n\n        private void copySimInfoDataToTmpTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from SIMINFO_TABLE to SIMINFO_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copySimInfoValuesV24(cv, c);\n                    // The card ID is supposed to be the ICCID of the profile for UICC card, and\n                    // the EID of the card for eUICC card. Since EID is unknown for old entries in\n                    // SIMINFO_TABLE, we use ICCID as the card ID for all the old entries while\n                    // upgrading the SIMINFO_TABLE. In UiccController, both the card ID and ICCID\n                    // will be checked when user queries the slot information using the card ID\n                    // from the database.\n                    getCardIdfromIccid(cv, c);\n                    try {\n                        db.insert(SIMINFO_TABLE_TMP, null, cv);\n                        if (VDBG) {\n                            log(\"dbh.copySimInfoDataToTmpTable: db.insert returned >= 0; \" +\n                                \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copySimInfoDataToTmpTable insertWithOnConflict exception \" +\n                                e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copySimInfoValuesV24(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ICC_ID);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CARRIER_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NUMBER);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NAME_SOURCE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_COLOR);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DATA_ROAMING);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MCC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MNC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_EMBEDDED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_REMOVABLE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_AMBER_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_VT_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED);\n\n            // Blob vals\n            getBlobValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ACCESS_RULES);\n        }\n\n        private void getCardIdfromIccid(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    cv.put(Telephony.SimInfo.COLUMN_CARD_ID, fromCursor);\n                }\n            }\n        }\n\n        private void recreateDB(SQLiteDatabase db, String[] proj, int version) {\n            // Upgrade steps are:\n            // 1. Create a temp table- done in createCarriersTable()\n            // 2. copy over APNs from old table to new table - done in copyDataToTmpTable()\n            // 3. Drop the existing table.\n            // 4. Copy over the tmp table.\n            Cursor c;\n            if (VDBG) {\n                c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n            if (VDBG) {\n                log(\"dbh.onUpgrade:- starting data copy of existing rows: \" +\n                        + ((c == null) ? 0 : c.getCount()));\n            }\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE_TMP);\n\n            createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n            copyDataToTmpTable(db, c, version);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE + \";\");\n        }\n\n        private void preserveUserAndCarrierApns(SQLiteDatabase db) {\n            if (VDBG) log(\"preserveUserAndCarrierApns\");\n            XmlPullParser confparser;\n            File confFile = new File(Environment.getRootDirectory(), OLD_APNS_PATH);\n            FileReader confreader = null;\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                deleteMatchingApns(db, confparser);\n            } catch (FileNotFoundException e) {\n                // This function is called only when upgrading db to version 15. Details about the\n                // upgrade are mentioned in onUpgrade(). This file missing means user/carrier added\n                // APNs cannot be preserved. Log an error message so that OEMs know they need to\n                // include old apns file for comparison.\n                loge(\"PRESERVEUSERANDCARRIERAPNS: \" + OLD_APNS_PATH +\n                        \" NOT FOUND. IT IS NEEDED TO UPGRADE FROM OLDER VERSIONS OF APN \" +\n                        \"DB WHILE PRESERVING USER/CARRIER ADDED/EDITED ENTRIES.\");\n            } catch (Exception e) {\n                loge(\"preserveUserAndCarrierApns: Exception while parsing '\" +\n                        confFile.getAbsolutePath() + \"'\" + e);\n            } finally {\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void deleteMatchingApns(SQLiteDatabase db, XmlPullParser parser) {\n            if (VDBG) log(\"deleteMatchingApns\");\n            if (parser != null) {\n                if (VDBG) log(\"deleteMatchingApns: parser != null\");\n                try {\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, false);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        deleteRow(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                } catch (XmlPullParserException e) {\n                    loge(\"deleteMatchingApns: Got XmlPullParserException while deleting apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"deleteMatchingApns: Got IOException while deleting apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"deleteMatchingApns: Got SQLException while deleting apns.\" + e);\n                }\n            }\n        }\n\n        private String queryValFirst(String field) {\n            return field + \"=?\";\n        }\n\n        private String queryVal(String field) {\n            return \" and \" + field + \"=?\";\n        }\n\n        private String queryValOrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private String queryVal2OrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private void deleteRow(SQLiteDatabase db, ContentValues values) {\n            if (VDBG) log(\"deleteRow\");\n            String where = queryValFirst(NUMERIC) +\n                    queryVal(MNC) +\n                    queryVal(MNC) +\n                    queryValOrNull(APN) +\n                    queryValOrNull(USER) +\n                    queryValOrNull(SERVER) +\n                    queryValOrNull(PASSWORD) +\n                    queryValOrNull(PROXY) +\n                    queryValOrNull(PORT) +\n                    queryValOrNull(MMSPROXY) +\n                    queryValOrNull(MMSPORT) +\n                    queryValOrNull(MMSC) +\n                    queryValOrNull(AUTH_TYPE) +\n                    queryValOrNull(TYPE) +\n                    queryValOrNull(PROTOCOL) +\n                    queryValOrNull(ROAMING_PROTOCOL) +\n                    queryVal2OrNull(CARRIER_ENABLED) +\n                    queryValOrNull(BEARER) +\n                    queryValOrNull(MVNO_TYPE) +\n                    queryValOrNull(MVNO_MATCH_DATA) +\n                    queryValOrNull(PROFILE_ID) +\n                    queryVal2OrNull(MODEM_PERSIST) +\n                    queryValOrNull(MAX_CONNECTIONS) +\n                    queryValOrNull(WAIT_TIME_RETRY) +\n                    queryValOrNull(TIME_LIMIT_FOR_MAX_CONNECTIONS) +\n                    queryValOrNull(MTU) +\n                    queryValOrNull(MTU_V4) +\n                    queryValOrNull(MTU_V6);\n            String[] whereArgs = new String[31];\n            int i = 0;\n            whereArgs[i++] = values.getAsString(NUMERIC);\n            whereArgs[i++] = values.getAsString(MCC);\n            whereArgs[i++] = values.getAsString(MNC);\n            whereArgs[i++] = values.getAsString(NAME);\n            whereArgs[i++] = values.containsKey(APN) ?\n                    values.getAsString(APN) : \"\";\n            whereArgs[i++] = values.containsKey(USER) ?\n                    values.getAsString(USER) : \"\";\n            whereArgs[i++] = values.containsKey(SERVER) ?\n                    values.getAsString(SERVER) : \"\";\n            whereArgs[i++] = values.containsKey(PASSWORD) ?\n                    values.getAsString(PASSWORD) : \"\";\n            whereArgs[i++] = values.containsKey(PROXY) ?\n                    values.getAsString(PROXY) : \"\";\n            whereArgs[i++] = values.containsKey(PORT) ?\n                    values.getAsString(PORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPROXY) ?\n                    values.getAsString(MMSPROXY) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPORT) ?\n                    values.getAsString(MMSPORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSC) ?\n                    values.getAsString(MMSC) : \"\";\n            whereArgs[i++] = values.containsKey(AUTH_TYPE) ?\n                    values.getAsString(AUTH_TYPE) : \"-1\";\n            whereArgs[i++] = values.containsKey(TYPE) ?\n                    values.getAsString(TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(PROTOCOL) ?\n                    values.getAsString(PROTOCOL) : DEFAULT_PROTOCOL;\n            whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ?\n                    values.getAsString(ROAMING_PROTOCOL) : DEFAULT_ROAMING_PROTOCOL;\n\n            if (values.containsKey(CARRIER_ENABLED)) {\n                whereArgs[i++] = convertStringToBoolString(values.getAsString(CARRIER_ENABLED));\n                whereArgs[i++] = convertStringToIntString(values.getAsString(CARRIER_ENABLED));\n            } else {\n                String defaultIntString = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(CARRIER_ENABLED);\n                whereArgs[i++] = convertStringToBoolString(defaultIntString);\n                whereArgs[i++] = defaultIntString;\n            }\n\n            whereArgs[i++] = values.containsKey(BEARER) ?\n                    values.getAsString(BEARER) : \"0\";\n            whereArgs[i++] = values.containsKey(MVNO_TYPE) ?\n                    values.getAsString(MVNO_TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ?\n                    values.getAsString(MVNO_MATCH_DATA) : \"\";\n            whereArgs[i++] = values.containsKey(PROFILE_ID) ?\n                    values.getAsString(PROFILE_ID) : \"0\";\n\n            if (values.containsKey(MODEM_PERSIST) &&\n                    (values.getAsString(MODEM_PERSIST).\n                            equalsIgnoreCase(\"true\") ||\n                            values.getAsString(MODEM_PERSIST).equals(\"1\"))) {\n                whereArgs[i++] = \"true\";\n                whereArgs[i++] = \"1\";\n            } else {\n                whereArgs[i++] = \"false\";\n                whereArgs[i++] = \"0\";\n            }\n\n            whereArgs[i++] = values.containsKey(MAX_CONNECTIONS) ?\n                    values.getAsString(MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(WAIT_TIME_RETRY) ?\n                    values.getAsString(WAIT_TIME_RETRY) : \"0\";\n            whereArgs[i++] = values.containsKey(TIME_LIMIT_FOR_MAX_CONNECTIONS) ?\n                    values.getAsString(TIME_LIMIT_FOR_MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU) ?\n                    values.getAsString(MTU) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V4) ?\n                    values.getAsString(MTU_V4) : String.valueOf(UNSPECIFIED_INT);\n            whereArgs[i++] = values.containsKey(MTU_V6) ?\n                    values.getAsString(MTU_V6) : String.valueOf(UNSPECIFIED_INT);\n\n            if (VDBG) {\n                log(\"deleteRow: where: \" + where);\n\n                StringBuilder builder = new StringBuilder();\n                for (String s : whereArgs) {\n                    builder.append(s + \", \");\n                }\n\n                log(\"deleteRow: whereArgs: \" + builder.toString());\n            }\n            db.delete(CARRIERS_TABLE, where, whereArgs);\n        }\n\n        private void copyDataToTmpTable(SQLiteDatabase db, Cursor c, int version) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copyAllApnValues(cv, c);\n                    if (version == 24) {\n                        // Sync bearer bitmask and network type bitmask\n                        getNetworkTypeBitmaskFromCursor(cv, c);\n                    }\n                    try {\n                        db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                SQLiteDatabase.CONFLICT_ABORT);\n                        if (VDBG) {\n                            log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                    \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                    e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copyApnValuesV17(ContentValues cv, Cursor c) {\n            // Include only non-null values in cv so that null values can be replaced\n            // with default if there's a default value for the field\n\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n        }\n\n        private void copyAllApnValues(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, MTU_V4);\n            getIntValueFromCursor(cv, c, MTU_V6);\n            getIntValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, LINGERING_NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n            getIntValueFromCursor(cv, c, USER_EDITABLE);\n            getIntValueFromCursor(cv, c, OWNED_BY);\n            getIntValueFromCursor(cv, c, APN_SET_ID);\n            getIntValueFromCursor(cv, c, SKIP_464XLAT);\n            getIntValueFromCursor(cv, c, ALWAYS_ON);\n        }\n\n        private void copyPreservedApnsToNewTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null && mContext.getResources() != null) {\n                try {\n                    String[] persistApnsForPlmns = mContext.getResources().getStringArray(\n                            R.array.persist_apns_for_plmn);\n                    while (c.moveToNext()) {\n                        ContentValues cv = new ContentValues();\n                        String val;\n                        // Using V17 copy function for V15 upgrade. This should be fine since it\n                        // handles columns that may not exist properly (getStringValueFromCursor()\n                        // and getIntValueFromCursor() handle column index -1)\n                        copyApnValuesV17(cv, c);\n                        // Change bearer to a bitmask\n                        String bearerStr = c.getString(c.getColumnIndex(BEARER));\n                        if (!TextUtils.isEmpty(bearerStr)) {\n                            int bearer_bitmask = getBitmaskForTech(Integer.parseInt(bearerStr));\n                            cv.put(BEARER_BITMASK, bearer_bitmask);\n\n                            int networkTypeBitmask = rilRadioTechnologyToNetworkTypeBitmask(\n                                    Integer.parseInt(bearerStr));\n                            cv.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n                        }\n\n                        int userEditedColumnIdx = c.getColumnIndex(\"user_edited\");\n                        if (userEditedColumnIdx != -1) {\n                            String user_edited = c.getString(userEditedColumnIdx);\n                            if (!TextUtils.isEmpty(user_edited)) {\n                                cv.put(EDITED_STATUS, new Integer(user_edited));\n                            }\n                        } else {\n                            cv.put(EDITED_STATUS, CARRIER_EDITED);\n                        }\n\n                        // New EDITED column. Default value (UNEDITED) will\n                        // be used for all rows except for non-mvno entries for plmns indicated\n                        // by resource: those will be set to CARRIER_EDITED to preserve\n                        // their current values\n                        val = c.getString(c.getColumnIndex(NUMERIC));\n                        for (String s : persistApnsForPlmns) {\n                            if (!TextUtils.isEmpty(val) && val.equals(s) &&\n                                    (!cv.containsKey(MVNO_TYPE) ||\n                                            TextUtils.isEmpty(cv.getAsString(MVNO_TYPE)))) {\n                                if (userEditedColumnIdx == -1) {\n                                    cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                } else { // if (oldVersion == 14) -- if db had user_edited column\n                                    if (cv.getAsInteger(EDITED_STATUS) == USER_EDITED) {\n                                        cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n\n                        try {\n                            db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                    SQLiteDatabase.CONFLICT_ABORT);\n                            if (VDBG) {\n                                log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                        \"insert successful for cv \" + cv);\n                            }\n                        } catch (SQLException e) {\n                            if (VDBG)\n                                log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                        e + \" for cv \" + cv);\n                            // Insertion failed which could be due to a conflict. Check if that is\n                            // the case and merge the entries\n                            Cursor oldRow = selectConflictingRow(db,\n                                    CARRIERS_TABLE_TMP, cv);\n                            if (oldRow != null) {\n                                ContentValues mergedValues = new ContentValues();\n                                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE_TMP, oldRow, cv,\n                                        mergedValues, true, mContext);\n                                oldRow.close();\n                            }\n                        }\n                    }\n                } catch (Resources.NotFoundException e) {\n                    loge(\"array.persist_apns_for_plmn is not found\");\n                    return;\n                }\n            }\n        }\n\n        private void getStringValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * If NETWORK_TYPE_BITMASK does not exist (upgrade from version 23 to version 24), generate\n         * NETWORK_TYPE_BITMASK with the use of BEARER_BITMASK. If NETWORK_TYPE_BITMASK existed\n         * (upgrade from version 24 to forward), always map NETWORK_TYPE_BITMASK to BEARER_BITMASK.\n         */\n        private void getNetworkTypeBitmaskFromCursor(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(NETWORK_TYPE_BITMASK);\n            if (columnIndex != -1) {\n                getStringValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n                // Map NETWORK_TYPE_BITMASK to BEARER_BITMASK if NETWORK_TYPE_BITMASK existed;\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int networkBitmask = Integer.valueOf(fromCursor);\n                    int bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkBitmask);\n                    cv.put(BEARER_BITMASK, String.valueOf(bearerBitmask));\n                }\n                return;\n            }\n            columnIndex = c.getColumnIndex(BEARER_BITMASK);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int bearerBitmask = Integer.valueOf(fromCursor);\n                    int networkBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                    cv.put(NETWORK_TYPE_BITMASK, String.valueOf(networkBitmask));\n                }\n            }\n        }\n\n        private void getIntValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    try {\n                        cv.put(key, new Integer(fromCursor));\n                    } catch (NumberFormatException nfe) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void getBlobValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                byte[] fromCursor = c.getBlob(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * Gets the next row of apn values.\n         *\n         * @param parser the parser\n         * @param isOverlay If the xml file comes from an overlay MCC/MNC are treated as integers\n         * @return the row or null if it's not an apn\n         */\n        private ContentValues getRow(XmlPullParser parser, boolean isOverlay) {\n            if (!\"apn\".equals(parser.getName())) {\n                return null;\n            }\n\n            ContentValues map = new ContentValues();\n\n            String mcc = parser.getAttributeValue(null, \"mcc\");\n            String mnc = parser.getAttributeValue(null, \"mnc\");\n            String mccString = mcc;\n            String mncString = mnc;\n            // Since an mnc can have both two and three digits and it is hard to verify\n            // all OEM's Global APN lists we only do this for overlays.\n            if (isOverlay) {\n                mccString = String.format(\"%03d\", Integer.parseInt(mcc));\n                // Looks up a two digit mnc in the carrier id DB\n                // if not found a three digit mnc value is chosen\n                mncString = getBestStringMnc(mContext, mccString, Integer.parseInt(mnc));\n            }\n\n            String numeric = (mccString == null | mncString == null) ? null : mccString + mncString;\n            map.put(NUMERIC, numeric);\n            map.put(MCC, mccString);\n            map.put(MNC, mncString);\n            map.put(NAME, parser.getAttributeValue(null, \"carrier\"));\n\n            // do not add NULL to the map so that default values can be inserted in db\n            addStringAttribute(parser, \"apn\", map, APN);\n            addStringAttribute(parser, \"user\", map, USER);\n            addStringAttribute(parser, \"server\", map, SERVER);\n            addStringAttribute(parser, \"password\", map, PASSWORD);\n            addStringAttribute(parser, \"proxy\", map, PROXY);\n            addStringAttribute(parser, \"port\", map, PORT);\n            addStringAttribute(parser, \"mmsproxy\", map, MMSPROXY);\n            addStringAttribute(parser, \"mmsport\", map, MMSPORT);\n            addStringAttribute(parser, \"mmsc\", map, MMSC);\n\n            String apnType = parser.getAttributeValue(null, \"type\");\n            if (apnType != null) {\n                // Remove spaces before putting it in the map.\n                apnType = apnType.replaceAll(\"\\\\s+\", \"\");\n                map.put(TYPE, apnType);\n            }\n\n            addStringAttribute(parser, \"protocol\", map, PROTOCOL);\n            addStringAttribute(parser, \"roaming_protocol\", map, ROAMING_PROTOCOL);\n\n            addIntAttribute(parser, \"authtype\", map, AUTH_TYPE);\n            addIntAttribute(parser, \"bearer\", map, BEARER);\n            addIntAttribute(parser, \"profile_id\", map, PROFILE_ID);\n            addIntAttribute(parser, \"max_conns\", map, MAX_CONNECTIONS);\n            addIntAttribute(parser, \"wait_time\", map, WAIT_TIME_RETRY);\n            addIntAttribute(parser, \"max_conns_time\", map, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            addIntAttribute(parser, \"mtu\", map, MTU);\n            addIntAttribute(parser, \"mtu_v4\", map, MTU_V4);\n            addIntAttribute(parser, \"mtu_v6\", map, MTU_V6);\n            addIntAttribute(parser, \"apn_set_id\", map, APN_SET_ID);\n            addIntAttribute(parser, \"carrier_id\", map, CARRIER_ID);\n            addIntAttribute(parser, \"skip_464xlat\", map, SKIP_464XLAT);\n\n            addBoolAttribute(parser, \"carrier_enabled\", map, CARRIER_ENABLED);\n            addBoolAttribute(parser, \"modem_cognitive\", map, MODEM_PERSIST);\n            addBoolAttribute(parser, \"user_visible\", map, USER_VISIBLE);\n            addBoolAttribute(parser, \"user_editable\", map, USER_EDITABLE);\n            addBoolAttribute(parser, \"always_on\", map, ALWAYS_ON);\n\n            int networkTypeBitmask = 0;\n            String networkTypeList = parser.getAttributeValue(null, \"network_type_bitmask\");\n            if (networkTypeList != null) {\n                networkTypeBitmask = getBitmaskFromString(networkTypeList);\n            }\n            map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n\n            int lingeringNetworkTypeBitmask = 0;\n            String lingeringNetworkTypeList =\n                    parser.getAttributeValue(null, \"lingering_network_type_bitmask\");\n            if (lingeringNetworkTypeList != null) {\n                lingeringNetworkTypeBitmask = getBitmaskFromString(lingeringNetworkTypeList);\n            }\n            map.put(LINGERING_NETWORK_TYPE_BITMASK, lingeringNetworkTypeBitmask);\n\n            int bearerBitmask = 0;\n            if (networkTypeList != null) {\n                bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkTypeBitmask);\n            } else {\n                String bearerList = parser.getAttributeValue(null, \"bearer_bitmask\");\n                if (bearerList != null) {\n                    bearerBitmask = getBitmaskFromString(bearerList);\n                }\n                // Update the network type bitmask to keep them sync.\n                networkTypeBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n            }\n            map.put(BEARER_BITMASK, bearerBitmask);\n\n            String mvno_type = parser.getAttributeValue(null, \"mvno_type\");\n            if (mvno_type != null) {\n                String mvno_match_data = parser.getAttributeValue(null, \"mvno_match_data\");\n                if (mvno_match_data != null) {\n                    map.put(MVNO_TYPE, mvno_type);\n                    map.put(MVNO_MATCH_DATA, mvno_match_data);\n                }\n            }\n            return map;\n        }\n\n        private void addStringAttribute(XmlPullParser parser, String att,\n                                        ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, val);\n            }\n        }\n\n        private void addIntAttribute(XmlPullParser parser, String att,\n                                     ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Integer.parseInt(val));\n            }\n        }\n\n        private void addBoolAttribute(XmlPullParser parser, String att,\n                                      ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Boolean.parseBoolean(val));\n            }\n        }\n\n        /*\n         * Loads apns from xml file into the database\n         *\n         * @param db the sqlite database to write to\n         * @param parser the xml parser\n         * @param isOverlay, if we are parsing an xml in an overlay\n         */\n        private void loadApns(SQLiteDatabase db, XmlPullParser parser, boolean isOverlay) {\n            if (parser != null) {\n                try {\n                    db.beginTransaction();\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, isOverlay);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        insertAddingDefaults(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                    db.setTransactionSuccessful();\n                } catch (XmlPullParserException e) {\n                    loge(\"Got XmlPullParserException while loading apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"Got IOException while loading apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"Got SQLException while loading apns.\" + e);\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        }\n\n        private void insertAddingDefaults(SQLiteDatabase db, ContentValues row) {\n            row = setDefaultValue(row);\n            try {\n                db.insertWithOnConflict(CARRIERS_TABLE, null, row, SQLiteDatabase.CONFLICT_ABORT);\n                if (VDBG) log(\"dbh.insertAddingDefaults: db.insert returned >= 0; insert \" +\n                        \"successful for cv \" + row);\n            } catch (SQLException e) {\n                if (VDBG) log(\"dbh.insertAddingDefaults: exception \" + e);\n                // Insertion failed which could be due to a conflict. Check if that is the case and\n                // update edited field accordingly.\n                // Search for the exact same entry and update edited field.\n                // If it is USER_EDITED/CARRIER_EDITED change it to UNEDITED,\n                // and if USER/CARRIER_DELETED change it to USER/CARRIER_DELETED_BUT_PRESENT_IN_XML.\n                Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, row);\n                if (oldRow != null) {\n                    // Update the row\n                    ContentValues mergedValues = new ContentValues();\n                    int edited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                    int old_edited = edited;\n                    if (edited != UNEDITED) {\n                        if (edited == USER_DELETED) {\n                            // USER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = USER_DELETED_BUT_PRESENT_IN_XML;\n                        } else if (edited == CARRIER_DELETED) {\n                            // CARRIER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                        }\n                        mergedValues.put(EDITED_STATUS, edited);\n                    }\n\n                    mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, row, mergedValues, false,\n                            mContext);\n\n                    if (VDBG) log(\"dbh.insertAddingDefaults: old edited = \" + old_edited\n                            + \" new edited = \" + edited);\n\n                    oldRow.close();\n                }\n            }\n        }\n    }\n\n    public static void mergeFieldsAndUpdateDb(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, ContentValues mergedValues,\n            boolean onUpgrade, Context context) {\n        if (newRow.containsKey(TYPE)) {\n            // Merge the types\n            String oldType = oldRow.getString(oldRow.getColumnIndex(TYPE));\n            String newType = newRow.getAsString(TYPE);\n\n            if (!oldType.equalsIgnoreCase(newType)) {\n                if (oldType.equals(\"\") || newType.equals(\"\")) {\n                    newRow.put(TYPE, \"\");\n                } else {\n                    String[] oldTypes = oldType.toLowerCase().split(\",\");\n                    String[] newTypes = newType.toLowerCase().split(\",\");\n\n                    if (VDBG) {\n                        log(\"mergeFieldsAndUpdateDb: Calling separateRowsNeeded() oldType=\" +\n                                oldType + \" old bearer=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                BEARER_BITMASK)) +  \" old networkType=\" +\n                                oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK)) +\n                                \" old profile_id=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                PROFILE_ID)) + \" newRow \" + newRow);\n                    }\n\n                    // If separate rows are needed, do not need to merge any further\n                    if (separateRowsNeeded(db, table, oldRow, newRow, context, oldTypes,\n                            newTypes)) {\n                        if (VDBG) log(\"mergeFieldsAndUpdateDb: separateRowsNeeded() returned \" +\n                                \"true\");\n                        return;\n                    }\n\n                    // Merge the 2 types\n                    ArrayList<String> mergedTypes = new ArrayList<String>();\n                    mergedTypes.addAll(Arrays.asList(oldTypes));\n                    for (String s : newTypes) {\n                        if (!mergedTypes.contains(s.trim())) {\n                            mergedTypes.add(s);\n                        }\n                    }\n                    StringBuilder mergedType = new StringBuilder();\n                    for (int i = 0; i < mergedTypes.size(); i++) {\n                        mergedType.append((i == 0 ? \"\" : \",\") + mergedTypes.get(i));\n                    }\n                    newRow.put(TYPE, mergedType.toString());\n                }\n            }\n            mergedValues.put(TYPE, newRow.getAsString(TYPE));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)) {\n            int oldBearer = oldRow.getInt(oldRow.getColumnIndex(BEARER_BITMASK));\n            int newBearer = newRow.getAsInteger(BEARER_BITMASK);\n            if (oldBearer != newBearer) {\n                if (oldBearer == 0 || newBearer == 0) {\n                    newRow.put(BEARER_BITMASK, 0);\n                } else {\n                    newRow.put(BEARER_BITMASK, (oldBearer | newBearer));\n                }\n            }\n            mergedValues.put(BEARER_BITMASK, newRow.getAsInteger(BEARER_BITMASK));\n        }\n\n        if (newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            int oldBitmask = oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK));\n            int newBitmask = newRow.getAsInteger(NETWORK_TYPE_BITMASK);\n            if (oldBitmask != newBitmask) {\n                if (oldBitmask == 0 || newBitmask == 0) {\n                    newRow.put(NETWORK_TYPE_BITMASK, 0);\n                } else {\n                    newRow.put(NETWORK_TYPE_BITMASK, (oldBitmask | newBitmask));\n                }\n            }\n            mergedValues.put(NETWORK_TYPE_BITMASK, newRow.getAsInteger(NETWORK_TYPE_BITMASK));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)\n                && newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            syncBearerBitmaskAndNetworkTypeBitmask(mergedValues);\n        }\n\n        if (!onUpgrade) {\n            // Do not overwrite a carrier or user edit with EDITED=UNEDITED\n            if (newRow.containsKey(EDITED_STATUS)) {\n                int oldEdited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                int newEdited = newRow.getAsInteger(EDITED_STATUS);\n                if (newEdited == UNEDITED && (oldEdited == CARRIER_EDITED\n                        || oldEdited == CARRIER_DELETED\n                        || oldEdited == CARRIER_DELETED_BUT_PRESENT_IN_XML\n                        || oldEdited == USER_EDITED\n                        || oldEdited == USER_DELETED\n                        || oldEdited == USER_DELETED_BUT_PRESENT_IN_XML)) {\n                    newRow.remove(EDITED_STATUS);\n                }\n            }\n            mergedValues.putAll(newRow);\n        }\n\n        if (mergedValues.size() > 0) {\n            db.update(table, mergedValues, \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")),\n                    null);\n        }\n    }\n\n    private static boolean separateRowsNeeded(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, Context context,\n            String[] oldTypes, String[] newTypes) {\n        // If this APN falls under persist_apns_for_plmn, and the\n        // only difference between old type and new type is that one has dun, and\n        // the APNs have profile_id 0 or not set, then set the profile_id to 1 for\n        // the dun APN/remove dun from type. This will ensure both oldRow and newRow exist\n        // separately in db.\n\n        boolean match = false;\n\n        // Check if APN falls under persist_apns_for_plmn\n        if (context.getResources() != null) {\n            String[] persistApnsForPlmns = context.getResources().getStringArray(\n                    R.array.persist_apns_for_plmn);\n            for (String s : persistApnsForPlmns) {\n                if (s.equalsIgnoreCase(newRow.getAsString(NUMERIC))) {\n                    match = true;\n                    break;\n                }\n            }\n        } else {\n            loge(\"separateRowsNeeded: resources=null\");\n        }\n\n        if (!match) return false;\n\n        // APN falls under persist_apns_for_plmn\n        // Check if only difference between old type and new type is that\n        // one has dun\n        ArrayList<String> oldTypesAl = new ArrayList<String>(Arrays.asList(oldTypes));\n        ArrayList<String> newTypesAl = new ArrayList<String>(Arrays.asList(newTypes));\n        ArrayList<String> listWithDun = null;\n        ArrayList<String> listWithoutDun = null;\n        boolean dunInOld = false;\n        if (oldTypesAl.size() == newTypesAl.size() + 1) {\n            listWithDun = oldTypesAl;\n            listWithoutDun = newTypesAl;\n            dunInOld = true;\n        } else if (oldTypesAl.size() + 1 == newTypesAl.size()) {\n            listWithDun = newTypesAl;\n            listWithoutDun = oldTypesAl;\n        } else {\n            return false;\n        }\n\n        if (listWithDun.contains(\"dun\") && !listWithoutDun.contains(\"dun\")) {\n            listWithoutDun.add(\"dun\");\n            if (!listWithDun.containsAll(listWithoutDun)) {\n                return false;\n            }\n\n            // Only difference between old type and new type is that\n            // one has dun\n            // Check if profile_id is 0/not set\n            if (oldRow.getInt(oldRow.getColumnIndex(PROFILE_ID)) == 0) {\n                if (dunInOld) {\n                    // Update oldRow to remove dun from its type field\n                    ContentValues updateOldRow = new ContentValues();\n                    StringBuilder sb = new StringBuilder();\n                    boolean first = true;\n                    for (String s : listWithDun) {\n                        if (!s.equalsIgnoreCase(\"dun\")) {\n                            sb.append(first ? s : \",\" + s);\n                            first = false;\n                        }\n                    }\n                    String updatedType = sb.toString();\n                    if (VDBG) {\n                        log(\"separateRowsNeeded: updating type in oldRow to \" + updatedType);\n                    }\n                    updateOldRow.put(TYPE, updatedType);\n                    db.update(table, updateOldRow,\n                            \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")), null);\n                    return true;\n                } else {\n                    if (VDBG) log(\"separateRowsNeeded: adding profile id 1 to newRow\");\n                    // Update newRow to set profile_id to 1\n                    newRow.put(PROFILE_ID, new Integer(1));\n                }\n            } else {\n                return false;\n            }\n\n            // If match was found, both oldRow and newRow need to exist\n            // separately in db. Add newRow to db.\n            try {\n                db.insertWithOnConflict(table, null, newRow, SQLiteDatabase.CONFLICT_REPLACE);\n                if (VDBG) log(\"separateRowsNeeded: added newRow with profile id 1 to db\");\n                return true;\n            } catch (SQLException e) {\n                loge(\"Exception on trying to add new row after updating profile_id\");\n            }\n        }\n\n        return false;\n    }\n\n    public static Cursor selectConflictingRow(SQLiteDatabase db, String table,\n            ContentValues row) {\n        // Conflict is possible only when numeric, mcc, mnc (fields without any default value)\n        // are set in the new row\n        if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {\n            loge(\"dbh.selectConflictingRow: called for non-conflicting row: \" + row);\n            return null;\n        }\n\n        String[] columns = { \"_id\",\n                TYPE,\n                EDITED_STATUS,\n                BEARER_BITMASK,\n                NETWORK_TYPE_BITMASK,\n                PROFILE_ID };\n        String selection = TextUtils.join(\"=? AND \", CARRIERS_UNIQUE_FIELDS) + \"=?\";\n        int i = 0;\n        String[] selectionArgs = new String[CARRIERS_UNIQUE_FIELDS.size()];\n        for (String field : CARRIERS_UNIQUE_FIELDS) {\n            if (!row.containsKey(field)) {\n                selectionArgs[i++] = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(field);\n            } else {\n                if (CARRIERS_BOOLEAN_FIELDS.contains(field)) {\n                    // for boolean fields we overwrite the strings \"true\" and \"false\" with \"1\"\n                    // and \"0\"\n                    selectionArgs[i++] = convertStringToIntString(row.getAsString(field));\n                } else {\n                    selectionArgs[i++] = row.getAsString(field);\n                }\n            }\n        }\n\n        Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);\n\n        if (c != null) {\n            if (c.getCount() == 1) {\n                if (VDBG) log(\"dbh.selectConflictingRow: \" + c.getCount() + \" conflicting \" +\n                        \"row found\");\n                if (c.moveToFirst()) {\n                    return c;\n                } else {\n                    loge(\"dbh.selectConflictingRow: moveToFirst() failed\");\n                }\n            } else {\n                loge(\"dbh.selectConflictingRow: Expected 1 but found \" + c.getCount() +\n                        \" matching rows found for cv \" + row);\n            }\n            c.close();\n        } else {\n            loge(\"dbh.selectConflictingRow: Error - c is null; no matching row found for \" +\n                    \"cv \" + row);\n        }\n\n        return null;\n    }\n\n    /**\n     * Convert \"true\" and \"false\" to \"1\" and \"0\".\n     * If the passed in string is already \"1\" or \"0\" returns the passed in string.\n     */\n    private static String convertStringToIntString(String boolString) {\n        if (\"0\".equals(boolString) || \"false\".equalsIgnoreCase(boolString)) return \"0\";\n        return \"1\";\n    }\n\n    /**\n     * Convert \"1\" and \"0\" to \"true\" and \"false\".\n     * If the passed in string is already \"true\" or \"false\" returns the passed in string.\n     */\n    private static String convertStringToBoolString(String intString) {\n        if (\"0\".equals(intString) || \"false\".equalsIgnoreCase(intString)) return \"false\";\n        return \"true\";\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing TelephonyProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase() {\n        return mOpenHelper.getReadableDatabase();\n    }\n    SQLiteDatabase getWritableDatabase() {\n        return mOpenHelper.getWritableDatabase();\n    }\n    void initDatabaseWithDatabaseHelper(SQLiteDatabase db) {\n        mOpenHelper.initDatabase(db);\n    }\n    boolean needApnDbUpdate() {\n        return mOpenHelper.apnDbUpdateNeeded();\n    }\n\n    private static boolean apnSourceServiceExists(Context context) {\n        if (s_apnSourceServiceExists != null) {\n            return s_apnSourceServiceExists;\n        }\n        try {\n            String service = context.getResources().getString(R.string.apn_source_service);\n            if (TextUtils.isEmpty(service)) {\n                s_apnSourceServiceExists = false;\n            } else {\n                s_apnSourceServiceExists = context.getPackageManager().getServiceInfo(\n                        ComponentName.unflattenFromString(service), 0)\n                        != null;\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            s_apnSourceServiceExists = false;\n        }\n        return s_apnSourceServiceExists;\n    }\n\n    private void restoreApnsWithService(int subId) {\n        Context context = getContext();\n        Resources r = context.getResources();\n        AtomicBoolean connectionBindingInvalid = new AtomicBoolean(false);\n        ServiceConnection connection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className,\n                    IBinder service) {\n                log(\"restoreApnsWithService: onServiceConnected\");\n                synchronized (mLock) {\n                    mIApnSourceService = IApnSourceService.Stub.asInterface(service);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {\n                loge(\"mIApnSourceService has disconnected unexpectedly\");\n                synchronized (mLock) {\n                    mIApnSourceService = null;\n                }\n            }\n\n            @Override\n            public void onBindingDied(ComponentName name) {\n                loge(\"The binding to the apn service connection is dead: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onNullBinding(ComponentName name) {\n                loge(\"Null binding: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n        };\n\n        Intent intent = new Intent(IApnSourceService.class.getName());\n        intent.setComponent(ComponentName.unflattenFromString(\n                r.getString(R.string.apn_source_service)));\n        log(\"binding to service to restore apns, intent=\" + intent);\n        try {\n            if (context.bindService(intent,\n                    Context.BIND_IMPORTANT | Context.BIND_AUTO_CREATE,\n                    runnable -> new Thread(runnable).start(),\n                    connection)) {\n                synchronized (mLock) {\n                    while (mIApnSourceService == null && !connectionBindingInvalid.get()) {\n                        try {\n                            mLock.wait();\n                        } catch (InterruptedException e) {\n                            loge(\"Error while waiting for service connection: \" + e);\n                        }\n                    }\n                    if (connectionBindingInvalid.get()) {\n                        loge(\"The binding is invalid.\");\n                        return;\n                    }\n                    try {\n                        ContentValues[] values = mIApnSourceService.getApns(subId);\n                        if (values != null) {\n                            // we use the unsynchronized insert because this function is called\n                            // within the syncrhonized function delete()\n                            unsynchronizedBulkInsert(CONTENT_URI, values);\n                            log(\"restoreApnsWithService: restored\");\n                        }\n                    } catch (RemoteException e) {\n                        loge(\"Error applying apns from service: \" + e);\n                    }\n                }\n            } else {\n                loge(\"unable to bind to service from intent=\" + intent);\n            }\n        } catch (SecurityException e) {\n            loge(\"Error applying apns from service: \" + e);\n        } finally {\n            if (connection != null) {\n                context.unbindService(connection);\n            }\n            synchronized (mLock) {\n                mIApnSourceService = null;\n            }\n        }\n    }\n\n\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new DatabaseHelper(getContext());\n\n        try {\n            PhoneFactory.addLocalLog(TAG, 64);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n\n        boolean isNewBuild = false;\n        String newBuildId = SystemProperties.get(\"ro.build.id\", null);\n        SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE,\n                Context.MODE_PRIVATE);\n        if (!TextUtils.isEmpty(newBuildId)) {\n            // Check if build id has changed\n            String oldBuildId = sp.getString(RO_BUILD_ID, \"\");\n            if (!newBuildId.equals(oldBuildId)) {\n                localLog(\"onCreate: build id changed from \" + oldBuildId + \" to \" + newBuildId);\n                isNewBuild = true;\n            } else {\n                if (VDBG) log(\"onCreate: build id did not change: \" + oldBuildId);\n            }\n        } else {\n            if (VDBG) log(\"onCreate: newBuildId is empty\");\n        }\n\n        if (isNewBuild) {\n            if (!apnSourceServiceExists(getContext())) {\n                // Update APN DB\n                updateApnDb();\n            }\n\n            // Add all APN related shared prefs to local log for dumpsys\n            if (DBG) addAllApnSharedPrefToLocalLog();\n        }\n\n        // Write build id to SharedPreferences after APNs have been updated above by updateApnDb()\n        if (!TextUtils.isEmpty(newBuildId)) {\n            if (isNewBuild) log(\"onCreate: updating build id to \" + newBuildId);\n            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();\n        }\n\n        SharedPreferences spEnforcedFile = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        mManagedApnEnforced = spEnforcedFile.getBoolean(ENFORCED_KEY, false);\n\n        if (VDBG) log(\"onCreate:- ret true\");\n\n        return true;\n    }\n\n    private void addAllApnSharedPrefToLocalLog() {\n        localLog(\"addAllApnSharedPrefToLocalLog\");\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefApnId.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n\n        SharedPreferences spFullApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefFullApn = spFullApn.getAll();\n        for (String key : allPrefFullApn.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefFullApn.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n    }\n\n    private static void localLog(String logMsg) {\n        Log.d(TAG, logMsg);\n        PhoneFactory.localLog(TAG, logMsg);\n    }\n\n    private synchronized boolean isManagedApnEnforced() {\n        return mManagedApnEnforced;\n    }\n\n    private void setManagedApnEnforced(boolean enforced) {\n        SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putBoolean(ENFORCED_KEY, enforced);\n        editor.apply();\n        synchronized (this) {\n            mManagedApnEnforced = enforced;\n        }\n    }\n\n    private void setPreferredApnId(Long id, int subId, boolean saveApn) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putLong(COLUMN_APN_ID + subId, id != null ? id : INVALID_APN_ID);\n        localLog(\"setPreferredApnId: \" + COLUMN_APN_ID + subId + \":\"\n                + (id != null ? id : INVALID_APN_ID));\n        // This is for debug purposes. It indicates if this APN was set by DcTracker or user (true)\n        // or if this was restored from APN saved in PREF_FILE_FULL_APN (false).\n        editor.putBoolean(EXPLICIT_SET_CALLED + subId, saveApn);\n        localLog(\"setPreferredApnId: \" + EXPLICIT_SET_CALLED + subId + \":\" + saveApn);\n        editor.apply();\n        if (id == null || id.longValue() == INVALID_APN_ID) {\n            deletePreferredApn(subId);\n        } else {\n            // If id is not invalid, and saveApn is true, save the actual APN in PREF_FILE_FULL_APN\n            // too.\n            if (saveApn) {\n                setPreferredApn(id, subId);\n            }\n        }\n    }\n\n    private long getPreferredApnId(int subId, boolean checkApnSp) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        long apnId = sp.getLong(COLUMN_APN_ID + subId, INVALID_APN_ID);\n        if (apnId == INVALID_APN_ID && checkApnSp) {\n            apnId = getPreferredApnIdFromApn(subId);\n            if (apnId != INVALID_APN_ID) {\n                setPreferredApnId(apnId, subId, false);\n            }\n        }\n        return apnId;\n    }\n\n    private int getPreferredApnSetId(int subId) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        try {\n            return Integer.parseInt(sp.getString(APN_SET_ID + subId, null));\n        } catch (NumberFormatException e) {\n            return NO_APN_SET_ID;\n        }\n    }\n\n    private void deletePreferredApnId(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.clear();\n        editor.apply();\n    }\n\n    private void setPreferredApn(Long id, int subId) {\n        localLog(\"setPreferredApn: _id \" + id + \" subId \" + subId);\n        SQLiteDatabase db = getWritableDatabase();\n        // query all unique fields from id\n        String[] proj = CARRIERS_UNIQUE_FIELDS.toArray(new String[CARRIERS_UNIQUE_FIELDS.size()]);\n\n        Cursor c = db.query(CARRIERS_TABLE, proj, \"_id=\" + id, null, null, null, null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                        Context.MODE_PRIVATE);\n                SharedPreferences.Editor editor = sp.edit();\n                // store values of all unique fields to SP\n                for (String key : CARRIERS_UNIQUE_FIELDS) {\n                    editor.putString(key + subId, c.getString(c.getColumnIndex(key)));\n                    localLog(\"setPreferredApn: \" + key + subId + \":\"\n                            + c.getString(c.getColumnIndex(key)));\n                }\n                // also store the version number\n                editor.putString(DB_VERSION_KEY + subId, \"\" + DATABASE_VERSION);\n                localLog(\"setPreferredApn: \" + DB_VERSION_KEY + subId + \":\" + DATABASE_VERSION);\n                editor.apply();\n            } else {\n                log(\"setPreferredApn: # matching APNs found \" + c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"setPreferredApn: No matching APN found\");\n        }\n    }\n\n    private long getPreferredApnIdFromApn(int subId) {\n        log(\"getPreferredApnIdFromApn: for subId \" + subId);\n        SQLiteDatabase db = getReadableDatabase();\n\n        List<String> whereList = new ArrayList<>();\n        List<String> whereArgsList = new ArrayList<>();\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        for (String key : CARRIERS_UNIQUE_FIELDS) {\n            String value = sp.getString(key + subId, null);\n            if (value == null) {\n                continue;\n            } else {\n                whereList.add(key);\n                whereArgsList.add(value);\n            }\n        }\n        if (whereList.size() == 0) return INVALID_APN_ID;\n\n        String where = TextUtils.join(\"=? and \", whereList) + \"=?\";\n        String[] whereArgs = new String[whereArgsList.size()];\n        whereArgs = whereArgsList.toArray(whereArgs);\n\n        long apnId = INVALID_APN_ID;\n        Cursor c = db.query(CARRIERS_TABLE, new String[]{\"_id\"}, where, whereArgs, null, null,\n                null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                apnId = c.getInt(c.getColumnIndex(\"_id\"));\n            } else {\n                log(\"getPreferredApnIdFromApn: returning INVALID. # matching APNs found \" +\n                        c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"getPreferredApnIdFromApn: returning INVALID. No matching APN found\");\n        }\n        return apnId;\n    }\n\n    private void deletePreferredApn(int subId) {\n        log(\"deletePreferredApn: for subId \" + subId);\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        if (sp.contains(DB_VERSION_KEY + subId)) {\n            log(\"deletePreferredApn: apn is stored. Deleting it now for subId \" + subId);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.remove(DB_VERSION_KEY + subId);\n            for (String key : CARRIERS_UNIQUE_FIELDS) {\n                editor.remove(key + subId);\n            }\n            editor.apply();\n        }\n    }\n\n    boolean isCallingFromSystemOrPhoneUid() {\n        return mInjector.binderGetCallingUid() == Process.SYSTEM_UID ||\n                mInjector.binderGetCallingUid() == Process.PHONE_UID;\n    }\n\n    void ensureCallingFromSystemOrPhoneUid(String message) {\n        if (!isCallingFromSystemOrPhoneUid()) {\n            throw new SecurityException(message);\n        }\n    }\n\n    @Override\n    public synchronized Bundle call(String method, @Nullable String args, @Nullable Bundle bundle) {\n        if (SubscriptionManager.GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return retrieveSimSpecificSettings();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else if (SubscriptionManager.RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MODIFY_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                restoreSimSpecificSettings(bundle, args);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else {\n            loge(\"method is not recognized\");\n        }\n\n        return null;\n    }\n\n    /**\n     * See {@link SubscriptionController#GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME} for details\n     */\n    private Bundle retrieveSimSpecificSettings() {\n        Bundle resultBundle = new Bundle();\n        resultBundle.putByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA,\n                getSimSpecificDataToBackUp());\n\n        return resultBundle;\n    }\n\n    /**\n     * Attempts to restore the backed up sim-specific configs to device. End result is SimInfoDB is\n     * modified to match any backed up configs for the appropriate inserted sims.\n     *\n     * @param bundle containing the data to be restored. If {@code null}, then backed up\n     * data should already be in internal storage and will be retrieved from there.\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void restoreSimSpecificSettings(@Nullable Bundle bundle, @Nullable String iccId) {\n        int restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_UNDEFINED_USE_CASE;\n        if (bundle != null) {\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SUW;\n            if (!writeSimSettingsToInternalStorage(\n                    bundle.getByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA))) {\n                return;\n            }\n        } else if (iccId != null){\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED;\n        }\n        mergeBackedUpDataToSimInfoDb(restoreCase, iccId);\n    }\n\n    @VisibleForTesting\n    boolean writeSimSettingsToInternalStorage(byte[] data) {\n        AtomicFile atomicFile = new AtomicFile(\n                new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE));\n        FileOutputStream fos = null;\n        try {\n            fos = atomicFile.startWrite();\n            fos.write(data);\n            atomicFile.finishWrite(fos);\n        } catch (IOException e) {\n            if (fos != null) {\n                atomicFile.failWrite(fos);\n            }\n            loge(\"Not able to create internal file with per-sim configs. Failed with error \"\n                    + e);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Attempt to match any SimInfoDB entries to what is in the internal backup data file and\n     * update DB entry with the adequate backed up data.\n     *\n     * @param restoreCase one of the SimSpecificSettingsRestoreMatchingCriteria values defined in\n     * frameworks/proto_logging/stats/enums/telephony/enums.proto\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void mergeBackedUpDataToSimInfoDb(int restoreCase, @Nullable String iccId) {\n        // Get data stored in internal file\n        File file = new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE);\n        if (!file.exists()) {\n            loge(\"internal sim-specific settings backup data file does not exist. \"\n                + \"Aborting restore\");\n            return;\n        }\n\n        AtomicFile atomicFile = new AtomicFile(file);\n        PersistableBundle bundle = null;\n        try (FileInputStream fis = atomicFile.openRead()) {\n            bundle = PersistableBundle.readFromStream(fis);\n        } catch (IOException e) {\n            loge(\"Failed to convert backed up per-sim configs to bundle. Stopping restore. \"\n                + \"Failed with error \" + e);\n            return;\n        }\n\n        String selection = null;\n        String[] selectionArgs = null;\n        if (iccId != null) {\n            selection = Telephony.SimInfo.COLUMN_ICC_ID + \"=?\";\n            selectionArgs = new String[]{iccId};\n        }\n        try (Cursor cursor = query(\n                SubscriptionManager.CONTENT_URI,\n                new String[]{\n                        Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_ICC_ID,\n                        Telephony.SimInfo.COLUMN_NUMBER,\n                        Telephony.SimInfo.COLUMN_CARRIER_ID,\n                        Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE},\n                selection,\n                selectionArgs,\n                ORDER_BY_SUB_ID)) {\n            findAndRestoreAllMatches(bundle.deepCopy(), cursor, restoreCase);\n        }\n    }\n\n    // backedUpDataBundle must to be mutable\n    private void findAndRestoreAllMatches(PersistableBundle backedUpDataBundle, Cursor cursor,\n            int restoreCase) {\n        int[] previouslyRestoredSubIdsArray =\n                backedUpDataBundle.getIntArray(KEY_PREVIOUSLY_RESTORED_SUB_IDS);\n        List<Integer> previouslyRestoredSubIdsList = previouslyRestoredSubIdsArray != null\n                ? Arrays.stream(previouslyRestoredSubIdsArray).boxed().collect(Collectors.toList())\n                : new ArrayList<>();\n        List<Integer> newlyRestoredSubIds = new ArrayList<>();\n        int backupDataFormatVersion = backedUpDataBundle\n                .getInt(KEY_BACKUP_DATA_FORMAT_VERSION, -1);\n\n        Resources r = getContext().getResources();\n        List<String> wfcRestoreBlockedCountries = Arrays.asList(r.getStringArray(\n                    R.array.wfc_restore_blocked_countries));\n\n        while (cursor != null && cursor.moveToNext()) {\n            // Get all the possible matching criteria.\n            int subIdColumnIndex = cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID);\n            int currSubIdFromDb = cursor.getInt(subIdColumnIndex);\n\n            if (previouslyRestoredSubIdsList.contains(currSubIdFromDb)) {\n                // Abort restore for any sims that were previously restored.\n                continue;\n            }\n\n            int iccIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            String currIccIdFromDb = cursor.getString(iccIdColumnIndex);\n\n            int phoneNumberColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_NUMBER);\n            String currPhoneNumberFromDb = cursor.getString(phoneNumberColumnIndex);\n\n            int carrierIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_CARRIER_ID);\n            int currCarrierIdFromDb = cursor.getInt(carrierIdColumnIndex);\n\n            int isoCountryCodeColumnIndex= cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE);\n            String isoCountryCodeFromDb = cursor.getString(isoCountryCodeColumnIndex);\n\n\n            // Find the best match from backed up data.\n            SimRestoreMatch bestRestoreMatch = null;\n            for (int rowNum = 0; true; rowNum++) {\n                PersistableBundle currRow = backedUpDataBundle.getPersistableBundle(\n                        KEY_SIMINFO_DB_ROW_PREFIX + rowNum);\n                if (currRow == null) {\n                    break;\n                }\n\n                SimRestoreMatch currSimRestoreMatch = new SimRestoreMatch(\n                        currIccIdFromDb, currCarrierIdFromDb, currPhoneNumberFromDb,\n                        isoCountryCodeFromDb, wfcRestoreBlockedCountries, currRow,\n                        backupDataFormatVersion);\n\n                if (currSimRestoreMatch == null) {\n                    continue;\n                }\n\n                /*\n                 * The three following match cases are ordered by descending priority:\n                 *   - Match by iccId: If iccId of backup data matches iccId of any inserted sims,\n                 *       we confidently restore all configs.\n                 *   - Match phone number and carrierId: If both of these values match, we\n                 *       confidently restore all configs.\n                 *   - Match only carrierId: If only carrierId of backup data matches an inserted\n                 *       sim, we only restore non-sensitive configs.\n                 *\n                 * Having a matchScore value for each match allows us to control these priorities.\n                 */\n                if (bestRestoreMatch == null || (currSimRestoreMatch.getMatchScore()\n                        >= bestRestoreMatch.getMatchScore()\n                        && currSimRestoreMatch.getContentValues() != null)) {\n                    bestRestoreMatch = currSimRestoreMatch;\n                }\n            }\n\n            if (bestRestoreMatch != null) {\n                ContentValues newContentValues = bestRestoreMatch.getContentValues();\n                if (bestRestoreMatch.getMatchScore() != 0 && newContentValues != null) {\n                    if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SUW) {\n                        update(SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    } else if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED) {\n                        Uri simInsertedRestoreUri = Uri.withAppendedPath(\n                                SubscriptionManager.SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI,\n                                SIM_INSERTED_RESTORE_URI_SUFFIX);\n                        update(simInsertedRestoreUri,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    }\n                    log(\"Restore of inserterd SIM's sim-specific settings has been successfully \"\n                            + \"completed.\");\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_SUCCESS,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                    newlyRestoredSubIds.add(currSubIdFromDb);\n                } else {\n                    /* If this block was reached because ContentValues was null, that means the\n                    database schema was newer during backup than during restore. We consider this\n                    a no-match to avoid updating columns that don't exist */\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_NONE_MATCH,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                }\n            } else {\n                log(\"No matching SIM in backup data. SIM-specific settings not restored.\");\n                TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                        TelephonyProtoEnums.SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP,\n                        restoreCase, TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE);\n            }\n        }\n\n        // Update the internal file with subIds that we just restored.\n        previouslyRestoredSubIdsList.addAll(newlyRestoredSubIds);\n        backedUpDataBundle.putIntArray(\n                KEY_PREVIOUSLY_RESTORED_SUB_IDS,\n                previouslyRestoredSubIdsList.stream().mapToInt(i -> i).toArray());\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            backedUpDataBundle.writeToStream(outputStream);\n            writeSimSettingsToInternalStorage(outputStream.toByteArray());\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Not storing which subIds were \"\n                    + \"restored\");\n        }\n    }\n\n    private static class SimRestoreMatch {\n\n        private Set<Integer> matches = new ArraySet<>();\n        private int subId;\n        private ContentValues contentValues;\n        private int matchingCriteria;\n        private int matchScore;\n\n        private static final int ICCID_MATCH = 1;\n        private static final int PHONE_NUMBER_MATCH = 2;\n        private static final int CARRIER_ID_MATCH = 3;\n\n        public SimRestoreMatch(String iccIdFromDb, int carrierIdFromDb,\n                String phoneNumberFromDb, String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries,\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion) {\n            subId = backedUpSimInfoEntry.getInt(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                DEFAULT_INT_COLUMN_VALUE);\n            String iccIdFromBackup = backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_ICC_ID,\n                  \"\");\n            String phoneNumberFromBackup = backedUpSimInfoEntry.getString(\n                  Telephony.SimInfo.COLUMN_NUMBER, \"\");\n            int carrierIdFromBackup = backedUpSimInfoEntry.getInt(\n                  Telephony.SimInfo.COLUMN_CARRIER_ID,\n                  TelephonyManager.UNKNOWN_CARRIER_ID);\n\n\n            // find all matching fields\n            if (iccIdFromDb != null && iccIdFromDb.equals(iccIdFromBackup)\n                    && !iccIdFromBackup.isEmpty()) {\n                matches.add(ICCID_MATCH);\n            }\n            if (carrierIdFromDb == carrierIdFromBackup\n                    && carrierIdFromBackup != TelephonyManager.UNKNOWN_CARRIER_ID) {\n                matches.add(CARRIER_ID_MATCH);\n            }\n            if (phoneNumberFromDb != null && phoneNumberFromDb.equals(phoneNumberFromBackup)\n                    && !phoneNumberFromBackup.isEmpty()) {\n                matches.add(PHONE_NUMBER_MATCH);\n            }\n\n            contentValues = convertBackedUpDataToContentValues(\n                    backedUpSimInfoEntry, backupDataFormatVersion, isoCountryCodeFromDb,\n                    wfcRestoreBlockedCountries);\n            matchScore = calculateMatchScore();\n            matchingCriteria = calculateMatchingCriteria();\n        }\n\n        public int getSubId() {\n            return subId;\n        }\n\n        public ContentValues getContentValues() {\n            return contentValues;\n        }\n\n        public int getMatchScore() {\n            return matchScore;\n        }\n\n        private int calculateMatchScore() {\n            int score = 0;\n\n            if (matches.contains(ICCID_MATCH)) {\n                score += 100;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    score += 10;\n                } else {\n                    score += 1;\n                }\n            }\n\n            return score;\n        }\n\n        public int getMatchingCriteriaForLogging() {\n            return matchingCriteria;\n        }\n\n        private int calculateMatchingCriteria() {\n            if (matches.contains(ICCID_MATCH)) {\n                return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_ICCID;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    return TelephonyProtoEnums\n                        .SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER;\n                } else {\n                    return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY;\n                }\n            }\n            return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE;\n        }\n\n        private ContentValues convertBackedUpDataToContentValues(\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion,\n                String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries) {\n            if (DATABASE_VERSION != 57 << 16) {\n                throw new AssertionError(\"The database schema has been updated which might make \"\n                    + \"the format of #BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE outdated. Make sure to \"\n                    + \"1) review whether any of the columns in #SIM_INFO_COLUMNS_TO_BACKUP have \"\n                    + \"been migrated or deleted, 2) add the new column name into one of those \"\n                    + \"maps, 3) add migration code in this method as necessary, and 4) update the \"\n                    + \"version check in this if statement.\");\n            }\n            ContentValues contentValues = new ContentValues();\n            // Don't restore anything if restoring from a newer version of the current database.\n            if (backupDataFormatVersion > DATABASE_VERSION) {\n                return null;\n            }\n\n            /* Any migration logic should be placed under this comment block.\n             * ex:\n             *   if (backupDataFormatVersion >= 48 << 19) {\n             *     contentValues.put(NEW_COLUMN_NAME_2,\n             *         backedUpSimInfoEntry.getInt( OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else if (backupDataFormatVersion >= 48 << 17) {\n             *     contentValues.put(NEW_COLUMN_NAME_1,\n             *         backedUpSimInfoEntry.getInt(OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else {\n             *     // The values from the first format of backup ever available.\n             *     contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *         backedUpSimInfoEntry.getInt(\n             *             Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *             DEFAULT_INT_COLUMN_VALUE));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n             *         backedUpSimInfoEntry.getString(\n             *              Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, \"\"));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               \"\"));\n             *     ...\n             *   }\n             *\n             * Also make sure to add necessary removal of sensitive settings in\n             * polishContentValues(ContentValues contentValues).\n             */\n            if (backupDataFormatVersion >= 57 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                                SubscriptionManager.USAGE_SETTING_UNKNOWN));\n            }\n            if (backupDataFormatVersion >= 52 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 51 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 50 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            if (isoCountryCodeFromDb != null\n                    && !wfcRestoreBlockedCountries\n                            .contains(isoCountryCodeFromDb.toLowerCase())) {\n                // Don't restore COLUMN_WFC_IMS_ENABLED if the sim is from one of the countries that\n                // requires WFC entitlement.\n                contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n\n            return polishContentValues(contentValues);\n        }\n\n        private ContentValues polishContentValues(ContentValues contentValues) {\n            /* Remove any values that weren't found in the backup file. These were set to defaults\n            in #convertBackedUpDataToContentValues(). */\n            for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n                String columnName = column.getKey();\n\n                if (!contentValues.containsKey(columnName)) {\n                    continue;\n                }\n\n                int columnType = column.getValue();\n                if (columnType == Cursor.FIELD_TYPE_INTEGER\n                        && DEFAULT_INT_COLUMN_VALUE == contentValues.getAsInteger(columnName)) {\n                    contentValues.remove(columnName);\n                } else if (columnType == Cursor.FIELD_TYPE_STRING && contentValues\n                        .getAsString(columnName).equals(DEFAULT_STRING_COLUMN_VALUE)) {\n                    contentValues.remove(columnName);\n                }\n            }\n\n            if (matches.contains(ICCID_MATCH)) {\n                return contentValues;\n            } else if (matches.contains(CARRIER_ID_MATCH)) {\n                if (!matches.contains(PHONE_NUMBER_MATCH)) {\n                    // Low confidence match should not restore sensitive configs.\n                    if (contentValues.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        contentValues.remove(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED);\n                    }\n                }\n                return contentValues;\n            }\n            return null;\n        }\n\n    }\n\n    /**\n     * Retrieves data from all columns in SimInfoDB of backup/restore interest.\n     *\n     * @return data of interest from SimInfoDB as a byte array.\n     */\n    private byte[] getSimSpecificDataToBackUp() {\n        String[] projection = SIM_INFO_COLUMNS_TO_BACKUP.keySet()\n                .toArray(new String[SIM_INFO_COLUMNS_TO_BACKUP.size()]);\n\n        try (Cursor cursor = query(SubscriptionManager.CONTENT_URI, projection, null, null, null);\n                ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            PersistableBundle topLevelBundle = new PersistableBundle();\n            topLevelBundle.putInt(KEY_BACKUP_DATA_FORMAT_VERSION, DATABASE_VERSION);\n            for (int rowNum = 0; cursor != null && cursor.moveToNext(); rowNum++) {\n                PersistableBundle rowBundle = convertSimInfoDbEntryToPersistableBundle(cursor);\n                topLevelBundle.putPersistableBundle(KEY_SIMINFO_DB_ROW_PREFIX + rowNum, rowBundle);\n            }\n            topLevelBundle.writeToStream(outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Returning empty byte array\");\n            return new byte[0];\n        }\n    }\n\n    private static PersistableBundle convertSimInfoDbEntryToPersistableBundle(Cursor cursor) {\n        PersistableBundle bundle = new PersistableBundle();\n        for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n            String columnName = column.getKey();\n            int columnType = column.getValue();\n            int columnIndex = cursor.getColumnIndex(columnName);\n            if (columnType == Cursor.FIELD_TYPE_INTEGER) {\n                bundle.putInt(columnName, cursor.getInt(columnIndex));\n            } else if (columnType == Cursor.FIELD_TYPE_STRING) {\n                bundle.putString(columnName, cursor.getString(columnIndex));\n            } else {\n                throw new AssertionError(\"SimInfoDB column to be backed up is not recognized. Make \"\n                    + \"sure to properly add the desired colum name and value type to \"\n                    + \"SIM_INFO_COLUMNS_TO_BACKUP.\");\n            }\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public synchronized Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        if (VDBG) log(\"query: url=\" + url + \", projectionIn=\" + projectionIn + \", selection=\"\n                + selection + \"selectionArgs=\" + selectionArgs + \", sort=\" + sort);\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String subIdString;\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true); // a little protection from injection attacks\n        qb.setTables(CARRIERS_TABLE);\n\n        List<String> constraints = new ArrayList<String>();\n\n        int match = s_urlMatcher.match(url);\n        checkPermissionCompat(match, projectionIn);\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID: {\n                // The behaves exactly same as URL_SIM_APN_LIST_ID.\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            case URL_TELEPHONY: {\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_CURRENT: {\n                constraints.add(\"current IS NOT NULL\");\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                // do not ignore the selection since MMS may use it.\n                //selection = null;\n                break;\n            }\n\n            case URL_ID: {\n                constraints.add(\"_id = \" + url.getPathSegments().get(1));\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE: {\n                constraints.add(\"_id = \" + getPreferredApnId(subId, true));\n                break;\n            }\n\n            case URL_PREFERAPNSET_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            // intentional fall through from above case\n            case URL_PREFERAPNSET: {\n                final int set = getPreferredApnSetId(subId);\n                if (set == NO_APN_SET_ID) {\n                    return null;\n                }\n                constraints.add(APN_SET_ID + \"=\" + set);\n                qb.appendWhere(TextUtils.join(\" AND \", constraints));\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_FILTERED_ID:\n            case URL_FILTERED_USING_SUBID: {\n                String idString = url.getLastPathSegment();\n                if (match == URL_FILTERED_ID) {\n                    constraints.add(\"_id = \" + idString);\n                } else {\n                    try {\n                        subId = Integer.parseInt(idString);\n                        // TODO b/74213956 turn this back on once insertion includes correct sub id\n                        // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n                    } catch (NumberFormatException e) {\n                        loge(\"NumberFormatException\" + e);\n                        return null;\n                    }\n                }\n            }\n            //intentional fall through from above case\n            case URL_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    constraints.add(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    constraints.add(IS_NOT_OWNED_BY_DPC);\n                }\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                MatrixCursor cursor = new MatrixCursor(new String[]{ENFORCED_KEY});\n                cursor.addRow(new Object[]{isManagedApnEnforced() ? 1 : 0});\n                return cursor;\n            }\n\n            case URL_SIMINFO: {\n                qb.setTables(SIMINFO_TABLE);\n                break;\n            }\n            case URL_SIM_APN_LIST_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST: {\n                qb.appendWhere(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_SIM_APN_LIST_FILTERED_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    qb.appendWhereStandalone(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                }\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                    sort, subId);\n            }\n\n            default: {\n                return null;\n            }\n        }\n\n        // appendWhere doesn't add ANDs so we do it ourselves\n        if (constraints.size() > 0) {\n            qb.appendWhere(TextUtils.join(\" AND \", constraints));\n        }\n\n        SQLiteDatabase db = getReadableDatabase();\n        Cursor ret = null;\n        try {\n            // Exclude entries marked deleted\n            if (CARRIERS_TABLE.equals(qb.getTables())) {\n                if (TextUtils.isEmpty(selection)) {\n                    selection = \"\";\n                } else {\n                    selection += \" and \";\n                }\n                selection += IS_NOT_USER_DELETED + \" and \" +\n                        IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                        IS_NOT_CARRIER_DELETED + \" and \" +\n                        IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                if (VDBG) log(\"query: selection modified to \" + selection);\n            }\n            ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);\n        } catch (SQLException e) {\n            loge(\"got exception when querying: \" + e);\n        }\n        if (ret != null)\n            ret.setNotificationUri(getContext().getContentResolver(), url);\n        return ret;\n    }\n\n    /**\n     * This method syncs PREF_FILE_FULL_APN with the db based on the current preferred apn ids.\n     */\n    private void updatePreferredApns() {\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            if (key.startsWith(COLUMN_APN_ID)) {\n                int subId;\n                try {\n                    subId = Integer.parseInt(key.substring(COLUMN_APN_ID.length()));\n                } catch (NumberFormatException e) {\n                    loge(\"updatePreferredApns: NumberFormatException for key=\" + key);\n                    continue;\n                }\n                long preferredApnId = getPreferredApnId(subId, false);\n                if (preferredApnId != INVALID_APN_ID) {\n                    setPreferredApn(preferredApnId, subId);\n                }\n            }\n        }\n    }\n\n    /**\n     * To find the current sim APN. Query APN based on {MCC, MNC, MVNO} and {Carrier_ID}.\n     *\n     * There has three steps:\n     * 1. Query the APN based on { MCC, MNC, MVNO } and if has results jump to step 3, else jump to\n     *    step 2.\n     * 2. Fallback to query the parent APN that query based on { MCC, MNC }.\n     * 3. Append the result with the APN that query based on { Carrier_ID }\n     */\n    private Cursor getSubscriptionMatchingAPNList(SQLiteQueryBuilder qb, String[] projectionIn,\n            String selection, String[] selectionArgs, String sort, int subId) {\n        Cursor ret;\n        Context context = getContext();\n        SubscriptionManager subscriptionManager = (SubscriptionManager) context\n                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);\n        if (!subscriptionManager.isActiveSubscriptionId(subId)) {\n            return null;\n        }\n\n        final TelephonyManager tm = ((TelephonyManager) context\n                .getSystemService(Context.TELEPHONY_SERVICE))\n                .createForSubscriptionId(subId);\n        SQLiteDatabase db = getReadableDatabase();\n        String mccmnc = tm.getSimOperator();\n        int carrierId = tm.getSimSpecificCarrierId();\n\n        qb.appendWhereStandalone(IS_NOT_USER_DELETED + \" and \" +\n                IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                IS_NOT_CARRIER_DELETED + \" and \" +\n                IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML);\n\n        // For query db one time, append all conditions in one selection and separate results after\n        // the query is completed. IMSI has special match rule, so just query the MCC / MNC and\n        // filter the MVNO by ourselves\n        qb.appendWhereStandalone(NUMERIC + \" = '\" + mccmnc + \"' OR \" +\n                CARRIER_ID + \" = '\" + carrierId + \"'\");\n\n        ret = qb.query(db, null, selection, selectionArgs, null, null, sort);\n        if (ret == null) {\n            loge(\"query current APN but cursor is null.\");\n            return null;\n        }\n\n        if (DBG) log(\"match current APN size:  \" + ret.getCount());\n\n        String[] columnNames = projectionIn != null ? projectionIn : ret.getColumnNames();\n        MatrixCursor currentCursor = new MatrixCursor(columnNames);\n        MatrixCursor parentCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdNonMatchingMNOCursor = new MatrixCursor(columnNames);\n\n        int numericIndex = ret.getColumnIndex(NUMERIC);\n        int mvnoIndex = ret.getColumnIndex(MVNO_TYPE);\n        int mvnoDataIndex = ret.getColumnIndex(MVNO_MATCH_DATA);\n        int carrierIdIndex = ret.getColumnIndex(CARRIER_ID);\n\n        // Separate the result into MatrixCursor\n        while (ret.moveToNext()) {\n            List<String> data = new ArrayList<>();\n            for (String column : columnNames) {\n                data.add(ret.getString(ret.getColumnIndex(column)));\n            }\n\n            boolean isCurrentSimOperator = false;\n            if (!TextUtils.isEmpty(ret.getString(numericIndex))) {\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    isCurrentSimOperator = tm.matchesCurrentSimOperator(\n                            ret.getString(numericIndex),\n                            getMvnoTypeIntFromString(ret.getString(mvnoIndex)),\n                            ret.getString(mvnoDataIndex));\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n\n            boolean isMVNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && isCurrentSimOperator;\n            boolean isMNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && ret.getString(numericIndex).equals(mccmnc)\n                    && TextUtils.isEmpty(ret.getString(mvnoIndex));\n            boolean isCarrierIdAPN = !TextUtils.isEmpty(ret.getString(carrierIdIndex))\n                    && ret.getString(carrierIdIndex).equals(String.valueOf(carrierId))\n                    && carrierId != TelephonyManager.UNKNOWN_CARRIER_ID;\n\n            if (isMVNOAPN) {\n                // 1. The APN that query based on legacy SIM MCC/MCC and MVNO\n                currentCursor.addRow(data);\n            } else if (isMNOAPN) {\n                // 2. The APN that query based on SIM MCC/MNC\n                parentCursor.addRow(data);\n            } else if (isCarrierIdAPN) {\n                // The APN that query based on carrier Id (not include the MVNO or MNO APN)\n                if (TextUtils.isEmpty(ret.getString(numericIndex))) {\n                    carrierIdCursor.addRow(data);\n                } else {\n                    carrierIdNonMatchingMNOCursor.addRow(data);\n                }\n            }\n        }\n        ret.close();\n\n        MatrixCursor result;\n        if (currentCursor.getCount() > 0) {\n            if (DBG) log(\"match MVNO APN: \" + currentCursor.getCount());\n            result = currentCursor;\n        } else if (parentCursor.getCount() > 0) {\n            if (DBG) log(\"match MNO APN: \" + parentCursor.getCount());\n            result = parentCursor;\n        } else {\n            if (DBG) {\n                log(\"No MVNO, MNO and no MCC/MNC match, but we have match/matches with the \" +\n                        \"same carrier id, count: \" + carrierIdNonMatchingMNOCursor.getCount());\n            }\n            result = carrierIdNonMatchingMNOCursor;\n        }\n\n        if (DBG) log(\"match carrier id APN: \" + carrierIdCursor.getCount());\n        appendCursorData(result, carrierIdCursor);\n        return result;\n    }\n\n    private static void appendCursorData(@NonNull MatrixCursor from, @NonNull MatrixCursor to) {\n        while (to.moveToNext()) {\n            List<Object> data = new ArrayList<>();\n            for (String column : to.getColumnNames()) {\n                int index = to.getColumnIndex(column);\n                switch (to.getType(index)) {\n                    case Cursor.FIELD_TYPE_INTEGER:\n                        data.add(to.getInt(index));\n                        break;\n                    case Cursor.FIELD_TYPE_FLOAT:\n                        data.add(to.getFloat(index));\n                        break;\n                    case Cursor.FIELD_TYPE_BLOB:\n                        data.add(to.getBlob(index));\n                        break;\n                    case Cursor.FIELD_TYPE_STRING:\n                    case Cursor.FIELD_TYPE_NULL:\n                        data.add(to.getString(index));\n                        break;\n                }\n            }\n            from.addRow(data);\n        }\n    }\n\n    @Override\n    public String getType(Uri url)\n    {\n        switch (s_urlMatcher.match(url)) {\n        case URL_TELEPHONY:\n        case URL_TELEPHONY_USING_SUBID:\n            return \"vnd.android.cursor.dir/telephony-carrier\";\n\n        case URL_ID:\n        case URL_FILTERED_ID:\n        case URL_FILTERED_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        case URL_PREFERAPN_USING_SUBID:\n        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n        case URL_PREFERAPN:\n        case URL_PREFERAPN_NO_UPDATE:\n        case URL_PREFERAPNSET:\n        case URL_PREFERAPNSET_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        default:\n            throw new IllegalArgumentException(\"Unknown URL \" + url);\n        }\n    }\n\n    /**\n     * Insert an array of ContentValues and call notifyChange at the end.\n     */\n    @Override\n    public synchronized int bulkInsert(Uri url, ContentValues[] values) {\n        return unsynchronizedBulkInsert(url, values);\n    }\n\n    /**\n     * Do a bulk insert while inside a synchronized function. This is typically not safe and should\n     * only be done when you are sure there will be no conflict.\n     */\n    private int unsynchronizedBulkInsert(Uri url, ContentValues[] values) {\n        int count = 0;\n        boolean notify = false;\n        for (ContentValues value : values) {\n            Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, value);\n            if (rowAndNotify.first != null) {\n                count++;\n            }\n            if (rowAndNotify.second == true) {\n                notify = true;\n            }\n        }\n        if (notify) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return count;\n    }\n\n    @Override\n    public synchronized Uri insert(Uri url, ContentValues initialValues) {\n        Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, initialValues);\n        if (rowAndNotify.second) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return rowAndNotify.first;\n    }\n\n    /**\n     * Internal insert function to prevent code duplication for URL_TELEPHONY and URL_DPC.\n     *\n     * @param values the value that caller wants to insert\n     * @return a pair in which the first element refers to the Uri for the row inserted, the second\n     *         element refers to whether sends out nofitication.\n     */\n    private Pair<Uri, Boolean> insertRowWithValue(ContentValues values) {\n        Uri result = null;\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n\n        try {\n            // Abort on conflict of unique fields and attempt merge\n            long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                    SQLiteDatabase.CONFLICT_ABORT);\n            if (rowID >= 0) {\n                result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                notify = true;\n            }\n            if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n        } catch (SQLException e) {\n            log(\"insert: exception \" + e);\n            // Insertion failed which could be due to a conflict. Check if that is the case\n            // and merge the entries\n            Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n            if (oldRow != null) {\n                ContentValues mergedValues = new ContentValues();\n                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                        mergedValues, false, getContext());\n                oldRow.close();\n                notify = true;\n            }\n        }\n        return Pair.create(result, notify);\n    }\n\n    private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {\n        Uri result = null;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(initialValues);\n\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                values = setDefaultValue(values);\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Owned_by should be others if inserted via general uri.\n                values.put(OWNED_BY, OWNED_BY_OTHERS);\n\n                Pair<Uri, Boolean> ret = insertRowWithValue(values);\n                result = ret.first;\n                notify = ret.second;\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // zero out the previous operator\n                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + \"!=0\", null);\n\n                String numeric = initialValues.getAsString(NUMERIC);\n                int updated = db.update(CARRIERS_TABLE, s_currentSetMap,\n                        NUMERIC + \" = '\" + numeric + \"'\", null);\n\n                if (updated > 0)\n                {\n                    if (VDBG) log(\"Setting numeric '\" + numeric + \"' to be the current operator\");\n                }\n                else\n                {\n                    loge(\"Failed setting numeric '\" + numeric + \"' to the current operator\");\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (initialValues != null) {\n                    if(initialValues.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);\n                        notify = true;\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                // Owned_by should be DPC if inserted via URL_DPC.\n                values.put(OWNED_BY, OWNED_BY_DPC);\n                // DPC records should not be user editable.\n                values.put(USER_EDITABLE, false);\n\n                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                        SQLiteDatabase.CONFLICT_IGNORE);\n                if (rowID >= 0) {\n                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                    notify = true;\n                }\n                if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n\n                break;\n            }\n\n            case URL_SIMINFO: {\n               long id = db.insert(SIMINFO_TABLE, null, initialValues);\n               result = ContentUris.withAppendedId(Telephony.SimInfo.CONTENT_URI, id);\n               break;\n            }\n        }\n\n        return Pair.create(result, notify);\n    }\n\n    @Override\n    public synchronized int delete(Uri url, String where, String[] whereArgs) {\n        int count = 0;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String userOrCarrierEdited = \") and (\" +\n                IS_USER_EDITED +  \" or \" +\n                IS_CARRIER_EDITED + \")\";\n        String notUserOrCarrierEdited = \") and (\" +\n                IS_NOT_USER_EDITED +  \" and \" +\n                IS_NOT_CARRIER_EDITED + \")\";\n        String unedited = \") and \" + IS_UNEDITED;\n        ContentValues cv = new ContentValues();\n        cv.put(EDITED_STATUS, USER_DELETED);\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_DELETE:\n            {\n                // Delete preferred APN for all subIds\n                deletePreferredApnId(getContext());\n                // Delete unedited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + unedited + \" and \" +\n                        IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_ID:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE,\n                        \"(\" + _ID + \"=?\" + userOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv,\n                        \"(\" + _ID + \"=?\" + notUserOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[]{url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_RESTOREAPN_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            // intentional fall through from above case\n\n            case URL_RESTOREAPN: {\n                count = 1;\n                restoreDefaultAPN(subId);\n                getContext().getContentResolver().notifyChange(\n                        Uri.withAppendedPath(CONTENT_URI, \"restore/subId/\" + subId), null,\n                        true, UserHandle.USER_ALL);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                setPreferredApnId((long)INVALID_APN_ID, subId, true);\n                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) count = 1;\n                break;\n            }\n\n            case URL_DPC_ID: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                // Only delete if owned by DPC.\n                count = db.delete(CARRIERS_TABLE, \"(\" + _ID + \"=?)\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_SIMINFO: {\n                count = db.delete(SIMINFO_TABLE, where, whereArgs);\n                break;\n            }\n\n            case URL_UPDATE_DB: {\n                updateApnDb();\n                count = 1;\n                break;\n            }\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot delete that URL: \" + url);\n            }\n        }\n\n        if (count > 0) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n\n        return count;\n    }\n\n    @Override\n    public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs)\n    {\n        int count = 0;\n        int uriType = URL_UNKNOWN;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(values);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs,\n                        SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        whereArgs, SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_ID:\n            {\n                String rowID = url.getLastPathSegment();\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                try {\n                    count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + \"=?\" + \" and \" +\n                            IS_NOT_OWNED_BY_DPC, new String[] { rowID },\n                            SQLiteDatabase.CONFLICT_ABORT);\n                } catch (SQLException e) {\n                    // Update failed which could be due to a conflict. Check if that is\n                    // the case and merge the entries\n                    log(\"update: exception \" + e);\n                    Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n                    if (oldRow != null) {\n                        ContentValues mergedValues = new ContentValues();\n                        mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                                mergedValues, false, getContext());\n                        oldRow.close();\n                        db.delete(CARRIERS_TABLE, _ID + \"=?\" + \" and \" + IS_NOT_OWNED_BY_DPC,\n                                new String[] { rowID });\n                    }\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (values != null) {\n                    if (values.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);\n                        if ((match == URL_PREFERAPN) ||\n                                (match == URL_PREFERAPN_USING_SUBID)) {\n                            count = 1;\n                        }\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC_ID:\n            {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values,\n                        _ID + \"=?\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_IGNORE);\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                if (values != null) {\n                    if (values.containsKey(ENFORCED_KEY)) {\n                        setManagedApnEnforced(values.getAsBoolean(ENFORCED_KEY));\n                        count = 1;\n                    }\n                }\n                break;\n            }\n\n            case URL_SIMINFO_USING_SUBID:\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.update(SIMINFO_TABLE, values, _ID + \"=?\",\n                        new String[] { subIdString});\n                uriType = URL_SIMINFO_USING_SUBID;\n                break;\n\n            case URL_SIMINFO: {\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO;\n                break;\n            }\n\n            case URL_SIMINFO_SUW_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO_SUW_RESTORE;\n                break;\n\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                break;\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot update that URL: \" + url);\n            }\n        }\n\n        // if APNs (CARRIERS_TABLE) have been updated, some of them may be preferred APN for\n        // different subs. So update the APN field values saved in SharedPref for all subIds.\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID:\n            case URL_TELEPHONY:\n            case URL_CURRENT_USING_SUBID:\n            case URL_CURRENT:\n            case URL_ID:\n            case URL_DPC_ID:\n                updatePreferredApns();\n                break;\n        }\n\n        if (count > 0) {\n            boolean usingSubId = false;\n            switch (uriType) {\n                case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                    break;\n                case URL_SIMINFO_SUW_RESTORE:\n                    getContext().getContentResolver().notifyChange(\n                            SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI, null);\n                    // intentional fall through from above case\n                case URL_SIMINFO_USING_SUBID:\n                    usingSubId = true;\n                    // intentional fall through from above case\n                case URL_SIMINFO:\n                    // skip notifying descendant URLs to avoid unneccessary wake up.\n                    // If not set, any change to SIMINFO will notify observers which listens to\n                    // specific field of SIMINFO.\n                    getContext().getContentResolver().notifyChange(\n                        Telephony.SimInfo.CONTENT_URI, null,\n                            ContentResolver.NOTIFY_SYNC_TO_NETWORK\n                                    | ContentResolver.NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS,\n                            UserHandle.USER_ALL);\n                    // notify observers on specific user settings changes.\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager\n                                                .ADVANCED_CALLING_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.VT_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_MODE)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_MODE_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED), usingSubId, subId),\n                                null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_USAGE_SETTING)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_USAGE_SETTING),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    break;\n                default:\n                    getContext().getContentResolver().notifyChange(\n                            CONTENT_URI, null, true, UserHandle.USER_ALL);\n            }\n        }\n\n        return count;\n    }\n\n    private static Uri getNotifyContentUri(Uri uri, boolean usingSubId, int subId) {\n        return (usingSubId) ? Uri.withAppendedPath(uri, \"\" + subId) : uri;\n    }\n\n    /**\n     * Checks permission to query or insert/update/delete the database. The permissions required\n     * for APN DB and SIMINFO DB are different:\n     * <ul>\n     * <li>APN DB requires WRITE_APN_SETTINGS or carrier privileges\n     * <li>SIMINFO DB requires phone UID; it's for phone internal usage only\n     * <\/ul>\n     */\n    private void checkPermission(int match) {\n        switch (match) {\n            case URL_SIMINFO:\n            case URL_SIMINFO_USING_SUBID:\n            case URL_SIMINFO_SUW_RESTORE:\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                checkPermissionForSimInfoTable();\n                break;\n            default:\n                checkPermissionForApnTable();\n        }\n    }\n\n    private void checkPermissionForApnTable() {\n        int status = getContext().checkCallingOrSelfPermission(\n                \"android.permission.WRITE_APN_SETTINGS\");\n        if (status == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        PackageManager packageManager = getContext().getPackageManager();\n        String[] packages = packageManager.getPackagesForUid(Binder.getCallingUid());\n\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            for (String pkg : packages) {\n                if (telephonyManager.checkCarrierPrivilegesForPackageAnyPhone(pkg) ==\n                    TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {\n                    return;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        throw new SecurityException(\"No permission to access APN settings\");\n    }\n\n    /**\n     * Check permission to query the database based on PlatformCompat settings -- if the compat\n     * change is enabled, check WRITE_APN_SETTINGS or carrier privs for all queries. Otherwise,\n     * use the legacy checkQueryPermission method to see if the query should be allowed.\n     */\n    private void checkPermissionCompat(int match, String[] projectionIn) {\n        boolean useNewBehavior = CompatChanges.isChangeEnabled(\n                Telephony.Carriers.APN_READING_PERMISSION_CHANGE_ID,\n                Binder.getCallingUid());\n\n        if (!useNewBehavior) {\n            log(\"Using old permission behavior for telephony provider compat\");\n            checkQueryPermission(match, projectionIn);\n        } else {\n            checkPermission(match);\n        }\n    }\n\n    private void checkQueryPermission(int match, String[] projectionIn) {\n        if (match == URL_SIMINFO) {\n            checkPermissionForSimInfoTable();\n        } else {\n            if (projectionIn != null) {\n                for (String column : projectionIn) {\n                    if (TYPE.equals(column) ||\n                            MMSC.equals(column) ||\n                            MMSPROXY.equals(column) ||\n                            MMSPORT.equals(column) ||\n                            MVNO_TYPE.equals(column) ||\n                            MVNO_MATCH_DATA.equals(column) ||\n                            APN.equals(column)) {\n                        // noop\n                    } else {\n                        checkPermissionForApnTable();\n                        break;\n                    }\n                }\n            } else {\n                // null returns all columns, so need permission check\n                checkPermissionForApnTable();\n            }\n        }\n    }\n\n    private void checkPermissionForSimInfoTable() {\n        ensureCallingFromSystemOrPhoneUid(\"Access SIMINFO table from not phone/system UID\");\n        if (getContext().checkCallingOrSelfPermission(\n                    \"android.permission.ACCESS_TELEPHONY_SIMINFO_DB\")\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n        throw new SecurityException(\"No permission to access SIMINFO table\");\n    }\n\n    private DatabaseHelper mOpenHelper;\n\n    private void restoreDefaultAPN(int subId) {\n        SQLiteDatabase db = getWritableDatabase();\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        String where = null;\n        if (telephonyManager.getPhoneCount() > 1) {\n            where = getWhereClauseForRestoreDefaultApn(db, subId);\n        }\n        if (TextUtils.isEmpty(where)) {\n            where = IS_NOT_OWNED_BY_DPC;\n        }\n        log(\"restoreDefaultAPN: where: \" + where);\n\n        try {\n            db.delete(CARRIERS_TABLE, where, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to restore: \" + e);\n        }\n\n        // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all\n        // subIds\n        SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApnId = spApnId.edit();\n        editorApnId.clear();\n        editorApnId.apply();\n\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApn = spApn.edit();\n        editorApn.clear();\n        editorApn.apply();\n\n        if (apnSourceServiceExists(getContext())) {\n            restoreApnsWithService(subId);\n        } else {\n            initDatabaseWithDatabaseHelper(db);\n        }\n    }\n\n    private String getWhereClauseForRestoreDefaultApn(SQLiteDatabase db, int subId) {\n        TelephonyManager telephonyManager =\n            getContext().getSystemService(TelephonyManager.class).createForSubscriptionId(subId);\n        String simOperator = telephonyManager.getSimOperator();\n        Cursor cursor = db.query(CARRIERS_TABLE, new String[] {MVNO_TYPE, MVNO_MATCH_DATA},\n                NUMERIC + \"='\" + simOperator + \"'\", null, null, null, DEFAULT_SORT_ORDER);\n        String where = null;\n\n        if (cursor != null) {\n            cursor.moveToFirst();\n            while (!cursor.isAfterLast()) {\n                String mvnoType = cursor.getString(0 /* MVNO_TYPE index */);\n                String mvnoMatchData = cursor.getString(1 /* MVNO_MATCH_DATA index */);\n                if (!TextUtils.isEmpty(mvnoType) && !TextUtils.isEmpty(mvnoMatchData)\n                        && telephonyManager.matchesCurrentSimOperator(simOperator,\n                            getMvnoTypeIntFromString(mvnoType), mvnoMatchData)) {\n                    where = NUMERIC + \"='\" + simOperator + \"'\"\n                            + \" AND \" + MVNO_TYPE + \"='\" + mvnoType + \"'\"\n                            + \" AND \" + MVNO_MATCH_DATA + \"='\" + mvnoMatchData + \"'\"\n                            + \" AND \" + IS_NOT_OWNED_BY_DPC;\n                    break;\n                }\n                cursor.moveToNext();\n            }\n            cursor.close();\n\n            if (TextUtils.isEmpty(where)) {\n                where = NUMERIC + \"='\" + simOperator + \"'\"\n                        + \" AND (\" + MVNO_TYPE + \"='' OR \" + MVNO_MATCH_DATA + \"='')\"\n                        + \" AND \" + IS_NOT_OWNED_BY_DPC;\n            }\n        }\n        return where;\n    }\n\n    private synchronized void updateApnDb() {\n        if (apnSourceServiceExists(getContext())) {\n            loge(\"called updateApnDb when apn source service exists\");\n            return;\n        }\n\n        if (!needApnDbUpdate()) {\n            log(\"Skipping apn db update since apn-conf has not changed.\");\n            return;\n        }\n\n        SQLiteDatabase db = getWritableDatabase();\n\n        // Delete preferred APN for all subIds\n        deletePreferredApnId(getContext());\n\n        // Delete entries in db\n        try {\n            if (VDBG) log(\"updateApnDb: deleting edited=UNEDITED entries\");\n            db.delete(CARRIERS_TABLE, IS_UNEDITED + \" and \" + IS_NOT_OWNED_BY_DPC, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to update: \" + e);\n        }\n\n        initDatabaseWithDatabaseHelper(db);\n\n        // Notify listeners of DB change since DB has been updated\n        getContext().getContentResolver().notifyChange(\n                CONTENT_URI, null, true, UserHandle.USER_ALL);\n\n    }\n\n    public static void fillInMccMncStringAtCursor(Context context, SQLiteDatabase db, Cursor c) {\n        int mcc, mnc;\n        String subId;\n        try {\n            mcc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MCC));\n            mnc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MNC));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        String mccString = String.format(Locale.getDefault(), \"%03d\", mcc);\n        String mncString = getBestStringMnc(context, mccString, mnc);\n        ContentValues cv = new ContentValues(2);\n        cv.put(Telephony.SimInfo.COLUMN_MCC_STRING, mccString);\n        cv.put(Telephony.SimInfo.COLUMN_MNC_STRING, mncString);\n        db.update(SIMINFO_TABLE, cv,\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                new String[]{subId});\n    }\n\n    /*\n     * Find the best string-form mnc by looking up possibilities in the carrier id db.\n     * Default to the three-digit version if neither/both are valid.\n     */\n    private static String getBestStringMnc(Context context, String mcc, int mnc) {\n        if (mnc >= 100 && mnc <= 999) {\n            return String.valueOf(mnc);\n        }\n        String twoDigitMnc = String.format(Locale.getDefault(), \"%02d\", mnc);\n        String threeDigitMnc = \"0\" + twoDigitMnc;\n        boolean threeDigitNetworkCode =\n                Arrays.asList(COUNTRY_MCC_WITH_THREE_DIGIT_MNC).contains(mcc);\n        int twoDigitResult = countMccMncInCarrierList(context, mcc + twoDigitMnc);\n        int threeDigitResult = countMccMncInCarrierList(context, mcc + threeDigitMnc);\n\n        if ((threeDigitResult > twoDigitResult) ||\n                (threeDigitNetworkCode && (twoDigitResult == threeDigitResult))) {\n            return threeDigitMnc;\n        } else {\n            return twoDigitMnc;\n        }\n    }\n\n    /**\n     * Check carrier_list how many mcc mnc combo matches there are\n     */\n    private static int countMccMncInCarrierList(Context ctx, String mccMncCombo) {\n        try (\n            Cursor mccMncCursor = ctx.getContentResolver().query(\n                    Telephony.CarrierId.All.CONTENT_URI,\n                    /* projection */ null,\n                    /* selection */ Telephony.CarrierId.All.MCCMNC + \"=?\",\n                    /* selectionArgs */ new String[]{mccMncCombo}, null);\n        )\n        {\n            return mccMncCursor.getCount();\n        }\n    }\n\n    /**\n     * Sync the bearer bitmask and network type bitmask when inserting and updating.\n     * Since bearerBitmask is deprecating, map the networkTypeBitmask to bearerBitmask if\n     * networkTypeBitmask was provided. But if networkTypeBitmask was not provided, map the\n     * bearerBitmask to networkTypeBitmask.\n     */\n    private static void syncBearerBitmaskAndNetworkTypeBitmask(ContentValues values) {\n        if (values.containsKey(NETWORK_TYPE_BITMASK)) {\n            int convertedBitmask = convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK));\n            if (values.containsKey(BEARER_BITMASK)\n                    && convertedBitmask != values.getAsInteger(BEARER_BITMASK)) {\n                loge(\"Network type bitmask and bearer bitmask are not compatible.\");\n            }\n            values.put(BEARER_BITMASK, convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK)));\n        } else {\n            if (values.containsKey(BEARER_BITMASK)) {\n                int convertedBitmask = convertBearerBitmaskToNetworkTypeBitmask(\n                        values.getAsInteger(BEARER_BITMASK));\n                values.put(NETWORK_TYPE_BITMASK, convertedBitmask);\n            }\n        }\n    }\n\n    /**\n     * Log with debug\n     *\n     * @param s is string log\n     */\n    private static void log(String s) {\n        Log.d(TAG, s);\n    }\n\n    private static void loge(String s) {\n        Log.e(TAG, s);\n    }\n\n    private static int getMvnoTypeIntFromString(String mvnoType) {\n        String mvnoTypeString = TextUtils.isEmpty(mvnoType) ? mvnoType : mvnoType.toLowerCase();\n        Integer mvnoTypeInt = MVNO_TYPE_STRING_MAP.get(mvnoTypeString);\n        return  mvnoTypeInt == null ? 0 : mvnoTypeInt;\n    }\n\n    private static int getBitmaskFromString(String bearerList) {\n        String[] bearers = bearerList.split(\"\\\\|\");\n        int bearerBitmask = 0;\n        for (String bearer : bearers) {\n            int bearerInt = 0;\n            try {\n                bearerInt = Integer.parseInt(bearer.trim());\n            } catch (NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (bearerInt == 0) {\n                return 0;\n            }\n            bearerBitmask |= getBitmaskForTech(bearerInt);\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Transform RIL radio technology value to Network\n     * type bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     *\n     * @param rat The RIL radio technology.\n     * @return The network type\n     * bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     */\n    private static int rilRadioTechnologyToNetworkTypeBitmask(int rat) {\n        switch (rat) {\n            case RIL_RADIO_TECHNOLOGY_GPRS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GPRS;\n            case RIL_RADIO_TECHNOLOGY_EDGE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EDGE;\n            case RIL_RADIO_TECHNOLOGY_UMTS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;\n            case RIL_RADIO_TECHNOLOGY_HSDPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSDPA;\n            case RIL_RADIO_TECHNOLOGY_HSUPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA;\n            case RIL_RADIO_TECHNOLOGY_HSPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPA;\n            case RIL_RADIO_TECHNOLOGY_IS95A:\n            case RIL_RADIO_TECHNOLOGY_IS95B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;\n            case RIL_RADIO_TECHNOLOGY_1xRTT:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT;\n            case RIL_RADIO_TECHNOLOGY_EVDO_0:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0;\n            case RIL_RADIO_TECHNOLOGY_EVDO_A:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A;\n            case RIL_RADIO_TECHNOLOGY_EVDO_B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B;\n            case RIL_RADIO_TECHNOLOGY_EHRPD:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD;\n            case RIL_RADIO_TECHNOLOGY_LTE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE;\n            case RIL_RADIO_TECHNOLOGY_HSPAP:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPAP;\n            case RIL_RADIO_TECHNOLOGY_GSM:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GSM;\n            case RIL_RADIO_TECHNOLOGY_TD_SCDMA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_TD_SCDMA;\n            case RIL_RADIO_TECHNOLOGY_IWLAN:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_IWLAN;\n            case RIL_RADIO_TECHNOLOGY_LTE_CA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;\n            case RIL_RADIO_TECHNOLOGY_NR:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_NR;\n            default:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UNKNOWN;\n        }\n    }\n\n    /**\n     * Convert network type bitmask to bearer bitmask.\n     *\n     * @param networkTypeBitmask The network type bitmask value\n     * @return The bearer bitmask value.\n     */\n    private static int convertNetworkTypeBitmaskToBearerBitmask(int networkTypeBitmask) {\n        if (networkTypeBitmask == 0) {\n            return 0;\n        }\n\n        int bearerBitmask = 0;\n        for (int bearerInt = 0; bearerInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerInt++) {\n            if (bitmaskHasTarget(networkTypeBitmask,\n                    rilRadioTechnologyToNetworkTypeBitmask(bearerInt))) {\n                bearerBitmask |= getBitmaskForTech(bearerInt);\n            }\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Convert bearer bitmask to network type bitmask.\n     *\n     * @param bearerBitmask The bearer bitmask value.\n     * @return The network type bitmask value.\n     */\n    private static int convertBearerBitmaskToNetworkTypeBitmask(int bearerBitmask) {\n        if (bearerBitmask == 0) {\n            return 0;\n        }\n\n        int networkTypeBitmask = 0;\n        for (int bearerUnitInt = 0; bearerUnitInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerUnitInt++) {\n            int bearerUnitBitmask = getBitmaskForTech(bearerUnitInt);\n            if (bitmaskHasTarget(bearerBitmask, bearerUnitBitmask)) {\n                networkTypeBitmask |= rilRadioTechnologyToNetworkTypeBitmask(bearerUnitInt);\n            }\n        }\n        return networkTypeBitmask;\n    }\n\n    private static boolean bitmaskHasTarget(int bearerBitmask, int targetBitmask) {\n        if (bearerBitmask == 0) {\n            return true;\n        } else if (targetBitmask != 0) {\n            return ((bearerBitmask & targetBitmask) != 0);\n        }\n        return false;\n    }\n\n    private static int getBitmaskForTech(int radioTech) {\n        if (radioTech >= 1) {\n            return (1 << (radioTech - 1));\n        }\n        return 0;\n    }\n\n    /**\n     * Migrate the old Long values{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} over to\n     * String{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} values in the sim info\n     *         table.\n     */\n    public static void fillInAllowedNetworkTypesStringAtCursor(SQLiteDatabase db, Cursor c) {\n        long allowedNetworkTypesReasonCarrier;\n        String subId;\n        try {\n            allowedNetworkTypesReasonCarrier = c.getLong(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        if (allowedNetworkTypesReasonCarrier != -1) {\n            ContentValues cv = new ContentValues(1);\n\n            cv.put(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS,\n                    \"carrier=\" + allowedNetworkTypesReasonCarrier);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n}\n","Method after Refactoring":"/* //device/content/providers/telephony/TelephonyProvider.java\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n\npackage com.android.providers.telephony;\n\nimport static android.provider.Telephony.Carriers.ALWAYS_ON;\nimport static android.provider.Telephony.Carriers.APN;\nimport static android.provider.Telephony.Carriers.APN_SET_ID;\nimport static android.provider.Telephony.Carriers.AUTH_TYPE;\nimport static android.provider.Telephony.Carriers.BEARER;\nimport static android.provider.Telephony.Carriers.BEARER_BITMASK;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED;\nimport static android.provider.Telephony.Carriers.CARRIER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.CARRIER_EDITED;\nimport static android.provider.Telephony.Carriers.CARRIER_ENABLED;\nimport static android.provider.Telephony.Carriers.CARRIER_ID;\nimport static android.provider.Telephony.Carriers.CONTENT_URI;\nimport static android.provider.Telephony.Carriers.CURRENT;\nimport static android.provider.Telephony.Carriers.DEFAULT_SORT_ORDER;\nimport static android.provider.Telephony.Carriers.EDITED_STATUS;\nimport static android.provider.Telephony.Carriers.LINGERING_NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.MCC;\nimport static android.provider.Telephony.Carriers.MMSC;\nimport static android.provider.Telephony.Carriers.MMSPORT;\nimport static android.provider.Telephony.Carriers.MMSPROXY;\nimport static android.provider.Telephony.Carriers.MNC;\nimport static android.provider.Telephony.Carriers.MODEM_PERSIST;\nimport static android.provider.Telephony.Carriers.MTU;\nimport static android.provider.Telephony.Carriers.MTU_V4;\nimport static android.provider.Telephony.Carriers.MTU_V6;\nimport static android.provider.Telephony.Carriers.MVNO_MATCH_DATA;\nimport static android.provider.Telephony.Carriers.MVNO_TYPE;\nimport static android.provider.Telephony.Carriers.NAME;\nimport static android.provider.Telephony.Carriers.NETWORK_TYPE_BITMASK;\nimport static android.provider.Telephony.Carriers.NO_APN_SET_ID;\nimport static android.provider.Telephony.Carriers.NUMERIC;\nimport static android.provider.Telephony.Carriers.OWNED_BY;\nimport static android.provider.Telephony.Carriers.OWNED_BY_DPC;\nimport static android.provider.Telephony.Carriers.OWNED_BY_OTHERS;\nimport static android.provider.Telephony.Carriers.PASSWORD;\nimport static android.provider.Telephony.Carriers.PORT;\nimport static android.provider.Telephony.Carriers.PROFILE_ID;\nimport static android.provider.Telephony.Carriers.PROTOCOL;\nimport static android.provider.Telephony.Carriers.PROXY;\nimport static android.provider.Telephony.Carriers.ROAMING_PROTOCOL;\nimport static android.provider.Telephony.Carriers.SERVER;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT;\nimport static android.provider.Telephony.Carriers.SKIP_464XLAT_DEFAULT;\nimport static android.provider.Telephony.Carriers.SUBSCRIPTION_ID;\nimport static android.provider.Telephony.Carriers.TIME_LIMIT_FOR_MAX_CONNECTIONS;\nimport static android.provider.Telephony.Carriers.TYPE;\nimport static android.provider.Telephony.Carriers.UNEDITED;\nimport static android.provider.Telephony.Carriers.USER;\nimport static android.provider.Telephony.Carriers.USER_DELETED;\nimport static android.provider.Telephony.Carriers.USER_DELETED_BUT_PRESENT_IN_XML;\nimport static android.provider.Telephony.Carriers.USER_EDITABLE;\nimport static android.provider.Telephony.Carriers.USER_EDITED;\nimport static android.provider.Telephony.Carriers.USER_VISIBLE;\nimport static android.provider.Telephony.Carriers.WAIT_TIME_RETRY;\nimport static android.provider.Telephony.Carriers._ID;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.compat.CompatChanges;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.content.res.Resources;\nimport android.content.res.XmlResourceParser;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.os.PersistableBundle;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.provider.Telephony;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.TelephonyProtoEnums;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.telephony.PhoneFactory;\nimport com.android.internal.telephony.TelephonyStatsLog;\nimport com.android.internal.util.XmlUtils;\nimport android.service.carrier.IApnSourceService;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.Integer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CRC32;\n\npublic class TelephonyProvider extends ContentProvider\n{\n    private static final String DATABASE_NAME = \"telephony.db\";\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n    private static final boolean DBG = true;\n    private static final boolean VDBG = false; // STOPSHIP if true\n\n    private static final int DATABASE_VERSION = 57 << 16;\n    private static final int URL_UNKNOWN = 0;\n    private static final int URL_TELEPHONY = 1;\n    private static final int URL_CURRENT = 2;\n    private static final int URL_ID = 3;\n    private static final int URL_RESTOREAPN = 4;\n    private static final int URL_PREFERAPN = 5;\n    private static final int URL_PREFERAPN_NO_UPDATE = 6;\n    private static final int URL_SIMINFO = 7;\n    private static final int URL_TELEPHONY_USING_SUBID = 8;\n    private static final int URL_CURRENT_USING_SUBID = 9;\n    private static final int URL_RESTOREAPN_USING_SUBID = 10;\n    private static final int URL_PREFERAPN_USING_SUBID = 11;\n    private static final int URL_PREFERAPN_NO_UPDATE_USING_SUBID = 12;\n    private static final int URL_SIMINFO_USING_SUBID = 13;\n    private static final int URL_UPDATE_DB = 14;\n    private static final int URL_DELETE = 15;\n    private static final int URL_DPC = 16;\n    private static final int URL_DPC_ID = 17;\n    private static final int URL_FILTERED = 18;\n    private static final int URL_FILTERED_ID = 19;\n    private static final int URL_ENFORCE_MANAGED = 20;\n    // URL_PREFERAPNSET and URL_PREFERAPNSET_USING_SUBID return all APNs for the current\n    // carrier which have an apn_set_id equal to the preferred APN\n    // (if no preferred APN, or preferred APN has no set id, the query will return null)\n    private static final int URL_PREFERAPNSET = 21;\n    private static final int URL_PREFERAPNSET_USING_SUBID = 22;\n    private static final int URL_SIM_APN_LIST = 23;\n    private static final int URL_SIM_APN_LIST_ID = 24;\n    private static final int URL_FILTERED_USING_SUBID = 25;\n    private static final int URL_SIM_APN_LIST_FILTERED = 26;\n    private static final int URL_SIM_APN_LIST_FILTERED_ID = 27;\n    private static final int URL_SIMINFO_SUW_RESTORE = 28;\n    private static final int URL_SIMINFO_SIM_INSERTED_RESTORE = 29;\n\n    /**\n     * Default value for mtu_v4 and mtu_v6 if it's not set. Moved from PhoneConstants.\n     */\n    private static final int UNSPECIFIED_INT = -1;\n\n    private static final String TAG = \"TelephonyProvider\";\n    private static final String CARRIERS_TABLE = \"carriers\";\n    private static final String CARRIERS_TABLE_TMP = \"carriers_tmp\";\n    private static final String SIMINFO_TABLE = \"siminfo\";\n    private static final String SIMINFO_TABLE_TMP = \"siminfo_tmp\";\n\n    private static final String PREF_FILE_APN = \"preferred-apn\";\n    private static final String COLUMN_APN_ID = \"apn_id\";\n    private static final String EXPLICIT_SET_CALLED = \"explicit_set_called\";\n\n    private static final String PREF_FILE_FULL_APN = \"preferred-full-apn\";\n    private static final String DB_VERSION_KEY = \"version\";\n\n    private static final String BUILD_ID_FILE = \"build-id\";\n    private static final String RO_BUILD_ID = \"ro_build_id\";\n\n    private static final String ENFORCED_FILE = \"dpc-apn-enforced\";\n    private static final String ENFORCED_KEY = \"enforced\";\n\n    private static final String PREF_FILE = \"telephonyprovider\";\n    private static final String APN_CONF_CHECKSUM = \"apn_conf_checksum\";\n\n    private static final String PARTNER_APNS_PATH = \"etc/apns-conf.xml\";\n    private static final String OEM_APNS_PATH = \"telephony/apns-conf.xml\";\n    private static final String OTA_UPDATED_APNS_PATH = \"misc/apns/apns-conf.xml\";\n    private static final String OLD_APNS_PATH = \"etc/old-apns-conf.xml\";\n\n    private static final String DEFAULT_PROTOCOL = \"IP\";\n    private static final String DEFAULT_ROAMING_PROTOCOL = \"IP\";\n\n    private static final UriMatcher s_urlMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    private static final ContentValues s_currentNullMap;\n    private static final ContentValues s_currentSetMap;\n\n    private static final String IS_UNEDITED = EDITED_STATUS + \"=\" + UNEDITED;\n    private static final String IS_EDITED = EDITED_STATUS + \"!=\" + UNEDITED;\n    private static final String IS_USER_EDITED = EDITED_STATUS + \"=\" + USER_EDITED;\n    private static final String IS_NOT_USER_EDITED = EDITED_STATUS + \"!=\" + USER_EDITED;\n    private static final String IS_USER_DELETED = EDITED_STATUS + \"=\" + USER_DELETED;\n    private static final String IS_NOT_USER_DELETED = EDITED_STATUS + \"!=\" + USER_DELETED;\n    private static final String IS_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + USER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_CARRIER_EDITED = EDITED_STATUS + \"=\" + CARRIER_EDITED;\n    private static final String IS_NOT_CARRIER_EDITED = EDITED_STATUS + \"!=\" + CARRIER_EDITED;\n    private static final String IS_CARRIER_DELETED = EDITED_STATUS + \"=\" + CARRIER_DELETED;\n    private static final String IS_NOT_CARRIER_DELETED = EDITED_STATUS + \"!=\" + CARRIER_DELETED;\n    private static final String IS_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML =\n            EDITED_STATUS + \"!=\" + CARRIER_DELETED_BUT_PRESENT_IN_XML;\n    private static final String IS_OWNED_BY_DPC = OWNED_BY + \"=\" + OWNED_BY_DPC;\n    private static final String IS_NOT_OWNED_BY_DPC = OWNED_BY + \"!=\" + OWNED_BY_DPC;\n\n    private static final String ORDER_BY_SUB_ID =\n            Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \" ASC\";\n\n    @VisibleForTesting\n    static final String BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE = \"sim_specific_settings_file\";\n    // Holds names and value types of SimInfoDb columns to backup.\n    private static final Map<String, Integer> SIM_INFO_COLUMNS_TO_BACKUP = new HashMap();\n    private static final String KEY_SIMINFO_DB_ROW_PREFIX = \"KEY_SIMINFO_DB_ROW_\";\n    private static final int DEFAULT_INT_COLUMN_VALUE = -111;\n    private static final String DEFAULT_STRING_COLUMN_VALUE = \"DEFAULT_STRING_COLUMN_VALUE\";\n    private static final String SIM_INSERTED_RESTORE_URI_SUFFIX = \"sim_inserted_restore\";\n    @VisibleForTesting\n    static final String KEY_BACKUP_DATA_FORMAT_VERSION = \"KEY_BACKUP_DATA_FORMAT_VERSION\";\n    @VisibleForTesting\n    static final String KEY_PREVIOUSLY_RESTORED_SUB_IDS = \"KEY_PREVIOUSLY_RESTORED_SUB_IDS\";\n\n    private static final int INVALID_APN_ID = -1;\n    private static final List<String> CARRIERS_UNIQUE_FIELDS = new ArrayList<String>();\n    private static final Set<String> CARRIERS_BOOLEAN_FIELDS = new HashSet<String>();\n    private static final Map<String, String> CARRIERS_UNIQUE_FIELDS_DEFAULTS = new HashMap();\n\n    @VisibleForTesting\n    static Boolean s_apnSourceServiceExists;\n\n    protected final Object mLock = new Object();\n    @GuardedBy(\"mLock\")\n    private IApnSourceService mIApnSourceService;\n    private Injector mInjector;\n\n    private boolean mManagedApnEnforced;\n\n    /**\n     * Mobile country codes where there is a high likelyhood that the MNC has 3 digits\n     * and need one more prefix zero to set correct mobile network code value.\n     *\n     * Please note! The best solution is to add the MCCMNC combo to carrier id\n     * carrier_list, this is just a best effort.\n     */\n    private static final String[] COUNTRY_MCC_WITH_THREE_DIGIT_MNC = {\n            \"302\" // Canada\n           ,\"310\" // Guam, USA\n           ,\"311\" // USA\n           ,\"312\" // USA\n           ,\"313\" // USA\n           ,\"316\" // USA\n           ,\"334\" // Mexico\n           ,\"338\" // Bermuda, Jamaica\n           ,\"342\" // Barbados\n           ,\"344\" // Antigua and Barbuda\n           ,\"346\" // Cayman Islands\n           ,\"348\" // British Virgin Islands\n           ,\"356\" // Saint Kitts and Nevis\n           ,\"358\" // Saint Lucia\n           ,\"360\" // Saint Vincent and the Grenadines\n           ,\"365\" // Anguilla\n           ,\"366\" // Dominica\n           ,\"376\" // Turks and Caicos Islands\n           ,\"405\" // India\n           ,\"708\" // Honduras\n           ,\"722\" // Argentina\n           ,\"732\" // Colombia\n           ,\"738\" // Guyana\n           ,\"750\" // Falkland Islands\n            };\n\n    /**\n     * Available radio technologies for GSM, UMTS and CDMA.\n     * Duplicates the constants from hardware/radio/include/ril.h\n     * This should only be used by agents working with the ril.  Others\n     * should use the equivalent TelephonyManager.NETWORK_TYPE_*\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_UNKNOWN = 0;\n    private static final int RIL_RADIO_TECHNOLOGY_GPRS = 1;\n    private static final int RIL_RADIO_TECHNOLOGY_EDGE = 2;\n    private static final int RIL_RADIO_TECHNOLOGY_UMTS = 3;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95A = 4;\n    private static final int RIL_RADIO_TECHNOLOGY_IS95B = 5;\n    private static final int RIL_RADIO_TECHNOLOGY_1xRTT = 6;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_0 = 7;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_A = 8;\n    private static final int RIL_RADIO_TECHNOLOGY_HSDPA = 9;\n    private static final int RIL_RADIO_TECHNOLOGY_HSUPA = 10;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPA = 11;\n    private static final int RIL_RADIO_TECHNOLOGY_EVDO_B = 12;\n    private static final int RIL_RADIO_TECHNOLOGY_EHRPD = 13;\n    private static final int RIL_RADIO_TECHNOLOGY_LTE = 14;\n    private static final int RIL_RADIO_TECHNOLOGY_HSPAP = 15;\n\n    /**\n     * GSM radio technology only supports voice. It does not support data.\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_GSM = 16;\n    private static final int RIL_RADIO_TECHNOLOGY_TD_SCDMA = 17;\n\n    /**\n     * IWLAN\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;\n\n    /**\n     * LTE_CA\n     */\n    private static final int RIL_RADIO_TECHNOLOGY_LTE_CA = 19;\n\n    /**\n     * NR(New Radio) 5G.\n     */\n    private static final int  RIL_RADIO_TECHNOLOGY_NR = 20;\n\n    /**\n     * The number of the radio technologies.\n     */\n    private static final int NEXT_RIL_RADIO_TECHNOLOGY = 21;\n\n    private static final Map<String, Integer> MVNO_TYPE_STRING_MAP;\n\n    static {\n        // Columns not included in UNIQUE constraint: name, current, edited, user, server, password,\n        // authtype, type, protocol, roaming_protocol, sub_id, modem_cognitive, max_conns,\n        // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n        // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(NUMERIC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MCC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MNC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPROXY, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSPORT, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MMSC, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ENABLED, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(BEARER, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_TYPE, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(MVNO_MATCH_DATA, \"\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROFILE_ID, \"0\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(ROAMING_PROTOCOL, \"IP\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(USER_EDITABLE, \"1\");\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(OWNED_BY, String.valueOf(OWNED_BY_OTHERS));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(APN_SET_ID, String.valueOf(NO_APN_SET_ID));\n        CARRIERS_UNIQUE_FIELDS_DEFAULTS.put(CARRIER_ID,\n                String.valueOf(TelephonyManager.UNKNOWN_CARRIER_ID));\n\n        CARRIERS_UNIQUE_FIELDS.addAll(CARRIERS_UNIQUE_FIELDS_DEFAULTS.keySet());\n\n        // SQLite databases store bools as ints but the ContentValues objects passed in through\n        // queries use bools. As a result there is some special handling of boolean fields within\n        // the TelephonyProvider.\n        CARRIERS_BOOLEAN_FIELDS.add(CARRIER_ENABLED);\n        CARRIERS_BOOLEAN_FIELDS.add(MODEM_PERSIST);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_VISIBLE);\n        CARRIERS_BOOLEAN_FIELDS.add(USER_EDITABLE);\n\n        MVNO_TYPE_STRING_MAP = new ArrayMap<String, Integer>();\n        MVNO_TYPE_STRING_MAP.put(\"spn\", ApnSetting.MVNO_TYPE_SPN);\n        MVNO_TYPE_STRING_MAP.put(\"imsi\", ApnSetting.MVNO_TYPE_IMSI);\n        MVNO_TYPE_STRING_MAP.put(\"gid\", ApnSetting.MVNO_TYPE_GID);\n        MVNO_TYPE_STRING_MAP.put(\"iccid\", ApnSetting.MVNO_TYPE_ICCID);\n\n        // To B&R a new config, simply add the column name and its appropriate value type to\n        // SIM_INFO_COLUMNS_TO_BACKUP. To no longer B&R a column, simply remove it from\n        // SIM_INFO_COLUMNS_TO_BACKUP. For both cases, add appropriate versioning logic in\n        // convertBackedUpDataToContentValues(ContentValues contenValues)\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ICC_ID, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NUMBER, Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_CARRIER_ID, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_VT_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                Cursor.FIELD_TYPE_STRING);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED, Cursor.FIELD_TYPE_INTEGER);\n        SIM_INFO_COLUMNS_TO_BACKUP.put(\n                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                Cursor.FIELD_TYPE_INTEGER);\n    }\n\n    @VisibleForTesting\n    public static String getStringForCarrierTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName +\n                \"(_id INTEGER PRIMARY KEY,\" +\n                NAME + \" TEXT DEFAULT '',\" +\n                NUMERIC + \" TEXT DEFAULT '',\" +\n                MCC + \" TEXT DEFAULT '',\" +\n                MNC + \" TEXT DEFAULT '',\" +\n                CARRIER_ID + \" INTEGER DEFAULT \" + TelephonyManager.UNKNOWN_CARRIER_ID  + \",\" +\n                APN + \" TEXT DEFAULT '',\" +\n                USER + \" TEXT DEFAULT '',\" +\n                SERVER + \" TEXT DEFAULT '',\" +\n                PASSWORD + \" TEXT DEFAULT '',\" +\n                PROXY + \" TEXT DEFAULT '',\" +\n                PORT + \" TEXT DEFAULT '',\" +\n                MMSPROXY + \" TEXT DEFAULT '',\" +\n                MMSPORT + \" TEXT DEFAULT '',\" +\n                MMSC + \" TEXT DEFAULT '',\" +\n                AUTH_TYPE + \" INTEGER DEFAULT -1,\" +\n                TYPE + \" TEXT DEFAULT '',\" +\n                CURRENT + \" INTEGER,\" +\n                PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_PROTOCOL + \",\" +\n                ROAMING_PROTOCOL + \" TEXT DEFAULT \" + DEFAULT_ROAMING_PROTOCOL + \",\" +\n                CARRIER_ENABLED + \" BOOLEAN DEFAULT 1,\" + // SQLite databases store bools as ints\n                BEARER + \" INTEGER DEFAULT 0,\" +\n                BEARER_BITMASK + \" INTEGER DEFAULT 0,\" +\n                NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0,\" +\n                MVNO_TYPE + \" TEXT DEFAULT '',\" +\n                MVNO_MATCH_DATA + \" TEXT DEFAULT '',\" +\n                SUBSCRIPTION_ID + \" INTEGER DEFAULT \" +\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID + \",\" +\n                PROFILE_ID + \" INTEGER DEFAULT 0,\" +\n                MODEM_PERSIST + \" BOOLEAN DEFAULT 0,\" +\n                MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                WAIT_TIME_RETRY + \" INTEGER DEFAULT 0,\" +\n                TIME_LIMIT_FOR_MAX_CONNECTIONS + \" INTEGER DEFAULT 0,\" +\n                MTU + \" INTEGER DEFAULT 0,\" +\n                MTU_V4 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \",\" +\n                MTU_V6 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \",\" +\n                EDITED_STATUS + \" INTEGER DEFAULT \" + UNEDITED + \",\" +\n                USER_VISIBLE + \" BOOLEAN DEFAULT 1,\" +\n                USER_EDITABLE + \" BOOLEAN DEFAULT 1,\" +\n                OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \",\" +\n                APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \",\" +\n                SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \",\" +\n                ALWAYS_ON + \" INTEGER DEFAULT 0,\" +\n                // Uniqueness collisions are used to trigger merge code so if a field is listed\n                // here it means we will accept both (user edited + new apn_conf definition)\n                // Columns not included in UNIQUE constraint: name, current, edited,\n                // user, server, password, authtype, type, sub_id, modem_cognitive, max_conns,\n                // wait_time, max_conns_time, mtu, mtu_v4, mtu_v6, bearer_bitmask, user_visible,\n                // network_type_bitmask, skip_464xlat, lingering_network_type_bitmask, always_on.\n                \"UNIQUE (\" + TextUtils.join(\", \", CARRIERS_UNIQUE_FIELDS) + \"));\";\n    }\n\n    @VisibleForTesting\n    public static String getStringForSimInfoTableCreation(String tableName) {\n        return \"CREATE TABLE \" + tableName + \"(\"\n                + Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID\n                + \" INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                + Telephony.SimInfo.COLUMN_ICC_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_NOT_INSERTED + \",\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NAME_SOURCE\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.NAME_SOURCE_CARRIER_ID + \",\"\n                + Telephony.SimInfo.COLUMN_COLOR + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.COLOR_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_NUMBER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT\n                + \" INTEGER NOT NULL DEFAULT \" + Telephony.SimInfo.DISPLAY_NUMBER_DEFAULT + \",\"\n                + Telephony.SimInfo.COLUMN_DATA_ROAMING\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.DATA_ROAMING_DISABLE + \",\"\n                + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS\n                + \" INTEGER DEFAULT \" + Telephony.SimInfo.SIM_PROVISIONED + \",\"\n                + Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CARD_ID + \" TEXT NOT NULL,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION + \" INTEGER DEFAULT 4,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.PROFILE_CLASS_UNSET + \",\"\n                + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \",\"\n                + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_IMSI + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED + \" INTEGER DEFAULT 1,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES + \" BIGINT DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_RCS_CONFIG + \" BLOB,\"\n                + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS + \" INTEGER DEFAULT 0,\"\n                + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED + \" INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS + \" TEXT,\"\n                + Telephony.SimInfo.COLUMN_PORT_INDEX + \"  INTEGER DEFAULT -1,\"\n                + Telephony.SimInfo.COLUMN_USAGE_SETTING + \" INTEGER DEFAULT \"\n                + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                + \");\";\n    }\n\n    static {\n        s_urlMatcher.addURI(\"telephony\", \"carriers\", URL_TELEPHONY);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current\", URL_CURRENT);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/#\", URL_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore\", URL_RESTOREAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn\", URL_PREFERAPN);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update\", URL_PREFERAPN_NO_UPDATE);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset\", URL_PREFERAPNSET);\n\n        s_urlMatcher.addURI(\"telephony\", \"siminfo\", URL_SIMINFO);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/#\", URL_SIMINFO_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/suw_restore\",\n                URL_SIMINFO_SUW_RESTORE);\n        s_urlMatcher.addURI(\"telephony\", \"siminfo/backup_and_restore/\" +\n                SIM_INSERTED_RESTORE_URI_SUFFIX,\n                URL_SIMINFO_SIM_INSERTED_RESTORE);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/subId/*\", URL_TELEPHONY_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/current/subId/*\", URL_CURRENT_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/restore/subId/*\", URL_RESTOREAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn/subId/*\", URL_PREFERAPN_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapn_no_update/subId/*\",\n                URL_PREFERAPN_NO_UPDATE_USING_SUBID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/preferapnset/subId/*\",\n                URL_PREFERAPNSET_USING_SUBID);\n\n        s_urlMatcher.addURI(\"telephony\", \"carriers/update_db\", URL_UPDATE_DB);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/delete\", URL_DELETE);\n\n        // Only called by DevicePolicyManager to manipulate DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc\", URL_DPC);\n        // Only called by DevicePolicyManager to manipulate a DPC record with certain _ID.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/dpc/#\", URL_DPC_ID);\n        // Only called by Settings app, DcTracker and other telephony components to get APN list\n        // according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered\", URL_FILTERED);\n        // Only called by Settings app, DcTracker and other telephony components to get a\n        // single APN according to whether DPC records are enforced.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/#\", URL_FILTERED_ID);\n        // Used by DcTracker to pass a subId.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/filtered/subId/*\", URL_FILTERED_USING_SUBID);\n\n        // Only Called by DevicePolicyManager to enforce DPC records.\n        s_urlMatcher.addURI(\"telephony\", \"carriers/enforce_managed\", URL_ENFORCE_MANAGED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list\", URL_SIM_APN_LIST);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/#\", URL_SIM_APN_LIST_ID);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered\",\n            URL_SIM_APN_LIST_FILTERED);\n        s_urlMatcher.addURI(\"telephony\", \"carriers/sim_apn_list/filtered/subId/*\",\n                URL_SIM_APN_LIST_FILTERED_ID);\n\n        s_currentNullMap = new ContentValues(1);\n        s_currentNullMap.put(CURRENT, \"0\");\n\n        s_currentSetMap = new ContentValues(1);\n        s_currentSetMap.put(CURRENT, \"1\");\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n    }\n\n    public TelephonyProvider() {\n        this(new Injector());\n    }\n\n    @VisibleForTesting\n    public TelephonyProvider(Injector injector) {\n        mInjector = injector;\n    }\n\n    @VisibleForTesting\n    public static int getVersion(Context context) {\n        if (VDBG) log(\"getVersion:+\");\n        // Get the database version, combining a static schema version and the XML version\n        Resources r = context.getResources();\n        if (r == null) {\n            loge(\"resources=null, return version=\" + Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        }\n        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n        try {\n            XmlUtils.beginDocument(parser, \"apns\");\n            int publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n            int version = DATABASE_VERSION | publicversion;\n            if (VDBG) log(\"getVersion:- version=0x\" + Integer.toHexString(version));\n            return version;\n        } catch (Exception e) {\n            loge(\"Can't get version of APN database\" + e + \" return version=\" +\n                    Integer.toHexString(DATABASE_VERSION));\n            return DATABASE_VERSION;\n        } finally {\n            parser.close();\n        }\n    }\n\n    static public ContentValues setDefaultValue(ContentValues values) {\n        if (!values.containsKey(SUBSCRIPTION_ID)) {\n            int subId = SubscriptionManager.getDefaultSubscriptionId();\n            values.put(SUBSCRIPTION_ID, subId);\n        }\n\n        return values;\n    }\n\n    @VisibleForTesting\n    public class DatabaseHelper extends SQLiteOpenHelper {\n        // Context to access resources with\n        private Context mContext;\n\n        /**\n         * DatabaseHelper helper class for loading apns into a database.\n         *\n         * @param context of the user.\n         */\n        public DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n            setWriteAheadLoggingEnabled(false);\n        }\n\n        @Override\n        public void onCreate(SQLiteDatabase db) {\n            if (DBG) log(\"dbh.onCreate:+ db=\" + db);\n            createSimInfoTable(db, SIMINFO_TABLE);\n            createCarriersTable(db, CARRIERS_TABLE);\n            // if CarrierSettings app is installed, we expect it to do the initializiation instead\n            if (apnSourceServiceExists(mContext)) {\n                log(\"dbh.onCreate: Skipping apply APNs from xml.\");\n            } else {\n                log(\"dbh.onCreate: Apply apns from xml.\");\n                initDatabase(db);\n            }\n            if (DBG) log(\"dbh.onCreate:- db=\" + db);\n        }\n\n        @Override\n        public void onOpen(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.onOpen:+ db=\" + db);\n            try {\n                // Try to access the table and create it if \"no such table\"\n                db.query(SIMINFO_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + SIMINFO_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + SIMINFO_TABLE + \"e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createSimInfoTable(db, SIMINFO_TABLE);\n                }\n            }\n            try {\n                db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n                if (DBG) log(\"dbh.onOpen: ok, queried table=\" + CARRIERS_TABLE);\n            } catch (SQLiteException e) {\n                loge(\"Exception \" + CARRIERS_TABLE + \" e=\" + e);\n                if (e.getMessage().startsWith(\"no such table\")) {\n                    createCarriersTable(db, CARRIERS_TABLE);\n                }\n            }\n            if (VDBG) log(\"dbh.onOpen:- db=\" + db);\n        }\n\n        private void createSimInfoTable(SQLiteDatabase db, String tableName) {\n            if (DBG) log(\"dbh.createSimInfoTable:+ \" + tableName);\n            db.execSQL(getStringForSimInfoTableCreation(tableName));\n            if (DBG) log(\"dbh.createSimInfoTable:-\");\n        }\n\n        private void createCarriersTable(SQLiteDatabase db, String tableName) {\n            // Set up the database schema\n            if (DBG) log(\"dbh.createCarriersTable: \" + tableName);\n            db.execSQL(getStringForCarrierTableCreation(tableName));\n            if (DBG) log(\"dbh.createCarriersTable:-\");\n        }\n\n        private long getChecksum(File file) {\n            CRC32 checkSummer = new CRC32();\n            long checkSum = -1;\n            try (CheckedInputStream cis =\n                new CheckedInputStream(new FileInputStream(file), checkSummer)){\n                byte[] buf = new byte[128];\n                if(cis != null) {\n                    while(cis.read(buf) >= 0) {\n                        // Just read for checksum to get calculated.\n                    }\n                }\n                checkSum = checkSummer.getValue();\n                if (DBG) log(\"Checksum for \" + file.getAbsolutePath() + \" is \" + checkSum);\n            } catch (FileNotFoundException e) {\n                loge(\"FileNotFoundException for \" + file.getAbsolutePath() + \":\" + e);\n            } catch (IOException e) {\n                loge(\"IOException for \" + file.getAbsolutePath() + \":\" + e);\n            }\n\n            // The RRO may have been updated in a firmware upgrade. Add checksum for the\n            // resources to the total checksum so that apns in an RRO update is not missed.\n            try (InputStream inputStream = mContext.getResources().\n                        openRawResource(com.android.internal.R.xml.apns)) {\n                byte[] array = toByteArray(inputStream);\n                checkSummer.reset();\n                checkSummer.update(array);\n                checkSum += checkSummer.getValue();\n                if (DBG) log(\"Checksum after adding resource is \" + checkSummer.getValue());\n            } catch (IOException | Resources.NotFoundException e) {\n                loge(\"Exception when calculating checksum for internal apn resources: \" + e);\n            }\n            return checkSum;\n        }\n\n        private byte[] toByteArray(InputStream input) throws IOException {\n            byte[] buffer = new byte[128];\n            int bytesRead;\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            while ((bytesRead = input.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            return output.toByteArray();\n        }\n\n        private long getApnConfChecksum() {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            return sp.getLong(APN_CONF_CHECKSUM, -1);\n        }\n\n        private void setApnConfChecksum(long checksum) {\n            SharedPreferences sp = mContext.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.putLong(APN_CONF_CHECKSUM, checksum);\n            editor.apply();\n        }\n\n        private File getApnConfFile() {\n            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or \"/system\".\n            File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);\n            File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);\n            File updatedConfFile = new File(Environment.getDataDirectory(), OTA_UPDATED_APNS_PATH);\n            File productConfFile = new File(Environment.getProductDirectory(), PARTNER_APNS_PATH);\n            confFile = pickSecondIfExists(confFile, oemConfFile);\n            confFile = pickSecondIfExists(confFile, productConfFile);\n            confFile = pickSecondIfExists(confFile, updatedConfFile);\n            return confFile;\n        }\n\n        /**\n         * This function computes checksum for the file to be read and compares it against the\n         * last read file. DB needs to be updated only if checksum has changed, or old checksum does\n         * not exist.\n         * @return true if DB should be updated with new conf file, false otherwise\n         */\n        private boolean apnDbUpdateNeeded() {\n            File confFile = getApnConfFile();\n            long newChecksum = getChecksum(confFile);\n            long oldChecksum = getApnConfChecksum();\n            if (DBG) log(\"newChecksum: \" + newChecksum);\n            if (DBG) log(\"oldChecksum: \" + oldChecksum);\n            if (newChecksum == oldChecksum) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        /**\n         *  This function adds APNs from xml file(s) to db. The db may or may not be empty to begin\n         *  with.\n         */\n        private void initDatabase(SQLiteDatabase db) {\n            if (VDBG) log(\"dbh.initDatabase:+ db=\" + db);\n            // Read internal APNS data\n            Resources r = mContext.getResources();\n            int publicversion = -1;\n            if (r != null) {\n                XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);\n                try {\n                    XmlUtils.beginDocument(parser, \"apns\");\n                    publicversion = Integer.parseInt(parser.getAttributeValue(null, \"version\"));\n                    loadApns(db, parser, true);\n                } catch (Exception e) {\n                    loge(\"Got exception while loading APN database.\" + e);\n                } finally {\n                    parser.close();\n                }\n            } else {\n                loge(\"initDatabase: resources=null\");\n            }\n\n            // Read external APNS data (partner-provided)\n            XmlPullParser confparser = null;\n            File confFile = getApnConfFile();\n\n            FileReader confreader = null;\n            if (DBG) log(\"confFile = \" + confFile);\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                // Correctness check. Force internal version and confidential versions to agree\n                int confversion = Integer.parseInt(confparser.getAttributeValue(null, \"version\"));\n                if (publicversion != confversion) {\n                    log(\"initDatabase: throwing exception due to version mismatch\");\n                    throw new IllegalStateException(\"Internal APNS file version doesn't match \"\n                            + confFile.getAbsolutePath());\n                }\n\n                loadApns(db, confparser, false);\n            } catch (FileNotFoundException e) {\n                // It's ok if the file isn't found. It means there isn't a confidential file\n                // Log.e(TAG, \"File not found: '\" + confFile.getAbsolutePath() + \"'\");\n            } catch (Exception e) {\n                loge(\"initDatabase: Exception while parsing '\" + confFile.getAbsolutePath() + \"'\" +\n                        e);\n            } finally {\n                // Get rid of user/carrier deleted entries that are not present in apn xml file.\n                // Those entries have edited value USER_DELETED/CARRIER_DELETED.\n                if (VDBG) {\n                    log(\"initDatabase: deleting USER_DELETED and replacing \"\n                            + \"DELETED_BUT_PRESENT_IN_XML with DELETED\");\n                }\n\n                // Delete USER_DELETED\n                db.delete(CARRIERS_TABLE, IS_USER_DELETED + \" or \" + IS_CARRIER_DELETED, null);\n\n                // Change USER_DELETED_BUT_PRESENT_IN_XML to USER_DELETED\n                ContentValues cv = new ContentValues();\n                cv.put(EDITED_STATUS, USER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_USER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                // Change CARRIER_DELETED_BUT_PRESENT_IN_XML to CARRIER_DELETED\n                cv = new ContentValues();\n                cv.put(EDITED_STATUS, CARRIER_DELETED);\n                db.update(CARRIERS_TABLE, cv, IS_CARRIER_DELETED_BUT_PRESENT_IN_XML, null);\n\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n\n                // Update the stored checksum\n                setApnConfChecksum(getChecksum(confFile));\n            }\n            if (VDBG) log(\"dbh.initDatabase:- db=\" + db);\n\n        }\n\n        private File pickSecondIfExists(File sysApnFile, File altApnFile) {\n            if (altApnFile.exists()) {\n                if (DBG) log(\"Load APNs from \" + altApnFile.getPath() +\n                        \" instead of \" + sysApnFile.getPath());\n                return altApnFile;\n            } else {\n                if (DBG) log(\"Load APNs from \" + sysApnFile.getPath() +\n                        \" instead of \" + altApnFile.getPath());\n                return sysApnFile;\n            }\n        }\n\n        @Override\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n            if (DBG) {\n                log(\"dbh.onUpgrade:+ db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n\n            deletePreferredApnId(mContext);\n\n            if (oldVersion < (5 << 16 | 6)) {\n                // 5 << 16 is the Database version and 6 in the xml version.\n\n                // This change adds a new authtype column to the database.\n                // The auth type column can have 4 values: 0 (None), 1 (PAP), 2 (CHAP)\n                // 3 (PAP or CHAP). To avoid breaking compatibility, with already working\n                // APNs, the unset value (-1) will be used. If the value is -1.\n                // the authentication will default to 0 (if no user / password) is specified\n                // or to 3. Currently, there have been no reported problems with\n                // pre-configured APNs and hence it is set to -1 for them. Similarly,\n                // if the user, has added a new APN, we set the authentication type\n                // to -1.\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN authtype INTEGER DEFAULT -1;\");\n\n                oldVersion = 5 << 16 | 6;\n            }\n            if (oldVersion < (6 << 16 | 6)) {\n                // Add protcol fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN protocol TEXT DEFAULT IP;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN roaming_protocol TEXT DEFAULT IP;\");\n                oldVersion = 6 << 16 | 6;\n            }\n            if (oldVersion < (7 << 16 | 6)) {\n                // Add carrier_enabled, bearer fields to the APN. The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN carrier_enabled BOOLEAN DEFAULT 1;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN bearer INTEGER DEFAULT 0;\");\n                oldVersion = 7 << 16 | 6;\n            }\n            if (oldVersion < (8 << 16 | 6)) {\n                // Add mvno_type, mvno_match_data fields to the APN.\n                // The XML file does not change.\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_type TEXT DEFAULT '';\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mvno_match_data TEXT DEFAULT '';\");\n                oldVersion = 8 << 16 | 6;\n            }\n            if (oldVersion < (9 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN sub_id INTEGER DEFAULT \" +\n                        SubscriptionManager.INVALID_SUBSCRIPTION_ID + \";\");\n                oldVersion = 9 << 16 | 6;\n            }\n            if (oldVersion < (10 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN profile_id INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN modem_cognitive BOOLEAN DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN wait_time INTEGER DEFAULT 0;\");\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN max_conns_time INTEGER DEFAULT 0;\");\n                oldVersion = 10 << 16 | 6;\n            }\n            if (oldVersion < (11 << 16 | 6)) {\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE +\n                        \" ADD COLUMN mtu INTEGER DEFAULT 0;\");\n                oldVersion = 11 << 16 | 6;\n            }\n            if (oldVersion < (12 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 12 << 16 | 6;\n            }\n            if (oldVersion < (13 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_CARRIER_NAME + \" TEXT DEFAULT '';\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 13 << 16 | 6;\n            }\n            if (oldVersion < (14 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for next version and that takes care of updates for this version as well.\n                // This version added a new column user_edited to carriers db.\n            }\n            if (oldVersion < (15 << 16 | 6)) {\n                // Most devices should be upgrading from version 13. On upgrade new db will be\n                // populated from the xml included in OTA but user and carrier edited/added entries\n                // need to be preserved. This new version also adds new columns EDITED and\n                // BEARER_BITMASK to the table. Upgrade steps from version 13 are:\n                // 1. preserve user and carrier added/edited APNs (by comparing against\n                // old-apns-conf.xml included in OTA) - done in preserveUserAndCarrierApns()\n                // 2. add new columns EDITED and BEARER_BITMASK (create a new table for that) - done\n                // in createCarriersTable()\n                // 3. copy over preserved APNs from old table to new table - done in\n                // copyPreservedApnsToNewTable()\n                // The only exception if upgrading from version 14 is that EDITED field is already\n                // present (but is called USER_EDITED)\n                /*********************************************************************************\n                 * IMPORTANT NOTE: SINCE CARRIERS TABLE IS RECREATED HERE, IT WILL BE THE LATEST\n                 * VERSION AFTER THIS. AS A RESULT ANY SUBSEQUENT UPDATES TO THE TABLE WILL FAIL\n                 * (DUE TO COLUMN-ALREADY-EXISTS KIND OF EXCEPTION). ALL SUBSEQUENT UPDATES SHOULD\n                 * HANDLE THAT GRACEFULLY.\n                 *********************************************************************************/\n                Cursor c;\n                String[] proj = {\"_id\"};\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                }\n\n                // Compare db with old apns xml file so that any user or carrier edited/added\n                // entries can be preserved across upgrade\n                preserveUserAndCarrierApns(db);\n\n                c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n                if (VDBG) {\n                    log(\"dbh.onUpgrade:- after preserveUserAndCarrierApns() total number of \" +\n                            \"rows: \" + ((c == null) ? 0 : c.getCount()));\n                }\n\n                createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n                copyPreservedApnsToNewTable(db, c);\n                c.close();\n\n                db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n                db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE +\n                        \";\");\n\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_UNEDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_UNEDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                    c = db.query(CARRIERS_TABLE, proj, IS_EDITED, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \" + IS_EDITED +\n                            \": \" + c.getCount());\n                    c.close();\n                }\n\n                oldVersion = 15 << 16 | 6;\n            }\n            if (oldVersion < (16 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    // These columns may already be present in which case execSQL will throw an\n                    // exception\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT\n                            + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_AMBER_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION\n                            + \" INTEGER DEFAULT 4;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL\n                            + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT + \" INTEGER DEFAULT 1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 16 << 16 | 6;\n            }\n            if (oldVersion < (17 << 16 | 6)) {\n                Cursor c = null;\n                try {\n                    c = db.query(CARRIERS_TABLE, null, null, null, null, null, null,\n                            String.valueOf(1));\n                    if (c == null || c.getColumnIndex(USER_VISIBLE) == -1) {\n                        db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                                USER_VISIBLE + \" BOOLEAN DEFAULT 1;\");\n                    } else {\n                        if (DBG) {\n                            log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade.  Column \" +\n                                    USER_VISIBLE + \" already exists.\");\n                        }\n                    }\n                } finally {\n                    if (c != null) {\n                        c.close();\n                    }\n                }\n                oldVersion = 17 << 16 | 6;\n            }\n            if (oldVersion < (18 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.SIM_PROVISIONED + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 18 << 16 | 6;\n            }\n            if (oldVersion < (19 << 16 | 6)) {\n                // Do nothing. This is to avoid recreating table twice. Table is anyway recreated\n                // for version 24 and that takes care of updates for this version as well.\n                // This version added more fields protocol and roaming protocol to the primary key.\n            }\n            if (oldVersion < (20 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_EMBEDDED + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES + \" BLOB;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_IS_REMOVABLE + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 20 << 16 | 6;\n            }\n            if (oldVersion < (21 << 16 | 6)) {\n                try {\n                    // Try to update the carriers table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            USER_EDITABLE + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    // This is possible if the column already exists which may be the case if the\n                    // table was just created as part of upgrade to version 19\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 21 << 16 | 6;\n            }\n            if (oldVersion < (22 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VT_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE + \" INTEGER DEFAULT -1;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 22 << 16 | 6;\n            }\n            if (oldVersion < (23 << 16 | 6)) {\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            OWNED_BY + \" INTEGER DEFAULT \" + OWNED_BY_OTHERS + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 23 << 16 | 6;\n            }\n            if (oldVersion < (24 << 16 | 6)) {\n                Cursor c = null;\n                String[] proj = {\"_id\"};\n                recreateDB(db, proj, /* version */24);\n                if (VDBG) {\n                    c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(\n                            CARRIERS_TABLE, proj, NETWORK_TYPE_BITMASK, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + NETWORK_TYPE_BITMASK + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 24 << 16 | 6;\n            }\n            if (oldVersion < (25 << 16 | 6)) {\n                // Add a new column SubscriptionManager.CARD_ID into the database and set the value\n                // to be the same as the existing column SubscriptionManager.ICC_ID. In order to do\n                // this, we need to first make a copy of the existing SIMINFO_TABLE, set the value\n                // of the new column SubscriptionManager.CARD_ID, and replace the SIMINFO_TABLE with\n                // the new table.\n                Cursor c = null;\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID};\n                recreateSimInfoDB(c, db, proj);\n                if (VDBG) {\n                    c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading \" + SIMINFO_TABLE\n                            + \" total number of rows: \" + c.getCount());\n                    c.close();\n                    c = db.query(SIMINFO_TABLE, proj, Telephony.SimInfo.COLUMN_CARD_ID\n                                    + \" IS NOT NULL\", null, null, null, null);\n                    log(\"dbh.onUpgrade:- after upgrading total number of rows with \"\n                            + Telephony.SimInfo.COLUMN_CARD_ID + \": \" + c.getCount());\n                    c.close();\n                }\n                oldVersion = 25 << 16 | 6;\n            }\n            if (oldVersion < (26 << 16 | 6)) {\n                // Add a new column Carriers.APN_SET_ID into the database and set the value to\n                // Carriers.NO_SET_SET by default.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            APN_SET_ID + \" INTEGER DEFAULT \" + NO_APN_SET_ID + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 26 << 16 | 6;\n            }\n\n            if (oldVersion < (27 << 16 | 6)) {\n                // Add the new MCC_STRING and MNC_STRING columns into the subscription table,\n                // and attempt to populate them.\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MCC_STRING + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_MNC_STRING + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \" The table will get created in onOpen.\");\n                    }\n                }\n                // Migrate the old integer values over to strings\n                String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_MCC, Telephony.SimInfo.COLUMN_MNC};\n                try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                    while (c.moveToNext()) {\n                        fillInMccMncStringAtCursor(mContext, db, c);\n                    }\n                }\n                oldVersion = 27 << 16 | 6;\n            }\n\n            if (oldVersion < (28 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_OPPORTUNISTIC + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 28 << 16 | 6;\n            }\n\n            if (oldVersion < (29 << 16 | 6)) {\n                try {\n                    // Add a new column Telephony.CARRIER_ID into the database and add UNIQUE\n                    // constraint into table. However, sqlite cannot add constraints to an existing\n                    // table, so recreate the table.\n                    String[] proj = {\"_id\"};\n                    recreateDB(db, proj,  /* version */29);\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 29 << 16 | 6;\n            }\n\n            if (oldVersion < (30 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_GROUP_UUID + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 30 << 16 | 6;\n            }\n\n            if (oldVersion < (31 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IS_METERED + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 31 << 16 | 6;\n            }\n\n            if (oldVersion < (32 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 32 << 16 | 6;\n            }\n\n            if (oldVersion < (33 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CARRIER_ID + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 33 << 16 | 6;\n            }\n\n            if (oldVersion < (34 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_PROFILE_CLASS + \" INTEGER DEFAULT \" +\n                            Telephony.SimInfo.PROFILE_CLASS_UNSET + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 34 << 16 | 6;\n            }\n\n            if (oldVersion < (35 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                        + Telephony.SimInfo.COLUMN_SUBSCRIPTION_TYPE + \" INTEGER DEFAULT \"\n                        + Telephony.SimInfo.SUBSCRIPTION_TYPE_LOCAL_SIM + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                            \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 35 << 16 | 6;\n            }\n\n            if (oldVersion < (36 << 16 | 6)) {\n                // Add a new column Carriers.SKIP_464XLAT into the database and set the value to\n                // SKIP_464XLAT_DEFAULT.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \" +\n                            SKIP_464XLAT + \" INTEGER DEFAULT \" + SKIP_464XLAT_DEFAULT + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + CARRIERS_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 36 << 16 | 6;\n            }\n\n            if (oldVersion < (37 << 16 | 6)) {\n                // Add new columns Telephony.SimInfo.EHPLMNS and Telephony.SimInfo.HPLMNS into\n                // the database.\n                try {\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_EHPLMNS + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE +\n                            \" ADD COLUMN \" + Telephony.SimInfo.COLUMN_HPLMNS + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade for ehplmns. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 37 << 16 | 6;\n            }\n\n            if (oldVersion < (39 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_GROUP_OWNER + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 39 << 16 | 6;\n            }\n\n            if (oldVersion < (40 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_DATA_ENABLED_OVERRIDE_RULES + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 40 << 16 | 6;\n            }\n\n            if (oldVersion < (41 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMSI + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 41 << 16 | 6;\n            }\n\n            if (oldVersion < (42 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \" +\n                            Telephony.SimInfo.COLUMN_ACCESS_RULES_FROM_CARRIER_CONFIGS + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n            }\n\n            if (oldVersion < (43 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_UICC_APPLICATIONS_ENABLED\n                            + \" INTEGER DEFAULT 1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 43 << 16 | 6;\n            }\n\n            if (oldVersion < (44 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES\n                            + \" BIGINT DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 44 << 16 | 6;\n            }\n\n            if (oldVersion < (45 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 45 << 16 | 6;\n            }\n\n            if (oldVersion < (46 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 46 << 16 | 6;\n            }\n\n            if (oldVersion < (47 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_RCS_CONFIG\n                            + \" BLOB;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 47 << 16 | 6;\n            }\n\n            if (oldVersion < (48 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                try {\n                    // Migrate the old Long values over to String\n                    String[] proj = {Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                            Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES};\n                    try (Cursor c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null)) {\n                        while (c.moveToNext()) {\n                            fillInAllowedNetworkTypesStringAtCursor(db, c);\n                        }\n                    }\n\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"can't migrate value from COLUMN_ALLOWED_NETWORK_TYPES to \"\n                                + \"COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON\");\n                    }\n                }\n                oldVersion = 48 << 16 | 6;\n            }\n\n            if (oldVersion < (49 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing column. \");\n                    }\n                }\n            }\n\n            if (oldVersion < (50 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS\n                            + \" INTEGER DEFAULT 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 50 << 16 | 6;\n            }\n\n            if (oldVersion < (51 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALERT TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 51 << 16 | 6;\n            }\n\n            if (oldVersion < (52 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 52 << 16 | 6;\n            }\n\n            if (oldVersion < (53 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. Fix typo error in version 51.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add d2d status sharing contacts. \");\n                    }\n                }\n                oldVersion = 53 << 16 | 6;\n            }\n\n            if (oldVersion < (54 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table with new columns.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_CARRIER\n                            + \" TEXT;\");\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PHONE_NUMBER_SOURCE_IMS\n                            + \" TEXT;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + SIMINFO_TABLE\n                                + \" to add phone numbers. \");\n                    }\n                }\n                oldVersion = 54 << 16 | 6;\n            }\n\n            if (oldVersion < (55 << 16 | 6)) {\n                try {\n                    // Try to add new fields LINGERING_NETWORK_TYPE_BITMASK, ALWAYS_ON,\n                    // MTU_V4, and MTU_V6\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + LINGERING_NETWORK_TYPE_BITMASK + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + ALWAYS_ON + \" INTEGER DEFAULT 0;\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V4 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \";\");\n                    db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE + \" ADD COLUMN \"\n                            + MTU_V6 + \" INTEGER DEFAULT \" + UNSPECIFIED_INT + \";\");\n                    // Populate MTU_V4 with MTU values, using default value -1 instead of 0\n                    db.execSQL(\"UPDATE \" + CARRIERS_TABLE + \" SET \" + MTU_V4 + \" = \"\n                            + MTU + \" WHERE \" + MTU + \" != 0;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to update \" + CARRIERS_TABLE\n                                + \" to add lingering network type bitmask, always on flag,\"\n                                + \" and MTU v4 and v6 values.\");\n                    }\n                }\n                oldVersion = 55 << 16 | 6;\n            }\n\n            if (oldVersion < (56 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_PORT_INDEX\n                            + \" INTEGER DEFAULT -1;\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade skipping \" + SIMINFO_TABLE + \" upgrade. \" +\n                                \"The table will get created in onOpen.\");\n                    }\n                }\n                oldVersion = 56 << 16 | 6;\n            }\n\n            if (oldVersion < (57 << 16 | 6)) {\n                try {\n                    // Try to update the siminfo table. It might not be there.\n                    db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE + \" ADD COLUMN \"\n                            + Telephony.SimInfo.COLUMN_USAGE_SETTING\n                            + \" INTEGER DEFAULT \" + SubscriptionManager.USAGE_SETTING_UNKNOWN\n                            + \";\");\n                } catch (SQLiteException e) {\n                    if (DBG) {\n                        log(\"onUpgrade failed to updated \" + SIMINFO_TABLE\n                                + \" to add preferred usage setting\");\n                    }\n                }\n                oldVersion = 57 << 16 | 6;\n            }\n\n            if (DBG) {\n                log(\"dbh.onUpgrade:- db=\" + db + \" oldV=\" + oldVersion + \" newV=\" + newVersion);\n            }\n            // when adding fields to onUpgrade, also add a unit test to TelephonyDatabaseHelperTest\n            // and update the DATABASE_VERSION field and add a column in copyAllApnValues\n        }\n\n        private void recreateSimInfoDB(Cursor c, SQLiteDatabase db, String[] proj) {\n            if (VDBG) {\n                c = db.query(SIMINFO_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:+ before upgrading \" + SIMINFO_TABLE +\n                        \" total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            // Sort in ascending order by subscription id to make sure the rows do not get flipped\n            // during the query and added in the new sim info table in another order (sub id is\n            // stored in settings between migrations).\n            c = db.query(SIMINFO_TABLE, null, null, null, null, null, ORDER_BY_SUB_ID);\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE_TMP);\n\n            createSimInfoTable(db, SIMINFO_TABLE_TMP);\n\n            copySimInfoDataToTmpTable(db, c);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + SIMINFO_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + SIMINFO_TABLE_TMP + \" rename to \" + SIMINFO_TABLE + \";\");\n\n        }\n\n        private void copySimInfoDataToTmpTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from SIMINFO_TABLE to SIMINFO_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copySimInfoValuesV24(cv, c);\n                    // The card ID is supposed to be the ICCID of the profile for UICC card, and\n                    // the EID of the card for eUICC card. Since EID is unknown for old entries in\n                    // SIMINFO_TABLE, we use ICCID as the card ID for all the old entries while\n                    // upgrading the SIMINFO_TABLE. In UiccController, both the card ID and ICCID\n                    // will be checked when user queries the slot information using the card ID\n                    // from the database.\n                    getCardIdfromIccid(cv, c);\n                    try {\n                        db.insert(SIMINFO_TABLE_TMP, null, cv);\n                        if (VDBG) {\n                            log(\"dbh.copySimInfoDataToTmpTable: db.insert returned >= 0; \" +\n                                \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copySimInfoDataToTmpTable insertWithOnConflict exception \" +\n                                e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copySimInfoValuesV24(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ICC_ID);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CARRIER_NAME);\n            getStringValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NUMBER);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_SLOT_INDEX);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_NAME_SOURCE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_COLOR);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DISPLAY_NUMBER_FORMAT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_DATA_ROAMING);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MCC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_MNC);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_SIM_PROVISIONING_STATUS);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_EMBEDDED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_IS_REMOVABLE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EXTREME_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_SEVERE_THREAT_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_AMBER_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_EMERGENCY_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SOUND_DURATION);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_REMINDER_INTERVAL);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_VIBRATE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ALERT_SPEECH);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_ETWS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CHANNEL_50_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_CMAS_TEST_ALERT);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_CB_OPT_OUT_DIALOG);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_VT_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE);\n            getIntValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED);\n\n            // Blob vals\n            getBlobValueFromCursor(cv, c, Telephony.SimInfo.COLUMN_ACCESS_RULES);\n        }\n\n        private void getCardIdfromIccid(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    cv.put(Telephony.SimInfo.COLUMN_CARD_ID, fromCursor);\n                }\n            }\n        }\n\n        private void recreateDB(SQLiteDatabase db, String[] proj, int version) {\n            // Upgrade steps are:\n            // 1. Create a temp table- done in createCarriersTable()\n            // 2. copy over APNs from old table to new table - done in copyDataToTmpTable()\n            // 3. Drop the existing table.\n            // 4. Copy over the tmp table.\n            Cursor c;\n            if (VDBG) {\n                c = db.query(CARRIERS_TABLE, proj, null, null, null, null, null);\n                log(\"dbh.onUpgrade:- before upgrading total number of rows: \" + c.getCount());\n                c.close();\n            }\n\n            c = db.query(CARRIERS_TABLE, null, null, null, null, null, null);\n\n            if (VDBG) {\n                log(\"dbh.onUpgrade:- starting data copy of existing rows: \" +\n                        + ((c == null) ? 0 : c.getCount()));\n            }\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE_TMP);\n\n            createCarriersTable(db, CARRIERS_TABLE_TMP);\n\n            copyDataToTmpTable(db, c, version);\n            c.close();\n\n            db.execSQL(\"DROP TABLE IF EXISTS \" + CARRIERS_TABLE);\n\n            db.execSQL(\"ALTER TABLE \" + CARRIERS_TABLE_TMP + \" rename to \" + CARRIERS_TABLE + \";\");\n        }\n\n        private void preserveUserAndCarrierApns(SQLiteDatabase db) {\n            if (VDBG) log(\"preserveUserAndCarrierApns\");\n            XmlPullParser confparser;\n            File confFile = new File(Environment.getRootDirectory(), OLD_APNS_PATH);\n            FileReader confreader = null;\n            try {\n                confreader = new FileReader(confFile);\n                confparser = Xml.newPullParser();\n                confparser.setInput(confreader);\n                XmlUtils.beginDocument(confparser, \"apns\");\n\n                deleteMatchingApns(db, confparser);\n            } catch (FileNotFoundException e) {\n                // This function is called only when upgrading db to version 15. Details about the\n                // upgrade are mentioned in onUpgrade(). This file missing means user/carrier added\n                // APNs cannot be preserved. Log an error message so that OEMs know they need to\n                // include old apns file for comparison.\n                loge(\"PRESERVEUSERANDCARRIERAPNS: \" + OLD_APNS_PATH +\n                        \" NOT FOUND. IT IS NEEDED TO UPGRADE FROM OLDER VERSIONS OF APN \" +\n                        \"DB WHILE PRESERVING USER/CARRIER ADDED/EDITED ENTRIES.\");\n            } catch (Exception e) {\n                loge(\"preserveUserAndCarrierApns: Exception while parsing '\" +\n                        confFile.getAbsolutePath() + \"'\" + e);\n            } finally {\n                if (confreader != null) {\n                    try {\n                        confreader.close();\n                    } catch (IOException e) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void deleteMatchingApns(SQLiteDatabase db, XmlPullParser parser) {\n            if (VDBG) log(\"deleteMatchingApns\");\n            if (parser != null) {\n                if (VDBG) log(\"deleteMatchingApns: parser != null\");\n                try {\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, false);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        deleteRow(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                } catch (XmlPullParserException e) {\n                    loge(\"deleteMatchingApns: Got XmlPullParserException while deleting apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"deleteMatchingApns: Got IOException while deleting apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"deleteMatchingApns: Got SQLException while deleting apns.\" + e);\n                }\n            }\n        }\n\n        private String queryValFirst(String field) {\n            return field + \"=?\";\n        }\n\n        private String queryVal(String field) {\n            return \" and \" + field + \"=?\";\n        }\n\n        private String queryValOrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private String queryVal2OrNull(String field) {\n            return \" and (\" + field + \"=? or \" + field + \"=? or \" + field + \" is null)\";\n        }\n\n        private void deleteRow(SQLiteDatabase db, ContentValues values) {\n            if (VDBG) log(\"deleteRow\");\n            String where = queryValFirst(NUMERIC) +\n                    queryVal(MNC) +\n                    queryVal(MNC) +\n                    queryValOrNull(APN) +\n                    queryValOrNull(USER) +\n                    queryValOrNull(SERVER) +\n                    queryValOrNull(PASSWORD) +\n                    queryValOrNull(PROXY) +\n                    queryValOrNull(PORT) +\n                    queryValOrNull(MMSPROXY) +\n                    queryValOrNull(MMSPORT) +\n                    queryValOrNull(MMSC) +\n                    queryValOrNull(AUTH_TYPE) +\n                    queryValOrNull(TYPE) +\n                    queryValOrNull(PROTOCOL) +\n                    queryValOrNull(ROAMING_PROTOCOL) +\n                    queryVal2OrNull(CARRIER_ENABLED) +\n                    queryValOrNull(BEARER) +\n                    queryValOrNull(MVNO_TYPE) +\n                    queryValOrNull(MVNO_MATCH_DATA) +\n                    queryValOrNull(PROFILE_ID) +\n                    queryVal2OrNull(MODEM_PERSIST) +\n                    queryValOrNull(MAX_CONNECTIONS) +\n                    queryValOrNull(WAIT_TIME_RETRY) +\n                    queryValOrNull(TIME_LIMIT_FOR_MAX_CONNECTIONS) +\n                    queryValOrNull(MTU) +\n                    queryValOrNull(MTU_V4) +\n                    queryValOrNull(MTU_V6);\n            String[] whereArgs = new String[31];\n            int i = 0;\n            whereArgs[i++] = values.getAsString(NUMERIC);\n            whereArgs[i++] = values.getAsString(MCC);\n            whereArgs[i++] = values.getAsString(MNC);\n            whereArgs[i++] = values.getAsString(NAME);\n            whereArgs[i++] = values.containsKey(APN) ?\n                    values.getAsString(APN) : \"\";\n            whereArgs[i++] = values.containsKey(USER) ?\n                    values.getAsString(USER) : \"\";\n            whereArgs[i++] = values.containsKey(SERVER) ?\n                    values.getAsString(SERVER) : \"\";\n            whereArgs[i++] = values.containsKey(PASSWORD) ?\n                    values.getAsString(PASSWORD) : \"\";\n            whereArgs[i++] = values.containsKey(PROXY) ?\n                    values.getAsString(PROXY) : \"\";\n            whereArgs[i++] = values.containsKey(PORT) ?\n                    values.getAsString(PORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPROXY) ?\n                    values.getAsString(MMSPROXY) : \"\";\n            whereArgs[i++] = values.containsKey(MMSPORT) ?\n                    values.getAsString(MMSPORT) : \"\";\n            whereArgs[i++] = values.containsKey(MMSC) ?\n                    values.getAsString(MMSC) : \"\";\n            whereArgs[i++] = values.containsKey(AUTH_TYPE) ?\n                    values.getAsString(AUTH_TYPE) : \"-1\";\n            whereArgs[i++] = values.containsKey(TYPE) ?\n                    values.getAsString(TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(PROTOCOL) ?\n                    values.getAsString(PROTOCOL) : DEFAULT_PROTOCOL;\n            whereArgs[i++] = values.containsKey(ROAMING_PROTOCOL) ?\n                    values.getAsString(ROAMING_PROTOCOL) : DEFAULT_ROAMING_PROTOCOL;\n\n            if (values.containsKey(CARRIER_ENABLED)) {\n                whereArgs[i++] = convertStringToBoolString(values.getAsString(CARRIER_ENABLED));\n                whereArgs[i++] = convertStringToIntString(values.getAsString(CARRIER_ENABLED));\n            } else {\n                String defaultIntString = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(CARRIER_ENABLED);\n                whereArgs[i++] = convertStringToBoolString(defaultIntString);\n                whereArgs[i++] = defaultIntString;\n            }\n\n            whereArgs[i++] = values.containsKey(BEARER) ?\n                    values.getAsString(BEARER) : \"0\";\n            whereArgs[i++] = values.containsKey(MVNO_TYPE) ?\n                    values.getAsString(MVNO_TYPE) : \"\";\n            whereArgs[i++] = values.containsKey(MVNO_MATCH_DATA) ?\n                    values.getAsString(MVNO_MATCH_DATA) : \"\";\n            whereArgs[i++] = values.containsKey(PROFILE_ID) ?\n                    values.getAsString(PROFILE_ID) : \"0\";\n\n            if (values.containsKey(MODEM_PERSIST) &&\n                    (values.getAsString(MODEM_PERSIST).\n                            equalsIgnoreCase(\"true\") ||\n                            values.getAsString(MODEM_PERSIST).equals(\"1\"))) {\n                whereArgs[i++] = \"true\";\n                whereArgs[i++] = \"1\";\n            } else {\n                whereArgs[i++] = \"false\";\n                whereArgs[i++] = \"0\";\n            }\n\n            whereArgs[i++] = values.containsKey(MAX_CONNECTIONS) ?\n                    values.getAsString(MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(WAIT_TIME_RETRY) ?\n                    values.getAsString(WAIT_TIME_RETRY) : \"0\";\n            whereArgs[i++] = values.containsKey(TIME_LIMIT_FOR_MAX_CONNECTIONS) ?\n                    values.getAsString(TIME_LIMIT_FOR_MAX_CONNECTIONS) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU) ?\n                    values.getAsString(MTU) : \"0\";\n            whereArgs[i++] = values.containsKey(MTU_V4) ?\n                    values.getAsString(MTU_V4) : String.valueOf(UNSPECIFIED_INT);\n            whereArgs[i++] = values.containsKey(MTU_V6) ?\n                    values.getAsString(MTU_V6) : String.valueOf(UNSPECIFIED_INT);\n\n            if (VDBG) {\n                log(\"deleteRow: where: \" + where);\n\n                StringBuilder builder = new StringBuilder();\n                for (String s : whereArgs) {\n                    builder.append(s + \", \");\n                }\n\n                log(\"deleteRow: whereArgs: \" + builder.toString());\n            }\n            db.delete(CARRIERS_TABLE, where, whereArgs);\n        }\n\n        private void copyDataToTmpTable(SQLiteDatabase db, Cursor c, int version) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null) {\n                while (c.moveToNext()) {\n                    ContentValues cv = new ContentValues();\n                    copyAllApnValues(cv, c);\n                    if (version == 24) {\n                        // Sync bearer bitmask and network type bitmask\n                        getNetworkTypeBitmaskFromCursor(cv, c);\n                    }\n                    try {\n                        db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                SQLiteDatabase.CONFLICT_ABORT);\n                        if (VDBG) {\n                            log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                    \"insert successful for cv \" + cv);\n                        }\n                    } catch (SQLException e) {\n                        if (VDBG)\n                            log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                    e + \" for cv \" + cv);\n                    }\n                }\n            }\n        }\n\n        private void copyApnValuesV17(ContentValues cv, Cursor c) {\n            // Include only non-null values in cv so that null values can be replaced\n            // with default if there's a default value for the field\n\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n        }\n\n        private void copyAllApnValues(ContentValues cv, Cursor c) {\n            // String vals\n            getStringValueFromCursor(cv, c, NAME);\n            getStringValueFromCursor(cv, c, NUMERIC);\n            getStringValueFromCursor(cv, c, MCC);\n            getStringValueFromCursor(cv, c, MNC);\n            getStringValueFromCursor(cv, c, APN);\n            getStringValueFromCursor(cv, c, USER);\n            getStringValueFromCursor(cv, c, SERVER);\n            getStringValueFromCursor(cv, c, PASSWORD);\n            getStringValueFromCursor(cv, c, PROXY);\n            getStringValueFromCursor(cv, c, PORT);\n            getStringValueFromCursor(cv, c, MMSPROXY);\n            getStringValueFromCursor(cv, c, MMSPORT);\n            getStringValueFromCursor(cv, c, MMSC);\n            getStringValueFromCursor(cv, c, TYPE);\n            getStringValueFromCursor(cv, c, PROTOCOL);\n            getStringValueFromCursor(cv, c, ROAMING_PROTOCOL);\n            getStringValueFromCursor(cv, c, MVNO_TYPE);\n            getStringValueFromCursor(cv, c, MVNO_MATCH_DATA);\n\n            // bool/int vals\n            getIntValueFromCursor(cv, c, AUTH_TYPE);\n            getIntValueFromCursor(cv, c, CURRENT);\n            getIntValueFromCursor(cv, c, CARRIER_ENABLED);\n            getIntValueFromCursor(cv, c, BEARER);\n            getIntValueFromCursor(cv, c, SUBSCRIPTION_ID);\n            getIntValueFromCursor(cv, c, PROFILE_ID);\n            getIntValueFromCursor(cv, c, MODEM_PERSIST);\n            getIntValueFromCursor(cv, c, MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, WAIT_TIME_RETRY);\n            getIntValueFromCursor(cv, c, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            getIntValueFromCursor(cv, c, MTU);\n            getIntValueFromCursor(cv, c, MTU_V4);\n            getIntValueFromCursor(cv, c, MTU_V6);\n            getIntValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, LINGERING_NETWORK_TYPE_BITMASK);\n            getIntValueFromCursor(cv, c, BEARER_BITMASK);\n            getIntValueFromCursor(cv, c, EDITED_STATUS);\n            getIntValueFromCursor(cv, c, USER_VISIBLE);\n            getIntValueFromCursor(cv, c, USER_EDITABLE);\n            getIntValueFromCursor(cv, c, OWNED_BY);\n            getIntValueFromCursor(cv, c, APN_SET_ID);\n            getIntValueFromCursor(cv, c, SKIP_464XLAT);\n            getIntValueFromCursor(cv, c, ALWAYS_ON);\n        }\n\n        private void copyPreservedApnsToNewTable(SQLiteDatabase db, Cursor c) {\n            // Move entries from CARRIERS_TABLE to CARRIERS_TABLE_TMP\n            if (c != null && mContext.getResources() != null) {\n                try {\n                    String[] persistApnsForPlmns = mContext.getResources().getStringArray(\n                            R.array.persist_apns_for_plmn);\n                    while (c.moveToNext()) {\n                        ContentValues cv = new ContentValues();\n                        String val;\n                        // Using V17 copy function for V15 upgrade. This should be fine since it\n                        // handles columns that may not exist properly (getStringValueFromCursor()\n                        // and getIntValueFromCursor() handle column index -1)\n                        copyApnValuesV17(cv, c);\n                        // Change bearer to a bitmask\n                        String bearerStr = c.getString(c.getColumnIndex(BEARER));\n                        if (!TextUtils.isEmpty(bearerStr)) {\n                            int bearer_bitmask = getBitmaskForTech(Integer.parseInt(bearerStr));\n                            cv.put(BEARER_BITMASK, bearer_bitmask);\n\n                            int networkTypeBitmask = rilRadioTechnologyToNetworkTypeBitmask(\n                                    Integer.parseInt(bearerStr));\n                            cv.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n                        }\n\n                        int userEditedColumnIdx = c.getColumnIndex(\"user_edited\");\n                        if (userEditedColumnIdx != -1) {\n                            String user_edited = c.getString(userEditedColumnIdx);\n                            if (!TextUtils.isEmpty(user_edited)) {\n                                cv.put(EDITED_STATUS, new Integer(user_edited));\n                            }\n                        } else {\n                            cv.put(EDITED_STATUS, CARRIER_EDITED);\n                        }\n\n                        // New EDITED column. Default value (UNEDITED) will\n                        // be used for all rows except for non-mvno entries for plmns indicated\n                        // by resource: those will be set to CARRIER_EDITED to preserve\n                        // their current values\n                        val = c.getString(c.getColumnIndex(NUMERIC));\n                        for (String s : persistApnsForPlmns) {\n                            if (!TextUtils.isEmpty(val) && val.equals(s) &&\n                                    (!cv.containsKey(MVNO_TYPE) ||\n                                            TextUtils.isEmpty(cv.getAsString(MVNO_TYPE)))) {\n                                if (userEditedColumnIdx == -1) {\n                                    cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                } else { // if (oldVersion == 14) -- if db had user_edited column\n                                    if (cv.getAsInteger(EDITED_STATUS) == USER_EDITED) {\n                                        cv.put(EDITED_STATUS, CARRIER_EDITED);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n\n                        try {\n                            db.insertWithOnConflict(CARRIERS_TABLE_TMP, null, cv,\n                                    SQLiteDatabase.CONFLICT_ABORT);\n                            if (VDBG) {\n                                log(\"dbh.copyPreservedApnsToNewTable: db.insert returned >= 0; \" +\n                                        \"insert successful for cv \" + cv);\n                            }\n                        } catch (SQLException e) {\n                            if (VDBG)\n                                log(\"dbh.copyPreservedApnsToNewTable insertWithOnConflict exception \" +\n                                        e + \" for cv \" + cv);\n                            // Insertion failed which could be due to a conflict. Check if that is\n                            // the case and merge the entries\n                            Cursor oldRow = selectConflictingRow(db,\n                                    CARRIERS_TABLE_TMP, cv);\n                            if (oldRow != null) {\n                                ContentValues mergedValues = new ContentValues();\n                                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE_TMP, oldRow, cv,\n                                        mergedValues, true, mContext);\n                                oldRow.close();\n                            }\n                        }\n                    }\n                } catch (Resources.NotFoundException e) {\n                    loge(\"array.persist_apns_for_plmn is not found\");\n                    return;\n                }\n            }\n        }\n\n        private void getStringValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * If NETWORK_TYPE_BITMASK does not exist (upgrade from version 23 to version 24), generate\n         * NETWORK_TYPE_BITMASK with the use of BEARER_BITMASK. If NETWORK_TYPE_BITMASK existed\n         * (upgrade from version 24 to forward), always map NETWORK_TYPE_BITMASK to BEARER_BITMASK.\n         */\n        private void getNetworkTypeBitmaskFromCursor(ContentValues cv, Cursor c) {\n            int columnIndex = c.getColumnIndex(NETWORK_TYPE_BITMASK);\n            if (columnIndex != -1) {\n                getStringValueFromCursor(cv, c, NETWORK_TYPE_BITMASK);\n                // Map NETWORK_TYPE_BITMASK to BEARER_BITMASK if NETWORK_TYPE_BITMASK existed;\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int networkBitmask = Integer.valueOf(fromCursor);\n                    int bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkBitmask);\n                    cv.put(BEARER_BITMASK, String.valueOf(bearerBitmask));\n                }\n                return;\n            }\n            columnIndex = c.getColumnIndex(BEARER_BITMASK);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor) && fromCursor.matches(\"\\\\d+\")) {\n                    int bearerBitmask = Integer.valueOf(fromCursor);\n                    int networkBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                    cv.put(NETWORK_TYPE_BITMASK, String.valueOf(networkBitmask));\n                }\n            }\n        }\n\n        private void getIntValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                String fromCursor = c.getString(columnIndex);\n                if (!TextUtils.isEmpty(fromCursor)) {\n                    try {\n                        cv.put(key, new Integer(fromCursor));\n                    } catch (NumberFormatException nfe) {\n                        // do nothing\n                    }\n                }\n            }\n        }\n\n        private void getBlobValueFromCursor(ContentValues cv, Cursor c, String key) {\n            int columnIndex = c.getColumnIndex(key);\n            if (columnIndex != -1) {\n                byte[] fromCursor = c.getBlob(columnIndex);\n                if (fromCursor != null) {\n                    cv.put(key, fromCursor);\n                }\n            }\n        }\n\n        /**\n         * Gets the next row of apn values.\n         *\n         * @param parser the parser\n         * @param isOverlay If the xml file comes from an overlay MCC/MNC are treated as integers\n         * @return the row or null if it's not an apn\n         */\n        private ContentValues getRow(XmlPullParser parser, boolean isOverlay) {\n            if (!\"apn\".equals(parser.getName())) {\n                return null;\n            }\n\n            ContentValues map = new ContentValues();\n\n            String mcc = parser.getAttributeValue(null, \"mcc\");\n            String mnc = parser.getAttributeValue(null, \"mnc\");\n            String mccString = mcc;\n            String mncString = mnc;\n            // Since an mnc can have both two and three digits and it is hard to verify\n            // all OEM's Global APN lists we only do this for overlays.\n            if (isOverlay) {\n                mccString = String.format(\"%03d\", Integer.parseInt(mcc));\n                // Looks up a two digit mnc in the carrier id DB\n                // if not found a three digit mnc value is chosen\n                mncString = getBestStringMnc(mContext, mccString, Integer.parseInt(mnc));\n            }\n\n            String numeric = (mccString == null | mncString == null) ? null : mccString + mncString;\n            map.put(NUMERIC, numeric);\n            map.put(MCC, mccString);\n            map.put(MNC, mncString);\n            map.put(NAME, parser.getAttributeValue(null, \"carrier\"));\n\n            // do not add NULL to the map so that default values can be inserted in db\n            addStringAttribute(parser, \"apn\", map, APN);\n            addStringAttribute(parser, \"user\", map, USER);\n            addStringAttribute(parser, \"server\", map, SERVER);\n            addStringAttribute(parser, \"password\", map, PASSWORD);\n            addStringAttribute(parser, \"proxy\", map, PROXY);\n            addStringAttribute(parser, \"port\", map, PORT);\n            addStringAttribute(parser, \"mmsproxy\", map, MMSPROXY);\n            addStringAttribute(parser, \"mmsport\", map, MMSPORT);\n            addStringAttribute(parser, \"mmsc\", map, MMSC);\n\n            String apnType = parser.getAttributeValue(null, \"type\");\n            if (apnType != null) {\n                // Remove spaces before putting it in the map.\n                apnType = apnType.replaceAll(\"\\\\s+\", \"\");\n                map.put(TYPE, apnType);\n            }\n\n            addStringAttribute(parser, \"protocol\", map, PROTOCOL);\n            addStringAttribute(parser, \"roaming_protocol\", map, ROAMING_PROTOCOL);\n\n            addIntAttribute(parser, \"authtype\", map, AUTH_TYPE);\n            addIntAttribute(parser, \"bearer\", map, BEARER);\n            addIntAttribute(parser, \"profile_id\", map, PROFILE_ID);\n            addIntAttribute(parser, \"max_conns\", map, MAX_CONNECTIONS);\n            addIntAttribute(parser, \"wait_time\", map, WAIT_TIME_RETRY);\n            addIntAttribute(parser, \"max_conns_time\", map, TIME_LIMIT_FOR_MAX_CONNECTIONS);\n            addIntAttribute(parser, \"mtu\", map, MTU);\n            addIntAttribute(parser, \"mtu_v4\", map, MTU_V4);\n            addIntAttribute(parser, \"mtu_v6\", map, MTU_V6);\n            addIntAttribute(parser, \"apn_set_id\", map, APN_SET_ID);\n            addIntAttribute(parser, \"carrier_id\", map, CARRIER_ID);\n            addIntAttribute(parser, \"skip_464xlat\", map, SKIP_464XLAT);\n\n            addBoolAttribute(parser, \"carrier_enabled\", map, CARRIER_ENABLED);\n            addBoolAttribute(parser, \"modem_cognitive\", map, MODEM_PERSIST);\n            addBoolAttribute(parser, \"user_visible\", map, USER_VISIBLE);\n            addBoolAttribute(parser, \"user_editable\", map, USER_EDITABLE);\n            addBoolAttribute(parser, \"always_on\", map, ALWAYS_ON);\n\n            int networkTypeBitmask = 0;\n            String networkTypeList = parser.getAttributeValue(null, \"network_type_bitmask\");\n            if (networkTypeList != null) {\n                networkTypeBitmask = getBitmaskFromString(networkTypeList);\n            }\n            map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n\n            int lingeringNetworkTypeBitmask = 0;\n            String lingeringNetworkTypeList =\n                    parser.getAttributeValue(null, \"lingering_network_type_bitmask\");\n            if (lingeringNetworkTypeList != null) {\n                lingeringNetworkTypeBitmask = getBitmaskFromString(lingeringNetworkTypeList);\n            }\n            map.put(LINGERING_NETWORK_TYPE_BITMASK, lingeringNetworkTypeBitmask);\n\n            int bearerBitmask = 0;\n            if (networkTypeList != null) {\n                bearerBitmask = convertNetworkTypeBitmaskToBearerBitmask(networkTypeBitmask);\n            } else {\n                String bearerList = parser.getAttributeValue(null, \"bearer_bitmask\");\n                if (bearerList != null) {\n                    bearerBitmask = getBitmaskFromString(bearerList);\n                }\n                // Update the network type bitmask to keep them sync.\n                networkTypeBitmask = convertBearerBitmaskToNetworkTypeBitmask(bearerBitmask);\n                map.put(NETWORK_TYPE_BITMASK, networkTypeBitmask);\n            }\n            map.put(BEARER_BITMASK, bearerBitmask);\n\n            String mvno_type = parser.getAttributeValue(null, \"mvno_type\");\n            if (mvno_type != null) {\n                String mvno_match_data = parser.getAttributeValue(null, \"mvno_match_data\");\n                if (mvno_match_data != null) {\n                    map.put(MVNO_TYPE, mvno_type);\n                    map.put(MVNO_MATCH_DATA, mvno_match_data);\n                }\n            }\n            return map;\n        }\n\n        private void addStringAttribute(XmlPullParser parser, String att,\n                                        ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, val);\n            }\n        }\n\n        private void addIntAttribute(XmlPullParser parser, String att,\n                                     ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Integer.parseInt(val));\n            }\n        }\n\n        private void addBoolAttribute(XmlPullParser parser, String att,\n                                      ContentValues map, String key) {\n            String val = parser.getAttributeValue(null, att);\n            if (val != null) {\n                map.put(key, Boolean.parseBoolean(val));\n            }\n        }\n\n        /*\n         * Loads apns from xml file into the database\n         *\n         * @param db the sqlite database to write to\n         * @param parser the xml parser\n         * @param isOverlay, if we are parsing an xml in an overlay\n         */\n        private void loadApns(SQLiteDatabase db, XmlPullParser parser, boolean isOverlay) {\n            if (parser != null) {\n                try {\n                    db.beginTransaction();\n                    XmlUtils.nextElement(parser);\n                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {\n                        ContentValues row = getRow(parser, isOverlay);\n                        if (row == null) {\n                            throw new XmlPullParserException(\"Expected 'apn' tag\", parser, null);\n                        }\n                        insertAddingDefaults(db, row);\n                        XmlUtils.nextElement(parser);\n                    }\n                    db.setTransactionSuccessful();\n                } catch (XmlPullParserException e) {\n                    loge(\"Got XmlPullParserException while loading apns.\" + e);\n                } catch (IOException e) {\n                    loge(\"Got IOException while loading apns.\" + e);\n                } catch (SQLException e) {\n                    loge(\"Got SQLException while loading apns.\" + e);\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        }\n\n        private void insertAddingDefaults(SQLiteDatabase db, ContentValues row) {\n            row = setDefaultValue(row);\n            try {\n                db.insertWithOnConflict(CARRIERS_TABLE, null, row, SQLiteDatabase.CONFLICT_ABORT);\n                if (VDBG) log(\"dbh.insertAddingDefaults: db.insert returned >= 0; insert \" +\n                        \"successful for cv \" + row);\n            } catch (SQLException e) {\n                if (VDBG) log(\"dbh.insertAddingDefaults: exception \" + e);\n                // Insertion failed which could be due to a conflict. Check if that is the case and\n                // update edited field accordingly.\n                // Search for the exact same entry and update edited field.\n                // If it is USER_EDITED/CARRIER_EDITED change it to UNEDITED,\n                // and if USER/CARRIER_DELETED change it to USER/CARRIER_DELETED_BUT_PRESENT_IN_XML.\n                Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, row);\n                if (oldRow != null) {\n                    // Update the row\n                    ContentValues mergedValues = new ContentValues();\n                    int edited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                    int old_edited = edited;\n                    if (edited != UNEDITED) {\n                        if (edited == USER_DELETED) {\n                            // USER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = USER_DELETED_BUT_PRESENT_IN_XML;\n                        } else if (edited == CARRIER_DELETED) {\n                            // CARRIER_DELETED_BUT_PRESENT_IN_XML indicates entry has been deleted\n                            // by user but present in apn xml file.\n                            edited = CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                        }\n                        mergedValues.put(EDITED_STATUS, edited);\n                    }\n\n                    mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, row, mergedValues, false,\n                            mContext);\n\n                    if (VDBG) log(\"dbh.insertAddingDefaults: old edited = \" + old_edited\n                            + \" new edited = \" + edited);\n\n                    oldRow.close();\n                }\n            }\n        }\n    }\n\n    public static void mergeFieldsAndUpdateDb(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, ContentValues mergedValues,\n            boolean onUpgrade, Context context) {\n        if (newRow.containsKey(TYPE)) {\n            // Merge the types\n            String oldType = oldRow.getString(oldRow.getColumnIndex(TYPE));\n            String newType = newRow.getAsString(TYPE);\n\n            if (!oldType.equalsIgnoreCase(newType)) {\n                if (oldType.equals(\"\") || newType.equals(\"\")) {\n                    newRow.put(TYPE, \"\");\n                } else {\n                    String[] oldTypes = oldType.toLowerCase().split(\",\");\n                    String[] newTypes = newType.toLowerCase().split(\",\");\n\n                    if (VDBG) {\n                        log(\"mergeFieldsAndUpdateDb: Calling separateRowsNeeded() oldType=\" +\n                                oldType + \" old bearer=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                BEARER_BITMASK)) +  \" old networkType=\" +\n                                oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK)) +\n                                \" old profile_id=\" + oldRow.getInt(oldRow.getColumnIndex(\n                                PROFILE_ID)) + \" newRow \" + newRow);\n                    }\n\n                    // If separate rows are needed, do not need to merge any further\n                    if (separateRowsNeeded(db, table, oldRow, newRow, context, oldTypes,\n                            newTypes)) {\n                        if (VDBG) log(\"mergeFieldsAndUpdateDb: separateRowsNeeded() returned \" +\n                                \"true\");\n                        return;\n                    }\n\n                    // Merge the 2 types\n                    ArrayList<String> mergedTypes = new ArrayList<String>();\n                    mergedTypes.addAll(Arrays.asList(oldTypes));\n                    for (String s : newTypes) {\n                        if (!mergedTypes.contains(s.trim())) {\n                            mergedTypes.add(s);\n                        }\n                    }\n                    StringBuilder mergedType = new StringBuilder();\n                    for (int i = 0; i < mergedTypes.size(); i++) {\n                        mergedType.append((i == 0 ? \"\" : \",\") + mergedTypes.get(i));\n                    }\n                    newRow.put(TYPE, mergedType.toString());\n                }\n            }\n            mergedValues.put(TYPE, newRow.getAsString(TYPE));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)) {\n            int oldBearer = oldRow.getInt(oldRow.getColumnIndex(BEARER_BITMASK));\n            int newBearer = newRow.getAsInteger(BEARER_BITMASK);\n            if (oldBearer != newBearer) {\n                if (oldBearer == 0 || newBearer == 0) {\n                    newRow.put(BEARER_BITMASK, 0);\n                } else {\n                    newRow.put(BEARER_BITMASK, (oldBearer | newBearer));\n                }\n            }\n            mergedValues.put(BEARER_BITMASK, newRow.getAsInteger(BEARER_BITMASK));\n        }\n\n        if (newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            int oldBitmask = oldRow.getInt(oldRow.getColumnIndex(NETWORK_TYPE_BITMASK));\n            int newBitmask = newRow.getAsInteger(NETWORK_TYPE_BITMASK);\n            if (oldBitmask != newBitmask) {\n                if (oldBitmask == 0 || newBitmask == 0) {\n                    newRow.put(NETWORK_TYPE_BITMASK, 0);\n                } else {\n                    newRow.put(NETWORK_TYPE_BITMASK, (oldBitmask | newBitmask));\n                }\n            }\n            mergedValues.put(NETWORK_TYPE_BITMASK, newRow.getAsInteger(NETWORK_TYPE_BITMASK));\n        }\n\n        if (newRow.containsKey(BEARER_BITMASK)\n                && newRow.containsKey(NETWORK_TYPE_BITMASK)) {\n            syncBearerBitmaskAndNetworkTypeBitmask(mergedValues);\n        }\n\n        if (!onUpgrade) {\n            // Do not overwrite a carrier or user edit with EDITED=UNEDITED\n            if (newRow.containsKey(EDITED_STATUS)) {\n                int oldEdited = oldRow.getInt(oldRow.getColumnIndex(EDITED_STATUS));\n                int newEdited = newRow.getAsInteger(EDITED_STATUS);\n                if (newEdited == UNEDITED && (oldEdited == CARRIER_EDITED\n                        || oldEdited == CARRIER_DELETED\n                        || oldEdited == CARRIER_DELETED_BUT_PRESENT_IN_XML\n                        || oldEdited == USER_EDITED\n                        || oldEdited == USER_DELETED\n                        || oldEdited == USER_DELETED_BUT_PRESENT_IN_XML)) {\n                    newRow.remove(EDITED_STATUS);\n                }\n            }\n            mergedValues.putAll(newRow);\n        }\n\n        if (mergedValues.size() > 0) {\n            db.update(table, mergedValues, \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")),\n                    null);\n        }\n    }\n\n    private static boolean separateRowsNeeded(SQLiteDatabase db, String table, Cursor oldRow,\n            ContentValues newRow, Context context,\n            String[] oldTypes, String[] newTypes) {\n        // If this APN falls under persist_apns_for_plmn, and the\n        // only difference between old type and new type is that one has dun, and\n        // the APNs have profile_id 0 or not set, then set the profile_id to 1 for\n        // the dun APN/remove dun from type. This will ensure both oldRow and newRow exist\n        // separately in db.\n\n        boolean match = false;\n\n        // Check if APN falls under persist_apns_for_plmn\n        if (context.getResources() != null) {\n            String[] persistApnsForPlmns = context.getResources().getStringArray(\n                    R.array.persist_apns_for_plmn);\n            for (String s : persistApnsForPlmns) {\n                if (s.equalsIgnoreCase(newRow.getAsString(NUMERIC))) {\n                    match = true;\n                    break;\n                }\n            }\n        } else {\n            loge(\"separateRowsNeeded: resources=null\");\n        }\n\n        if (!match) return false;\n\n        // APN falls under persist_apns_for_plmn\n        // Check if only difference between old type and new type is that\n        // one has dun\n        ArrayList<String> oldTypesAl = new ArrayList<String>(Arrays.asList(oldTypes));\n        ArrayList<String> newTypesAl = new ArrayList<String>(Arrays.asList(newTypes));\n        ArrayList<String> listWithDun = null;\n        ArrayList<String> listWithoutDun = null;\n        boolean dunInOld = false;\n        if (oldTypesAl.size() == newTypesAl.size() + 1) {\n            listWithDun = oldTypesAl;\n            listWithoutDun = newTypesAl;\n            dunInOld = true;\n        } else if (oldTypesAl.size() + 1 == newTypesAl.size()) {\n            listWithDun = newTypesAl;\n            listWithoutDun = oldTypesAl;\n        } else {\n            return false;\n        }\n\n        if (listWithDun.contains(\"dun\") && !listWithoutDun.contains(\"dun\")) {\n            listWithoutDun.add(\"dun\");\n            if (!listWithDun.containsAll(listWithoutDun)) {\n                return false;\n            }\n\n            // Only difference between old type and new type is that\n            // one has dun\n            // Check if profile_id is 0/not set\n            if (oldRow.getInt(oldRow.getColumnIndex(PROFILE_ID)) == 0) {\n                if (dunInOld) {\n                    // Update oldRow to remove dun from its type field\n                    ContentValues updateOldRow = new ContentValues();\n                    StringBuilder sb = new StringBuilder();\n                    boolean first = true;\n                    for (String s : listWithDun) {\n                        if (!s.equalsIgnoreCase(\"dun\")) {\n                            sb.append(first ? s : \",\" + s);\n                            first = false;\n                        }\n                    }\n                    String updatedType = sb.toString();\n                    if (VDBG) {\n                        log(\"separateRowsNeeded: updating type in oldRow to \" + updatedType);\n                    }\n                    updateOldRow.put(TYPE, updatedType);\n                    db.update(table, updateOldRow,\n                            \"_id=\" + oldRow.getInt(oldRow.getColumnIndex(\"_id\")), null);\n                    return true;\n                } else {\n                    if (VDBG) log(\"separateRowsNeeded: adding profile id 1 to newRow\");\n                    // Update newRow to set profile_id to 1\n                    newRow.put(PROFILE_ID, new Integer(1));\n                }\n            } else {\n                return false;\n            }\n\n            // If match was found, both oldRow and newRow need to exist\n            // separately in db. Add newRow to db.\n            try {\n                db.insertWithOnConflict(table, null, newRow, SQLiteDatabase.CONFLICT_REPLACE);\n                if (VDBG) log(\"separateRowsNeeded: added newRow with profile id 1 to db\");\n                return true;\n            } catch (SQLException e) {\n                loge(\"Exception on trying to add new row after updating profile_id\");\n            }\n        }\n\n        return false;\n    }\n\n    public static Cursor selectConflictingRow(SQLiteDatabase db, String table,\n            ContentValues row) {\n        // Conflict is possible only when numeric, mcc, mnc (fields without any default value)\n        // are set in the new row\n        if (!row.containsKey(NUMERIC) || !row.containsKey(MCC) || !row.containsKey(MNC)) {\n            loge(\"dbh.selectConflictingRow: called for non-conflicting row: \" + row);\n            return null;\n        }\n\n        String[] columns = { \"_id\",\n                TYPE,\n                EDITED_STATUS,\n                BEARER_BITMASK,\n                NETWORK_TYPE_BITMASK,\n                PROFILE_ID };\n        String selection = TextUtils.join(\"=? AND \", CARRIERS_UNIQUE_FIELDS) + \"=?\";\n        int i = 0;\n        String[] selectionArgs = new String[CARRIERS_UNIQUE_FIELDS.size()];\n        for (String field : CARRIERS_UNIQUE_FIELDS) {\n            if (!row.containsKey(field)) {\n                selectionArgs[i++] = CARRIERS_UNIQUE_FIELDS_DEFAULTS.get(field);\n            } else {\n                if (CARRIERS_BOOLEAN_FIELDS.contains(field)) {\n                    // for boolean fields we overwrite the strings \"true\" and \"false\" with \"1\"\n                    // and \"0\"\n                    selectionArgs[i++] = convertStringToIntString(row.getAsString(field));\n                } else {\n                    selectionArgs[i++] = row.getAsString(field);\n                }\n            }\n        }\n\n        Cursor c = db.query(table, columns, selection, selectionArgs, null, null, null);\n\n        if (c != null) {\n            if (c.getCount() == 1) {\n                if (VDBG) log(\"dbh.selectConflictingRow: \" + c.getCount() + \" conflicting \" +\n                        \"row found\");\n                if (c.moveToFirst()) {\n                    return c;\n                } else {\n                    loge(\"dbh.selectConflictingRow: moveToFirst() failed\");\n                }\n            } else {\n                loge(\"dbh.selectConflictingRow: Expected 1 but found \" + c.getCount() +\n                        \" matching rows found for cv \" + row);\n            }\n            c.close();\n        } else {\n            loge(\"dbh.selectConflictingRow: Error - c is null; no matching row found for \" +\n                    \"cv \" + row);\n        }\n\n        return null;\n    }\n\n    /**\n     * Convert \"true\" and \"false\" to \"1\" and \"0\".\n     * If the passed in string is already \"1\" or \"0\" returns the passed in string.\n     */\n    private static String convertStringToIntString(String boolString) {\n        if (\"0\".equals(boolString) || \"false\".equalsIgnoreCase(boolString)) return \"0\";\n        return \"1\";\n    }\n\n    /**\n     * Convert \"1\" and \"0\" to \"true\" and \"false\".\n     * If the passed in string is already \"true\" or \"false\" returns the passed in string.\n     */\n    private static String convertStringToBoolString(String intString) {\n        if (\"0\".equals(intString) || \"false\".equalsIgnoreCase(intString)) return \"false\";\n        return \"true\";\n    }\n\n    /**\n     * These methods can be overridden in a subclass for testing TelephonyProvider using an\n     * in-memory database.\n     */\n    SQLiteDatabase getReadableDatabase() {\n        return mOpenHelper.getReadableDatabase();\n    }\n    SQLiteDatabase getWritableDatabase() {\n        return mOpenHelper.getWritableDatabase();\n    }\n    void initDatabaseWithDatabaseHelper(SQLiteDatabase db) {\n        mOpenHelper.initDatabase(db);\n    }\n    boolean needApnDbUpdate() {\n        return mOpenHelper.apnDbUpdateNeeded();\n    }\n\n    private static boolean apnSourceServiceExists(Context context) {\n        if (s_apnSourceServiceExists != null) {\n            return s_apnSourceServiceExists;\n        }\n        try {\n            String service = context.getResources().getString(R.string.apn_source_service);\n            if (TextUtils.isEmpty(service)) {\n                s_apnSourceServiceExists = false;\n            } else {\n                s_apnSourceServiceExists = context.getPackageManager().getServiceInfo(\n                        ComponentName.unflattenFromString(service), 0)\n                        != null;\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            s_apnSourceServiceExists = false;\n        }\n        return s_apnSourceServiceExists;\n    }\n\n    private void restoreApnsWithService(int subId) {\n        Context context = getContext();\n        Resources r = context.getResources();\n        AtomicBoolean connectionBindingInvalid = new AtomicBoolean(false);\n        ServiceConnection connection = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName className,\n                    IBinder service) {\n                log(\"restoreApnsWithService: onServiceConnected\");\n                synchronized (mLock) {\n                    mIApnSourceService = IApnSourceService.Stub.asInterface(service);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName arg0) {\n                loge(\"mIApnSourceService has disconnected unexpectedly\");\n                synchronized (mLock) {\n                    mIApnSourceService = null;\n                }\n            }\n\n            @Override\n            public void onBindingDied(ComponentName name) {\n                loge(\"The binding to the apn service connection is dead: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n\n            @Override\n            public void onNullBinding(ComponentName name) {\n                loge(\"Null binding: \" + name);\n                synchronized (mLock) {\n                    connectionBindingInvalid.set(true);\n                    mLock.notifyAll();\n                }\n            }\n        };\n\n        Intent intent = new Intent(IApnSourceService.class.getName());\n        intent.setComponent(ComponentName.unflattenFromString(\n                r.getString(R.string.apn_source_service)));\n        log(\"binding to service to restore apns, intent=\" + intent);\n        try {\n            if (context.bindService(intent,\n                    Context.BIND_IMPORTANT | Context.BIND_AUTO_CREATE,\n                    runnable -> new Thread(runnable).start(),\n                    connection)) {\n                synchronized (mLock) {\n                    while (mIApnSourceService == null && !connectionBindingInvalid.get()) {\n                        try {\n                            mLock.wait();\n                        } catch (InterruptedException e) {\n                            loge(\"Error while waiting for service connection: \" + e);\n                        }\n                    }\n                    if (connectionBindingInvalid.get()) {\n                        loge(\"The binding is invalid.\");\n                        return;\n                    }\n                    try {\n                        ContentValues[] values = mIApnSourceService.getApns(subId);\n                        if (values != null) {\n                            // we use the unsynchronized insert because this function is called\n                            // within the syncrhonized function delete()\n                            unsynchronizedBulkInsert(CONTENT_URI, values);\n                            log(\"restoreApnsWithService: restored\");\n                        }\n                    } catch (RemoteException e) {\n                        loge(\"Error applying apns from service: \" + e);\n                    }\n                }\n            } else {\n                loge(\"unable to bind to service from intent=\" + intent);\n            }\n        } catch (SecurityException e) {\n            loge(\"Error applying apns from service: \" + e);\n        } finally {\n            if (connection != null) {\n                context.unbindService(connection);\n            }\n            synchronized (mLock) {\n                mIApnSourceService = null;\n            }\n        }\n    }\n\n\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new DatabaseHelper(getContext());\n\n        try {\n            PhoneFactory.addLocalLog(TAG, 64);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n\n        boolean isNewBuild = false;\n        String newBuildId = SystemProperties.get(\"ro.build.id\", null);\n        SharedPreferences sp = getContext().getSharedPreferences(BUILD_ID_FILE,\n                Context.MODE_PRIVATE);\n        if (!TextUtils.isEmpty(newBuildId)) {\n            // Check if build id has changed\n            String oldBuildId = sp.getString(RO_BUILD_ID, \"\");\n            if (!newBuildId.equals(oldBuildId)) {\n                localLog(\"onCreate: build id changed from \" + oldBuildId + \" to \" + newBuildId);\n                isNewBuild = true;\n            } else {\n                if (VDBG) log(\"onCreate: build id did not change: \" + oldBuildId);\n            }\n        } else {\n            if (VDBG) log(\"onCreate: newBuildId is empty\");\n        }\n\n        if (isNewBuild) {\n            if (!apnSourceServiceExists(getContext())) {\n                // Update APN DB\n                updateApnDb();\n            }\n\n            // Add all APN related shared prefs to local log for dumpsys\n            if (DBG) addAllApnSharedPrefToLocalLog();\n        }\n\n        // Write build id to SharedPreferences after APNs have been updated above by updateApnDb()\n        if (!TextUtils.isEmpty(newBuildId)) {\n            if (isNewBuild) log(\"onCreate: updating build id to \" + newBuildId);\n            sp.edit().putString(RO_BUILD_ID, newBuildId).apply();\n        }\n\n        SharedPreferences spEnforcedFile = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        mManagedApnEnforced = spEnforcedFile.getBoolean(ENFORCED_KEY, false);\n\n        if (VDBG) log(\"onCreate:- ret true\");\n\n        return true;\n    }\n\n    private void addAllApnSharedPrefToLocalLog() {\n        localLog(\"addAllApnSharedPrefToLocalLog\");\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefApnId.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n\n        SharedPreferences spFullApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefFullApn = spFullApn.getAll();\n        for (String key : allPrefFullApn.keySet()) {\n            try {\n                localLog(key + \":\" + allPrefFullApn.get(key).toString());\n            } catch (Exception e) {\n                localLog(\"Skipping over key \" + key + \" due to exception \" + e);\n            }\n        }\n    }\n\n    private static void localLog(String logMsg) {\n        Log.d(TAG, logMsg);\n        PhoneFactory.localLog(TAG, logMsg);\n    }\n\n    private synchronized boolean isManagedApnEnforced() {\n        return mManagedApnEnforced;\n    }\n\n    private void setManagedApnEnforced(boolean enforced) {\n        SharedPreferences sp = getContext().getSharedPreferences(ENFORCED_FILE,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putBoolean(ENFORCED_KEY, enforced);\n        editor.apply();\n        synchronized (this) {\n            mManagedApnEnforced = enforced;\n        }\n    }\n\n    private void setPreferredApnId(Long id, int subId, boolean saveApn) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.putLong(COLUMN_APN_ID + subId, id != null ? id : INVALID_APN_ID);\n        localLog(\"setPreferredApnId: \" + COLUMN_APN_ID + subId + \":\"\n                + (id != null ? id : INVALID_APN_ID));\n        // This is for debug purposes. It indicates if this APN was set by DcTracker or user (true)\n        // or if this was restored from APN saved in PREF_FILE_FULL_APN (false).\n        editor.putBoolean(EXPLICIT_SET_CALLED + subId, saveApn);\n        localLog(\"setPreferredApnId: \" + EXPLICIT_SET_CALLED + subId + \":\" + saveApn);\n        editor.apply();\n        if (id == null || id.longValue() == INVALID_APN_ID) {\n            deletePreferredApn(subId);\n        } else {\n            // If id is not invalid, and saveApn is true, save the actual APN in PREF_FILE_FULL_APN\n            // too.\n            if (saveApn) {\n                setPreferredApn(id, subId);\n            }\n        }\n    }\n\n    private long getPreferredApnId(int subId, boolean checkApnSp) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        long apnId = sp.getLong(COLUMN_APN_ID + subId, INVALID_APN_ID);\n        if (apnId == INVALID_APN_ID && checkApnSp) {\n            apnId = getPreferredApnIdFromApn(subId);\n            if (apnId != INVALID_APN_ID) {\n                setPreferredApnId(apnId, subId, false);\n            }\n        }\n        return apnId;\n    }\n\n    private int getPreferredApnSetId(int subId) {\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        try {\n            return Integer.parseInt(sp.getString(APN_SET_ID + subId, null));\n        } catch (NumberFormatException e) {\n            return NO_APN_SET_ID;\n        }\n    }\n\n    private void deletePreferredApnId(Context context) {\n        SharedPreferences sp = context.getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sp.edit();\n        editor.clear();\n        editor.apply();\n    }\n\n    private void setPreferredApn(Long id, int subId) {\n        localLog(\"setPreferredApn: _id \" + id + \" subId \" + subId);\n        SQLiteDatabase db = getWritableDatabase();\n        // query all unique fields from id\n        String[] proj = CARRIERS_UNIQUE_FIELDS.toArray(new String[CARRIERS_UNIQUE_FIELDS.size()]);\n\n        Cursor c = db.query(CARRIERS_TABLE, proj, \"_id=\" + id, null, null, null, null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                        Context.MODE_PRIVATE);\n                SharedPreferences.Editor editor = sp.edit();\n                // store values of all unique fields to SP\n                for (String key : CARRIERS_UNIQUE_FIELDS) {\n                    editor.putString(key + subId, c.getString(c.getColumnIndex(key)));\n                    localLog(\"setPreferredApn: \" + key + subId + \":\"\n                            + c.getString(c.getColumnIndex(key)));\n                }\n                // also store the version number\n                editor.putString(DB_VERSION_KEY + subId, \"\" + DATABASE_VERSION);\n                localLog(\"setPreferredApn: \" + DB_VERSION_KEY + subId + \":\" + DATABASE_VERSION);\n                editor.apply();\n            } else {\n                log(\"setPreferredApn: # matching APNs found \" + c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"setPreferredApn: No matching APN found\");\n        }\n    }\n\n    private long getPreferredApnIdFromApn(int subId) {\n        log(\"getPreferredApnIdFromApn: for subId \" + subId);\n        SQLiteDatabase db = getReadableDatabase();\n\n        List<String> whereList = new ArrayList<>();\n        List<String> whereArgsList = new ArrayList<>();\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        for (String key : CARRIERS_UNIQUE_FIELDS) {\n            String value = sp.getString(key + subId, null);\n            if (value == null) {\n                continue;\n            } else {\n                whereList.add(key);\n                whereArgsList.add(value);\n            }\n        }\n        if (whereList.size() == 0) return INVALID_APN_ID;\n\n        String where = TextUtils.join(\"=? and \", whereList) + \"=?\";\n        String[] whereArgs = new String[whereArgsList.size()];\n        whereArgs = whereArgsList.toArray(whereArgs);\n\n        long apnId = INVALID_APN_ID;\n        Cursor c = db.query(CARRIERS_TABLE, new String[]{\"_id\"}, where, whereArgs, null, null,\n                null);\n        if (c != null) {\n            if (c.getCount() == 1) {\n                c.moveToFirst();\n                apnId = c.getInt(c.getColumnIndex(\"_id\"));\n            } else {\n                log(\"getPreferredApnIdFromApn: returning INVALID. # matching APNs found \" +\n                        c.getCount());\n            }\n            c.close();\n        } else {\n            log(\"getPreferredApnIdFromApn: returning INVALID. No matching APN found\");\n        }\n        return apnId;\n    }\n\n    private void deletePreferredApn(int subId) {\n        log(\"deletePreferredApn: for subId \" + subId);\n        SharedPreferences sp = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        if (sp.contains(DB_VERSION_KEY + subId)) {\n            log(\"deletePreferredApn: apn is stored. Deleting it now for subId \" + subId);\n            SharedPreferences.Editor editor = sp.edit();\n            editor.remove(DB_VERSION_KEY + subId);\n            for (String key : CARRIERS_UNIQUE_FIELDS) {\n                editor.remove(key + subId);\n            }\n            editor.apply();\n        }\n    }\n\n    boolean isCallingFromSystemOrPhoneUid() {\n        int callingUid = mInjector.binderGetCallingUid();\n        return callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID\n                // Allow ROOT for testing. ROOT can access underlying DB files anyways.\n                || callingUid == Process.ROOT_UID;\n    }\n\n    void ensureCallingFromSystemOrPhoneUid(String message) {\n        if (!isCallingFromSystemOrPhoneUid()) {\n            throw new SecurityException(message);\n        }\n    }\n\n    @Override\n    public synchronized Bundle call(String method, @Nullable String args, @Nullable Bundle bundle) {\n        if (SubscriptionManager.GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return retrieveSimSpecificSettings();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else if (SubscriptionManager.RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME.equals(method)) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.MODIFY_PHONE_STATE, TAG);\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                restoreSimSpecificSettings(bundle, args);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        } else {\n            loge(\"method is not recognized\");\n        }\n\n        return null;\n    }\n\n    /**\n     * See {@link SubscriptionController#GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME} for details\n     */\n    private Bundle retrieveSimSpecificSettings() {\n        Bundle resultBundle = new Bundle();\n        resultBundle.putByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA,\n                getSimSpecificDataToBackUp());\n\n        return resultBundle;\n    }\n\n    /**\n     * Attempts to restore the backed up sim-specific configs to device. End result is SimInfoDB is\n     * modified to match any backed up configs for the appropriate inserted sims.\n     *\n     * @param bundle containing the data to be restored. If {@code null}, then backed up\n     * data should already be in internal storage and will be retrieved from there.\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void restoreSimSpecificSettings(@Nullable Bundle bundle, @Nullable String iccId) {\n        int restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_UNDEFINED_USE_CASE;\n        if (bundle != null) {\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SUW;\n            if (!writeSimSettingsToInternalStorage(\n                    bundle.getByteArray(SubscriptionManager.KEY_SIM_SPECIFIC_SETTINGS_DATA))) {\n                return;\n            }\n        } else if (iccId != null){\n            restoreCase = TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED;\n        }\n        mergeBackedUpDataToSimInfoDb(restoreCase, iccId);\n    }\n\n    @VisibleForTesting\n    boolean writeSimSettingsToInternalStorage(byte[] data) {\n        AtomicFile atomicFile = new AtomicFile(\n                new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE));\n        FileOutputStream fos = null;\n        try {\n            fos = atomicFile.startWrite();\n            fos.write(data);\n            atomicFile.finishWrite(fos);\n        } catch (IOException e) {\n            if (fos != null) {\n                atomicFile.failWrite(fos);\n            }\n            loge(\"Not able to create internal file with per-sim configs. Failed with error \"\n                    + e);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Attempt to match any SimInfoDB entries to what is in the internal backup data file and\n     * update DB entry with the adequate backed up data.\n     *\n     * @param restoreCase one of the SimSpecificSettingsRestoreMatchingCriteria values defined in\n     * frameworks/proto_logging/stats/enums/telephony/enums.proto\n     * @param iccId of the SIM that a restore is being attempted for. If {@code null}, then try to\n     * restore for all simInfo entries in SimInfoDB\n     */\n    private void mergeBackedUpDataToSimInfoDb(int restoreCase, @Nullable String iccId) {\n        // Get data stored in internal file\n        File file = new File(getContext().getFilesDir(), BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE);\n        if (!file.exists()) {\n            loge(\"internal sim-specific settings backup data file does not exist. \"\n                + \"Aborting restore\");\n            return;\n        }\n\n        AtomicFile atomicFile = new AtomicFile(file);\n        PersistableBundle bundle = null;\n        try (FileInputStream fis = atomicFile.openRead()) {\n            bundle = PersistableBundle.readFromStream(fis);\n        } catch (IOException e) {\n            loge(\"Failed to convert backed up per-sim configs to bundle. Stopping restore. \"\n                + \"Failed with error \" + e);\n            return;\n        }\n\n        String selection = null;\n        String[] selectionArgs = null;\n        if (iccId != null) {\n            selection = Telephony.SimInfo.COLUMN_ICC_ID + \"=?\";\n            selectionArgs = new String[]{iccId};\n        }\n        try (Cursor cursor = query(\n                SubscriptionManager.CONTENT_URI,\n                new String[]{\n                        Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                        Telephony.SimInfo.COLUMN_ICC_ID,\n                        Telephony.SimInfo.COLUMN_NUMBER,\n                        Telephony.SimInfo.COLUMN_CARRIER_ID,\n                        Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE},\n                selection,\n                selectionArgs,\n                ORDER_BY_SUB_ID)) {\n            findAndRestoreAllMatches(bundle.deepCopy(), cursor, restoreCase);\n        }\n    }\n\n    // backedUpDataBundle must to be mutable\n    private void findAndRestoreAllMatches(PersistableBundle backedUpDataBundle, Cursor cursor,\n            int restoreCase) {\n        int[] previouslyRestoredSubIdsArray =\n                backedUpDataBundle.getIntArray(KEY_PREVIOUSLY_RESTORED_SUB_IDS);\n        List<Integer> previouslyRestoredSubIdsList = previouslyRestoredSubIdsArray != null\n                ? Arrays.stream(previouslyRestoredSubIdsArray).boxed().collect(Collectors.toList())\n                : new ArrayList<>();\n        List<Integer> newlyRestoredSubIds = new ArrayList<>();\n        int backupDataFormatVersion = backedUpDataBundle\n                .getInt(KEY_BACKUP_DATA_FORMAT_VERSION, -1);\n\n        Resources r = getContext().getResources();\n        List<String> wfcRestoreBlockedCountries = Arrays.asList(r.getStringArray(\n                    R.array.wfc_restore_blocked_countries));\n\n        while (cursor != null && cursor.moveToNext()) {\n            // Get all the possible matching criteria.\n            int subIdColumnIndex = cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID);\n            int currSubIdFromDb = cursor.getInt(subIdColumnIndex);\n\n            if (previouslyRestoredSubIdsList.contains(currSubIdFromDb)) {\n                // Abort restore for any sims that were previously restored.\n                continue;\n            }\n\n            int iccIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_ICC_ID);\n            String currIccIdFromDb = cursor.getString(iccIdColumnIndex);\n\n            int phoneNumberColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_NUMBER);\n            String currPhoneNumberFromDb = cursor.getString(phoneNumberColumnIndex);\n\n            int carrierIdColumnIndex = cursor.getColumnIndex(Telephony.SimInfo.COLUMN_CARRIER_ID);\n            int currCarrierIdFromDb = cursor.getInt(carrierIdColumnIndex);\n\n            int isoCountryCodeColumnIndex= cursor.getColumnIndex(\n                    Telephony.SimInfo.COLUMN_ISO_COUNTRY_CODE);\n            String isoCountryCodeFromDb = cursor.getString(isoCountryCodeColumnIndex);\n\n\n            // Find the best match from backed up data.\n            SimRestoreMatch bestRestoreMatch = null;\n            for (int rowNum = 0; true; rowNum++) {\n                PersistableBundle currRow = backedUpDataBundle.getPersistableBundle(\n                        KEY_SIMINFO_DB_ROW_PREFIX + rowNum);\n                if (currRow == null) {\n                    break;\n                }\n\n                SimRestoreMatch currSimRestoreMatch = new SimRestoreMatch(\n                        currIccIdFromDb, currCarrierIdFromDb, currPhoneNumberFromDb,\n                        isoCountryCodeFromDb, wfcRestoreBlockedCountries, currRow,\n                        backupDataFormatVersion);\n\n                if (currSimRestoreMatch == null) {\n                    continue;\n                }\n\n                /*\n                 * The three following match cases are ordered by descending priority:\n                 *   - Match by iccId: If iccId of backup data matches iccId of any inserted sims,\n                 *       we confidently restore all configs.\n                 *   - Match phone number and carrierId: If both of these values match, we\n                 *       confidently restore all configs.\n                 *   - Match only carrierId: If only carrierId of backup data matches an inserted\n                 *       sim, we only restore non-sensitive configs.\n                 *\n                 * Having a matchScore value for each match allows us to control these priorities.\n                 */\n                if (bestRestoreMatch == null || (currSimRestoreMatch.getMatchScore()\n                        >= bestRestoreMatch.getMatchScore()\n                        && currSimRestoreMatch.getContentValues() != null)) {\n                    bestRestoreMatch = currSimRestoreMatch;\n                }\n            }\n\n            if (bestRestoreMatch != null) {\n                ContentValues newContentValues = bestRestoreMatch.getContentValues();\n                if (bestRestoreMatch.getMatchScore() != 0 && newContentValues != null) {\n                    if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SUW) {\n                        update(SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    } else if (restoreCase == TelephonyProtoEnums.SIM_RESTORE_CASE_SIM_INSERTED) {\n                        Uri simInsertedRestoreUri = Uri.withAppendedPath(\n                                SubscriptionManager.SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI,\n                                SIM_INSERTED_RESTORE_URI_SUFFIX);\n                        update(simInsertedRestoreUri,\n                                newContentValues,\n                                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                                new String[]{Integer.toString(currSubIdFromDb)});\n                    }\n                    log(\"Restore of inserterd SIM's sim-specific settings has been successfully \"\n                            + \"completed.\");\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_SUCCESS,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                    newlyRestoredSubIds.add(currSubIdFromDb);\n                } else {\n                    /* If this block was reached because ContentValues was null, that means the\n                    database schema was newer during backup than during restore. We consider this\n                    a no-match to avoid updating columns that don't exist */\n                    TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                            TelephonyProtoEnums.SIM_RESTORE_RESULT_NONE_MATCH,\n                            restoreCase, bestRestoreMatch.getMatchingCriteriaForLogging());\n                }\n            } else {\n                log(\"No matching SIM in backup data. SIM-specific settings not restored.\");\n                TelephonyStatsLog.write(TelephonyStatsLog.SIM_SPECIFIC_SETTINGS_RESTORED,\n                        TelephonyProtoEnums.SIM_RESTORE_RESULT_ZERO_SIM_IN_BACKUP,\n                        restoreCase, TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE);\n            }\n        }\n\n        // Update the internal file with subIds that we just restored.\n        previouslyRestoredSubIdsList.addAll(newlyRestoredSubIds);\n        backedUpDataBundle.putIntArray(\n                KEY_PREVIOUSLY_RESTORED_SUB_IDS,\n                previouslyRestoredSubIdsList.stream().mapToInt(i -> i).toArray());\n        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            backedUpDataBundle.writeToStream(outputStream);\n            writeSimSettingsToInternalStorage(outputStream.toByteArray());\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Not storing which subIds were \"\n                    + \"restored\");\n        }\n    }\n\n    private static class SimRestoreMatch {\n\n        private Set<Integer> matches = new ArraySet<>();\n        private int subId;\n        private ContentValues contentValues;\n        private int matchingCriteria;\n        private int matchScore;\n\n        private static final int ICCID_MATCH = 1;\n        private static final int PHONE_NUMBER_MATCH = 2;\n        private static final int CARRIER_ID_MATCH = 3;\n\n        public SimRestoreMatch(String iccIdFromDb, int carrierIdFromDb,\n                String phoneNumberFromDb, String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries,\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion) {\n            subId = backedUpSimInfoEntry.getInt(\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID,\n                DEFAULT_INT_COLUMN_VALUE);\n            String iccIdFromBackup = backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_ICC_ID,\n                  \"\");\n            String phoneNumberFromBackup = backedUpSimInfoEntry.getString(\n                  Telephony.SimInfo.COLUMN_NUMBER, \"\");\n            int carrierIdFromBackup = backedUpSimInfoEntry.getInt(\n                  Telephony.SimInfo.COLUMN_CARRIER_ID,\n                  TelephonyManager.UNKNOWN_CARRIER_ID);\n\n\n            // find all matching fields\n            if (iccIdFromDb != null && iccIdFromDb.equals(iccIdFromBackup)\n                    && !iccIdFromBackup.isEmpty()) {\n                matches.add(ICCID_MATCH);\n            }\n            if (carrierIdFromDb == carrierIdFromBackup\n                    && carrierIdFromBackup != TelephonyManager.UNKNOWN_CARRIER_ID) {\n                matches.add(CARRIER_ID_MATCH);\n            }\n            if (phoneNumberFromDb != null && phoneNumberFromDb.equals(phoneNumberFromBackup)\n                    && !phoneNumberFromBackup.isEmpty()) {\n                matches.add(PHONE_NUMBER_MATCH);\n            }\n\n            contentValues = convertBackedUpDataToContentValues(\n                    backedUpSimInfoEntry, backupDataFormatVersion, isoCountryCodeFromDb,\n                    wfcRestoreBlockedCountries);\n            matchScore = calculateMatchScore();\n            matchingCriteria = calculateMatchingCriteria();\n        }\n\n        public int getSubId() {\n            return subId;\n        }\n\n        public ContentValues getContentValues() {\n            return contentValues;\n        }\n\n        public int getMatchScore() {\n            return matchScore;\n        }\n\n        private int calculateMatchScore() {\n            int score = 0;\n\n            if (matches.contains(ICCID_MATCH)) {\n                score += 100;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    score += 10;\n                } else {\n                    score += 1;\n                }\n            }\n\n            return score;\n        }\n\n        public int getMatchingCriteriaForLogging() {\n            return matchingCriteria;\n        }\n\n        private int calculateMatchingCriteria() {\n            if (matches.contains(ICCID_MATCH)) {\n                return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_ICCID;\n            }\n            if (matches.contains(CARRIER_ID_MATCH)) {\n                if (matches.contains(PHONE_NUMBER_MATCH)) {\n                    return TelephonyProtoEnums\n                        .SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_AND_PHONE_NUMBER;\n                } else {\n                    return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_CARRIER_ID_ONLY;\n                }\n            }\n            return TelephonyProtoEnums.SIM_RESTORE_MATCHING_CRITERIA_NONE;\n        }\n\n        private ContentValues convertBackedUpDataToContentValues(\n                PersistableBundle backedUpSimInfoEntry, int backupDataFormatVersion,\n                String isoCountryCodeFromDb,\n                List<String> wfcRestoreBlockedCountries) {\n            if (DATABASE_VERSION != 57 << 16) {\n                throw new AssertionError(\"The database schema has been updated which might make \"\n                    + \"the format of #BACKED_UP_SIM_SPECIFIC_SETTINGS_FILE outdated. Make sure to \"\n                    + \"1) review whether any of the columns in #SIM_INFO_COLUMNS_TO_BACKUP have \"\n                    + \"been migrated or deleted, 2) add the new column name into one of those \"\n                    + \"maps, 3) add migration code in this method as necessary, and 4) update the \"\n                    + \"version check in this if statement.\");\n            }\n            ContentValues contentValues = new ContentValues();\n            // Don't restore anything if restoring from a newer version of the current database.\n            if (backupDataFormatVersion > DATABASE_VERSION) {\n                return null;\n            }\n\n            /* Any migration logic should be placed under this comment block.\n             * ex:\n             *   if (backupDataFormatVersion >= 48 << 19) {\n             *     contentValues.put(NEW_COLUMN_NAME_2,\n             *         backedUpSimInfoEntry.getInt( OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else if (backupDataFormatVersion >= 48 << 17) {\n             *     contentValues.put(NEW_COLUMN_NAME_1,\n             *         backedUpSimInfoEntry.getInt(OLD_COLUMN_NAME, DEFAULT_INT_COLUMN_VALUE));\n             *     ...\n             *   } else {\n             *     // The values from the first format of backup ever available.\n             *     contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *         backedUpSimInfoEntry.getInt(\n             *             Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n             *             DEFAULT_INT_COLUMN_VALUE));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n             *         backedUpSimInfoEntry.getString(\n             *              Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED, \"\"));\n             *     contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               backedUpSimInfoEntry.getString(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n             *               \"\"));\n             *     ...\n             *   }\n             *\n             * Also make sure to add necessary removal of sensitive settings in\n             * polishContentValues(ContentValues contentValues).\n             */\n            if (backupDataFormatVersion >= 57 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_USAGE_SETTING,\n                                SubscriptionManager.USAGE_SETTING_UNKNOWN));\n            }\n            if (backupDataFormatVersion >= 52 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 51 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                        backedUpSimInfoEntry.getString(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING_SELECTED_CONTACTS,\n                                DEFAULT_STRING_COLUMN_VALUE));\n            }\n            if (backupDataFormatVersion >= 50 << 16) {\n                contentValues.put(Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_D2D_STATUS_SHARING,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_VT_IMS_ENABLED,\n                            DEFAULT_INT_COLUMN_VALUE));\n            if (isoCountryCodeFromDb != null\n                    && !wfcRestoreBlockedCountries\n                            .contains(isoCountryCodeFromDb.toLowerCase())) {\n                // Don't restore COLUMN_WFC_IMS_ENABLED if the sim is from one of the countries that\n                // requires WFC entitlement.\n                contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                        backedUpSimInfoEntry.getInt(\n                                Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED,\n                                DEFAULT_INT_COLUMN_VALUE));\n            }\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n            contentValues.put(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                    backedUpSimInfoEntry.getInt(\n                            Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE,\n                            DEFAULT_INT_COLUMN_VALUE));\n\n            return polishContentValues(contentValues);\n        }\n\n        private ContentValues polishContentValues(ContentValues contentValues) {\n            /* Remove any values that weren't found in the backup file. These were set to defaults\n            in #convertBackedUpDataToContentValues(). */\n            for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n                String columnName = column.getKey();\n\n                if (!contentValues.containsKey(columnName)) {\n                    continue;\n                }\n\n                int columnType = column.getValue();\n                if (columnType == Cursor.FIELD_TYPE_INTEGER\n                        && DEFAULT_INT_COLUMN_VALUE == contentValues.getAsInteger(columnName)) {\n                    contentValues.remove(columnName);\n                } else if (columnType == Cursor.FIELD_TYPE_STRING && contentValues\n                        .getAsString(columnName).equals(DEFAULT_STRING_COLUMN_VALUE)) {\n                    contentValues.remove(columnName);\n                }\n            }\n\n            if (matches.contains(ICCID_MATCH)) {\n                return contentValues;\n            } else if (matches.contains(CARRIER_ID_MATCH)) {\n                if (!matches.contains(PHONE_NUMBER_MATCH)) {\n                    // Low confidence match should not restore sensitive configs.\n                    if (contentValues.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        contentValues.remove(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED);\n                    }\n                }\n                return contentValues;\n            }\n            return null;\n        }\n\n    }\n\n    /**\n     * Retrieves data from all columns in SimInfoDB of backup/restore interest.\n     *\n     * @return data of interest from SimInfoDB as a byte array.\n     */\n    private byte[] getSimSpecificDataToBackUp() {\n        String[] projection = SIM_INFO_COLUMNS_TO_BACKUP.keySet()\n                .toArray(new String[SIM_INFO_COLUMNS_TO_BACKUP.size()]);\n\n        try (Cursor cursor = query(SubscriptionManager.CONTENT_URI, projection, null, null, null);\n                ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            PersistableBundle topLevelBundle = new PersistableBundle();\n            topLevelBundle.putInt(KEY_BACKUP_DATA_FORMAT_VERSION, DATABASE_VERSION);\n            for (int rowNum = 0; cursor != null && cursor.moveToNext(); rowNum++) {\n                PersistableBundle rowBundle = convertSimInfoDbEntryToPersistableBundle(cursor);\n                topLevelBundle.putPersistableBundle(KEY_SIMINFO_DB_ROW_PREFIX + rowNum, rowBundle);\n            }\n            topLevelBundle.writeToStream(outputStream);\n            return outputStream.toByteArray();\n        } catch (IOException e) {\n            loge(\"Not able to convert SimInfoDB to byte array. Returning empty byte array\");\n            return new byte[0];\n        }\n    }\n\n    private static PersistableBundle convertSimInfoDbEntryToPersistableBundle(Cursor cursor) {\n        PersistableBundle bundle = new PersistableBundle();\n        for (Map.Entry<String, Integer> column : SIM_INFO_COLUMNS_TO_BACKUP.entrySet()) {\n            String columnName = column.getKey();\n            int columnType = column.getValue();\n            int columnIndex = cursor.getColumnIndex(columnName);\n            if (columnType == Cursor.FIELD_TYPE_INTEGER) {\n                bundle.putInt(columnName, cursor.getInt(columnIndex));\n            } else if (columnType == Cursor.FIELD_TYPE_STRING) {\n                bundle.putString(columnName, cursor.getString(columnIndex));\n            } else {\n                throw new AssertionError(\"SimInfoDB column to be backed up is not recognized. Make \"\n                    + \"sure to properly add the desired colum name and value type to \"\n                    + \"SIM_INFO_COLUMNS_TO_BACKUP.\");\n            }\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public synchronized Cursor query(Uri url, String[] projectionIn, String selection,\n            String[] selectionArgs, String sort) {\n        if (VDBG) log(\"query: url=\" + url + \", projectionIn=\" + projectionIn + \", selection=\"\n                + selection + \"selectionArgs=\" + selectionArgs + \", sort=\" + sort);\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String subIdString;\n        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true); // a little protection from injection attacks\n        qb.setTables(CARRIERS_TABLE);\n\n        List<String> constraints = new ArrayList<String>();\n\n        int match = s_urlMatcher.match(url);\n        checkPermissionCompat(match, projectionIn);\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID: {\n                // The behaves exactly same as URL_SIM_APN_LIST_ID.\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            case URL_TELEPHONY: {\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_CURRENT: {\n                constraints.add(\"current IS NOT NULL\");\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                // do not ignore the selection since MMS may use it.\n                //selection = null;\n                break;\n            }\n\n            case URL_ID: {\n                constraints.add(\"_id = \" + url.getPathSegments().get(1));\n                constraints.add(IS_NOT_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            //intentional fall through from above case\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE: {\n                constraints.add(\"_id = \" + getPreferredApnId(subId, true));\n                break;\n            }\n\n            case URL_PREFERAPNSET_USING_SUBID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // TODO b/74213956 turn this back on once insertion includes correct sub id\n                // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n            }\n            // intentional fall through from above case\n            case URL_PREFERAPNSET: {\n                final int set = getPreferredApnSetId(subId);\n                if (set == NO_APN_SET_ID) {\n                    return null;\n                }\n                constraints.add(APN_SET_ID + \"=\" + set);\n                qb.appendWhere(TextUtils.join(\" AND \", constraints));\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n                // DPC query only returns DPC records.\n                constraints.add(IS_OWNED_BY_DPC);\n                break;\n            }\n\n            case URL_FILTERED_ID:\n            case URL_FILTERED_USING_SUBID: {\n                String idString = url.getLastPathSegment();\n                if (match == URL_FILTERED_ID) {\n                    constraints.add(\"_id = \" + idString);\n                } else {\n                    try {\n                        subId = Integer.parseInt(idString);\n                        // TODO b/74213956 turn this back on once insertion includes correct sub id\n                        // constraints.add(SUBSCRIPTION_ID + \"=\" + subIdString);\n                    } catch (NumberFormatException e) {\n                        loge(\"NumberFormatException\" + e);\n                        return null;\n                    }\n                }\n            }\n            //intentional fall through from above case\n            case URL_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    constraints.add(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    constraints.add(IS_NOT_OWNED_BY_DPC);\n                }\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                MatrixCursor cursor = new MatrixCursor(new String[]{ENFORCED_KEY});\n                cursor.addRow(new Object[]{isManagedApnEnforced() ? 1 : 0});\n                return cursor;\n            }\n\n            case URL_SIMINFO: {\n                qb.setTables(SIMINFO_TABLE);\n                break;\n            }\n            case URL_SIM_APN_LIST_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST: {\n                qb.appendWhere(IS_NOT_OWNED_BY_DPC);\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                        sort, subId);\n            }\n\n            case URL_SIM_APN_LIST_FILTERED_ID: {\n                subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return null;\n                }\n            }\n            //intentional fall through from above case\n            case URL_SIM_APN_LIST_FILTERED: {\n                if (isManagedApnEnforced()) {\n                    // If enforced, return DPC records only.\n                    qb.appendWhereStandalone(IS_OWNED_BY_DPC);\n                } else {\n                    // Otherwise return non-DPC records only.\n                    qb.appendWhereStandalone(IS_NOT_OWNED_BY_DPC);\n                }\n                return getSubscriptionMatchingAPNList(qb, projectionIn, selection, selectionArgs,\n                    sort, subId);\n            }\n\n            default: {\n                return null;\n            }\n        }\n\n        // appendWhere doesn't add ANDs so we do it ourselves\n        if (constraints.size() > 0) {\n            qb.appendWhere(TextUtils.join(\" AND \", constraints));\n        }\n\n        SQLiteDatabase db = getReadableDatabase();\n        Cursor ret = null;\n        try {\n            // Exclude entries marked deleted\n            if (CARRIERS_TABLE.equals(qb.getTables())) {\n                if (TextUtils.isEmpty(selection)) {\n                    selection = \"\";\n                } else {\n                    selection += \" and \";\n                }\n                selection += IS_NOT_USER_DELETED + \" and \" +\n                        IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                        IS_NOT_CARRIER_DELETED + \" and \" +\n                        IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;\n                if (VDBG) log(\"query: selection modified to \" + selection);\n            }\n            ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);\n        } catch (SQLException e) {\n            loge(\"got exception when querying: \" + e);\n        }\n        if (ret != null)\n            ret.setNotificationUri(getContext().getContentResolver(), url);\n        return ret;\n    }\n\n    /**\n     * This method syncs PREF_FILE_FULL_APN with the db based on the current preferred apn ids.\n     */\n    private void updatePreferredApns() {\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n\n        Map<String, ?> allPrefApnId = spApn.getAll();\n        for (String key : allPrefApnId.keySet()) {\n            if (key.startsWith(COLUMN_APN_ID)) {\n                int subId;\n                try {\n                    subId = Integer.parseInt(key.substring(COLUMN_APN_ID.length()));\n                } catch (NumberFormatException e) {\n                    loge(\"updatePreferredApns: NumberFormatException for key=\" + key);\n                    continue;\n                }\n                long preferredApnId = getPreferredApnId(subId, false);\n                if (preferredApnId != INVALID_APN_ID) {\n                    setPreferredApn(preferredApnId, subId);\n                }\n            }\n        }\n    }\n\n    /**\n     * To find the current sim APN. Query APN based on {MCC, MNC, MVNO} and {Carrier_ID}.\n     *\n     * There has three steps:\n     * 1. Query the APN based on { MCC, MNC, MVNO } and if has results jump to step 3, else jump to\n     *    step 2.\n     * 2. Fallback to query the parent APN that query based on { MCC, MNC }.\n     * 3. Append the result with the APN that query based on { Carrier_ID }\n     */\n    private Cursor getSubscriptionMatchingAPNList(SQLiteQueryBuilder qb, String[] projectionIn,\n            String selection, String[] selectionArgs, String sort, int subId) {\n        Cursor ret;\n        Context context = getContext();\n        SubscriptionManager subscriptionManager = (SubscriptionManager) context\n                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);\n        if (!subscriptionManager.isActiveSubscriptionId(subId)) {\n            return null;\n        }\n\n        final TelephonyManager tm = ((TelephonyManager) context\n                .getSystemService(Context.TELEPHONY_SERVICE))\n                .createForSubscriptionId(subId);\n        SQLiteDatabase db = getReadableDatabase();\n        String mccmnc = tm.getSimOperator();\n        int carrierId = tm.getSimSpecificCarrierId();\n\n        qb.appendWhereStandalone(IS_NOT_USER_DELETED + \" and \" +\n                IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + \" and \" +\n                IS_NOT_CARRIER_DELETED + \" and \" +\n                IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML);\n\n        // For query db one time, append all conditions in one selection and separate results after\n        // the query is completed. IMSI has special match rule, so just query the MCC / MNC and\n        // filter the MVNO by ourselves\n        qb.appendWhereStandalone(NUMERIC + \" = '\" + mccmnc + \"' OR \" +\n                CARRIER_ID + \" = '\" + carrierId + \"'\");\n\n        ret = qb.query(db, null, selection, selectionArgs, null, null, sort);\n        if (ret == null) {\n            loge(\"query current APN but cursor is null.\");\n            return null;\n        }\n\n        if (DBG) log(\"match current APN size:  \" + ret.getCount());\n\n        String[] columnNames = projectionIn != null ? projectionIn : ret.getColumnNames();\n        MatrixCursor currentCursor = new MatrixCursor(columnNames);\n        MatrixCursor parentCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdCursor = new MatrixCursor(columnNames);\n        MatrixCursor carrierIdNonMatchingMNOCursor = new MatrixCursor(columnNames);\n\n        int numericIndex = ret.getColumnIndex(NUMERIC);\n        int mvnoIndex = ret.getColumnIndex(MVNO_TYPE);\n        int mvnoDataIndex = ret.getColumnIndex(MVNO_MATCH_DATA);\n        int carrierIdIndex = ret.getColumnIndex(CARRIER_ID);\n\n        // Separate the result into MatrixCursor\n        while (ret.moveToNext()) {\n            List<String> data = new ArrayList<>();\n            for (String column : columnNames) {\n                data.add(ret.getString(ret.getColumnIndex(column)));\n            }\n\n            boolean isCurrentSimOperator = false;\n            if (!TextUtils.isEmpty(ret.getString(numericIndex))) {\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    isCurrentSimOperator = tm.matchesCurrentSimOperator(\n                            ret.getString(numericIndex),\n                            getMvnoTypeIntFromString(ret.getString(mvnoIndex)),\n                            ret.getString(mvnoDataIndex));\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n\n            boolean isMVNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && isCurrentSimOperator;\n            boolean isMNOAPN = !TextUtils.isEmpty(ret.getString(numericIndex))\n                    && ret.getString(numericIndex).equals(mccmnc)\n                    && TextUtils.isEmpty(ret.getString(mvnoIndex));\n            boolean isCarrierIdAPN = !TextUtils.isEmpty(ret.getString(carrierIdIndex))\n                    && ret.getString(carrierIdIndex).equals(String.valueOf(carrierId))\n                    && carrierId != TelephonyManager.UNKNOWN_CARRIER_ID;\n\n            if (isMVNOAPN) {\n                // 1. The APN that query based on legacy SIM MCC/MCC and MVNO\n                currentCursor.addRow(data);\n            } else if (isMNOAPN) {\n                // 2. The APN that query based on SIM MCC/MNC\n                parentCursor.addRow(data);\n            } else if (isCarrierIdAPN) {\n                // The APN that query based on carrier Id (not include the MVNO or MNO APN)\n                if (TextUtils.isEmpty(ret.getString(numericIndex))) {\n                    carrierIdCursor.addRow(data);\n                } else {\n                    carrierIdNonMatchingMNOCursor.addRow(data);\n                }\n            }\n        }\n        ret.close();\n\n        MatrixCursor result;\n        if (currentCursor.getCount() > 0) {\n            if (DBG) log(\"match MVNO APN: \" + currentCursor.getCount());\n            result = currentCursor;\n        } else if (parentCursor.getCount() > 0) {\n            if (DBG) log(\"match MNO APN: \" + parentCursor.getCount());\n            result = parentCursor;\n        } else {\n            if (DBG) {\n                log(\"No MVNO, MNO and no MCC/MNC match, but we have match/matches with the \" +\n                        \"same carrier id, count: \" + carrierIdNonMatchingMNOCursor.getCount());\n            }\n            result = carrierIdNonMatchingMNOCursor;\n        }\n\n        if (DBG) log(\"match carrier id APN: \" + carrierIdCursor.getCount());\n        appendCursorData(result, carrierIdCursor);\n        return result;\n    }\n\n    private static void appendCursorData(@NonNull MatrixCursor from, @NonNull MatrixCursor to) {\n        while (to.moveToNext()) {\n            List<Object> data = new ArrayList<>();\n            for (String column : to.getColumnNames()) {\n                int index = to.getColumnIndex(column);\n                switch (to.getType(index)) {\n                    case Cursor.FIELD_TYPE_INTEGER:\n                        data.add(to.getInt(index));\n                        break;\n                    case Cursor.FIELD_TYPE_FLOAT:\n                        data.add(to.getFloat(index));\n                        break;\n                    case Cursor.FIELD_TYPE_BLOB:\n                        data.add(to.getBlob(index));\n                        break;\n                    case Cursor.FIELD_TYPE_STRING:\n                    case Cursor.FIELD_TYPE_NULL:\n                        data.add(to.getString(index));\n                        break;\n                }\n            }\n            from.addRow(data);\n        }\n    }\n\n    @Override\n    public String getType(Uri url)\n    {\n        switch (s_urlMatcher.match(url)) {\n        case URL_TELEPHONY:\n        case URL_TELEPHONY_USING_SUBID:\n            return \"vnd.android.cursor.dir/telephony-carrier\";\n\n        case URL_ID:\n        case URL_FILTERED_ID:\n        case URL_FILTERED_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        case URL_PREFERAPN_USING_SUBID:\n        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n        case URL_PREFERAPN:\n        case URL_PREFERAPN_NO_UPDATE:\n        case URL_PREFERAPNSET:\n        case URL_PREFERAPNSET_USING_SUBID:\n            return \"vnd.android.cursor.item/telephony-carrier\";\n\n        default:\n            throw new IllegalArgumentException(\"Unknown URL \" + url);\n        }\n    }\n\n    /**\n     * Insert an array of ContentValues and call notifyChange at the end.\n     */\n    @Override\n    public synchronized int bulkInsert(Uri url, ContentValues[] values) {\n        return unsynchronizedBulkInsert(url, values);\n    }\n\n    /**\n     * Do a bulk insert while inside a synchronized function. This is typically not safe and should\n     * only be done when you are sure there will be no conflict.\n     */\n    private int unsynchronizedBulkInsert(Uri url, ContentValues[] values) {\n        int count = 0;\n        boolean notify = false;\n        for (ContentValues value : values) {\n            Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, value);\n            if (rowAndNotify.first != null) {\n                count++;\n            }\n            if (rowAndNotify.second == true) {\n                notify = true;\n            }\n        }\n        if (notify) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return count;\n    }\n\n    @Override\n    public synchronized Uri insert(Uri url, ContentValues initialValues) {\n        Pair<Uri, Boolean> rowAndNotify = insertSingleRow(url, initialValues);\n        if (rowAndNotify.second) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n        return rowAndNotify.first;\n    }\n\n    /**\n     * Internal insert function to prevent code duplication for URL_TELEPHONY and URL_DPC.\n     *\n     * @param values the value that caller wants to insert\n     * @return a pair in which the first element refers to the Uri for the row inserted, the second\n     *         element refers to whether sends out nofitication.\n     */\n    private Pair<Uri, Boolean> insertRowWithValue(ContentValues values) {\n        Uri result = null;\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n\n        try {\n            // Abort on conflict of unique fields and attempt merge\n            long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                    SQLiteDatabase.CONFLICT_ABORT);\n            if (rowID >= 0) {\n                result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                notify = true;\n            }\n            if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n        } catch (SQLException e) {\n            log(\"insert: exception \" + e);\n            // Insertion failed which could be due to a conflict. Check if that is the case\n            // and merge the entries\n            Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n            if (oldRow != null) {\n                ContentValues mergedValues = new ContentValues();\n                mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                        mergedValues, false, getContext());\n                oldRow.close();\n                notify = true;\n            }\n        }\n        return Pair.create(result, notify);\n    }\n\n    private Pair<Uri, Boolean> insertSingleRow(Uri url, ContentValues initialValues) {\n        Uri result = null;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(initialValues);\n\n        boolean notify = false;\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                values = setDefaultValue(values);\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Owned_by should be others if inserted via general uri.\n                values.put(OWNED_BY, OWNED_BY_OTHERS);\n\n                Pair<Uri, Boolean> ret = insertRowWithValue(values);\n                result = ret.first;\n                notify = ret.second;\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // zero out the previous operator\n                db.update(CARRIERS_TABLE, s_currentNullMap, CURRENT + \"!=0\", null);\n\n                String numeric = initialValues.getAsString(NUMERIC);\n                int updated = db.update(CARRIERS_TABLE, s_currentSetMap,\n                        NUMERIC + \" = '\" + numeric + \"'\", null);\n\n                if (updated > 0)\n                {\n                    if (VDBG) log(\"Setting numeric '\" + numeric + \"' to be the current operator\");\n                }\n                else\n                {\n                    loge(\"Failed setting numeric '\" + numeric + \"' to the current operator\");\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    return Pair.create(result, notify);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (initialValues != null) {\n                    if(initialValues.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(initialValues.getAsLong(COLUMN_APN_ID), subId, true);\n                        notify = true;\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC called from non SYSTEM_UID.\");\n\n                ContentValues values;\n                if (initialValues != null) {\n                    values = new ContentValues(initialValues);\n                } else {\n                    values = new ContentValues();\n                }\n\n                // Owned_by should be DPC if inserted via URL_DPC.\n                values.put(OWNED_BY, OWNED_BY_DPC);\n                // DPC records should not be user editable.\n                values.put(USER_EDITABLE, false);\n\n                final long rowID = db.insertWithOnConflict(CARRIERS_TABLE, null, values,\n                        SQLiteDatabase.CONFLICT_IGNORE);\n                if (rowID >= 0) {\n                    result = ContentUris.withAppendedId(CONTENT_URI, rowID);\n                    notify = true;\n                }\n                if (VDBG) log(\"insert: inserted \" + values.toString() + \" rowID = \" + rowID);\n\n                break;\n            }\n\n            case URL_SIMINFO: {\n               long id = db.insert(SIMINFO_TABLE, null, initialValues);\n               result = ContentUris.withAppendedId(Telephony.SimInfo.CONTENT_URI, id);\n               break;\n            }\n        }\n\n        return Pair.create(result, notify);\n    }\n\n    @Override\n    public synchronized int delete(Uri url, String where, String[] whereArgs) {\n        int count = 0;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n        String userOrCarrierEdited = \") and (\" +\n                IS_USER_EDITED +  \" or \" +\n                IS_CARRIER_EDITED + \")\";\n        String notUserOrCarrierEdited = \") and (\" +\n                IS_NOT_USER_EDITED +  \" and \" +\n                IS_NOT_CARRIER_EDITED + \")\";\n        String unedited = \") and \" + IS_UNEDITED;\n        ContentValues cv = new ContentValues();\n        cv.put(EDITED_STATUS, USER_DELETED);\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_DELETE:\n            {\n                // Delete preferred APN for all subIds\n                deletePreferredApnId(getContext());\n                // Delete unedited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + unedited + \" and \" +\n                        IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                // FIXME use subId in query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE, \"(\" + where + userOrCarrierEdited\n                        + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv, \"(\" + where +\n                        notUserOrCarrierEdited + \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs);\n                break;\n            }\n\n            case URL_ID:\n            {\n                // Delete user/carrier edited entries\n                count = db.delete(CARRIERS_TABLE,\n                        \"(\" + _ID + \"=?\" + userOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                // Otherwise mark as user deleted instead of deleting\n                count += db.update(CARRIERS_TABLE, cv,\n                        \"(\" + _ID + \"=?\" + notUserOrCarrierEdited +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        new String[]{url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_RESTOREAPN_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            // intentional fall through from above case\n\n            case URL_RESTOREAPN: {\n                count = 1;\n                restoreDefaultAPN(subId);\n                getContext().getContentResolver().notifyChange(\n                        Uri.withAppendedPath(CONTENT_URI, \"restore/subId/\" + subId), null,\n                        true, UserHandle.USER_ALL);\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID: {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n            //intentional fall through from above case\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                setPreferredApnId((long)INVALID_APN_ID, subId, true);\n                if ((match == URL_PREFERAPN) || (match == URL_PREFERAPN_USING_SUBID)) count = 1;\n                break;\n            }\n\n            case URL_DPC_ID: {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                // Only delete if owned by DPC.\n                count = db.delete(CARRIERS_TABLE, \"(\" + _ID + \"=?)\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() });\n                break;\n            }\n\n            case URL_SIMINFO: {\n                count = db.delete(SIMINFO_TABLE, where, whereArgs);\n                break;\n            }\n\n            case URL_UPDATE_DB: {\n                updateApnDb();\n                count = 1;\n                break;\n            }\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot delete that URL: \" + url);\n            }\n        }\n\n        if (count > 0) {\n            getContext().getContentResolver().notifyChange(CONTENT_URI, null,\n                    true, UserHandle.USER_ALL);\n        }\n\n        return count;\n    }\n\n    @Override\n    public synchronized int update(Uri url, ContentValues values, String where, String[] whereArgs)\n    {\n        int count = 0;\n        int uriType = URL_UNKNOWN;\n        int subId = SubscriptionManager.getDefaultSubscriptionId();\n\n        int match = s_urlMatcher.match(url);\n        checkPermission(match);\n        syncBearerBitmaskAndNetworkTypeBitmask(values);\n\n        SQLiteDatabase db = getWritableDatabase();\n        switch (match)\n        {\n            case URL_TELEPHONY_USING_SUBID:\n            {\n                 String subIdString = url.getLastPathSegment();\n                 try {\n                     subId = Integer.parseInt(subIdString);\n                 } catch (NumberFormatException e) {\n                     loge(\"NumberFormatException\" + e);\n                     throw new IllegalArgumentException(\"Invalid subId \" + url);\n                 }\n                 if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_TELEPHONY:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC, whereArgs,\n                        SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_CURRENT_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                //FIXME use subId in the query\n            }\n            //intentional fall through from above case\n\n            case URL_CURRENT:\n            {\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n                // Replace on conflict so that if same APN is present in db with edited\n                // as UNEDITED or USER/CARRIER_DELETED, it is replaced with\n                // edited USER/CARRIER_EDITED\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values, where +\n                                \" and \" + IS_NOT_OWNED_BY_DPC,\n                        whereArgs, SQLiteDatabase.CONFLICT_REPLACE);\n                break;\n            }\n\n            case URL_ID:\n            {\n                String rowID = url.getLastPathSegment();\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                if (!values.containsKey(EDITED_STATUS)) {\n                    values.put(EDITED_STATUS, CARRIER_EDITED);\n                }\n\n                try {\n                    count = db.updateWithOnConflict(CARRIERS_TABLE, values, _ID + \"=?\" + \" and \" +\n                            IS_NOT_OWNED_BY_DPC, new String[] { rowID },\n                            SQLiteDatabase.CONFLICT_ABORT);\n                } catch (SQLException e) {\n                    // Update failed which could be due to a conflict. Check if that is\n                    // the case and merge the entries\n                    log(\"update: exception \" + e);\n                    Cursor oldRow = selectConflictingRow(db, CARRIERS_TABLE, values);\n                    if (oldRow != null) {\n                        ContentValues mergedValues = new ContentValues();\n                        mergeFieldsAndUpdateDb(db, CARRIERS_TABLE, oldRow, values,\n                                mergedValues, false, getContext());\n                        oldRow.close();\n                        db.delete(CARRIERS_TABLE, _ID + \"=?\" + \" and \" + IS_NOT_OWNED_BY_DPC,\n                                new String[] { rowID });\n                    }\n                }\n                break;\n            }\n\n            case URL_PREFERAPN_USING_SUBID:\n            case URL_PREFERAPN_NO_UPDATE_USING_SUBID:\n            {\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n            }\n\n            case URL_PREFERAPN:\n            case URL_PREFERAPN_NO_UPDATE:\n            {\n                if (values != null) {\n                    if (values.containsKey(COLUMN_APN_ID)) {\n                        setPreferredApnId(values.getAsLong(COLUMN_APN_ID), subId, true);\n                        if ((match == URL_PREFERAPN) ||\n                                (match == URL_PREFERAPN_USING_SUBID)) {\n                            count = 1;\n                        }\n                    }\n                }\n                break;\n            }\n\n            case URL_DPC_ID:\n            {\n                ensureCallingFromSystemOrPhoneUid(\"URL_DPC_ID called from non SYSTEM_UID.\");\n\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.updateWithOnConflict(CARRIERS_TABLE, values,\n                        _ID + \"=?\" + \" and \" + IS_OWNED_BY_DPC,\n                        new String[] { url.getLastPathSegment() }, SQLiteDatabase.CONFLICT_IGNORE);\n                break;\n            }\n\n            case URL_ENFORCE_MANAGED: {\n                ensureCallingFromSystemOrPhoneUid(\n                        \"URL_ENFORCE_MANAGED called from non SYSTEM_UID.\");\n                if (values != null) {\n                    if (values.containsKey(ENFORCED_KEY)) {\n                        setManagedApnEnforced(values.getAsBoolean(ENFORCED_KEY));\n                        count = 1;\n                    }\n                }\n                break;\n            }\n\n            case URL_SIMINFO_USING_SUBID:\n                String subIdString = url.getLastPathSegment();\n                try {\n                    subId = Integer.parseInt(subIdString);\n                } catch (NumberFormatException e) {\n                    loge(\"NumberFormatException\" + e);\n                    throw new IllegalArgumentException(\"Invalid subId \" + url);\n                }\n                if (DBG) log(\"subIdString = \" + subIdString + \" subId = \" + subId);\n                if (where != null || whereArgs != null) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot update URL \" + url + \" with a where clause\");\n                }\n                count = db.update(SIMINFO_TABLE, values, _ID + \"=?\",\n                        new String[] { subIdString});\n                uriType = URL_SIMINFO_USING_SUBID;\n                break;\n\n            case URL_SIMINFO: {\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO;\n                break;\n            }\n\n            case URL_SIMINFO_SUW_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                uriType = URL_SIMINFO_SUW_RESTORE;\n                break;\n\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                count = db.update(SIMINFO_TABLE, values, where, whereArgs);\n                break;\n\n            default: {\n                throw new UnsupportedOperationException(\"Cannot update that URL: \" + url);\n            }\n        }\n\n        // if APNs (CARRIERS_TABLE) have been updated, some of them may be preferred APN for\n        // different subs. So update the APN field values saved in SharedPref for all subIds.\n        switch (match) {\n            case URL_TELEPHONY_USING_SUBID:\n            case URL_TELEPHONY:\n            case URL_CURRENT_USING_SUBID:\n            case URL_CURRENT:\n            case URL_ID:\n            case URL_DPC_ID:\n                updatePreferredApns();\n                break;\n        }\n\n        if (count > 0) {\n            boolean usingSubId = false;\n            switch (uriType) {\n                case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                    break;\n                case URL_SIMINFO_SUW_RESTORE:\n                    getContext().getContentResolver().notifyChange(\n                            SubscriptionManager.SIM_INFO_SUW_RESTORE_CONTENT_URI, null);\n                    // intentional fall through from above case\n                case URL_SIMINFO_USING_SUBID:\n                    usingSubId = true;\n                    // intentional fall through from above case\n                case URL_SIMINFO:\n                    // skip notifying descendant URLs to avoid unneccessary wake up.\n                    // If not set, any change to SIMINFO will notify observers which listens to\n                    // specific field of SIMINFO.\n                    getContext().getContentResolver().notifyChange(\n                        Telephony.SimInfo.CONTENT_URI, null,\n                            ContentResolver.NOTIFY_SYNC_TO_NETWORK\n                                    | ContentResolver.NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS,\n                            UserHandle.USER_ALL);\n                    // notify observers on specific user settings changes.\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_ENHANCED_4G_MODE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager\n                                                .ADVANCED_CALLING_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VT_IMS_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.VT_ENABLED_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_MODE)) {\n                        getContext().getContentResolver().notifyChange(\n                                getNotifyContentUri(SubscriptionManager.WFC_MODE_CONTENT_URI,\n                                        usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_MODE)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_WFC_IMS_ROAMING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI,\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_IMS_RCS_UCE_ENABLED), usingSubId, subId),\n                                null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_CROSS_SIM_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_VOIMS_OPT_IN_STATUS),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_NR_ADVANCED_CALLING_ENABLED),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    if (values.containsKey(Telephony.SimInfo.COLUMN_USAGE_SETTING)) {\n                        getContext().getContentResolver().notifyChange(getNotifyContentUri(\n                                Uri.withAppendedPath(Telephony.SimInfo.CONTENT_URI,\n                                        Telephony.SimInfo.COLUMN_USAGE_SETTING),\n                                usingSubId, subId), null, true, UserHandle.USER_ALL);\n                    }\n                    break;\n                default:\n                    getContext().getContentResolver().notifyChange(\n                            CONTENT_URI, null, true, UserHandle.USER_ALL);\n            }\n        }\n\n        return count;\n    }\n\n    private static Uri getNotifyContentUri(Uri uri, boolean usingSubId, int subId) {\n        return (usingSubId) ? Uri.withAppendedPath(uri, \"\" + subId) : uri;\n    }\n\n    /**\n     * Checks permission to query or insert/update/delete the database. The permissions required\n     * for APN DB and SIMINFO DB are different:\n     * <ul>\n     * <li>APN DB requires WRITE_APN_SETTINGS or carrier privileges\n     * <li>SIMINFO DB requires phone UID; it's for phone internal usage only\n     * <\/ul>\n     */\n    private void checkPermission(int match) {\n        switch (match) {\n            case URL_SIMINFO:\n            case URL_SIMINFO_USING_SUBID:\n            case URL_SIMINFO_SUW_RESTORE:\n            case URL_SIMINFO_SIM_INSERTED_RESTORE:\n                checkPermissionForSimInfoTable();\n                break;\n            default:\n                checkPermissionForApnTable();\n        }\n    }\n\n    private void checkPermissionForApnTable() {\n        int status = getContext().checkCallingOrSelfPermission(\n                \"android.permission.WRITE_APN_SETTINGS\");\n        if (status == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        PackageManager packageManager = getContext().getPackageManager();\n        String[] packages = packageManager.getPackagesForUid(Binder.getCallingUid());\n\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            for (String pkg : packages) {\n                if (telephonyManager.checkCarrierPrivilegesForPackageAnyPhone(pkg) ==\n                    TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {\n                    return;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        throw new SecurityException(\"No permission to access APN settings\");\n    }\n\n    /**\n     * Check permission to query the database based on PlatformCompat settings -- if the compat\n     * change is enabled, check WRITE_APN_SETTINGS or carrier privs for all queries. Otherwise,\n     * use the legacy checkQueryPermission method to see if the query should be allowed.\n     */\n    private void checkPermissionCompat(int match, String[] projectionIn) {\n        boolean useNewBehavior = CompatChanges.isChangeEnabled(\n                Telephony.Carriers.APN_READING_PERMISSION_CHANGE_ID,\n                Binder.getCallingUid());\n\n        if (!useNewBehavior) {\n            log(\"Using old permission behavior for telephony provider compat\");\n            checkQueryPermission(match, projectionIn);\n        } else {\n            checkPermission(match);\n        }\n    }\n\n    private void checkQueryPermission(int match, String[] projectionIn) {\n        if (match == URL_SIMINFO) {\n            checkPermissionForSimInfoTable();\n        } else {\n            if (projectionIn != null) {\n                for (String column : projectionIn) {\n                    if (TYPE.equals(column) ||\n                            MMSC.equals(column) ||\n                            MMSPROXY.equals(column) ||\n                            MMSPORT.equals(column) ||\n                            MVNO_TYPE.equals(column) ||\n                            MVNO_MATCH_DATA.equals(column) ||\n                            APN.equals(column)) {\n                        // noop\n                    } else {\n                        checkPermissionForApnTable();\n                        break;\n                    }\n                }\n            } else {\n                // null returns all columns, so need permission check\n                checkPermissionForApnTable();\n            }\n        }\n    }\n\n    private void checkPermissionForSimInfoTable() {\n        ensureCallingFromSystemOrPhoneUid(\"Access SIMINFO table from not phone/system UID\");\n        if (getContext().checkCallingOrSelfPermission(\n                    \"android.permission.ACCESS_TELEPHONY_SIMINFO_DB\")\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n        throw new SecurityException(\"No permission to access SIMINFO table\");\n    }\n\n    private DatabaseHelper mOpenHelper;\n\n    private void restoreDefaultAPN(int subId) {\n        SQLiteDatabase db = getWritableDatabase();\n        TelephonyManager telephonyManager =\n                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);\n        String where = null;\n        if (telephonyManager.getPhoneCount() > 1) {\n            where = getWhereClauseForRestoreDefaultApn(db, subId);\n        }\n        if (TextUtils.isEmpty(where)) {\n            where = IS_NOT_OWNED_BY_DPC;\n        }\n        log(\"restoreDefaultAPN: where: \" + where);\n\n        try {\n            db.delete(CARRIERS_TABLE, where, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to restore: \" + e);\n        }\n\n        // delete preferred apn ids and preferred apns (both stored in diff SharedPref) for all\n        // subIds\n        SharedPreferences spApnId = getContext().getSharedPreferences(PREF_FILE_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApnId = spApnId.edit();\n        editorApnId.clear();\n        editorApnId.apply();\n\n        SharedPreferences spApn = getContext().getSharedPreferences(PREF_FILE_FULL_APN,\n                Context.MODE_PRIVATE);\n        SharedPreferences.Editor editorApn = spApn.edit();\n        editorApn.clear();\n        editorApn.apply();\n\n        if (apnSourceServiceExists(getContext())) {\n            restoreApnsWithService(subId);\n        } else {\n            initDatabaseWithDatabaseHelper(db);\n        }\n    }\n\n    private String getWhereClauseForRestoreDefaultApn(SQLiteDatabase db, int subId) {\n        TelephonyManager telephonyManager =\n            getContext().getSystemService(TelephonyManager.class).createForSubscriptionId(subId);\n        String simOperator = telephonyManager.getSimOperator();\n        Cursor cursor = db.query(CARRIERS_TABLE, new String[] {MVNO_TYPE, MVNO_MATCH_DATA},\n                NUMERIC + \"='\" + simOperator + \"'\", null, null, null, DEFAULT_SORT_ORDER);\n        String where = null;\n\n        if (cursor != null) {\n            cursor.moveToFirst();\n            while (!cursor.isAfterLast()) {\n                String mvnoType = cursor.getString(0 /* MVNO_TYPE index */);\n                String mvnoMatchData = cursor.getString(1 /* MVNO_MATCH_DATA index */);\n                if (!TextUtils.isEmpty(mvnoType) && !TextUtils.isEmpty(mvnoMatchData)\n                        && telephonyManager.matchesCurrentSimOperator(simOperator,\n                            getMvnoTypeIntFromString(mvnoType), mvnoMatchData)) {\n                    where = NUMERIC + \"='\" + simOperator + \"'\"\n                            + \" AND \" + MVNO_TYPE + \"='\" + mvnoType + \"'\"\n                            + \" AND \" + MVNO_MATCH_DATA + \"='\" + mvnoMatchData + \"'\"\n                            + \" AND \" + IS_NOT_OWNED_BY_DPC;\n                    break;\n                }\n                cursor.moveToNext();\n            }\n            cursor.close();\n\n            if (TextUtils.isEmpty(where)) {\n                where = NUMERIC + \"='\" + simOperator + \"'\"\n                        + \" AND (\" + MVNO_TYPE + \"='' OR \" + MVNO_MATCH_DATA + \"='')\"\n                        + \" AND \" + IS_NOT_OWNED_BY_DPC;\n            }\n        }\n        return where;\n    }\n\n    private synchronized void updateApnDb() {\n        if (apnSourceServiceExists(getContext())) {\n            loge(\"called updateApnDb when apn source service exists\");\n            return;\n        }\n\n        if (!needApnDbUpdate()) {\n            log(\"Skipping apn db update since apn-conf has not changed.\");\n            return;\n        }\n\n        SQLiteDatabase db = getWritableDatabase();\n\n        // Delete preferred APN for all subIds\n        deletePreferredApnId(getContext());\n\n        // Delete entries in db\n        try {\n            if (VDBG) log(\"updateApnDb: deleting edited=UNEDITED entries\");\n            db.delete(CARRIERS_TABLE, IS_UNEDITED + \" and \" + IS_NOT_OWNED_BY_DPC, null);\n        } catch (SQLException e) {\n            loge(\"got exception when deleting to update: \" + e);\n        }\n\n        initDatabaseWithDatabaseHelper(db);\n\n        // Notify listeners of DB change since DB has been updated\n        getContext().getContentResolver().notifyChange(\n                CONTENT_URI, null, true, UserHandle.USER_ALL);\n\n    }\n\n    public static void fillInMccMncStringAtCursor(Context context, SQLiteDatabase db, Cursor c) {\n        int mcc, mnc;\n        String subId;\n        try {\n            mcc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MCC));\n            mnc = c.getInt(c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_MNC));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        String mccString = String.format(Locale.getDefault(), \"%03d\", mcc);\n        String mncString = getBestStringMnc(context, mccString, mnc);\n        ContentValues cv = new ContentValues(2);\n        cv.put(Telephony.SimInfo.COLUMN_MCC_STRING, mccString);\n        cv.put(Telephony.SimInfo.COLUMN_MNC_STRING, mncString);\n        db.update(SIMINFO_TABLE, cv,\n                Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                new String[]{subId});\n    }\n\n    /*\n     * Find the best string-form mnc by looking up possibilities in the carrier id db.\n     * Default to the three-digit version if neither/both are valid.\n     */\n    private static String getBestStringMnc(Context context, String mcc, int mnc) {\n        if (mnc >= 100 && mnc <= 999) {\n            return String.valueOf(mnc);\n        }\n        String twoDigitMnc = String.format(Locale.getDefault(), \"%02d\", mnc);\n        String threeDigitMnc = \"0\" + twoDigitMnc;\n        boolean threeDigitNetworkCode =\n                Arrays.asList(COUNTRY_MCC_WITH_THREE_DIGIT_MNC).contains(mcc);\n        int twoDigitResult = countMccMncInCarrierList(context, mcc + twoDigitMnc);\n        int threeDigitResult = countMccMncInCarrierList(context, mcc + threeDigitMnc);\n\n        if ((threeDigitResult > twoDigitResult) ||\n                (threeDigitNetworkCode && (twoDigitResult == threeDigitResult))) {\n            return threeDigitMnc;\n        } else {\n            return twoDigitMnc;\n        }\n    }\n\n    /**\n     * Check carrier_list how many mcc mnc combo matches there are\n     */\n    private static int countMccMncInCarrierList(Context ctx, String mccMncCombo) {\n        try (\n            Cursor mccMncCursor = ctx.getContentResolver().query(\n                    Telephony.CarrierId.All.CONTENT_URI,\n                    /* projection */ null,\n                    /* selection */ Telephony.CarrierId.All.MCCMNC + \"=?\",\n                    /* selectionArgs */ new String[]{mccMncCombo}, null);\n        )\n        {\n            return mccMncCursor.getCount();\n        }\n    }\n\n    /**\n     * Sync the bearer bitmask and network type bitmask when inserting and updating.\n     * Since bearerBitmask is deprecating, map the networkTypeBitmask to bearerBitmask if\n     * networkTypeBitmask was provided. But if networkTypeBitmask was not provided, map the\n     * bearerBitmask to networkTypeBitmask.\n     */\n    private static void syncBearerBitmaskAndNetworkTypeBitmask(ContentValues values) {\n        if (values.containsKey(NETWORK_TYPE_BITMASK)) {\n            int convertedBitmask = convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK));\n            if (values.containsKey(BEARER_BITMASK)\n                    && convertedBitmask != values.getAsInteger(BEARER_BITMASK)) {\n                loge(\"Network type bitmask and bearer bitmask are not compatible.\");\n            }\n            values.put(BEARER_BITMASK, convertNetworkTypeBitmaskToBearerBitmask(\n                    values.getAsInteger(NETWORK_TYPE_BITMASK)));\n        } else {\n            if (values.containsKey(BEARER_BITMASK)) {\n                int convertedBitmask = convertBearerBitmaskToNetworkTypeBitmask(\n                        values.getAsInteger(BEARER_BITMASK));\n                values.put(NETWORK_TYPE_BITMASK, convertedBitmask);\n            }\n        }\n    }\n\n    /**\n     * Log with debug\n     *\n     * @param s is string log\n     */\n    private static void log(String s) {\n        Log.d(TAG, s);\n    }\n\n    private static void loge(String s) {\n        Log.e(TAG, s);\n    }\n\n    private static int getMvnoTypeIntFromString(String mvnoType) {\n        String mvnoTypeString = TextUtils.isEmpty(mvnoType) ? mvnoType : mvnoType.toLowerCase();\n        Integer mvnoTypeInt = MVNO_TYPE_STRING_MAP.get(mvnoTypeString);\n        return  mvnoTypeInt == null ? 0 : mvnoTypeInt;\n    }\n\n    private static int getBitmaskFromString(String bearerList) {\n        String[] bearers = bearerList.split(\"\\\\|\");\n        int bearerBitmask = 0;\n        for (String bearer : bearers) {\n            int bearerInt = 0;\n            try {\n                bearerInt = Integer.parseInt(bearer.trim());\n            } catch (NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (bearerInt == 0) {\n                return 0;\n            }\n            bearerBitmask |= getBitmaskForTech(bearerInt);\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Transform RIL radio technology value to Network\n     * type bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     *\n     * @param rat The RIL radio technology.\n     * @return The network type\n     * bitmask{@link android.telephony.TelephonyManager.NetworkTypeBitMask}.\n     */\n    private static int rilRadioTechnologyToNetworkTypeBitmask(int rat) {\n        switch (rat) {\n            case RIL_RADIO_TECHNOLOGY_GPRS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GPRS;\n            case RIL_RADIO_TECHNOLOGY_EDGE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EDGE;\n            case RIL_RADIO_TECHNOLOGY_UMTS:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;\n            case RIL_RADIO_TECHNOLOGY_HSDPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSDPA;\n            case RIL_RADIO_TECHNOLOGY_HSUPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSUPA;\n            case RIL_RADIO_TECHNOLOGY_HSPA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPA;\n            case RIL_RADIO_TECHNOLOGY_IS95A:\n            case RIL_RADIO_TECHNOLOGY_IS95B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_CDMA;\n            case RIL_RADIO_TECHNOLOGY_1xRTT:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_1xRTT;\n            case RIL_RADIO_TECHNOLOGY_EVDO_0:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_0;\n            case RIL_RADIO_TECHNOLOGY_EVDO_A:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_A;\n            case RIL_RADIO_TECHNOLOGY_EVDO_B:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EVDO_B;\n            case RIL_RADIO_TECHNOLOGY_EHRPD:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_EHRPD;\n            case RIL_RADIO_TECHNOLOGY_LTE:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE;\n            case RIL_RADIO_TECHNOLOGY_HSPAP:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_HSPAP;\n            case RIL_RADIO_TECHNOLOGY_GSM:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_GSM;\n            case RIL_RADIO_TECHNOLOGY_TD_SCDMA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_TD_SCDMA;\n            case RIL_RADIO_TECHNOLOGY_IWLAN:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_IWLAN;\n            case RIL_RADIO_TECHNOLOGY_LTE_CA:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;\n            case RIL_RADIO_TECHNOLOGY_NR:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_NR;\n            default:\n                return (int) TelephonyManager.NETWORK_TYPE_BITMASK_UNKNOWN;\n        }\n    }\n\n    /**\n     * Convert network type bitmask to bearer bitmask.\n     *\n     * @param networkTypeBitmask The network type bitmask value\n     * @return The bearer bitmask value.\n     */\n    private static int convertNetworkTypeBitmaskToBearerBitmask(int networkTypeBitmask) {\n        if (networkTypeBitmask == 0) {\n            return 0;\n        }\n\n        int bearerBitmask = 0;\n        for (int bearerInt = 0; bearerInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerInt++) {\n            if (bitmaskHasTarget(networkTypeBitmask,\n                    rilRadioTechnologyToNetworkTypeBitmask(bearerInt))) {\n                bearerBitmask |= getBitmaskForTech(bearerInt);\n            }\n        }\n        return bearerBitmask;\n    }\n\n    /**\n     * Convert bearer bitmask to network type bitmask.\n     *\n     * @param bearerBitmask The bearer bitmask value.\n     * @return The network type bitmask value.\n     */\n    private static int convertBearerBitmaskToNetworkTypeBitmask(int bearerBitmask) {\n        if (bearerBitmask == 0) {\n            return 0;\n        }\n\n        int networkTypeBitmask = 0;\n        for (int bearerUnitInt = 0; bearerUnitInt < NEXT_RIL_RADIO_TECHNOLOGY; bearerUnitInt++) {\n            int bearerUnitBitmask = getBitmaskForTech(bearerUnitInt);\n            if (bitmaskHasTarget(bearerBitmask, bearerUnitBitmask)) {\n                networkTypeBitmask |= rilRadioTechnologyToNetworkTypeBitmask(bearerUnitInt);\n            }\n        }\n        return networkTypeBitmask;\n    }\n\n    private static boolean bitmaskHasTarget(int bearerBitmask, int targetBitmask) {\n        if (bearerBitmask == 0) {\n            return true;\n        } else if (targetBitmask != 0) {\n            return ((bearerBitmask & targetBitmask) != 0);\n        }\n        return false;\n    }\n\n    private static int getBitmaskForTech(int radioTech) {\n        if (radioTech >= 1) {\n            return (1 << (radioTech - 1));\n        }\n        return 0;\n    }\n\n    /**\n     * Migrate the old Long values{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} over to\n     * String{@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_ALL_REASON}\n     *\n     * @param db The sqlite database to write to\n     * @param c The {@link Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES} values in the sim info\n     *         table.\n     */\n    public static void fillInAllowedNetworkTypesStringAtCursor(SQLiteDatabase db, Cursor c) {\n        long allowedNetworkTypesReasonCarrier;\n        String subId;\n        try {\n            allowedNetworkTypesReasonCarrier = c.getLong(\n                    c.getColumnIndexOrThrow(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES));\n            subId = c.getString(c.getColumnIndexOrThrow(\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID));\n        } catch (IllegalArgumentException e) {\n            Log.e(TAG, \"Possible database corruption -- some columns not found.\");\n            return;\n        }\n\n        if (allowedNetworkTypesReasonCarrier != -1) {\n            ContentValues cv = new ContentValues(1);\n\n            cv.put(Telephony.SimInfo.COLUMN_ALLOWED_NETWORK_TYPES_FOR_REASONS,\n                    \"carrier=\" + allowedNetworkTypesReasonCarrier);\n            db.update(SIMINFO_TABLE, cv,\n                    Telephony.SimInfo.COLUMN_UNIQUE_KEY_SUBSCRIPTION_ID + \"=?\",\n                    new String[]{subId});\n        }\n    }\n}\n","lineNo":3270}
