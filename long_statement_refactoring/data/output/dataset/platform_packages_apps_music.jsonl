{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.KeyguardManager;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n\n    private boolean mSeeking = false;\n    private boolean mDeviceHasDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n    private ServiceToken mToken;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasDpad = (getResources().getConfiguration().navigation ==\n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        long audioid;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n            audioid = mService.getAudioId();\n        } catch (RemoteException ex) {\n            return true;\n        } catch (NullPointerException ex) {\n            // we might not actually have the service yet\n            return true;\n        }\n\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                song != null &&\n                song.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        if (audioid < 0) {\n            return false;\n        }\n\n        Cursor c = MusicUtils.query(this,\n                ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioid),\n                new String[] {MediaStore.Audio.Media.IS_MUSIC}, null, null, null);\n        boolean ismusic = true;\n        if (c != null) {\n            if (c.moveToFirst()) {\n                ismusic = c.getInt(0) != 0;\n            }\n            c.close();\n        }\n        if (!ismusic) {\n            return false;\n        }\n\n        boolean knownartist =\n            (artist != null) && !MediaStore.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaStore.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaStore.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(mToken);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        mToken = MusicUtils.bindToService(this, osc);\n        if (mToken == null) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            // these next two are in a separate group, so they can be shown/hidden as needed\n            // based on the keyguard state\n            menu.add(1, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short)\n                    .setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(1, DELETE_ITEM, 0, R.string.delete_item)\n                    .setIcon(R.drawable.ic_menu_delete);\n\n            Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n            if (getPackageManager().resolveActivity(i, 0) != null) {\n                menu.add(0, EFFECTS_PANEL, 0, R.string.effectspanel).setIcon(R.drawable.ic_menu_eq);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        if (mService == null) return false;\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n\n        item = menu.findItem(ADD_TO_PLAYLIST);\n        if (item != null) {\n            SubMenu sub = item.getSubMenu();\n            MusicUtils.makePlaylistMenu(this, sub);\n        }\n\n        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);\n        menu.setGroupVisible(1, !km.inKeyguardRestrictedInputMode());\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                    startActivity(intent);\n                    finish();\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    MusicUtils.togglePartyShuffle();\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        long [] list = new long[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        String f;\n                        if (android.os.Environment.isExternalStorageRemovable()) {\n                            f = getString(R.string.delete_song_desc, mService.getTrackName());\n                        } else {\n                            f = getString(R.string.delete_song_desc_nosdcard, mService.getTrackName());\n                        }\n                        b.putString(\"description\", f);\n                        b.putLongArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n\n                case EFFECTS_PANEL: {\n                    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n                    i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, mService.getAudioSessionId());\n                    startActivityForResult(i, EFFECTS_PANEL);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    private boolean useDpadMusicControl() {\n        if (mDeviceHasDpad && (mPrevButton.isFocused() ||\n                mNextButton.isFocused() ||\n                mPauseButton.isFocused())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mService.stop();\n                mService.openFile(filename);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        mRepeatButton.setVisibility(View.VISIBLE);\n                        mShuffleButton.setVisibility(View.VISIBLE);\n                        mQueueButton.setVisibility(View.VISIBLE);\n                        setRepeatButtonImage();\n                        setShuffleButtonImage();\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n                mService = null;\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private static class AlbumSongIdWrapper {\n        public long albumid;\n        public long songid;\n        AlbumSongIdWrapper(long aid, long sid) {\n            albumid = aid;\n            songid = sid;\n        }\n    }\n    \n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            long songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(-1, -1)).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                long albumid = mService.getAlbumId();\n                if (MediaStore.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(albumid, songid)).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private long mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg)\n        {\n            long albumid = ((AlbumSongIdWrapper) msg.obj).albumid;\n            long songid = ((AlbumSongIdWrapper) msg.obj).songid;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                // Don't allow default artwork here, because we want to fall back to song-specific\n                // album art if we can't find anything for the album.\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid, false);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.KeyguardManager;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n\n    private boolean mSeeking = false;\n    private boolean mDeviceHasDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n    private ServiceToken mToken;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasDpad = (getResources().getConfiguration().navigation ==\n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        long audioid;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n            audioid = mService.getAudioId();\n        } catch (RemoteException ex) {\n            return true;\n        } catch (NullPointerException ex) {\n            // we might not actually have the service yet\n            return true;\n        }\n\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                song != null &&\n                song.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        if (audioid < 0) {\n            return false;\n        }\n\n        Cursor c = MusicUtils.query(this,\n                ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioid),\n                new String[] {MediaStore.Audio.Media.IS_MUSIC}, null, null, null);\n        boolean ismusic = true;\n        if (c != null) {\n            if (c.moveToFirst()) {\n                ismusic = c.getInt(0) != 0;\n            }\n            c.close();\n        }\n        if (!ismusic) {\n            return false;\n        }\n\n        boolean knownartist =\n            (artist != null) && !MediaStore.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaStore.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaStore.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(mToken);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        mToken = MusicUtils.bindToService(this, osc);\n        if (mToken == null) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            // these next two are in a separate group, so they can be shown/hidden as needed\n            // based on the keyguard state\n            menu.add(1, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short)\n                    .setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(1, DELETE_ITEM, 0, R.string.delete_item)\n                    .setIcon(R.drawable.ic_menu_delete);\n\n            Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n            if (getPackageManager().resolveActivity(i, 0) != null) {\n                menu.add(0, EFFECTS_PANEL, 0, R.string.effectspanel).setIcon(R.drawable.ic_menu_eq);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        if (mService == null) return false;\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n\n        item = menu.findItem(ADD_TO_PLAYLIST);\n        if (item != null) {\n            SubMenu sub = item.getSubMenu();\n            MusicUtils.makePlaylistMenu(this, sub);\n        }\n\n        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);\n        menu.setGroupVisible(1, !km.inKeyguardRestrictedInputMode());\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                    startActivity(intent);\n                    finish();\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    MusicUtils.togglePartyShuffle();\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        long [] list = new long[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        String f;\n                        if (android.os.Environment.isExternalStorageRemovable()) {\n                            f = getString(R.string.delete_song_desc, mService.getTrackName());\n                        } else {\n                            f = getString(R.string.delete_song_desc_nosdcard, mService.getTrackName());\n                        }\n                        b.putString(\"description\", f);\n                        b.putLongArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n\n                case EFFECTS_PANEL: {\n                    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n                    i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, mService.getAudioSessionId());\n                    startActivityForResult(i, EFFECTS_PANEL);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    private boolean useDpadMusicControl() {\n        if (mDeviceHasDpad && (mPrevButton.isFocused() ||\n                mNextButton.isFocused() ||\n                mPauseButton.isFocused())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mService.stop();\n                mService.openFile(filename);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        mRepeatButton.setVisibility(View.VISIBLE);\n                        mShuffleButton.setVisibility(View.VISIBLE);\n                        mQueueButton.setVisibility(View.VISIBLE);\n                        setRepeatButtonImage();\n                        setShuffleButtonImage();\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n                mService = null;\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                int progress = (int) (1000 * pos / mDuration);\n                mProgress.setProgress(progress);\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    return 500;\n                }\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // calculate the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            long remaining = 1000 - (pos % 1000);\n\n            // approximate how often we would need to refresh the slider to\n            // move it smoothly\n            int width = mProgress.getWidth();\n            if (width == 0) width = 320;\n            long smoothrefreshtime = mDuration / width;\n\n            if (smoothrefreshtime > remaining) return remaining;\n            if (smoothrefreshtime < 20) return 20;\n            return smoothrefreshtime;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private static class AlbumSongIdWrapper {\n        public long albumid;\n        public long songid;\n        AlbumSongIdWrapper(long aid, long sid) {\n            albumid = aid;\n            songid = sid;\n        }\n    }\n    \n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            long songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(-1, -1)).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                long albumid = mService.getAlbumId();\n                if (MediaStore.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(albumid, songid)).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private long mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg)\n        {\n            long albumid = ((AlbumSongIdWrapper) msg.obj).albumid;\n            long songid = ((AlbumSongIdWrapper) msg.obj).songid;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                // Don't allow default artwork here, because we want to fall back to song-specific\n                // album art if we can't find anything for the album.\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid, false);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":1175}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.media.AudioManager.OnAudioFocusChangeListener;\nimport android.media.MediaPlayer;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.os.PowerManager.WakeLock;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Provides \"background\" audio playback capabilities, allowing the\n * user to switch between activities without stopping playback.\n */\npublic class MediaPlaybackService extends Service {\n    /** used to specify whether enqueue() should start playing\n     * the new list of files right away, next or once all the currently\n     * queued files have been played\n     */\n    public static final int NOW = 1;\n    public static final int NEXT = 2;\n    public static final int LAST = 3;\n    public static final int PLAYBACKSERVICE_STATUS = 1;\n    \n    public static final int SHUFFLE_NONE = 0;\n    public static final int SHUFFLE_NORMAL = 1;\n    public static final int SHUFFLE_AUTO = 2;\n    \n    public static final int REPEAT_NONE = 0;\n    public static final int REPEAT_CURRENT = 1;\n    public static final int REPEAT_ALL = 2;\n\n    public static final String PLAYSTATE_CHANGED = \"com.android.music.playstatechanged\";\n    public static final String META_CHANGED = \"com.android.music.metachanged\";\n    public static final String QUEUE_CHANGED = \"com.android.music.queuechanged\";\n\n    public static final String SERVICECMD = \"com.android.music.musicservicecommand\";\n    public static final String CMDNAME = \"command\";\n    public static final String CMDTOGGLEPAUSE = \"togglepause\";\n    public static final String CMDSTOP = \"stop\";\n    public static final String CMDPAUSE = \"pause\";\n    public static final String CMDPLAY = \"play\";\n    public static final String CMDPREVIOUS = \"previous\";\n    public static final String CMDNEXT = \"next\";\n\n    public static final String TOGGLEPAUSE_ACTION = \"com.android.music.musicservicecommand.togglepause\";\n    public static final String PAUSE_ACTION = \"com.android.music.musicservicecommand.pause\";\n    public static final String PREVIOUS_ACTION = \"com.android.music.musicservicecommand.previous\";\n    public static final String NEXT_ACTION = \"com.android.music.musicservicecommand.next\";\n\n    private static final int TRACK_ENDED = 1;\n    private static final int RELEASE_WAKELOCK = 2;\n    private static final int SERVER_DIED = 3;\n    private static final int FOCUSCHANGE = 4;\n    private static final int FADEDOWN = 5;\n    private static final int FADEUP = 6;\n    private static final int MAX_HISTORY_SIZE = 100;\n    \n    private MultiPlayer mPlayer;\n    private String mFileToPlay;\n    private int mShuffleMode = SHUFFLE_NONE;\n    private int mRepeatMode = REPEAT_NONE;\n    private int mMediaMountedCount = 0;\n    private long [] mAutoShuffleList = null;\n    private long [] mPlayList = null;\n    private int mPlayListLen = 0;\n    private Vector<Integer> mHistory = new Vector<Integer>(MAX_HISTORY_SIZE);\n    private Cursor mCursor;\n    private int mPlayPos = -1;\n    private static final String LOGTAG = \"MediaPlaybackService\";\n    private final Shuffler mRand = new Shuffler();\n    private int mOpenFailedCounter = 0;\n    String[] mCursorCols = new String[] {\n            \"audio._id AS _id\",             // index must match IDCOLIDX below\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE,\n            MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.IS_PODCAST, // index must match PODCASTCOLIDX below\n            MediaStore.Audio.Media.BOOKMARK    // index must match BOOKMARKCOLIDX below\n    };\n    private final static int IDCOLIDX = 0;\n    private final static int PODCASTCOLIDX = 8;\n    private final static int BOOKMARKCOLIDX = 9;\n    private BroadcastReceiver mUnmountReceiver = null;\n    private WakeLock mWakeLock;\n    private int mServiceStartId = -1;\n    private boolean mServiceInUse = false;\n    private boolean mIsSupposedToBePlaying = false;\n    private boolean mQuietMode = false;\n    private AudioManager mAudioManager;\n    private boolean mQueueIsSaveable = true;\n    // used to track what type of audio focus loss caused the playback to pause\n    private boolean mPausedByTransientLossOfFocus = false;\n\n    private SharedPreferences mPreferences;\n    // We use this to distinguish between different cards when saving/restoring playlists.\n    // This will have to change if we want to support multiple simultaneous cards.\n    private int mCardId;\n    \n    private MediaAppWidgetProvider mAppWidgetProvider = MediaAppWidgetProvider.getInstance();\n    \n    // interval after which we stop the service when idle\n    private static final int IDLE_DELAY = 60000;\n    \n    private Handler mMediaplayerHandler = new Handler() {\n        float mCurrentVolume = 1.0f;\n        @Override\n        public void handleMessage(Message msg) {\n            MusicUtils.debugLog(\"mMediaplayerHandler.handleMessage \" + msg.what);\n            switch (msg.what) {\n                case FADEDOWN:\n                    mCurrentVolume -= .05f;\n                    if (mCurrentVolume > .2f) {\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEDOWN, 10);\n                    } else {\n                        mCurrentVolume = .2f;\n                    }\n                    mPlayer.setVolume(mCurrentVolume);\n                    break;\n                case FADEUP:\n                    mCurrentVolume += .01f;\n                    if (mCurrentVolume < 1.0f) {\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEUP, 10);\n                    } else {\n                        mCurrentVolume = 1.0f;\n                    }\n                    mPlayer.setVolume(mCurrentVolume);\n                    break;\n                case SERVER_DIED:\n                    if (mIsSupposedToBePlaying) {\n                        next(true);\n                    } else {\n                        // the server died when we were idle, so just\n                        // reopen the same song (it will start again\n                        // from the beginning though when the user\n                        // restarts)\n                        openCurrent();\n                    }\n                    break;\n                case TRACK_ENDED:\n                    if (mRepeatMode == REPEAT_CURRENT) {\n                        seek(0);\n                        play();\n                    } else {\n                        next(false);\n                    }\n                    break;\n                case RELEASE_WAKELOCK:\n                    mWakeLock.release();\n                    break;\n\n                case FOCUSCHANGE:\n                    // This code is here so we can better synchronize it with the code that\n                    // handles fade-in\n                    switch (msg.arg1) {\n                        case AudioManager.AUDIOFOCUS_LOSS:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_LOSS\");\n                            if(isPlaying()) {\n                                mPausedByTransientLossOfFocus = false;\n                            }\n                            pause();\n                            break;\n                        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:\n                            mMediaplayerHandler.removeMessages(FADEUP);\n                            mMediaplayerHandler.sendEmptyMessage(FADEDOWN);\n                            break;\n                        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_LOSS_TRANSIENT\");\n                            if(isPlaying()) {\n                                mPausedByTransientLossOfFocus = true;\n                            }\n                            pause();\n                            break;\n                        case AudioManager.AUDIOFOCUS_GAIN:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_GAIN\");\n                            if(!isPlaying() && mPausedByTransientLossOfFocus) {\n                                mPausedByTransientLossOfFocus = false;\n                                mCurrentVolume = 0f;\n                                mPlayer.setVolume(mCurrentVolume);\n                                play(); // also queues a fade-in\n                            } else {\n                                mMediaplayerHandler.removeMessages(FADEDOWN);\n                                mMediaplayerHandler.sendEmptyMessage(FADEUP);\n                            }\n                            break;\n                        default:\n                            Log.e(LOGTAG, \"Unknown audio focus change code\");\n                    }\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            MusicUtils.debugLog(\"mIntentReceiver.onReceive \" + action + \" / \" + cmd);\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                prev();\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                    mPausedByTransientLossOfFocus = false;\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            } else if (CMDPLAY.equals(cmd)) {\n                play();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n                seek(0);\n            } else if (MediaAppWidgetProvider.CMDAPPWIDGETUPDATE.equals(cmd)) {\n                // Someone asked us to refresh a set of specific widgets, probably\n                // because they were just added.\n                int[] appWidgetIds = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);\n                mAppWidgetProvider.performUpdate(MediaPlaybackService.this, appWidgetIds);\n            }\n        }\n    };\n\n    private OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {\n        public void onAudioFocusChange(int focusChange) {\n            mMediaplayerHandler.obtainMessage(FOCUSCHANGE, focusChange, 0).sendToTarget();\n        }\n    };\n\n    public MediaPlaybackService() {\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n        mAudioManager.registerMediaButtonEventReceiver(new ComponentName(getPackageName(),\n                MediaButtonIntentReceiver.class.getName()));\n        \n        mPreferences = getSharedPreferences(\"Music\", MODE_WORLD_READABLE | MODE_WORLD_WRITEABLE);\n        mCardId = MusicUtils.getCardId(this);\n        \n        registerExternalStorageListener();\n\n        // Needs to be done in this thread, since otherwise ApplicationContext.getPowerManager() crashes.\n        mPlayer = new MultiPlayer();\n        mPlayer.setHandler(mMediaplayerHandler);\n\n        reloadQueue();\n        \n        IntentFilter commandFilter = new IntentFilter();\n        commandFilter.addAction(SERVICECMD);\n        commandFilter.addAction(TOGGLEPAUSE_ACTION);\n        commandFilter.addAction(PAUSE_ACTION);\n        commandFilter.addAction(NEXT_ACTION);\n        commandFilter.addAction(PREVIOUS_ACTION);\n        registerReceiver(mIntentReceiver, commandFilter);\n        \n        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);\n        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, this.getClass().getName());\n        mWakeLock.setReferenceCounted(false);\n\n        // If the service was idle, but got killed before it stopped itself, the\n        // system will relaunch it. Make sure it gets stopped again in that case.\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n\n    @Override\n    public void onDestroy() {\n        // Check that we're not being destroyed while something is still playing.\n        if (isPlaying()) {\n            Log.e(LOGTAG, \"Service being destroyed while still playing.\");\n        }\n        // release all MediaPlayer resources, including the native player and wakelocks\n        Intent i = new Intent(AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\n        i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n        i.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n        sendBroadcast(i);\n        mPlayer.release();\n        mPlayer = null;\n\n        mAudioManager.abandonAudioFocus(mAudioFocusListener);\n        \n        // make sure there aren't any other messages coming\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mMediaplayerHandler.removeCallbacksAndMessages(null);\n\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n\n        unregisterReceiver(mIntentReceiver);\n        if (mUnmountReceiver != null) {\n            unregisterReceiver(mUnmountReceiver);\n            mUnmountReceiver = null;\n        }\n        mWakeLock.release();\n        super.onDestroy();\n    }\n    \n    private final char hexdigits [] = new char [] {\n            '0', '1', '2', '3',\n            '4', '5', '6', '7',\n            '8', '9', 'a', 'b',\n            'c', 'd', 'e', 'f'\n    };\n\n    private void saveQueue(boolean full) {\n        if (!mQueueIsSaveable) {\n            return;\n        }\n\n        Editor ed = mPreferences.edit();\n        //long start = System.currentTimeMillis();\n        if (full) {\n            StringBuilder q = new StringBuilder();\n            \n            // The current playlist is saved as a list of \"reverse hexadecimal\"\n            // numbers, which we can generate faster than normal decimal or\n            // hexadecimal numbers, which in turn allows us to save the playlist\n            // more often without worrying too much about performance.\n            // (saving the full state takes about 40 ms under no-load conditions\n            // on the phone)\n            int len = mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                long n = mPlayList[i];\n                if (n < 0) {\n                    continue;\n                } else if (n == 0) {\n                    q.append(\"0;\");\n                } else {\n                    while (n != 0) {\n                        int digit = (int)(n & 0xf);\n                        n >>>= 4;\n                        q.append(hexdigits[digit]);\n                    }\n                    q.append(\";\");\n                }\n            }\n            //Log.i(\"@@@@ service\", \"created queue string in \" + (System.currentTimeMillis() - start) + \" ms\");\n            ed.putString(\"queue\", q.toString());\n            ed.putInt(\"cardid\", mCardId);\n            if (mShuffleMode != SHUFFLE_NONE) {\n                // In shuffle mode we need to save the history too\n                len = mHistory.size();\n                q.setLength(0);\n                for (int i = 0; i < len; i++) {\n                    int n = mHistory.get(i);\n                    if (n == 0) {\n                        q.append(\"0;\");\n                    } else {\n                        while (n != 0) {\n                            int digit = (n & 0xf);\n                            n >>>= 4;\n                            q.append(hexdigits[digit]);\n                        }\n                        q.append(\";\");\n                    }\n                }\n                ed.putString(\"history\", q.toString());\n            }\n        }\n        ed.putInt(\"curpos\", mPlayPos);\n        if (mPlayer.isInitialized()) {\n            ed.putLong(\"seekpos\", mPlayer.position());\n        }\n        ed.putInt(\"repeatmode\", mRepeatMode);\n        ed.putInt(\"shufflemode\", mShuffleMode);\n        SharedPreferencesCompat.apply(ed);\n\n        //Log.i(\"@@@@ service\", \"saved state in \" + (System.currentTimeMillis() - start) + \" ms\");\n    }\n\n    private void reloadQueue() {\n        String q = null;\n        \n        boolean newstyle = false;\n        int id = mCardId;\n        if (mPreferences.contains(\"cardid\")) {\n            newstyle = true;\n            id = mPreferences.getInt(\"cardid\", ~mCardId);\n        }\n        if (id == mCardId) {\n            // Only restore the saved playlist if the card is still\n            // the same one as when the playlist was saved\n            q = mPreferences.getString(\"queue\", \"\");\n        }\n        int qlen = q != null ? q.length() : 0;\n        if (qlen > 1) {\n            //Log.i(\"@@@@ service\", \"loaded queue: \" + q);\n            int plen = 0;\n            int n = 0;\n            int shift = 0;\n            for (int i = 0; i < qlen; i++) {\n                char c = q.charAt(i);\n                if (c == ';') {\n                    ensurePlayListCapacity(plen + 1);\n                    mPlayList[plen] = n;\n                    plen++;\n                    n = 0;\n                    shift = 0;\n                } else {\n                    if (c >= '0' && c <= '9') {\n                        n += ((c - '0') << shift);\n                    } else if (c >= 'a' && c <= 'f') {\n                        n += ((10 + c - 'a') << shift);\n                    } else {\n                        // bogus playlist data\n                        plen = 0;\n                        break;\n                    }\n                    shift += 4;\n                }\n            }\n            mPlayListLen = plen;\n\n            int pos = mPreferences.getInt(\"curpos\", 0);\n            if (pos < 0 || pos >= mPlayListLen) {\n                // The saved playlist is bogus, discard it\n                mPlayListLen = 0;\n                return;\n            }\n            mPlayPos = pos;\n            \n            // When reloadQueue is called in response to a card-insertion,\n            // we might not be able to query the media provider right away.\n            // To deal with this, try querying for the current file, and if\n            // that fails, wait a while and try again. If that too fails,\n            // assume there is a problem and don't restore the state.\n            Cursor crsr = MusicUtils.query(this,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] {\"_id\"}, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            if (crsr == null || crsr.getCount() == 0) {\n                // wait a bit and try again\n                SystemClock.sleep(3000);\n                crsr = getContentResolver().query(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            }\n            if (crsr != null) {\n                crsr.close();\n            }\n\n            // Make sure we don't auto-skip to the next song, since that\n            // also starts playback. What could happen in that case is:\n            // - music is paused\n            // - go to UMS and delete some files, including the currently playing one\n            // - come back from UMS\n            // (time passes)\n            // - music app is killed for some reason (out of memory)\n            // - music service is restarted, service restores state, doesn't find\n            //   the \"current\" file, goes to the next and: playback starts on its\n            //   own, potentially at some random inconvenient time.\n            mOpenFailedCounter = 20;\n            mQuietMode = true;\n            openCurrent();\n            mQuietMode = false;\n            if (!mPlayer.isInitialized()) {\n                // couldn't restore the saved state\n                mPlayListLen = 0;\n                return;\n            }\n            \n            long seekpos = mPreferences.getLong(\"seekpos\", 0);\n            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);\n            Log.d(LOGTAG, \"restored queue, currently at position \"\n                    + position() + \"/\" + duration()\n                    + \" (requested \" + seekpos + \")\");\n            \n            int repmode = mPreferences.getInt(\"repeatmode\", REPEAT_NONE);\n            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {\n                repmode = REPEAT_NONE;\n            }\n            mRepeatMode = repmode;\n\n            int shufmode = mPreferences.getInt(\"shufflemode\", SHUFFLE_NONE);\n            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {\n                shufmode = SHUFFLE_NONE;\n            }\n            if (shufmode != SHUFFLE_NONE) {\n                // in shuffle mode we need to restore the history too\n                q = mPreferences.getString(\"history\", \"\");\n                qlen = q != null ? q.length() : 0;\n                if (qlen > 1) {\n                    plen = 0;\n                    n = 0;\n                    shift = 0;\n                    mHistory.clear();\n                    for (int i = 0; i < qlen; i++) {\n                        char c = q.charAt(i);\n                        if (c == ';') {\n                            if (n >= mPlayListLen) {\n                                // bogus history data\n                                mHistory.clear();\n                                break;\n                            }\n                            mHistory.add(n);\n                            n = 0;\n                            shift = 0;\n                        } else {\n                            if (c >= '0' && c <= '9') {\n                                n += ((c - '0') << shift);\n                            } else if (c >= 'a' && c <= 'f') {\n                                n += ((10 + c - 'a') << shift);\n                            } else {\n                                // bogus history data\n                                mHistory.clear();\n                                break;\n                            }\n                            shift += 4;\n                        }\n                    }\n                }\n            }\n            if (shufmode == SHUFFLE_AUTO) {\n                if (! makeAutoShuffleList()) {\n                    shufmode = SHUFFLE_NONE;\n                }\n            }\n            mShuffleMode = shufmode;\n        }\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n        return mBinder;\n    }\n\n    @Override\n    public void onRebind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        mServiceStartId = startId;\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n\n        if (intent != null) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            MusicUtils.debugLog(\"onStartCommand \" + action + \" / \" + cmd);\n\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                if (position() < 2000) {\n                    prev();\n                } else {\n                    seek(0);\n                    play();\n                }\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                    mPausedByTransientLossOfFocus = false;\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            } else if (CMDPLAY.equals(cmd)) {\n                play();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n                seek(0);\n            }\n        }\n        \n        // make sure the service will shut down on its own if it was\n        // just started but not bound to and nothing is playing\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n        return START_STICKY;\n    }\n    \n    @Override\n    public boolean onUnbind(Intent intent) {\n        mServiceInUse = false;\n\n        // Take a snapshot of the current playlist\n        saveQueue(true);\n\n        if (isPlaying() || mPausedByTransientLossOfFocus) {\n            // something is currently playing, or will be playing once \n            // an in-progress action requesting audio focus ends, so don't stop the service now.\n            return true;\n        }\n        \n        // If there is a playlist but playback is paused, then wait a while\n        // before stopping the service, so that pause/resume isn't slow.\n        // Also delay stopping the service if we're transitioning between tracks.\n        if (mPlayListLen > 0  || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n            Message msg = mDelayedStopHandler.obtainMessage();\n            mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n            return true;\n        }\n        \n        // No active playlist, OK to stop the service right now\n        stopSelf(mServiceStartId);\n        return true;\n    }\n    \n    private Handler mDelayedStopHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            // Check again to make sure nothing is playing right now\n            if (isPlaying() || mPausedByTransientLossOfFocus || mServiceInUse\n                    || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n                return;\n            }\n            // save the queue again, because it might have changed\n            // since the user exited the music app (because of\n            // party-shuffle or because the play-position changed)\n            saveQueue(true);\n            stopSelf(mServiceStartId);\n        }\n    };\n\n    /**\n     * Called when we receive a ACTION_MEDIA_EJECT notification.\n     *\n     * @param storagePath path to mount point for the removed media\n     */\n    public void closeExternalStorageFiles(String storagePath) {\n        // stop playback and clean up if the SD card is going to be unmounted.\n        stop(true);\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n    }\n\n    /**\n     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.\n     * The intent will call closeExternalStorageFiles() if the external media\n     * is going to be ejected, so applications can clean up any files they have open.\n     */\n    public void registerExternalStorageListener() {\n        if (mUnmountReceiver == null) {\n            mUnmountReceiver = new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    String action = intent.getAction();\n                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {\n                        saveQueue(true);\n                        mQueueIsSaveable = false;\n                        closeExternalStorageFiles(intent.getData().getPath());\n                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n                        mMediaMountedCount++;\n                        mCardId = MusicUtils.getCardId(MediaPlaybackService.this);\n                        reloadQueue();\n                        mQueueIsSaveable = true;\n                        notifyChange(QUEUE_CHANGED);\n                        notifyChange(META_CHANGED);\n                    }\n                }\n            };\n            IntentFilter iFilter = new IntentFilter();\n            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);\n            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);\n            iFilter.addDataScheme(\"file\");\n            registerReceiver(mUnmountReceiver, iFilter);\n        }\n    }\n\n    /**\n     * Notify the change-receivers that something has changed.\n     * The intent that is sent contains the following data\n     * for the currently playing track:\n     * \"id\" - Integer: the database row ID\n     * \"artist\" - String: the name of the artist\n     * \"album\" - String: the name of the album\n     * \"track\" - String: the name of the track\n     * The intent has an action that is one of\n     * \"com.android.music.metachanged\"\n     * \"com.android.music.queuechanged\",\n     * \"com.android.music.playbackcomplete\"\n     * \"com.android.music.playstatechanged\"\n     * respectively indicating that a new track has\n     * started playing, that the playback queue has\n     * changed, that playback has stopped because\n     * the last file in the list has been played,\n     * or that the play-state changed (paused/resumed).\n     */\n    private void notifyChange(String what) {\n        \n        Intent i = new Intent(what);\n        i.putExtra(\"id\", Long.valueOf(getAudioId()));\n        i.putExtra(\"artist\", getArtistName());\n        i.putExtra(\"album\",getAlbumName());\n        i.putExtra(\"track\", getTrackName());\n        i.putExtra(\"playing\", isPlaying());\n        sendStickyBroadcast(i);\n        \n        if (what.equals(QUEUE_CHANGED)) {\n            saveQueue(true);\n        } else {\n            saveQueue(false);\n        }\n        \n        // Share this notification directly with our widgets\n        mAppWidgetProvider.notifyChange(this, what);\n    }\n\n    private void ensurePlayListCapacity(int size) {\n        if (mPlayList == null || size > mPlayList.length) {\n            // reallocate at 2x requested size so we don't\n            // need to grow and copy the array for every\n            // insert\n            long [] newlist = new long[size * 2];\n            int len = mPlayList != null ? mPlayList.length : mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                newlist[i] = mPlayList[i];\n            }\n            mPlayList = newlist;\n        }\n        // FIXME: shrink the array when the needed size is much smaller\n        // than the allocated size\n    }\n    \n    // insert the list of songs at the specified position in the playlist\n    private void addToPlayList(long [] list, int position) {\n        int addlen = list.length;\n        if (position < 0) { // overwrite\n            mPlayListLen = 0;\n            position = 0;\n        }\n        ensurePlayListCapacity(mPlayListLen + addlen);\n        if (position > mPlayListLen) {\n            position = mPlayListLen;\n        }\n        \n        // move part of list after insertion point\n        int tailsize = mPlayListLen - position;\n        for (int i = tailsize ; i > 0 ; i--) {\n            mPlayList[position + i] = mPlayList[position + i - addlen]; \n        }\n        \n        // copy list into playlist\n        for (int i = 0; i < addlen; i++) {\n            mPlayList[position + i] = list[i];\n        }\n        mPlayListLen += addlen;\n        if (mPlayListLen == 0) {\n            mCursor.close();\n            mCursor = null;\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    /**\n     * Appends a list of tracks to the current playlist.\n     * If nothing is playing currently, playback will be started at\n     * the first track.\n     * If the action is NOW, playback will switch to the first of\n     * the new tracks immediately.\n     * @param list The list of tracks to append.\n     * @param action NOW, NEXT or LAST\n     */\n    public void enqueue(long [] list, int action) {\n        synchronized(this) {\n            if (action == NEXT && mPlayPos + 1 < mPlayListLen) {\n                addToPlayList(list, mPlayPos + 1);\n                notifyChange(QUEUE_CHANGED);\n            } else {\n                // action == LAST || action == NOW || mPlayPos + 1 == mPlayListLen\n                addToPlayList(list, Integer.MAX_VALUE);\n                notifyChange(QUEUE_CHANGED);\n                if (action == NOW) {\n                    mPlayPos = mPlayListLen - list.length;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                }\n            }\n            if (mPlayPos < 0) {\n                mPlayPos = 0;\n                openCurrent();\n                play();\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    /**\n     * Replaces the current playlist with a new list,\n     * and prepares for starting playback at the specified\n     * position in the list, or a random position if the\n     * specified position is 0.\n     * @param list The new list of tracks.\n     */\n    public void open(long [] list, int position) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                mShuffleMode = SHUFFLE_NORMAL;\n            }\n            long oldId = getAudioId();\n            int listlength = list.length;\n            boolean newlist = true;\n            if (mPlayListLen == listlength) {\n                // possible fast path: list might be the same\n                newlist = false;\n                for (int i = 0; i < listlength; i++) {\n                    if (list[i] != mPlayList[i]) {\n                        newlist = true;\n                        break;\n                    }\n                }\n            }\n            if (newlist) {\n                addToPlayList(list, -1);\n                notifyChange(QUEUE_CHANGED);\n            }\n            int oldpos = mPlayPos;\n            if (position >= 0) {\n                mPlayPos = position;\n            } else {\n                mPlayPos = mRand.nextInt(mPlayListLen);\n            }\n            mHistory.clear();\n\n            saveBookmarkIfNeeded();\n            openCurrent();\n            if (oldId != getAudioId()) {\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n    \n    /**\n     * Moves the item at index1 to index2.\n     * @param index1\n     * @param index2\n     */\n    public void moveQueueItem(int index1, int index2) {\n        synchronized (this) {\n            if (index1 >= mPlayListLen) {\n                index1 = mPlayListLen - 1;\n            }\n            if (index2 >= mPlayListLen) {\n                index2 = mPlayListLen - 1;\n            }\n            if (index1 < index2) {\n                long tmp = mPlayList[index1];\n                for (int i = index1; i < index2; i++) {\n                    mPlayList[i] = mPlayList[i+1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index1 && mPlayPos <= index2) {\n                        mPlayPos--;\n                }\n            } else if (index2 < index1) {\n                long tmp = mPlayList[index1];\n                for (int i = index1; i > index2; i--) {\n                    mPlayList[i] = mPlayList[i-1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index2 && mPlayPos <= index1) {\n                        mPlayPos++;\n                }\n            }\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    /**\n     * Returns the current play list\n     * @return An array of integers containing the IDs of the tracks in the play list\n     */\n    public long [] getQueue() {\n        synchronized (this) {\n            int len = mPlayListLen;\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                list[i] = mPlayList[i];\n            }\n            return list;\n        }\n    }\n\n    private void openCurrent() {\n        synchronized (this) {\n            if (mCursor != null) {\n                mCursor.close();\n                mCursor = null;\n            }\n\n            if (mPlayListLen == 0) {\n                return;\n            }\n            stop(false);\n\n            String id = String.valueOf(mPlayList[mPlayPos]);\n            \n            mCursor = getContentResolver().query(\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, \"_id=\" + id , null, null);\n            if (mCursor != null) {\n                mCursor.moveToFirst();\n                open(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + \"/\" + id);\n                // go to bookmark if needed\n                if (isPodcast()) {\n                    long bookmark = getBookmark();\n                    // Start playing a little bit before the bookmark,\n                    // so it's easier to get back in to the narrative.\n                    seek(bookmark - 5000);\n                }\n            }\n        }\n    }\n\n    /**\n     * Opens the specified file and readies it for playback.\n     *\n     * @param path The full path of the file to be opened.\n     */\n    public void open(String path) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            // if mCursor is null, try to associate path with a database cursor\n            if (mCursor == null) {\n\n                ContentResolver resolver = getContentResolver();\n                Uri uri;\n                String where;\n                String selectionArgs[];\n                if (path.startsWith(\"content://media/\")) {\n                    uri = Uri.parse(path);\n                    where = null;\n                    selectionArgs = null;\n                } else {\n                   uri = MediaStore.Audio.Media.getContentUriForPath(path);\n                   where = MediaStore.Audio.Media.DATA + \"=?\";\n                   selectionArgs = new String[] { path };\n                }\n                \n                try {\n                    mCursor = resolver.query(uri, mCursorCols, where, selectionArgs, null);\n                    if  (mCursor != null) {\n                        if (mCursor.getCount() == 0) {\n                            mCursor.close();\n                            mCursor = null;\n                        } else {\n                            mCursor.moveToNext();\n                            ensurePlayListCapacity(1);\n                            mPlayListLen = 1;\n                            mPlayList[0] = mCursor.getLong(IDCOLIDX);\n                            mPlayPos = 0;\n                        }\n                    }\n                } catch (UnsupportedOperationException ex) {\n                }\n            }\n            mFileToPlay = path;\n            mPlayer.setDataSource(mFileToPlay);\n            if (! mPlayer.isInitialized()) {\n                stop(true);\n                if (mOpenFailedCounter++ < 10 &&  mPlayListLen > 1) {\n                    // beware: this ends up being recursive because next() calls open() again.\n                    next(false);\n                }\n                if (! mPlayer.isInitialized() && mOpenFailedCounter != 0) {\n                    // need to make sure we only shows this once\n                    mOpenFailedCounter = 0;\n                    if (!mQuietMode) {\n                        Toast.makeText(this, R.string.playback_failed, Toast.LENGTH_SHORT).show();\n                    }\n                    Log.d(LOGTAG, \"Failed to open file for playback\");\n                }\n            } else {\n                mOpenFailedCounter = 0;\n            }\n        }\n    }\n\n    /**\n     * Starts playback of a previously opened file.\n     */\n    public void play() {\n        mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC,\n                AudioManager.AUDIOFOCUS_GAIN);\n        mAudioManager.registerMediaButtonEventReceiver(new ComponentName(this.getPackageName(),\n                MediaButtonIntentReceiver.class.getName()));\n\n        if (mPlayer.isInitialized()) {\n            // if we are at the end of the song, go to the next song first\n            long duration = mPlayer.duration();\n            if (mRepeatMode != REPEAT_CURRENT && duration > 2000 &&\n                mPlayer.position() >= duration - 2000) {\n                next(true);\n            }\n\n            mPlayer.start();\n            // make sure we fade in, in case a previous fadein was stopped because\n            // of another focus loss\n            mMediaplayerHandler.removeMessages(FADEDOWN);\n            mMediaplayerHandler.sendEmptyMessage(FADEUP);\n\n            RemoteViews views = new RemoteViews(getPackageName(), R.layout.statusbar);\n            views.setImageViewResource(R.id.icon, R.drawable.stat_notify_musicplayer);\n            if (getAudioId() < 0) {\n                // streaming\n                views.setTextViewText(R.id.trackname, getPath());\n                views.setTextViewText(R.id.artistalbum, null);\n            } else {\n                String artist = getArtistName();\n                views.setTextViewText(R.id.trackname, getTrackName());\n                if (artist == null || artist.equals(MediaStore.UNKNOWN_STRING)) {\n                    artist = getString(R.string.unknown_artist_name);\n                }\n                String album = getAlbumName();\n                if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n                    album = getString(R.string.unknown_album_name);\n                }\n                \n                views.setTextViewText(R.id.artistalbum,\n                        getString(R.string.notification_artist_album, artist, album)\n                        );\n            }\n            \n            Notification status = new Notification();\n            status.contentView = views;\n            status.flags |= Notification.FLAG_ONGOING_EVENT;\n            status.icon = R.drawable.stat_notify_musicplayer;\n            status.contentIntent = PendingIntent.getActivity(this, 0,\n                    new Intent(\"com.android.music.PLAYBACK_VIEWER\")\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), 0);\n            startForeground(PLAYBACKSERVICE_STATUS, status);\n            if (!mIsSupposedToBePlaying) {\n                mIsSupposedToBePlaying = true;\n                notifyChange(PLAYSTATE_CHANGED);\n            }\n\n        } else if (mPlayListLen <= 0) {\n            // This is mostly so that if you press 'play' on a bluetooth headset\n            // without every having played anything before, it will still play\n            // something.\n            setShuffleMode(SHUFFLE_AUTO);\n        }\n    }\n    \n    private void stop(boolean remove_status_icon) {\n        if (mPlayer.isInitialized()) {\n            mPlayer.stop();\n        }\n        mFileToPlay = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n        if (remove_status_icon) {\n            gotoIdleState();\n        } else {\n            stopForeground(false);\n        }\n        if (remove_status_icon) {\n            mIsSupposedToBePlaying = false;\n        }\n    }\n\n    /**\n     * Stops playback.\n     */\n    public void stop() {\n        stop(true);\n    }\n\n    /**\n     * Pauses playback (call play() to resume)\n     */\n    public void pause() {\n        synchronized(this) {\n            mMediaplayerHandler.removeMessages(FADEUP);\n            if (isPlaying()) {\n                mPlayer.pause();\n                gotoIdleState();\n                mIsSupposedToBePlaying = false;\n                notifyChange(PLAYSTATE_CHANGED);\n                saveBookmarkIfNeeded();\n            }\n        }\n    }\n\n    /** Returns whether something is currently playing\n     *\n     * @return true if something is playing (or will be playing shortly, in case\n     * we're currently transitioning between tracks), false if not.\n     */\n    public boolean isPlaying() {\n        return mIsSupposedToBePlaying;\n    }\n\n    /*\n      Desired behavior for prev/next/shuffle:\n\n      - NEXT will move to the next track in the list when not shuffling, and to\n        a track randomly picked from the not-yet-played tracks when shuffling.\n        If all tracks have already been played, pick from the full set, but\n        avoid picking the previously played track if possible.\n      - when shuffling, PREV will go to the previously played track. Hitting PREV\n        again will go to the track played before that, etc. When the start of the\n        history has been reached, PREV is a no-op.\n        When not shuffling, PREV will go to the sequentially previous track (the\n        difference with the shuffle-case is mainly that when not shuffling, the\n        user can back up to tracks that are not in the history).\n\n        Example:\n        When playing an album with 10 tracks from the start, and enabling shuffle\n        while playing track 5, the remaining tracks (6-10) will be shuffled, e.g.\n        the final play order might be 1-2-3-4-5-8-10-6-9-7.\n        When hitting 'prev' 8 times while playing track 7 in this example, the\n        user will go to tracks 9-6-10-8-5-4-3-2. If the user then hits 'next',\n        a random track will be picked again. If at any time user disables shuffling\n        the next/previous track will be picked in sequential order again.\n     */\n\n    public void prev() {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // go to previously-played track and remove it from the history\n                int histsize = mHistory.size();\n                if (histsize == 0) {\n                    // prev is a no-op\n                    return;\n                }\n                Integer pos = mHistory.remove(histsize - 1);\n                mPlayPos = pos.intValue();\n            } else {\n                if (mPlayPos > 0) {\n                    mPlayPos--;\n                } else {\n                    mPlayPos = mPlayListLen - 1;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void next(boolean force) {\n        synchronized (this) {\n            if (mPlayListLen <= 0) {\n                Log.d(LOGTAG, \"No play queue\");\n                return;\n            }\n\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // Pick random next track from the not-yet-played ones\n                // TODO: make it work right after adding/removing items in the queue.\n\n                // Store the current file in the history, but keep the history at a\n                // reasonable size\n                if (mPlayPos >= 0) {\n                    mHistory.add(mPlayPos);\n                }\n                if (mHistory.size() > MAX_HISTORY_SIZE) {\n                    mHistory.removeElementAt(0);\n                }\n\n                int numTracks = mPlayListLen;\n                int[] tracks = new int[numTracks];\n                for (int i=0;i < numTracks; i++) {\n                    tracks[i] = i;\n                }\n\n                int numHistory = mHistory.size();\n                int numUnplayed = numTracks;\n                for (int i=0;i < numHistory; i++) {\n                    int idx = mHistory.get(i).intValue();\n                    if (idx < numTracks && tracks[idx] >= 0) {\n                        numUnplayed--;\n                        tracks[idx] = -1;\n                    }\n                }\n\n                // 'numUnplayed' now indicates how many tracks have not yet\n                // been played, and 'tracks' contains the indices of those\n                // tracks.\n                if (numUnplayed <=0) {\n                    // everything's already been played\n                    if (mRepeatMode == REPEAT_ALL || force) {\n                        //pick from full set\n                        numUnplayed = numTracks;\n                        for (int i=0;i < numTracks; i++) {\n                            tracks[i] = i;\n                        }\n                    } else {\n                        // all done\n                        gotoIdleState();\n                        if (mIsSupposedToBePlaying) {\n                            mIsSupposedToBePlaying = false;\n                            notifyChange(PLAYSTATE_CHANGED);\n                        }\n                        return;\n                    }\n                }\n                int skip = mRand.nextInt(numUnplayed);\n                int cnt = -1;\n                while (true) {\n                    while (tracks[++cnt] < 0)\n                        ;\n                    skip--;\n                    if (skip < 0) {\n                        break;\n                    }\n                }\n                mPlayPos = cnt;\n            } else if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n                mPlayPos++;\n            } else {\n                if (mPlayPos >= mPlayListLen - 1) {\n                    // we're at the end of the list\n                    if (mRepeatMode == REPEAT_NONE && !force) {\n                        // all done\n                        gotoIdleState();\n                        mIsSupposedToBePlaying = false;\n                        notifyChange(PLAYSTATE_CHANGED);\n                        return;\n                    } else if (mRepeatMode == REPEAT_ALL || force) {\n                        mPlayPos = 0;\n                    }\n                } else {\n                    mPlayPos++;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    private void gotoIdleState() {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n        stopForeground(true);\n    }\n    \n    private void saveBookmarkIfNeeded() {\n        try {\n            if (isPodcast()) {\n                long pos = position();\n                long bookmark = getBookmark();\n                long duration = duration();\n                if ((pos < bookmark && (pos + 10000) > bookmark) ||\n                        (pos > bookmark && (pos - 10000) < bookmark)) {\n                    // The existing bookmark is close to the current\n                    // position, so don't update it.\n                    return;\n                }\n                if (pos < 15000 || (pos + 10000) > duration) {\n                    // if we're near the start or end, clear the bookmark\n                    pos = 0;\n                }\n                \n                // write 'pos' to the bookmark field\n                ContentValues values = new ContentValues();\n                values.put(MediaStore.Audio.Media.BOOKMARK, pos);\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursor.getLong(IDCOLIDX));\n                getContentResolver().update(uri, values, null, null);\n            }\n        } catch (SQLiteException ex) {\n        }\n    }\n\n    // Make sure there are at least 5 items after the currently playing item\n    // and no more than 10 items before.\n    private void doAutoShuffleUpdate() {\n        boolean notify = false;\n\n        // remove old entries\n        if (mPlayPos > 10) {\n            removeTracks(0, mPlayPos - 9);\n            notify = true;\n        }\n        // add new entries if needed\n        int to_add = 7 - (mPlayListLen - (mPlayPos < 0 ? -1 : mPlayPos));\n        for (int i = 0; i < to_add; i++) {\n            // pick something at random from the list\n\n            int lookback = mHistory.size();\n            int idx = -1;\n            while(true) {\n                idx = mRand.nextInt(mAutoShuffleList.length);\n                if (!wasRecentlyUsed(idx, lookback)) {\n                    break;\n                }\n                lookback /= 2;\n            }\n            mHistory.add(idx);\n            if (mHistory.size() > MAX_HISTORY_SIZE) {\n                mHistory.remove(0);\n            }\n            ensurePlayListCapacity(mPlayListLen + 1);\n            mPlayList[mPlayListLen++] = mAutoShuffleList[idx];\n            notify = true;\n        }\n        if (notify) {\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    // check that the specified idx is not in the history (but only look at at\n    // most lookbacksize entries in the history)\n    private boolean wasRecentlyUsed(int idx, int lookbacksize) {\n\n        // early exit to prevent infinite loops in case idx == mPlayPos\n        if (lookbacksize == 0) {\n            return false;\n        }\n\n        int histsize = mHistory.size();\n        if (histsize < lookbacksize) {\n            Log.d(LOGTAG, \"lookback too big\");\n            lookbacksize = histsize;\n        }\n        int maxidx = histsize - 1;\n        for (int i = 0; i < lookbacksize; i++) {\n            long entry = mHistory.get(maxidx - i);\n            if (entry == idx) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // A simple variation of Random that makes sure that the\n    // value it returns is not equal to the value it returned\n    // previously, unless the interval is 1.\n    private static class Shuffler {\n        private int mPrevious;\n        private Random mRandom = new Random();\n        public int nextInt(int interval) {\n            int ret;\n            do {\n                ret = mRandom.nextInt(interval);\n            } while (ret == mPrevious && interval > 1);\n            mPrevious = ret;\n            return ret;\n        }\n    };\n\n    private boolean makeAutoShuffleList() {\n        ContentResolver res = getContentResolver();\n        Cursor c = null;\n        try {\n            c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                    null, null);\n            if (c == null || c.getCount() == 0) {\n                return false;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n            mAutoShuffleList = list;\n            return true;\n        } catch (RuntimeException ex) {\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Removes the range of tracks specified from the play list. If a file within the range is\n     * the file currently being played, playback will move to the next file after the\n     * range. \n     * @param first The first file to be removed\n     * @param last The last file to be removed\n     * @return the number of tracks deleted\n     */\n    public int removeTracks(int first, int last) {\n        int numremoved = removeTracksInternal(first, last);\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    private int removeTracksInternal(int first, int last) {\n        synchronized (this) {\n            if (last < first) return 0;\n            if (first < 0) first = 0;\n            if (last >= mPlayListLen) last = mPlayListLen - 1;\n\n            boolean gotonext = false;\n            if (first <= mPlayPos && mPlayPos <= last) {\n                mPlayPos = first;\n                gotonext = true;\n            } else if (mPlayPos > last) {\n                mPlayPos -= (last - first + 1);\n            }\n            int num = mPlayListLen - last - 1;\n            for (int i = 0; i < num; i++) {\n                mPlayList[first + i] = mPlayList[last + 1 + i];\n            }\n            mPlayListLen -= last - first + 1;\n            \n            if (gotonext) {\n                if (mPlayListLen == 0) {\n                    stop(true);\n                    mPlayPos = -1;\n                    if (mCursor != null) {\n                        mCursor.close();\n                        mCursor = null;\n                    }\n                } else {\n                    if (mPlayPos >= mPlayListLen) {\n                        mPlayPos = 0;\n                    }\n                    boolean wasPlaying = isPlaying();\n                    stop(false);\n                    openCurrent();\n                    if (wasPlaying) {\n                        play();\n                    }\n                }\n                notifyChange(META_CHANGED);\n            }\n            return last - first + 1;\n        }\n    }\n    \n    /**\n     * Removes all instances of the track with the given id\n     * from the playlist.\n     * @param id The id to be removed\n     * @return how many instances of the track were removed\n     */\n    public int removeTrack(long id) {\n        int numremoved = 0;\n        synchronized (this) {\n            for (int i = 0; i < mPlayListLen; i++) {\n                if (mPlayList[i] == id) {\n                    numremoved += removeTracksInternal(i, i);\n                    i--;\n                }\n            }\n        }\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    public void setShuffleMode(int shufflemode) {\n        synchronized(this) {\n            if (mShuffleMode == shufflemode && mPlayListLen > 0) {\n                return;\n            }\n            mShuffleMode = shufflemode;\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                if (makeAutoShuffleList()) {\n                    mPlayListLen = 0;\n                    doAutoShuffleUpdate();\n                    mPlayPos = 0;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                } else {\n                    // failed to build a list of files to shuffle\n                    mShuffleMode = SHUFFLE_NONE;\n                }\n            }\n            saveQueue(false);\n        }\n    }\n    public int getShuffleMode() {\n        return mShuffleMode;\n    }\n    \n    public void setRepeatMode(int repeatmode) {\n        synchronized(this) {\n            mRepeatMode = repeatmode;\n            saveQueue(false);\n        }\n    }\n    public int getRepeatMode() {\n        return mRepeatMode;\n    }\n\n    public int getMediaMountedCount() {\n        return mMediaMountedCount;\n    }\n\n    /**\n     * Returns the path of the currently playing file, or null if\n     * no file is currently playing.\n     */\n    public String getPath() {\n        return mFileToPlay;\n    }\n    \n    /**\n     * Returns the rowid of the currently playing file, or -1 if\n     * no file is currently playing.\n     */\n    public long getAudioId() {\n        synchronized (this) {\n            if (mPlayPos >= 0 && mPlayer.isInitialized()) {\n                return mPlayList[mPlayPos];\n            }\n        }\n        return -1;\n    }\n    \n    /**\n     * Returns the position in the queue \n     * @return the position in the queue\n     */\n    public int getQueuePosition() {\n        synchronized(this) {\n            return mPlayPos;\n        }\n    }\n    \n    /**\n     * Starts playing the track at the given position in the queue.\n     * @param pos The position in the queue of the track that will be played.\n     */\n    public void setQueuePosition(int pos) {\n        synchronized(this) {\n            stop(false);\n            mPlayPos = pos;\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n            }\n        }\n    }\n\n    public String getArtistName() {\n        synchronized(this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));\n        }\n    }\n    \n    public long getArtistId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID));\n        }\n    }\n\n    public String getAlbumName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM));\n        }\n    }\n\n    public long getAlbumId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID));\n        }\n    }\n\n    public String getTrackName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));\n        }\n    }\n\n    private boolean isPodcast() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return false;\n            }\n            return (mCursor.getInt(PODCASTCOLIDX) > 0);\n        }\n    }\n    \n    private long getBookmark() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return 0;\n            }\n            return mCursor.getLong(BOOKMARKCOLIDX);\n        }\n    }\n    \n    /**\n     * Returns the duration of the file in milliseconds.\n     * Currently this method returns -1 for the duration of MIDI files.\n     */\n    public long duration() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.duration();\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the current playback position in milliseconds\n     */\n    public long position() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.position();\n        }\n        return -1;\n    }\n\n    /**\n     * Seeks to the position specified.\n     *\n     * @param pos The position to seek to, in milliseconds\n     */\n    public long seek(long pos) {\n        if (mPlayer.isInitialized()) {\n            if (pos < 0) pos = 0;\n            if (pos > mPlayer.duration()) pos = mPlayer.duration();\n            return mPlayer.seek(pos);\n        }\n        return -1;\n    }\n\n    /**\n     * Sets the audio session ID.\n     *\n     * @param sessionId: the audio session ID.\n     */\n    public void setAudioSessionId(int sessionId) {\n        synchronized (this) {\n            mPlayer.setAudioSessionId(sessionId);\n        }\n    }\n\n    /**\n     * Returns the audio session ID.\n     */\n    public int getAudioSessionId() {\n        synchronized (this) {\n            return mPlayer.getAudioSessionId();\n        }\n    }\n\n    /**\n     * Provides a unified interface for dealing with midi files and\n     * other media files.\n     */\n    private class MultiPlayer {\n        private MediaPlayer mMediaPlayer = new MediaPlayer();\n        private Handler mHandler;\n        private boolean mIsInitialized = false;\n\n        public MultiPlayer() {\n            mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n        }\n\n        public void setDataSource(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setOnPreparedListener(null);\n                if (path.startsWith(\"content://\")) {\n                    mMediaPlayer.setDataSource(MediaPlaybackService.this, Uri.parse(path));\n                } else {\n                    mMediaPlayer.setDataSource(path);\n                }\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.prepare();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            Intent i = new Intent(AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION);\n            i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n            i.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n            sendBroadcast(i);\n            mIsInitialized = true;\n        }\n        \n        public boolean isInitialized() {\n            return mIsInitialized;\n        }\n\n        public void start() {\n            MusicUtils.debugLog(new Exception(\"MultiPlayer.start called\"));\n            mMediaPlayer.start();\n        }\n\n        public void stop() {\n            mMediaPlayer.reset();\n            mIsInitialized = false;\n        }\n\n        /**\n         * You CANNOT use this player anymore after calling release()\n         */\n        public void release() {\n            stop();\n            mMediaPlayer.release();\n        }\n        \n        public void pause() {\n            mMediaPlayer.pause();\n        }\n        \n        public void setHandler(Handler handler) {\n            mHandler = handler;\n        }\n\n        MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n            public void onCompletion(MediaPlayer mp) {\n                // Acquire a temporary wakelock, since when we return from\n                // this callback the MediaPlayer will release its wakelock\n                // and allow the device to go to sleep.\n                // This temporary wakelock is released when the RELEASE_WAKELOCK\n                // message is processed, but just in case, put a timeout on it.\n                mWakeLock.acquire(30000);\n                mHandler.sendEmptyMessage(TRACK_ENDED);\n                mHandler.sendEmptyMessage(RELEASE_WAKELOCK);\n            }\n        };\n\n        MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() {\n            public boolean onError(MediaPlayer mp, int what, int extra) {\n                switch (what) {\n                case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                    mIsInitialized = false;\n                    mMediaPlayer.release();\n                    // Creating a new MediaPlayer and settings its wakemode does not\n                    // require the media service, so it's OK to do this now, while the\n                    // service is still being restarted\n                    mMediaPlayer = new MediaPlayer(); \n                    mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n                    mHandler.sendMessageDelayed(mHandler.obtainMessage(SERVER_DIED), 2000);\n                    return true;\n                default:\n                    Log.d(\"MultiPlayer\", \"Error: \" + what + \",\" + extra);\n                    break;\n                }\n                return false;\n           }\n        };\n\n        public long duration() {\n            return mMediaPlayer.getDuration();\n        }\n\n        public long position() {\n            return mMediaPlayer.getCurrentPosition();\n        }\n\n        public long seek(long whereto) {\n            mMediaPlayer.seekTo((int) whereto);\n            return whereto;\n        }\n\n        public void setVolume(float vol) {\n            mMediaPlayer.setVolume(vol, vol);\n        }\n\n        public void setAudioSessionId(int sessionId) {\n            mMediaPlayer.setAudioSessionId(sessionId);\n        }\n\n        public int getAudioSessionId() {\n            return mMediaPlayer.getAudioSessionId();\n        }\n    }\n\n    /*\n     * By making this a static class with a WeakReference to the Service, we\n     * ensure that the Service can be GCd even when the system process still\n     * has a remote reference to the stub.\n     */\n    static class ServiceStub extends IMediaPlaybackService.Stub {\n        WeakReference<MediaPlaybackService> mService;\n        \n        ServiceStub(MediaPlaybackService service) {\n            mService = new WeakReference<MediaPlaybackService>(service);\n        }\n\n        public void openFile(String path)\n        {\n            mService.get().open(path);\n        }\n        public void open(long [] list, int position) {\n            mService.get().open(list, position);\n        }\n        public int getQueuePosition() {\n            return mService.get().getQueuePosition();\n        }\n        public void setQueuePosition(int index) {\n            mService.get().setQueuePosition(index);\n        }\n        public boolean isPlaying() {\n            return mService.get().isPlaying();\n        }\n        public void stop() {\n            mService.get().stop();\n        }\n        public void pause() {\n            mService.get().pause();\n        }\n        public void play() {\n            mService.get().play();\n        }\n        public void prev() {\n            mService.get().prev();\n        }\n        public void next() {\n            mService.get().next(true);\n        }\n        public String getTrackName() {\n            return mService.get().getTrackName();\n        }\n        public String getAlbumName() {\n            return mService.get().getAlbumName();\n        }\n        public long getAlbumId() {\n            return mService.get().getAlbumId();\n        }\n        public String getArtistName() {\n            return mService.get().getArtistName();\n        }\n        public long getArtistId() {\n            return mService.get().getArtistId();\n        }\n        public void enqueue(long [] list , int action) {\n            mService.get().enqueue(list, action);\n        }\n        public long [] getQueue() {\n            return mService.get().getQueue();\n        }\n        public void moveQueueItem(int from, int to) {\n            mService.get().moveQueueItem(from, to);\n        }\n        public String getPath() {\n            return mService.get().getPath();\n        }\n        public long getAudioId() {\n            return mService.get().getAudioId();\n        }\n        public long position() {\n            return mService.get().position();\n        }\n        public long duration() {\n            return mService.get().duration();\n        }\n        public long seek(long pos) {\n            return mService.get().seek(pos);\n        }\n        public void setShuffleMode(int shufflemode) {\n            mService.get().setShuffleMode(shufflemode);\n        }\n        public int getShuffleMode() {\n            return mService.get().getShuffleMode();\n        }\n        public int removeTracks(int first, int last) {\n            return mService.get().removeTracks(first, last);\n        }\n        public int removeTrack(long id) {\n            return mService.get().removeTrack(id);\n        }\n        public void setRepeatMode(int repeatmode) {\n            mService.get().setRepeatMode(repeatmode);\n        }\n        public int getRepeatMode() {\n            return mService.get().getRepeatMode();\n        }\n        public int getMediaMountedCount() {\n            return mService.get().getMediaMountedCount();\n        }\n        public int getAudioSessionId() {\n            return mService.get().getAudioSessionId();\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        writer.println(\"\" + mPlayListLen + \" items in queue, currently at index \" + mPlayPos);\n        writer.println(\"Currently loaded:\");\n        writer.println(getArtistName());\n        writer.println(getAlbumName());\n        writer.println(getTrackName());\n        writer.println(getPath());\n        writer.println(\"playing: \" + mIsSupposedToBePlaying);\n        writer.println(\"actual: \" + mPlayer.mMediaPlayer.isPlaying());\n        writer.println(\"shuffle mode: \" + mShuffleMode);\n        MusicUtils.debugDump(writer);\n    }\n\n    private final IBinder mBinder = new ServiceStub(this);\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.graphics.Bitmap;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.media.AudioManager.OnAudioFocusChangeListener;\nimport android.media.MediaMetadataRetriever;\nimport android.media.MediaPlayer;\nimport android.media.RemoteControlClient;\nimport android.media.RemoteControlClient.MetadataEditor;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.os.PowerManager.WakeLock;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Provides \"background\" audio playback capabilities, allowing the\n * user to switch between activities without stopping playback.\n */\npublic class MediaPlaybackService extends Service {\n    /** used to specify whether enqueue() should start playing\n     * the new list of files right away, next or once all the currently\n     * queued files have been played\n     */\n    public static final int NOW = 1;\n    public static final int NEXT = 2;\n    public static final int LAST = 3;\n    public static final int PLAYBACKSERVICE_STATUS = 1;\n    \n    public static final int SHUFFLE_NONE = 0;\n    public static final int SHUFFLE_NORMAL = 1;\n    public static final int SHUFFLE_AUTO = 2;\n    \n    public static final int REPEAT_NONE = 0;\n    public static final int REPEAT_CURRENT = 1;\n    public static final int REPEAT_ALL = 2;\n\n    public static final String PLAYSTATE_CHANGED = \"com.android.music.playstatechanged\";\n    public static final String META_CHANGED = \"com.android.music.metachanged\";\n    public static final String QUEUE_CHANGED = \"com.android.music.queuechanged\";\n\n    public static final String SERVICECMD = \"com.android.music.musicservicecommand\";\n    public static final String CMDNAME = \"command\";\n    public static final String CMDTOGGLEPAUSE = \"togglepause\";\n    public static final String CMDSTOP = \"stop\";\n    public static final String CMDPAUSE = \"pause\";\n    public static final String CMDPLAY = \"play\";\n    public static final String CMDPREVIOUS = \"previous\";\n    public static final String CMDNEXT = \"next\";\n\n    public static final String TOGGLEPAUSE_ACTION = \"com.android.music.musicservicecommand.togglepause\";\n    public static final String PAUSE_ACTION = \"com.android.music.musicservicecommand.pause\";\n    public static final String PREVIOUS_ACTION = \"com.android.music.musicservicecommand.previous\";\n    public static final String NEXT_ACTION = \"com.android.music.musicservicecommand.next\";\n\n    private static final int TRACK_ENDED = 1;\n    private static final int RELEASE_WAKELOCK = 2;\n    private static final int SERVER_DIED = 3;\n    private static final int FOCUSCHANGE = 4;\n    private static final int FADEDOWN = 5;\n    private static final int FADEUP = 6;\n    private static final int MAX_HISTORY_SIZE = 100;\n    \n    private MultiPlayer mPlayer;\n    private String mFileToPlay;\n    private int mShuffleMode = SHUFFLE_NONE;\n    private int mRepeatMode = REPEAT_NONE;\n    private int mMediaMountedCount = 0;\n    private long [] mAutoShuffleList = null;\n    private long [] mPlayList = null;\n    private int mPlayListLen = 0;\n    private Vector<Integer> mHistory = new Vector<Integer>(MAX_HISTORY_SIZE);\n    private Cursor mCursor;\n    private int mPlayPos = -1;\n    private static final String LOGTAG = \"MediaPlaybackService\";\n    private final Shuffler mRand = new Shuffler();\n    private int mOpenFailedCounter = 0;\n    String[] mCursorCols = new String[] {\n            \"audio._id AS _id\",             // index must match IDCOLIDX below\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE,\n            MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.IS_PODCAST, // index must match PODCASTCOLIDX below\n            MediaStore.Audio.Media.BOOKMARK    // index must match BOOKMARKCOLIDX below\n    };\n    private final static int IDCOLIDX = 0;\n    private final static int PODCASTCOLIDX = 8;\n    private final static int BOOKMARKCOLIDX = 9;\n    private BroadcastReceiver mUnmountReceiver = null;\n    private WakeLock mWakeLock;\n    private int mServiceStartId = -1;\n    private boolean mServiceInUse = false;\n    private boolean mIsSupposedToBePlaying = false;\n    private boolean mQuietMode = false;\n    private AudioManager mAudioManager;\n    private boolean mQueueIsSaveable = true;\n    // used to track what type of audio focus loss caused the playback to pause\n    private boolean mPausedByTransientLossOfFocus = false;\n\n    private SharedPreferences mPreferences;\n    // We use this to distinguish between different cards when saving/restoring playlists.\n    // This will have to change if we want to support multiple simultaneous cards.\n    private int mCardId;\n    \n    private MediaAppWidgetProvider mAppWidgetProvider = MediaAppWidgetProvider.getInstance();\n    \n    // interval after which we stop the service when idle\n    private static final int IDLE_DELAY = 60000;\n\n    private RemoteControlClient mRemoteControlClient;\n\n    private Handler mMediaplayerHandler = new Handler() {\n        float mCurrentVolume = 1.0f;\n        @Override\n        public void handleMessage(Message msg) {\n            MusicUtils.debugLog(\"mMediaplayerHandler.handleMessage \" + msg.what);\n            switch (msg.what) {\n                case FADEDOWN:\n                    mCurrentVolume -= .05f;\n                    if (mCurrentVolume > .2f) {\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEDOWN, 10);\n                    } else {\n                        mCurrentVolume = .2f;\n                    }\n                    mPlayer.setVolume(mCurrentVolume);\n                    break;\n                case FADEUP:\n                    mCurrentVolume += .01f;\n                    if (mCurrentVolume < 1.0f) {\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEUP, 10);\n                    } else {\n                        mCurrentVolume = 1.0f;\n                    }\n                    mPlayer.setVolume(mCurrentVolume);\n                    break;\n                case SERVER_DIED:\n                    if (mIsSupposedToBePlaying) {\n                        next(true);\n                    } else {\n                        // the server died when we were idle, so just\n                        // reopen the same song (it will start again\n                        // from the beginning though when the user\n                        // restarts)\n                        openCurrent();\n                    }\n                    break;\n                case TRACK_ENDED:\n                    if (mRepeatMode == REPEAT_CURRENT) {\n                        seek(0);\n                        play();\n                    } else {\n                        next(false);\n                    }\n                    break;\n                case RELEASE_WAKELOCK:\n                    mWakeLock.release();\n                    break;\n\n                case FOCUSCHANGE:\n                    // This code is here so we can better synchronize it with the code that\n                    // handles fade-in\n                    switch (msg.arg1) {\n                        case AudioManager.AUDIOFOCUS_LOSS:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_LOSS\");\n                            if(isPlaying()) {\n                                mPausedByTransientLossOfFocus = false;\n                            }\n                            pause();\n                            break;\n                        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:\n                            mMediaplayerHandler.removeMessages(FADEUP);\n                            mMediaplayerHandler.sendEmptyMessage(FADEDOWN);\n                            break;\n                        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_LOSS_TRANSIENT\");\n                            if(isPlaying()) {\n                                mPausedByTransientLossOfFocus = true;\n                            }\n                            pause();\n                            break;\n                        case AudioManager.AUDIOFOCUS_GAIN:\n                            Log.v(LOGTAG, \"AudioFocus: received AUDIOFOCUS_GAIN\");\n                            if(!isPlaying() && mPausedByTransientLossOfFocus) {\n                                mPausedByTransientLossOfFocus = false;\n                                mCurrentVolume = 0f;\n                                mPlayer.setVolume(mCurrentVolume);\n                                play(); // also queues a fade-in\n                            } else {\n                                mMediaplayerHandler.removeMessages(FADEDOWN);\n                                mMediaplayerHandler.sendEmptyMessage(FADEUP);\n                            }\n                            break;\n                        default:\n                            Log.e(LOGTAG, \"Unknown audio focus change code\");\n                    }\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            MusicUtils.debugLog(\"mIntentReceiver.onReceive \" + action + \" / \" + cmd);\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                prev();\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                    mPausedByTransientLossOfFocus = false;\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            } else if (CMDPLAY.equals(cmd)) {\n                play();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n                seek(0);\n            } else if (MediaAppWidgetProvider.CMDAPPWIDGETUPDATE.equals(cmd)) {\n                // Someone asked us to refresh a set of specific widgets, probably\n                // because they were just added.\n                int[] appWidgetIds = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);\n                mAppWidgetProvider.performUpdate(MediaPlaybackService.this, appWidgetIds);\n            }\n        }\n    };\n\n    private OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {\n        public void onAudioFocusChange(int focusChange) {\n            mMediaplayerHandler.obtainMessage(FOCUSCHANGE, focusChange, 0).sendToTarget();\n        }\n    };\n\n    public MediaPlaybackService() {\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n        ComponentName rec = new ComponentName(getPackageName(),\n                MediaButtonIntentReceiver.class.getName());\n        mAudioManager.registerMediaButtonEventReceiver(rec);\n        mRemoteControlClient = new RemoteControlClient(rec);\n        mAudioManager.registerRemoteControlClient(mRemoteControlClient);\n\n        int flags = RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS\n                | RemoteControlClient.FLAG_KEY_MEDIA_NEXT\n                | RemoteControlClient.FLAG_KEY_MEDIA_PLAY\n                | RemoteControlClient.FLAG_KEY_MEDIA_PAUSE\n                | RemoteControlClient.FLAG_KEY_MEDIA_PLAY_PAUSE\n                | RemoteControlClient.FLAG_KEY_MEDIA_STOP;\n        mRemoteControlClient.setTransportControlFlags(flags);\n        \n        mPreferences = getSharedPreferences(\"Music\", MODE_WORLD_READABLE | MODE_WORLD_WRITEABLE);\n        mCardId = MusicUtils.getCardId(this);\n        \n        registerExternalStorageListener();\n\n        // Needs to be done in this thread, since otherwise ApplicationContext.getPowerManager() crashes.\n        mPlayer = new MultiPlayer();\n        mPlayer.setHandler(mMediaplayerHandler);\n\n        reloadQueue();\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n\n        IntentFilter commandFilter = new IntentFilter();\n        commandFilter.addAction(SERVICECMD);\n        commandFilter.addAction(TOGGLEPAUSE_ACTION);\n        commandFilter.addAction(PAUSE_ACTION);\n        commandFilter.addAction(NEXT_ACTION);\n        commandFilter.addAction(PREVIOUS_ACTION);\n        registerReceiver(mIntentReceiver, commandFilter);\n        \n        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);\n        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, this.getClass().getName());\n        mWakeLock.setReferenceCounted(false);\n\n        // If the service was idle, but got killed before it stopped itself, the\n        // system will relaunch it. Make sure it gets stopped again in that case.\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n\n    @Override\n    public void onDestroy() {\n        // Check that we're not being destroyed while something is still playing.\n        if (isPlaying()) {\n            Log.e(LOGTAG, \"Service being destroyed while still playing.\");\n        }\n        // release all MediaPlayer resources, including the native player and wakelocks\n        Intent i = new Intent(AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);\n        i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n        i.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n        sendBroadcast(i);\n        mPlayer.release();\n        mPlayer = null;\n\n        mAudioManager.abandonAudioFocus(mAudioFocusListener);\n        mAudioManager.unregisterRemoteControlClient(mRemoteControlClient);\n        \n        // make sure there aren't any other messages coming\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mMediaplayerHandler.removeCallbacksAndMessages(null);\n\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n\n        unregisterReceiver(mIntentReceiver);\n        if (mUnmountReceiver != null) {\n            unregisterReceiver(mUnmountReceiver);\n            mUnmountReceiver = null;\n        }\n        mWakeLock.release();\n        super.onDestroy();\n    }\n    \n    private final char hexdigits [] = new char [] {\n            '0', '1', '2', '3',\n            '4', '5', '6', '7',\n            '8', '9', 'a', 'b',\n            'c', 'd', 'e', 'f'\n    };\n\n    private void saveQueue(boolean full) {\n        if (!mQueueIsSaveable) {\n            return;\n        }\n\n        Editor ed = mPreferences.edit();\n        //long start = System.currentTimeMillis();\n        if (full) {\n            StringBuilder q = new StringBuilder();\n            \n            // The current playlist is saved as a list of \"reverse hexadecimal\"\n            // numbers, which we can generate faster than normal decimal or\n            // hexadecimal numbers, which in turn allows us to save the playlist\n            // more often without worrying too much about performance.\n            // (saving the full state takes about 40 ms under no-load conditions\n            // on the phone)\n            int len = mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                long n = mPlayList[i];\n                if (n < 0) {\n                    continue;\n                } else if (n == 0) {\n                    q.append(\"0;\");\n                } else {\n                    while (n != 0) {\n                        int digit = (int)(n & 0xf);\n                        n >>>= 4;\n                        q.append(hexdigits[digit]);\n                    }\n                    q.append(\";\");\n                }\n            }\n            //Log.i(\"@@@@ service\", \"created queue string in \" + (System.currentTimeMillis() - start) + \" ms\");\n            ed.putString(\"queue\", q.toString());\n            ed.putInt(\"cardid\", mCardId);\n            if (mShuffleMode != SHUFFLE_NONE) {\n                // In shuffle mode we need to save the history too\n                len = mHistory.size();\n                q.setLength(0);\n                for (int i = 0; i < len; i++) {\n                    int n = mHistory.get(i);\n                    if (n == 0) {\n                        q.append(\"0;\");\n                    } else {\n                        while (n != 0) {\n                            int digit = (n & 0xf);\n                            n >>>= 4;\n                            q.append(hexdigits[digit]);\n                        }\n                        q.append(\";\");\n                    }\n                }\n                ed.putString(\"history\", q.toString());\n            }\n        }\n        ed.putInt(\"curpos\", mPlayPos);\n        if (mPlayer.isInitialized()) {\n            ed.putLong(\"seekpos\", mPlayer.position());\n        }\n        ed.putInt(\"repeatmode\", mRepeatMode);\n        ed.putInt(\"shufflemode\", mShuffleMode);\n        SharedPreferencesCompat.apply(ed);\n\n        //Log.i(\"@@@@ service\", \"saved state in \" + (System.currentTimeMillis() - start) + \" ms\");\n    }\n\n    private void reloadQueue() {\n        String q = null;\n        \n        boolean newstyle = false;\n        int id = mCardId;\n        if (mPreferences.contains(\"cardid\")) {\n            newstyle = true;\n            id = mPreferences.getInt(\"cardid\", ~mCardId);\n        }\n        if (id == mCardId) {\n            // Only restore the saved playlist if the card is still\n            // the same one as when the playlist was saved\n            q = mPreferences.getString(\"queue\", \"\");\n        }\n        int qlen = q != null ? q.length() : 0;\n        if (qlen > 1) {\n            //Log.i(\"@@@@ service\", \"loaded queue: \" + q);\n            int plen = 0;\n            int n = 0;\n            int shift = 0;\n            for (int i = 0; i < qlen; i++) {\n                char c = q.charAt(i);\n                if (c == ';') {\n                    ensurePlayListCapacity(plen + 1);\n                    mPlayList[plen] = n;\n                    plen++;\n                    n = 0;\n                    shift = 0;\n                } else {\n                    if (c >= '0' && c <= '9') {\n                        n += ((c - '0') << shift);\n                    } else if (c >= 'a' && c <= 'f') {\n                        n += ((10 + c - 'a') << shift);\n                    } else {\n                        // bogus playlist data\n                        plen = 0;\n                        break;\n                    }\n                    shift += 4;\n                }\n            }\n            mPlayListLen = plen;\n\n            int pos = mPreferences.getInt(\"curpos\", 0);\n            if (pos < 0 || pos >= mPlayListLen) {\n                // The saved playlist is bogus, discard it\n                mPlayListLen = 0;\n                return;\n            }\n            mPlayPos = pos;\n            \n            // When reloadQueue is called in response to a card-insertion,\n            // we might not be able to query the media provider right away.\n            // To deal with this, try querying for the current file, and if\n            // that fails, wait a while and try again. If that too fails,\n            // assume there is a problem and don't restore the state.\n            Cursor crsr = MusicUtils.query(this,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] {\"_id\"}, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            if (crsr == null || crsr.getCount() == 0) {\n                // wait a bit and try again\n                SystemClock.sleep(3000);\n                crsr = getContentResolver().query(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            }\n            if (crsr != null) {\n                crsr.close();\n            }\n\n            // Make sure we don't auto-skip to the next song, since that\n            // also starts playback. What could happen in that case is:\n            // - music is paused\n            // - go to UMS and delete some files, including the currently playing one\n            // - come back from UMS\n            // (time passes)\n            // - music app is killed for some reason (out of memory)\n            // - music service is restarted, service restores state, doesn't find\n            //   the \"current\" file, goes to the next and: playback starts on its\n            //   own, potentially at some random inconvenient time.\n            mOpenFailedCounter = 20;\n            mQuietMode = true;\n            openCurrent();\n            mQuietMode = false;\n            if (!mPlayer.isInitialized()) {\n                // couldn't restore the saved state\n                mPlayListLen = 0;\n                return;\n            }\n            \n            long seekpos = mPreferences.getLong(\"seekpos\", 0);\n            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);\n            Log.d(LOGTAG, \"restored queue, currently at position \"\n                    + position() + \"/\" + duration()\n                    + \" (requested \" + seekpos + \")\");\n            \n            int repmode = mPreferences.getInt(\"repeatmode\", REPEAT_NONE);\n            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {\n                repmode = REPEAT_NONE;\n            }\n            mRepeatMode = repmode;\n\n            int shufmode = mPreferences.getInt(\"shufflemode\", SHUFFLE_NONE);\n            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {\n                shufmode = SHUFFLE_NONE;\n            }\n            if (shufmode != SHUFFLE_NONE) {\n                // in shuffle mode we need to restore the history too\n                q = mPreferences.getString(\"history\", \"\");\n                qlen = q != null ? q.length() : 0;\n                if (qlen > 1) {\n                    plen = 0;\n                    n = 0;\n                    shift = 0;\n                    mHistory.clear();\n                    for (int i = 0; i < qlen; i++) {\n                        char c = q.charAt(i);\n                        if (c == ';') {\n                            if (n >= mPlayListLen) {\n                                // bogus history data\n                                mHistory.clear();\n                                break;\n                            }\n                            mHistory.add(n);\n                            n = 0;\n                            shift = 0;\n                        } else {\n                            if (c >= '0' && c <= '9') {\n                                n += ((c - '0') << shift);\n                            } else if (c >= 'a' && c <= 'f') {\n                                n += ((10 + c - 'a') << shift);\n                            } else {\n                                // bogus history data\n                                mHistory.clear();\n                                break;\n                            }\n                            shift += 4;\n                        }\n                    }\n                }\n            }\n            if (shufmode == SHUFFLE_AUTO) {\n                if (! makeAutoShuffleList()) {\n                    shufmode = SHUFFLE_NONE;\n                }\n            }\n            mShuffleMode = shufmode;\n        }\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n        return mBinder;\n    }\n\n    @Override\n    public void onRebind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        mServiceStartId = startId;\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n\n        if (intent != null) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            MusicUtils.debugLog(\"onStartCommand \" + action + \" / \" + cmd);\n\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                if (position() < 2000) {\n                    prev();\n                } else {\n                    seek(0);\n                    play();\n                }\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                    mPausedByTransientLossOfFocus = false;\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n            } else if (CMDPLAY.equals(cmd)) {\n                play();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                mPausedByTransientLossOfFocus = false;\n                seek(0);\n            }\n        }\n        \n        // make sure the service will shut down on its own if it was\n        // just started but not bound to and nothing is playing\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n        return START_STICKY;\n    }\n    \n    @Override\n    public boolean onUnbind(Intent intent) {\n        mServiceInUse = false;\n\n        // Take a snapshot of the current playlist\n        saveQueue(true);\n\n        if (isPlaying() || mPausedByTransientLossOfFocus) {\n            // something is currently playing, or will be playing once \n            // an in-progress action requesting audio focus ends, so don't stop the service now.\n            return true;\n        }\n        \n        // If there is a playlist but playback is paused, then wait a while\n        // before stopping the service, so that pause/resume isn't slow.\n        // Also delay stopping the service if we're transitioning between tracks.\n        if (mPlayListLen > 0  || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n            Message msg = mDelayedStopHandler.obtainMessage();\n            mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n            return true;\n        }\n        \n        // No active playlist, OK to stop the service right now\n        stopSelf(mServiceStartId);\n        return true;\n    }\n    \n    private Handler mDelayedStopHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            // Check again to make sure nothing is playing right now\n            if (isPlaying() || mPausedByTransientLossOfFocus || mServiceInUse\n                    || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n                return;\n            }\n            // save the queue again, because it might have changed\n            // since the user exited the music app (because of\n            // party-shuffle or because the play-position changed)\n            saveQueue(true);\n            stopSelf(mServiceStartId);\n        }\n    };\n\n    /**\n     * Called when we receive a ACTION_MEDIA_EJECT notification.\n     *\n     * @param storagePath path to mount point for the removed media\n     */\n    public void closeExternalStorageFiles(String storagePath) {\n        // stop playback and clean up if the SD card is going to be unmounted.\n        stop(true);\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n    }\n\n    /**\n     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.\n     * The intent will call closeExternalStorageFiles() if the external media\n     * is going to be ejected, so applications can clean up any files they have open.\n     */\n    public void registerExternalStorageListener() {\n        if (mUnmountReceiver == null) {\n            mUnmountReceiver = new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    String action = intent.getAction();\n                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {\n                        saveQueue(true);\n                        mQueueIsSaveable = false;\n                        closeExternalStorageFiles(intent.getData().getPath());\n                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n                        mMediaMountedCount++;\n                        mCardId = MusicUtils.getCardId(MediaPlaybackService.this);\n                        reloadQueue();\n                        mQueueIsSaveable = true;\n                        notifyChange(QUEUE_CHANGED);\n                        notifyChange(META_CHANGED);\n                    }\n                }\n            };\n            IntentFilter iFilter = new IntentFilter();\n            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);\n            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);\n            iFilter.addDataScheme(\"file\");\n            registerReceiver(mUnmountReceiver, iFilter);\n        }\n    }\n\n    /**\n     * Notify the change-receivers that something has changed.\n     * The intent that is sent contains the following data\n     * for the currently playing track:\n     * \"id\" - Integer: the database row ID\n     * \"artist\" - String: the name of the artist\n     * \"album\" - String: the name of the album\n     * \"track\" - String: the name of the track\n     * The intent has an action that is one of\n     * \"com.android.music.metachanged\"\n     * \"com.android.music.queuechanged\",\n     * \"com.android.music.playbackcomplete\"\n     * \"com.android.music.playstatechanged\"\n     * respectively indicating that a new track has\n     * started playing, that the playback queue has\n     * changed, that playback has stopped because\n     * the last file in the list has been played,\n     * or that the play-state changed (paused/resumed).\n     */\n    private void notifyChange(String what) {\n\n        Intent i = new Intent(what);\n        i.putExtra(\"id\", Long.valueOf(getAudioId()));\n        i.putExtra(\"artist\", getArtistName());\n        i.putExtra(\"album\",getAlbumName());\n        i.putExtra(\"track\", getTrackName());\n        i.putExtra(\"playing\", isPlaying());\n        sendStickyBroadcast(i);\n\n        if (what.equals(PLAYSTATE_CHANGED)) {\n            mRemoteControlClient.setPlaybackState(isPlaying() ?\n                    RemoteControlClient.PLAYSTATE_PLAYING : RemoteControlClient.PLAYSTATE_PAUSED);\n        } else if (what.equals(META_CHANGED)) {\n            RemoteControlClient.MetadataEditor ed = mRemoteControlClient.editMetadata(true);\n            ed.putString(MediaMetadataRetriever.METADATA_KEY_TITLE, getTrackName());\n            ed.putString(MediaMetadataRetriever.METADATA_KEY_ALBUM, getAlbumName());\n            ed.putString(MediaMetadataRetriever.METADATA_KEY_ARTIST, getArtistName());\n            ed.putLong(MediaMetadataRetriever.METADATA_KEY_DURATION, duration());\n            Bitmap b = MusicUtils.getArtwork(this, getAudioId(), getAlbumId(), false);\n            if (b != null) {\n                ed.putBitmap(MetadataEditor.METADATA_KEY_ARTWORK, b);\n            }\n            ed.apply();\n        }\n\n        if (what.equals(QUEUE_CHANGED)) {\n            saveQueue(true);\n        } else {\n            saveQueue(false);\n        }\n        \n        // Share this notification directly with our widgets\n        mAppWidgetProvider.notifyChange(this, what);\n    }\n\n    private void ensurePlayListCapacity(int size) {\n        if (mPlayList == null || size > mPlayList.length) {\n            // reallocate at 2x requested size so we don't\n            // need to grow and copy the array for every\n            // insert\n            long [] newlist = new long[size * 2];\n            int len = mPlayList != null ? mPlayList.length : mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                newlist[i] = mPlayList[i];\n            }\n            mPlayList = newlist;\n        }\n        // FIXME: shrink the array when the needed size is much smaller\n        // than the allocated size\n    }\n    \n    // insert the list of songs at the specified position in the playlist\n    private void addToPlayList(long [] list, int position) {\n        int addlen = list.length;\n        if (position < 0) { // overwrite\n            mPlayListLen = 0;\n            position = 0;\n        }\n        ensurePlayListCapacity(mPlayListLen + addlen);\n        if (position > mPlayListLen) {\n            position = mPlayListLen;\n        }\n        \n        // move part of list after insertion point\n        int tailsize = mPlayListLen - position;\n        for (int i = tailsize ; i > 0 ; i--) {\n            mPlayList[position + i] = mPlayList[position + i - addlen]; \n        }\n        \n        // copy list into playlist\n        for (int i = 0; i < addlen; i++) {\n            mPlayList[position + i] = list[i];\n        }\n        mPlayListLen += addlen;\n        if (mPlayListLen == 0) {\n            mCursor.close();\n            mCursor = null;\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    /**\n     * Appends a list of tracks to the current playlist.\n     * If nothing is playing currently, playback will be started at\n     * the first track.\n     * If the action is NOW, playback will switch to the first of\n     * the new tracks immediately.\n     * @param list The list of tracks to append.\n     * @param action NOW, NEXT or LAST\n     */\n    public void enqueue(long [] list, int action) {\n        synchronized(this) {\n            if (action == NEXT && mPlayPos + 1 < mPlayListLen) {\n                addToPlayList(list, mPlayPos + 1);\n                notifyChange(QUEUE_CHANGED);\n            } else {\n                // action == LAST || action == NOW || mPlayPos + 1 == mPlayListLen\n                addToPlayList(list, Integer.MAX_VALUE);\n                notifyChange(QUEUE_CHANGED);\n                if (action == NOW) {\n                    mPlayPos = mPlayListLen - list.length;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                }\n            }\n            if (mPlayPos < 0) {\n                mPlayPos = 0;\n                openCurrent();\n                play();\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    /**\n     * Replaces the current playlist with a new list,\n     * and prepares for starting playback at the specified\n     * position in the list, or a random position if the\n     * specified position is 0.\n     * @param list The new list of tracks.\n     */\n    public void open(long [] list, int position) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                mShuffleMode = SHUFFLE_NORMAL;\n            }\n            long oldId = getAudioId();\n            int listlength = list.length;\n            boolean newlist = true;\n            if (mPlayListLen == listlength) {\n                // possible fast path: list might be the same\n                newlist = false;\n                for (int i = 0; i < listlength; i++) {\n                    if (list[i] != mPlayList[i]) {\n                        newlist = true;\n                        break;\n                    }\n                }\n            }\n            if (newlist) {\n                addToPlayList(list, -1);\n                notifyChange(QUEUE_CHANGED);\n            }\n            int oldpos = mPlayPos;\n            if (position >= 0) {\n                mPlayPos = position;\n            } else {\n                mPlayPos = mRand.nextInt(mPlayListLen);\n            }\n            mHistory.clear();\n\n            saveBookmarkIfNeeded();\n            openCurrent();\n            if (oldId != getAudioId()) {\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n    \n    /**\n     * Moves the item at index1 to index2.\n     * @param index1\n     * @param index2\n     */\n    public void moveQueueItem(int index1, int index2) {\n        synchronized (this) {\n            if (index1 >= mPlayListLen) {\n                index1 = mPlayListLen - 1;\n            }\n            if (index2 >= mPlayListLen) {\n                index2 = mPlayListLen - 1;\n            }\n            if (index1 < index2) {\n                long tmp = mPlayList[index1];\n                for (int i = index1; i < index2; i++) {\n                    mPlayList[i] = mPlayList[i+1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index1 && mPlayPos <= index2) {\n                        mPlayPos--;\n                }\n            } else if (index2 < index1) {\n                long tmp = mPlayList[index1];\n                for (int i = index1; i > index2; i--) {\n                    mPlayList[i] = mPlayList[i-1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index2 && mPlayPos <= index1) {\n                        mPlayPos++;\n                }\n            }\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    /**\n     * Returns the current play list\n     * @return An array of integers containing the IDs of the tracks in the play list\n     */\n    public long [] getQueue() {\n        synchronized (this) {\n            int len = mPlayListLen;\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                list[i] = mPlayList[i];\n            }\n            return list;\n        }\n    }\n\n    private void openCurrent() {\n        synchronized (this) {\n            if (mCursor != null) {\n                mCursor.close();\n                mCursor = null;\n            }\n\n            if (mPlayListLen == 0) {\n                return;\n            }\n            stop(false);\n\n            String id = String.valueOf(mPlayList[mPlayPos]);\n            \n            mCursor = getContentResolver().query(\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, \"_id=\" + id , null, null);\n            if (mCursor != null) {\n                mCursor.moveToFirst();\n                open(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + \"/\" + id);\n                // go to bookmark if needed\n                if (isPodcast()) {\n                    long bookmark = getBookmark();\n                    // Start playing a little bit before the bookmark,\n                    // so it's easier to get back in to the narrative.\n                    seek(bookmark - 5000);\n                }\n            }\n        }\n    }\n\n    /**\n     * Opens the specified file and readies it for playback.\n     *\n     * @param path The full path of the file to be opened.\n     */\n    public void open(String path) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            // if mCursor is null, try to associate path with a database cursor\n            if (mCursor == null) {\n\n                ContentResolver resolver = getContentResolver();\n                Uri uri;\n                String where;\n                String selectionArgs[];\n                if (path.startsWith(\"content://media/\")) {\n                    uri = Uri.parse(path);\n                    where = null;\n                    selectionArgs = null;\n                } else {\n                   uri = MediaStore.Audio.Media.getContentUriForPath(path);\n                   where = MediaStore.Audio.Media.DATA + \"=?\";\n                   selectionArgs = new String[] { path };\n                }\n                \n                try {\n                    mCursor = resolver.query(uri, mCursorCols, where, selectionArgs, null);\n                    if  (mCursor != null) {\n                        if (mCursor.getCount() == 0) {\n                            mCursor.close();\n                            mCursor = null;\n                        } else {\n                            mCursor.moveToNext();\n                            ensurePlayListCapacity(1);\n                            mPlayListLen = 1;\n                            mPlayList[0] = mCursor.getLong(IDCOLIDX);\n                            mPlayPos = 0;\n                        }\n                    }\n                } catch (UnsupportedOperationException ex) {\n                }\n            }\n            mFileToPlay = path;\n            mPlayer.setDataSource(mFileToPlay);\n            if (! mPlayer.isInitialized()) {\n                stop(true);\n                if (mOpenFailedCounter++ < 10 &&  mPlayListLen > 1) {\n                    // beware: this ends up being recursive because next() calls open() again.\n                    next(false);\n                }\n                if (! mPlayer.isInitialized() && mOpenFailedCounter != 0) {\n                    // need to make sure we only shows this once\n                    mOpenFailedCounter = 0;\n                    if (!mQuietMode) {\n                        Toast.makeText(this, R.string.playback_failed, Toast.LENGTH_SHORT).show();\n                    }\n                    Log.d(LOGTAG, \"Failed to open file for playback\");\n                }\n            } else {\n                mOpenFailedCounter = 0;\n            }\n        }\n    }\n\n    /**\n     * Starts playback of a previously opened file.\n     */\n    public void play() {\n        mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC,\n                AudioManager.AUDIOFOCUS_GAIN);\n        mAudioManager.registerMediaButtonEventReceiver(new ComponentName(this.getPackageName(),\n                MediaButtonIntentReceiver.class.getName()));\n\n        if (mPlayer.isInitialized()) {\n            // if we are at the end of the song, go to the next song first\n            long duration = mPlayer.duration();\n            if (mRepeatMode != REPEAT_CURRENT && duration > 2000 &&\n                mPlayer.position() >= duration - 2000) {\n                next(true);\n            }\n\n            mPlayer.start();\n            // make sure we fade in, in case a previous fadein was stopped because\n            // of another focus loss\n            mMediaplayerHandler.removeMessages(FADEDOWN);\n            mMediaplayerHandler.sendEmptyMessage(FADEUP);\n\n            RemoteViews views = new RemoteViews(getPackageName(), R.layout.statusbar);\n            views.setImageViewResource(R.id.icon, R.drawable.stat_notify_musicplayer);\n            if (getAudioId() < 0) {\n                // streaming\n                views.setTextViewText(R.id.trackname, getPath());\n                views.setTextViewText(R.id.artistalbum, null);\n            } else {\n                String artist = getArtistName();\n                views.setTextViewText(R.id.trackname, getTrackName());\n                if (artist == null || artist.equals(MediaStore.UNKNOWN_STRING)) {\n                    artist = getString(R.string.unknown_artist_name);\n                }\n                String album = getAlbumName();\n                if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n                    album = getString(R.string.unknown_album_name);\n                }\n                \n                views.setTextViewText(R.id.artistalbum,\n                        getString(R.string.notification_artist_album, artist, album)\n                        );\n            }\n            \n            Notification status = new Notification();\n            status.contentView = views;\n            status.flags |= Notification.FLAG_ONGOING_EVENT;\n            status.icon = R.drawable.stat_notify_musicplayer;\n            status.contentIntent = PendingIntent.getActivity(this, 0,\n                    new Intent(\"com.android.music.PLAYBACK_VIEWER\")\n                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), 0);\n            startForeground(PLAYBACKSERVICE_STATUS, status);\n            if (!mIsSupposedToBePlaying) {\n                mIsSupposedToBePlaying = true;\n                notifyChange(PLAYSTATE_CHANGED);\n            }\n\n        } else if (mPlayListLen <= 0) {\n            // This is mostly so that if you press 'play' on a bluetooth headset\n            // without every having played anything before, it will still play\n            // something.\n            setShuffleMode(SHUFFLE_AUTO);\n        }\n    }\n    \n    private void stop(boolean remove_status_icon) {\n        if (mPlayer.isInitialized()) {\n            mPlayer.stop();\n        }\n        mFileToPlay = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n        if (remove_status_icon) {\n            gotoIdleState();\n        } else {\n            stopForeground(false);\n        }\n        if (remove_status_icon) {\n            mIsSupposedToBePlaying = false;\n        }\n    }\n\n    /**\n     * Stops playback.\n     */\n    public void stop() {\n        stop(true);\n    }\n\n    /**\n     * Pauses playback (call play() to resume)\n     */\n    public void pause() {\n        synchronized(this) {\n            mMediaplayerHandler.removeMessages(FADEUP);\n            if (isPlaying()) {\n                mPlayer.pause();\n                gotoIdleState();\n                mIsSupposedToBePlaying = false;\n                notifyChange(PLAYSTATE_CHANGED);\n                saveBookmarkIfNeeded();\n            }\n        }\n    }\n\n    /** Returns whether something is currently playing\n     *\n     * @return true if something is playing (or will be playing shortly, in case\n     * we're currently transitioning between tracks), false if not.\n     */\n    public boolean isPlaying() {\n        return mIsSupposedToBePlaying;\n    }\n\n    /*\n      Desired behavior for prev/next/shuffle:\n\n      - NEXT will move to the next track in the list when not shuffling, and to\n        a track randomly picked from the not-yet-played tracks when shuffling.\n        If all tracks have already been played, pick from the full set, but\n        avoid picking the previously played track if possible.\n      - when shuffling, PREV will go to the previously played track. Hitting PREV\n        again will go to the track played before that, etc. When the start of the\n        history has been reached, PREV is a no-op.\n        When not shuffling, PREV will go to the sequentially previous track (the\n        difference with the shuffle-case is mainly that when not shuffling, the\n        user can back up to tracks that are not in the history).\n\n        Example:\n        When playing an album with 10 tracks from the start, and enabling shuffle\n        while playing track 5, the remaining tracks (6-10) will be shuffled, e.g.\n        the final play order might be 1-2-3-4-5-8-10-6-9-7.\n        When hitting 'prev' 8 times while playing track 7 in this example, the\n        user will go to tracks 9-6-10-8-5-4-3-2. If the user then hits 'next',\n        a random track will be picked again. If at any time user disables shuffling\n        the next/previous track will be picked in sequential order again.\n     */\n\n    public void prev() {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // go to previously-played track and remove it from the history\n                int histsize = mHistory.size();\n                if (histsize == 0) {\n                    // prev is a no-op\n                    return;\n                }\n                Integer pos = mHistory.remove(histsize - 1);\n                mPlayPos = pos.intValue();\n            } else {\n                if (mPlayPos > 0) {\n                    mPlayPos--;\n                } else {\n                    mPlayPos = mPlayListLen - 1;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void next(boolean force) {\n        synchronized (this) {\n            if (mPlayListLen <= 0) {\n                Log.d(LOGTAG, \"No play queue\");\n                return;\n            }\n\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // Pick random next track from the not-yet-played ones\n                // TODO: make it work right after adding/removing items in the queue.\n\n                // Store the current file in the history, but keep the history at a\n                // reasonable size\n                if (mPlayPos >= 0) {\n                    mHistory.add(mPlayPos);\n                }\n                if (mHistory.size() > MAX_HISTORY_SIZE) {\n                    mHistory.removeElementAt(0);\n                }\n\n                int numTracks = mPlayListLen;\n                int[] tracks = new int[numTracks];\n                for (int i=0;i < numTracks; i++) {\n                    tracks[i] = i;\n                }\n\n                int numHistory = mHistory.size();\n                int numUnplayed = numTracks;\n                for (int i=0;i < numHistory; i++) {\n                    int idx = mHistory.get(i).intValue();\n                    if (idx < numTracks && tracks[idx] >= 0) {\n                        numUnplayed--;\n                        tracks[idx] = -1;\n                    }\n                }\n\n                // 'numUnplayed' now indicates how many tracks have not yet\n                // been played, and 'tracks' contains the indices of those\n                // tracks.\n                if (numUnplayed <=0) {\n                    // everything's already been played\n                    if (mRepeatMode == REPEAT_ALL || force) {\n                        //pick from full set\n                        numUnplayed = numTracks;\n                        for (int i=0;i < numTracks; i++) {\n                            tracks[i] = i;\n                        }\n                    } else {\n                        // all done\n                        gotoIdleState();\n                        if (mIsSupposedToBePlaying) {\n                            mIsSupposedToBePlaying = false;\n                            notifyChange(PLAYSTATE_CHANGED);\n                        }\n                        return;\n                    }\n                }\n                int skip = mRand.nextInt(numUnplayed);\n                int cnt = -1;\n                while (true) {\n                    while (tracks[++cnt] < 0)\n                        ;\n                    skip--;\n                    if (skip < 0) {\n                        break;\n                    }\n                }\n                mPlayPos = cnt;\n            } else if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n                mPlayPos++;\n            } else {\n                if (mPlayPos >= mPlayListLen - 1) {\n                    // we're at the end of the list\n                    if (mRepeatMode == REPEAT_NONE && !force) {\n                        // all done\n                        gotoIdleState();\n                        mIsSupposedToBePlaying = false;\n                        notifyChange(PLAYSTATE_CHANGED);\n                        return;\n                    } else if (mRepeatMode == REPEAT_ALL || force) {\n                        mPlayPos = 0;\n                    }\n                } else {\n                    mPlayPos++;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    private void gotoIdleState() {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n        stopForeground(true);\n    }\n    \n    private void saveBookmarkIfNeeded() {\n        try {\n            if (isPodcast()) {\n                long pos = position();\n                long bookmark = getBookmark();\n                long duration = duration();\n                if ((pos < bookmark && (pos + 10000) > bookmark) ||\n                        (pos > bookmark && (pos - 10000) < bookmark)) {\n                    // The existing bookmark is close to the current\n                    // position, so don't update it.\n                    return;\n                }\n                if (pos < 15000 || (pos + 10000) > duration) {\n                    // if we're near the start or end, clear the bookmark\n                    pos = 0;\n                }\n                \n                // write 'pos' to the bookmark field\n                ContentValues values = new ContentValues();\n                values.put(MediaStore.Audio.Media.BOOKMARK, pos);\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursor.getLong(IDCOLIDX));\n                getContentResolver().update(uri, values, null, null);\n            }\n        } catch (SQLiteException ex) {\n        }\n    }\n\n    // Make sure there are at least 5 items after the currently playing item\n    // and no more than 10 items before.\n    private void doAutoShuffleUpdate() {\n        boolean notify = false;\n\n        // remove old entries\n        if (mPlayPos > 10) {\n            removeTracks(0, mPlayPos - 9);\n            notify = true;\n        }\n        // add new entries if needed\n        int to_add = 7 - (mPlayListLen - (mPlayPos < 0 ? -1 : mPlayPos));\n        for (int i = 0; i < to_add; i++) {\n            // pick something at random from the list\n\n            int lookback = mHistory.size();\n            int idx = -1;\n            while(true) {\n                idx = mRand.nextInt(mAutoShuffleList.length);\n                if (!wasRecentlyUsed(idx, lookback)) {\n                    break;\n                }\n                lookback /= 2;\n            }\n            mHistory.add(idx);\n            if (mHistory.size() > MAX_HISTORY_SIZE) {\n                mHistory.remove(0);\n            }\n            ensurePlayListCapacity(mPlayListLen + 1);\n            mPlayList[mPlayListLen++] = mAutoShuffleList[idx];\n            notify = true;\n        }\n        if (notify) {\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    // check that the specified idx is not in the history (but only look at at\n    // most lookbacksize entries in the history)\n    private boolean wasRecentlyUsed(int idx, int lookbacksize) {\n\n        // early exit to prevent infinite loops in case idx == mPlayPos\n        if (lookbacksize == 0) {\n            return false;\n        }\n\n        int histsize = mHistory.size();\n        if (histsize < lookbacksize) {\n            Log.d(LOGTAG, \"lookback too big\");\n            lookbacksize = histsize;\n        }\n        int maxidx = histsize - 1;\n        for (int i = 0; i < lookbacksize; i++) {\n            long entry = mHistory.get(maxidx - i);\n            if (entry == idx) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // A simple variation of Random that makes sure that the\n    // value it returns is not equal to the value it returned\n    // previously, unless the interval is 1.\n    private static class Shuffler {\n        private int mPrevious;\n        private Random mRandom = new Random();\n        public int nextInt(int interval) {\n            int ret;\n            do {\n                ret = mRandom.nextInt(interval);\n            } while (ret == mPrevious && interval > 1);\n            mPrevious = ret;\n            return ret;\n        }\n    };\n\n    private boolean makeAutoShuffleList() {\n        ContentResolver res = getContentResolver();\n        Cursor c = null;\n        try {\n            c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                    null, null);\n            if (c == null || c.getCount() == 0) {\n                return false;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n            mAutoShuffleList = list;\n            return true;\n        } catch (RuntimeException ex) {\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Removes the range of tracks specified from the play list. If a file within the range is\n     * the file currently being played, playback will move to the next file after the\n     * range. \n     * @param first The first file to be removed\n     * @param last The last file to be removed\n     * @return the number of tracks deleted\n     */\n    public int removeTracks(int first, int last) {\n        int numremoved = removeTracksInternal(first, last);\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    private int removeTracksInternal(int first, int last) {\n        synchronized (this) {\n            if (last < first) return 0;\n            if (first < 0) first = 0;\n            if (last >= mPlayListLen) last = mPlayListLen - 1;\n\n            boolean gotonext = false;\n            if (first <= mPlayPos && mPlayPos <= last) {\n                mPlayPos = first;\n                gotonext = true;\n            } else if (mPlayPos > last) {\n                mPlayPos -= (last - first + 1);\n            }\n            int num = mPlayListLen - last - 1;\n            for (int i = 0; i < num; i++) {\n                mPlayList[first + i] = mPlayList[last + 1 + i];\n            }\n            mPlayListLen -= last - first + 1;\n            \n            if (gotonext) {\n                if (mPlayListLen == 0) {\n                    stop(true);\n                    mPlayPos = -1;\n                    if (mCursor != null) {\n                        mCursor.close();\n                        mCursor = null;\n                    }\n                } else {\n                    if (mPlayPos >= mPlayListLen) {\n                        mPlayPos = 0;\n                    }\n                    boolean wasPlaying = isPlaying();\n                    stop(false);\n                    openCurrent();\n                    if (wasPlaying) {\n                        play();\n                    }\n                }\n                notifyChange(META_CHANGED);\n            }\n            return last - first + 1;\n        }\n    }\n    \n    /**\n     * Removes all instances of the track with the given id\n     * from the playlist.\n     * @param id The id to be removed\n     * @return how many instances of the track were removed\n     */\n    public int removeTrack(long id) {\n        int numremoved = 0;\n        synchronized (this) {\n            for (int i = 0; i < mPlayListLen; i++) {\n                if (mPlayList[i] == id) {\n                    numremoved += removeTracksInternal(i, i);\n                    i--;\n                }\n            }\n        }\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    public void setShuffleMode(int shufflemode) {\n        synchronized(this) {\n            if (mShuffleMode == shufflemode && mPlayListLen > 0) {\n                return;\n            }\n            mShuffleMode = shufflemode;\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                if (makeAutoShuffleList()) {\n                    mPlayListLen = 0;\n                    doAutoShuffleUpdate();\n                    mPlayPos = 0;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                } else {\n                    // failed to build a list of files to shuffle\n                    mShuffleMode = SHUFFLE_NONE;\n                }\n            }\n            saveQueue(false);\n        }\n    }\n    public int getShuffleMode() {\n        return mShuffleMode;\n    }\n    \n    public void setRepeatMode(int repeatmode) {\n        synchronized(this) {\n            mRepeatMode = repeatmode;\n            saveQueue(false);\n        }\n    }\n    public int getRepeatMode() {\n        return mRepeatMode;\n    }\n\n    public int getMediaMountedCount() {\n        return mMediaMountedCount;\n    }\n\n    /**\n     * Returns the path of the currently playing file, or null if\n     * no file is currently playing.\n     */\n    public String getPath() {\n        return mFileToPlay;\n    }\n    \n    /**\n     * Returns the rowid of the currently playing file, or -1 if\n     * no file is currently playing.\n     */\n    public long getAudioId() {\n        synchronized (this) {\n            if (mPlayPos >= 0 && mPlayer.isInitialized()) {\n                return mPlayList[mPlayPos];\n            }\n        }\n        return -1;\n    }\n    \n    /**\n     * Returns the position in the queue \n     * @return the position in the queue\n     */\n    public int getQueuePosition() {\n        synchronized(this) {\n            return mPlayPos;\n        }\n    }\n    \n    /**\n     * Starts playing the track at the given position in the queue.\n     * @param pos The position in the queue of the track that will be played.\n     */\n    public void setQueuePosition(int pos) {\n        synchronized(this) {\n            stop(false);\n            mPlayPos = pos;\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n            }\n        }\n    }\n\n    public String getArtistName() {\n        synchronized(this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));\n        }\n    }\n    \n    public long getArtistId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID));\n        }\n    }\n\n    public String getAlbumName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM));\n        }\n    }\n\n    public long getAlbumId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID));\n        }\n    }\n\n    public String getTrackName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));\n        }\n    }\n\n    private boolean isPodcast() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return false;\n            }\n            return (mCursor.getInt(PODCASTCOLIDX) > 0);\n        }\n    }\n    \n    private long getBookmark() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return 0;\n            }\n            return mCursor.getLong(BOOKMARKCOLIDX);\n        }\n    }\n    \n    /**\n     * Returns the duration of the file in milliseconds.\n     * Currently this method returns -1 for the duration of MIDI files.\n     */\n    public long duration() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.duration();\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the current playback position in milliseconds\n     */\n    public long position() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.position();\n        }\n        return -1;\n    }\n\n    /**\n     * Seeks to the position specified.\n     *\n     * @param pos The position to seek to, in milliseconds\n     */\n    public long seek(long pos) {\n        if (mPlayer.isInitialized()) {\n            if (pos < 0) pos = 0;\n            if (pos > mPlayer.duration()) pos = mPlayer.duration();\n            return mPlayer.seek(pos);\n        }\n        return -1;\n    }\n\n    /**\n     * Sets the audio session ID.\n     *\n     * @param sessionId: the audio session ID.\n     */\n    public void setAudioSessionId(int sessionId) {\n        synchronized (this) {\n            mPlayer.setAudioSessionId(sessionId);\n        }\n    }\n\n    /**\n     * Returns the audio session ID.\n     */\n    public int getAudioSessionId() {\n        synchronized (this) {\n            return mPlayer.getAudioSessionId();\n        }\n    }\n\n    /**\n     * Provides a unified interface for dealing with midi files and\n     * other media files.\n     */\n    private class MultiPlayer {\n        private MediaPlayer mMediaPlayer = new MediaPlayer();\n        private Handler mHandler;\n        private boolean mIsInitialized = false;\n\n        public MultiPlayer() {\n            mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n        }\n\n        public void setDataSource(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setOnPreparedListener(null);\n                if (path.startsWith(\"content://\")) {\n                    mMediaPlayer.setDataSource(MediaPlaybackService.this, Uri.parse(path));\n                } else {\n                    mMediaPlayer.setDataSource(path);\n                }\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.prepare();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            Intent i = new Intent(AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION);\n            i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());\n            i.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());\n            sendBroadcast(i);\n            mIsInitialized = true;\n        }\n        \n        public boolean isInitialized() {\n            return mIsInitialized;\n        }\n\n        public void start() {\n            MusicUtils.debugLog(new Exception(\"MultiPlayer.start called\"));\n            mMediaPlayer.start();\n        }\n\n        public void stop() {\n            mMediaPlayer.reset();\n            mIsInitialized = false;\n        }\n\n        /**\n         * You CANNOT use this player anymore after calling release()\n         */\n        public void release() {\n            stop();\n            mMediaPlayer.release();\n        }\n        \n        public void pause() {\n            mMediaPlayer.pause();\n        }\n        \n        public void setHandler(Handler handler) {\n            mHandler = handler;\n        }\n\n        MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n            public void onCompletion(MediaPlayer mp) {\n                // Acquire a temporary wakelock, since when we return from\n                // this callback the MediaPlayer will release its wakelock\n                // and allow the device to go to sleep.\n                // This temporary wakelock is released when the RELEASE_WAKELOCK\n                // message is processed, but just in case, put a timeout on it.\n                mWakeLock.acquire(30000);\n                mHandler.sendEmptyMessage(TRACK_ENDED);\n                mHandler.sendEmptyMessage(RELEASE_WAKELOCK);\n            }\n        };\n\n        MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() {\n            public boolean onError(MediaPlayer mp, int what, int extra) {\n                switch (what) {\n                case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                    mIsInitialized = false;\n                    mMediaPlayer.release();\n                    // Creating a new MediaPlayer and settings its wakemode does not\n                    // require the media service, so it's OK to do this now, while the\n                    // service is still being restarted\n                    mMediaPlayer = new MediaPlayer(); \n                    mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n                    mHandler.sendMessageDelayed(mHandler.obtainMessage(SERVER_DIED), 2000);\n                    return true;\n                default:\n                    Log.d(\"MultiPlayer\", \"Error: \" + what + \",\" + extra);\n                    break;\n                }\n                return false;\n           }\n        };\n\n        public long duration() {\n            return mMediaPlayer.getDuration();\n        }\n\n        public long position() {\n            return mMediaPlayer.getCurrentPosition();\n        }\n\n        public long seek(long whereto) {\n            mMediaPlayer.seekTo((int) whereto);\n            return whereto;\n        }\n\n        public void setVolume(float vol) {\n            mMediaPlayer.setVolume(vol, vol);\n        }\n\n        public void setAudioSessionId(int sessionId) {\n            mMediaPlayer.setAudioSessionId(sessionId);\n        }\n\n        public int getAudioSessionId() {\n            return mMediaPlayer.getAudioSessionId();\n        }\n    }\n\n    /*\n     * By making this a static class with a WeakReference to the Service, we\n     * ensure that the Service can be GCd even when the system process still\n     * has a remote reference to the stub.\n     */\n    static class ServiceStub extends IMediaPlaybackService.Stub {\n        WeakReference<MediaPlaybackService> mService;\n        \n        ServiceStub(MediaPlaybackService service) {\n            mService = new WeakReference<MediaPlaybackService>(service);\n        }\n\n        public void openFile(String path)\n        {\n            mService.get().open(path);\n        }\n        public void open(long [] list, int position) {\n            mService.get().open(list, position);\n        }\n        public int getQueuePosition() {\n            return mService.get().getQueuePosition();\n        }\n        public void setQueuePosition(int index) {\n            mService.get().setQueuePosition(index);\n        }\n        public boolean isPlaying() {\n            return mService.get().isPlaying();\n        }\n        public void stop() {\n            mService.get().stop();\n        }\n        public void pause() {\n            mService.get().pause();\n        }\n        public void play() {\n            mService.get().play();\n        }\n        public void prev() {\n            mService.get().prev();\n        }\n        public void next() {\n            mService.get().next(true);\n        }\n        public String getTrackName() {\n            return mService.get().getTrackName();\n        }\n        public String getAlbumName() {\n            return mService.get().getAlbumName();\n        }\n        public long getAlbumId() {\n            return mService.get().getAlbumId();\n        }\n        public String getArtistName() {\n            return mService.get().getArtistName();\n        }\n        public long getArtistId() {\n            return mService.get().getArtistId();\n        }\n        public void enqueue(long [] list , int action) {\n            mService.get().enqueue(list, action);\n        }\n        public long [] getQueue() {\n            return mService.get().getQueue();\n        }\n        public void moveQueueItem(int from, int to) {\n            mService.get().moveQueueItem(from, to);\n        }\n        public String getPath() {\n            return mService.get().getPath();\n        }\n        public long getAudioId() {\n            return mService.get().getAudioId();\n        }\n        public long position() {\n            return mService.get().position();\n        }\n        public long duration() {\n            return mService.get().duration();\n        }\n        public long seek(long pos) {\n            return mService.get().seek(pos);\n        }\n        public void setShuffleMode(int shufflemode) {\n            mService.get().setShuffleMode(shufflemode);\n        }\n        public int getShuffleMode() {\n            return mService.get().getShuffleMode();\n        }\n        public int removeTracks(int first, int last) {\n            return mService.get().removeTracks(first, last);\n        }\n        public int removeTrack(long id) {\n            return mService.get().removeTrack(id);\n        }\n        public void setRepeatMode(int repeatmode) {\n            mService.get().setRepeatMode(repeatmode);\n        }\n        public int getRepeatMode() {\n            return mService.get().getRepeatMode();\n        }\n        public int getMediaMountedCount() {\n            return mService.get().getMediaMountedCount();\n        }\n        public int getAudioSessionId() {\n            return mService.get().getAudioSessionId();\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        writer.println(\"\" + mPlayListLen + \" items in queue, currently at index \" + mPlayPos);\n        writer.println(\"Currently loaded:\");\n        writer.println(getArtistName());\n        writer.println(getAlbumName());\n        writer.println(getTrackName());\n        writer.println(getPath());\n        writer.println(\"playing: \" + mIsSupposedToBePlaying);\n        writer.println(\"actual: \" + mPlayer.mMediaPlayer.isPlaying());\n        writer.println(\"shuffle mode: \" + mShuffleMode);\n        MusicUtils.debugDump(writer);\n    }\n\n    private final IBinder mBinder = new ServiceStub(this);\n}\n","lineNo":303}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    private boolean mCreateShortcut;\n    private ServiceToken mToken;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    long id = Long.parseLong(intent.getExtras().getString(\"playlist\"));\n                    if (id == RECENTLY_ADDED_PLAYLIST) {\n                        playRecentlyAdded();\n                    } else if (id == PODCASTS_PLAYLIST) {\n                        playPodcasts();\n                    } else if (id == ALL_SONGS_PLAYLIST) {\n                        long [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                        if (list != null) {\n                            MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                        }\n                    } else {\n                        MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                    }\n                    finish();\n                    return;\n                }\n                MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n        MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n    public void init(Cursor cursor) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else if (mAdapter != null) {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.ic_launcher_shortcut_music_playlist));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        MatrixCursor autoplaylistscursor = new MatrixCursor(mCols);\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylistscursor.addRow(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylistscursor.addRow(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylistscursor.addRow(podcasts);\n            }\n        }\n\n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getPlaylistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    private boolean mCreateShortcut;\n    private ServiceToken mToken;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    Bundle b = intent.getExtras();\n                    if (b == null) {\n                        Log.w(TAG, \"Unexpected:getExtras() returns null.\");\n                    } else {\n                        try {\n                            long id = Long.parseLong(b.getString(\"playlist\"));\n                            if (id == RECENTLY_ADDED_PLAYLIST) {\n                                playRecentlyAdded();\n                            } else if (id == PODCASTS_PLAYLIST) {\n                                playPodcasts();\n                            } else if (id == ALL_SONGS_PLAYLIST) {\n                                long[] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                                if (list != null) {\n                                    MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                                }\n                            } else {\n                                MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                            }\n                        } catch (NumberFormatException e) {\n                            Log.w(TAG, \"Playlist id missing or broken\");\n                        }\n                    }\n                    finish();\n                    return;\n                }\n                MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n        MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n    public void init(Cursor cursor) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else if (mAdapter != null) {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.ic_launcher_shortcut_music_playlist));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        MatrixCursor autoplaylistscursor = new MatrixCursor(mCols);\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylistscursor.addRow(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylistscursor.addRow(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylistscursor.addRow(podcasts);\n            }\n        }\n\n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getPlaylistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","lineNo":101}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.KeyguardManager;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n\n    private boolean mSeeking = false;\n    private boolean mDeviceHasDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n    private ServiceToken mToken;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasDpad = (getResources().getConfiguration().navigation ==\n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        long audioid;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n            audioid = mService.getAudioId();\n        } catch (RemoteException ex) {\n            return true;\n        } catch (NullPointerException ex) {\n            // we might not actually have the service yet\n            return true;\n        }\n\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                song != null &&\n                song.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        if (audioid < 0) {\n            return false;\n        }\n\n        Cursor c = MusicUtils.query(this,\n                ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioid),\n                new String[] {MediaStore.Audio.Media.IS_MUSIC}, null, null, null);\n        boolean ismusic = true;\n        if (c != null) {\n            if (c.moveToFirst()) {\n                ismusic = c.getInt(0) != 0;\n            }\n            c.close();\n        }\n        if (!ismusic) {\n            return false;\n        }\n\n        boolean knownartist =\n            (artist != null) && !MediaStore.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaStore.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaStore.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(mToken);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        mToken = MusicUtils.bindToService(this, osc);\n        if (mToken == null) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            // these next two are in a separate group, so they can be shown/hidden as needed\n            // based on the keyguard state\n            menu.add(1, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short)\n                    .setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(1, DELETE_ITEM, 0, R.string.delete_item)\n                    .setIcon(R.drawable.ic_menu_delete);\n\n            Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n            if (getPackageManager().resolveActivity(i, 0) != null) {\n                menu.add(0, EFFECTS_PANEL, 0, R.string.effectspanel).setIcon(R.drawable.ic_menu_eq);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        if (mService == null) return false;\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n\n        item = menu.findItem(ADD_TO_PLAYLIST);\n        if (item != null) {\n            SubMenu sub = item.getSubMenu();\n            MusicUtils.makePlaylistMenu(this, sub);\n        }\n\n        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);\n        menu.setGroupVisible(1, !km.inKeyguardRestrictedInputMode());\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                    startActivity(intent);\n                    finish();\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    MusicUtils.togglePartyShuffle();\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        long [] list = new long[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", getString(R.string.delete_song_desc,\n                                mService.getTrackName()));\n                        b.putLongArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n\n                case EFFECTS_PANEL: {\n                    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n                    i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, mService.getAudioSessionId());\n                    startActivityForResult(i, EFFECTS_PANEL);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    private boolean useDpadMusicControl() {\n        if (mDeviceHasDpad && (mPrevButton.isFocused() ||\n                mNextButton.isFocused() ||\n                mPauseButton.isFocused())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mService.stop();\n                mService.openFile(filename);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        mRepeatButton.setVisibility(View.VISIBLE);\n                        mShuffleButton.setVisibility(View.VISIBLE);\n                        mQueueButton.setVisibility(View.VISIBLE);\n                        setRepeatButtonImage();\n                        setShuffleButtonImage();\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n                mService = null;\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE) ||\n                    action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private static class AlbumSongIdWrapper {\n        public long albumid;\n        public long songid;\n        AlbumSongIdWrapper(long aid, long sid) {\n            albumid = aid;\n            songid = sid;\n        }\n    }\n    \n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            long songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(-1, -1)).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                long albumid = mService.getAlbumId();\n                if (MediaStore.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(albumid, songid)).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private long mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg)\n        {\n            long albumid = ((AlbumSongIdWrapper) msg.obj).albumid;\n            long songid = ((AlbumSongIdWrapper) msg.obj).songid;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.KeyguardManager;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.audiofx.AudioEffect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n\n    private boolean mSeeking = false;\n    private boolean mDeviceHasDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n    private ServiceToken mToken;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasDpad = (getResources().getConfiguration().navigation ==\n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        long audioid;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n            audioid = mService.getAudioId();\n        } catch (RemoteException ex) {\n            return true;\n        } catch (NullPointerException ex) {\n            // we might not actually have the service yet\n            return true;\n        }\n\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                song != null &&\n                song.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        if (audioid < 0) {\n            return false;\n        }\n\n        Cursor c = MusicUtils.query(this,\n                ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioid),\n                new String[] {MediaStore.Audio.Media.IS_MUSIC}, null, null, null);\n        boolean ismusic = true;\n        if (c != null) {\n            if (c.moveToFirst()) {\n                ismusic = c.getInt(0) != 0;\n            }\n            c.close();\n        }\n        if (!ismusic) {\n            return false;\n        }\n\n        boolean knownartist =\n            (artist != null) && !MediaStore.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaStore.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaStore.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(mToken);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        mToken = MusicUtils.bindToService(this, osc);\n        if (mToken == null) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            // these next two are in a separate group, so they can be shown/hidden as needed\n            // based on the keyguard state\n            menu.add(1, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short)\n                    .setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(1, DELETE_ITEM, 0, R.string.delete_item)\n                    .setIcon(R.drawable.ic_menu_delete);\n\n            Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n            if (getPackageManager().resolveActivity(i, 0) != null) {\n                menu.add(0, EFFECTS_PANEL, 0, R.string.effectspanel).setIcon(R.drawable.ic_menu_eq);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        if (mService == null) return false;\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n\n        item = menu.findItem(ADD_TO_PLAYLIST);\n        if (item != null) {\n            SubMenu sub = item.getSubMenu();\n            MusicUtils.makePlaylistMenu(this, sub);\n        }\n\n        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);\n        menu.setGroupVisible(1, !km.inKeyguardRestrictedInputMode());\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n                    startActivity(intent);\n                    finish();\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    MusicUtils.togglePartyShuffle();\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        long [] list = new long[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        String f;\n                        if (android.os.Environment.isExternalStorageRemovable()) {\n                            f = getString(R.string.delete_song_desc, mService.getTrackName());\n                        } else {\n                            f = getString(R.string.delete_song_desc_nosdcard, mService.getTrackName());\n                        }\n                        b.putString(\"description\", f);\n                        b.putLongArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n\n                case EFFECTS_PANEL: {\n                    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);\n                    i.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, mService.getAudioSessionId());\n                    startActivityForResult(i, EFFECTS_PANEL);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    private boolean useDpadMusicControl() {\n        if (mDeviceHasDpad && (mPrevButton.isFocused() ||\n                mNextButton.isFocused() ||\n                mPauseButton.isFocused())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mService.stop();\n                mService.openFile(filename);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        mRepeatButton.setVisibility(View.VISIBLE);\n                        mShuffleButton.setVisibility(View.VISIBLE);\n                        mQueueButton.setVisibility(View.VISIBLE);\n                        setRepeatButtonImage();\n                        setShuffleButtonImage();\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n                mService = null;\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        if (mService == null) return;\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE) ||\n                    action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private static class AlbumSongIdWrapper {\n        public long albumid;\n        public long songid;\n        AlbumSongIdWrapper(long aid, long sid) {\n            albumid = aid;\n            songid = sid;\n        }\n    }\n    \n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            long songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(-1, -1)).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                long albumid = mService.getAlbumId();\n                if (MediaStore.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(albumid, songid)).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private long mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg)\n        {\n            long albumid = ((AlbumSongIdWrapper) msg.obj).albumid;\n            long songid = ((AlbumSongIdWrapper) msg.obj).songid;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":612}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n\n\n        Cursor ret = null;\n        if (mArtistId != null) {\n            Uri uri = MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                    Long.valueOf(mArtistId));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            if (async != null) {\n                async.startQuery(0, null, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            Uri uri = MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            if (async != null) {\n                async.startQuery(0, null,\n                        uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":457}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n\n\n        Cursor ret = null;\n        if (mArtistId != null) {\n            Uri uri = MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                    Long.valueOf(mArtistId));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            if (async != null) {\n                async.startQuery(0, null, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            Uri uri = MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            if (async != null) {\n                async.startQuery(0, null,\n                        uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, uri,\n                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":470}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        \n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaStore.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaStore.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        \n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n\n        Uri uri = MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI;\n        if (!TextUtils.isEmpty(filter)) {\n            uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n        }\n\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, uri,\n                    cols, null , null, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, uri,\n                    cols, null , null, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaStore.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaStore.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":521}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.RadioButton;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.io.IOException;\nimport java.text.Collator;\nimport java.util.Formatter;\nimport java.util.Locale;\n\n/**\n * Activity allowing the user to select a music track on the device, and\n * return it to its caller.  The music picker user interface is fairly\n * extensive, providing information about each track like the music\n * application (title, author, album, duration), as well as the ability to\n * previous tracks and sort them in different orders.\n * \n * <p>This class also illustrates how you can load data from a content\n * provider asynchronously, providing a good UI while doing so, perform\n * indexing of the content for use inside of a {@link FastScrollView}, and\n * perform filtering of the data as the user presses keys.\n */\npublic class MusicPicker extends ListActivity\n        implements View.OnClickListener, MediaPlayer.OnCompletionListener,\n        MusicUtils.Defs {\n    static final boolean DBG = false;\n    static final String TAG = \"MusicPicker\";\n    \n    /** Holds the previous state of the list, to restore after the async\n     * query has completed. */\n    static final String LIST_STATE_KEY = \"liststate\";\n    /** Remember whether the list last had focus for restoring its state. */\n    static final String FOCUS_KEY = \"focused\";\n    /** Remember the last ordering mode for restoring state. */\n    static final String SORT_MODE_KEY = \"sortMode\";\n    \n    /** Arbitrary number, doesn't matter since we only do one query type. */\n    static final int MY_QUERY_TOKEN = 42;\n    \n    /** Menu item to sort the music list by track title. */\n    static final int TRACK_MENU = Menu.FIRST;\n    /** Menu item to sort the music list by album title. */\n    static final int ALBUM_MENU = Menu.FIRST+1;\n    /** Menu item to sort the music list by artist name. */\n    static final int ARTIST_MENU = Menu.FIRST+2;\n    \n    /** These are the columns in the music cursor that we are interested in. */\n    static final String[] CURSOR_COLS = new String[] {\n            MediaStore.Audio.Media._ID,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.TITLE_KEY,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.DURATION,\n            MediaStore.Audio.Media.TRACK\n    };\n    \n    /** Formatting optimization to avoid creating many temporary objects. */\n    static StringBuilder sFormatBuilder = new StringBuilder();\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static final Object[] sTimeArgs = new Object[5];\n\n    /** Uri to the directory of all music being displayed. */\n    Uri mBaseUri;\n    \n    /** This is the adapter used to display all of the tracks. */\n    TrackListAdapter mAdapter;\n    /** Our instance of QueryHandler used to perform async background queries. */\n    QueryHandler mQueryHandler;\n    \n    /** Used to keep track of the last scroll state of the list. */\n    Parcelable mListState = null;\n    /** Used to keep track of whether the list last had focus. */\n    boolean mListHasFocus;\n    \n    /** The current cursor on the music that is being displayed. */\n    Cursor mCursor;\n    /** The actual sort order the user has selected. */\n    int mSortMode = -1;\n    /** SQL order by string describing the currently selected sort order. */\n    String mSortOrder;\n\n    /** Container of the in-screen progress indicator, to be able to hide it\n     * when done loading the initial cursor. */\n    View mProgressContainer;\n    /** Container of the list view hierarchy, to be able to show it when done\n     * loading the initial cursor. */\n    View mListContainer;\n    /** Set to true when the list view has been shown for the first time. */\n    boolean mListShown;\n    \n    /** View holding the okay button. */\n    View mOkayButton;\n    /** View holding the cancel button. */\n    View mCancelButton;\n    \n    /** Which track row ID the user has last selected. */\n    long mSelectedId = -1;\n    /** Completel Uri that the user has last selected. */\n    Uri mSelectedUri;\n    \n    /** If >= 0, we are currently playing a track for preview, and this is its\n     * row ID. */\n    long mPlayingId = -1;\n    \n    /** This is used for playing previews of the music files. */\n    MediaPlayer mMediaPlayer;\n    \n    /**\n     * A special implementation of SimpleCursorAdapter that knows how to bind\n     * our cursor data to our list item structure, and takes care of other\n     * advanced features such as indexing and filtering.\n     */\n    class TrackListAdapter extends SimpleCursorAdapter\n            implements SectionIndexer {\n        final ListView mListView;\n        \n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n\n        private int mIdIdx;\n        private int mTitleIdx;\n        private int mArtistIdx;\n        private int mAlbumIdx;\n        private int mDurationIdx;\n\n        private boolean mLoading = true;\n        private int mIndexerSortMode;\n        private MusicAlphabetIndexer mIndexer;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            RadioButton radio;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, ListView listView, int layout,\n                String[] from, int[] to) {\n            super(context, layout, null, from, to);\n            mListView = listView;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n        }\n\n        /**\n         * The mLoading flag is set while we are performing a background\n         * query, to avoid displaying the \"No music\" empty view during\n         * this time.\n         */\n        public void setLoading(boolean loading) {\n            mLoading = loading;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            if (mLoading) {\n                // We don't want the empty state to show when loading.\n                return false;\n            } else {\n                return super.isEmpty();\n            }\n        }\n        \n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.radio = (RadioButton) v.findViewById(R.id.radio);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            // Update the checkbox of the item, based on which the user last\n            // selected.  Note that doing it this way means we must have the\n            // list view update all of its items when the selected item\n            // changes.\n            final long id = cursor.getLong(mIdIdx);\n            vh.radio.setChecked(id == mSelectedId);\n            if (DBG) Log.v(TAG, \"Binding id=\" + id + \" sel=\" + mSelectedId\n                    + \" playing=\" + mPlayingId + \" cursor=\" + cursor);\n            \n            // Likewise, display the \"now playing\" icon if this item is\n            // currently being previewed for the user.\n            ImageView iv = vh.play_indicator;\n            if (id == mPlayingId) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        /**\n         * This method is called whenever we receive a new cursor due to\n         * an async query, and must take care of plugging the new one in\n         * to the adapter.\n         */\n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            if (DBG) Log.v(TAG, \"Setting cursor to: \" + cursor\n                    + \" from: \" + MusicPicker.this.mCursor);\n            \n            MusicPicker.this.mCursor = cursor;\n            \n            if (cursor != null) {\n                // Retrieve indices of the various columns we are interested in.\n                mIdIdx = cursor.getColumnIndex(MediaStore.Audio.Media._ID);\n                mTitleIdx = cursor.getColumnIndex(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DURATION);\n\n                // If the sort mode has changed, or we haven't yet created an\n                // indexer one, then create a new one that is indexing the\n                // appropriate column based on the sort mode.\n                if (mIndexerSortMode != mSortMode || mIndexer == null) {\n                    mIndexerSortMode = mSortMode;\n                    int idx = mTitleIdx;\n                    switch (mIndexerSortMode) {\n                        case ARTIST_MENU:\n                            idx = mArtistIdx;\n                            break;\n                        case ALBUM_MENU:\n                            idx = mAlbumIdx;\n                            break;\n                    }\n                    mIndexer = new MusicAlphabetIndexer(cursor, idx,\n                            getResources().getString(R.string.fast_scroll_alphabet));\n                    \n                // If we have a valid indexer, but the cursor has changed since\n                // its last use, then point it to the current cursor.\n                } else {\n                    mIndexer.setCursor(cursor);\n                }\n            }\n            \n            // Ensure that the list is shown (and initial progress indicator\n            // hidden) in case this is the first cursor we have gotten.\n            makeListShown();\n        }\n        \n        /**\n         * This method is called from a background thread by the list view\n         * when the user has typed a letter that should result in a filtering\n         * of the displayed items.  It returns a Cursor, when will then be\n         * handed to changeCursor.\n         */\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            if (DBG) Log.v(TAG, \"Getting new cursor...\");\n            return doQuery(true, constraint.toString());\n        }\n        \n        public int getPositionForSection(int section) {\n            Cursor cursor = getCursor();\n            if (cursor == null) {\n                // No cursor, the section doesn't exist so just return 0\n                return 0;\n            }\n            \n            return mIndexer.getPositionForSection(section);\n        }\n\n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n\n        public Object[] getSections() {\n            if (mIndexer != null) {\n                return mIndexer.getSections();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * This is our specialization of AsyncQueryHandler applies new cursors\n     * to our state as they become available.\n     */\n    private final class QueryHandler extends AsyncQueryHandler {\n        public QueryHandler(Context context) {\n            super(context.getContentResolver());\n        }\n\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (!isFinishing()) {\n                // Update the adapter: we are no longer loading, and have\n                // a new cursor for it.\n                mAdapter.setLoading(false);\n                mAdapter.changeCursor(cursor);\n                setProgressBarIndeterminateVisibility(false);\n    \n                // Now that the cursor is populated again, it's possible to restore the list state\n                if (mListState != null) {\n                    getListView().onRestoreInstanceState(mListState);\n                    if (mListHasFocus) {\n                        getListView().requestFocus();\n                    }\n                    mListHasFocus = false;\n                    mListState = null;\n                }\n            } else {\n                cursor.close();\n            }\n        }\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        \n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        \n        int sortMode = TRACK_MENU;\n        if (icicle == null) {\n            mSelectedUri = getIntent().getParcelableExtra(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n        } else {\n            mSelectedUri = (Uri)icicle.getParcelable(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n            // Retrieve list state. This will be applied after the\n            // QueryHandler has run\n            mListState = icicle.getParcelable(LIST_STATE_KEY);\n            mListHasFocus = icicle.getBoolean(FOCUS_KEY);\n            sortMode = icicle.getInt(SORT_MODE_KEY, sortMode);\n        }\n        if (Intent.ACTION_GET_CONTENT.equals(getIntent().getAction())) {\n            mBaseUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        } else {\n            mBaseUri = getIntent().getData();\n            if (mBaseUri == null) {\n                Log.w(\"MusicPicker\", \"No data URI given to PICK action\");\n                finish();\n                return;\n            }\n        }\n        \n        setContentView(R.layout.music_picker);\n\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n\n        final ListView listView = getListView();\n\n        listView.setItemsCanFocus(false);\n        \n        mAdapter = new TrackListAdapter(this, listView,\n                R.layout.music_picker_item, new String[] {},\n                new int[] {});\n\n        setListAdapter(mAdapter);\n        \n        listView.setTextFilterEnabled(true);\n        \n        // We manually save/restore the listview state\n        listView.setSaveEnabled(false);\n\n        mQueryHandler = new QueryHandler(this);\n        \n        mProgressContainer = findViewById(R.id.progressContainer);\n        mListContainer = findViewById(R.id.listContainer);\n        \n        mOkayButton = findViewById(R.id.okayButton);\n        mOkayButton.setOnClickListener(this);\n        mCancelButton = findViewById(R.id.cancelButton);\n        mCancelButton.setOnClickListener(this);\n        \n        // If there is a currently selected Uri, then try to determine who\n        // it is.\n        if (mSelectedUri != null) {\n            Uri.Builder builder = mSelectedUri.buildUpon();\n            String path = mSelectedUri.getEncodedPath();\n            int idx = path.lastIndexOf('/');\n            if (idx >= 0) {\n                path = path.substring(0, idx);\n            }\n            builder.encodedPath(path);\n            Uri baseSelectedUri = builder.build();\n            if (DBG) Log.v(TAG, \"Selected Uri: \" + mSelectedUri);\n            if (DBG) Log.v(TAG, \"Selected base Uri: \" + baseSelectedUri);\n            if (DBG) Log.v(TAG, \"Base Uri: \" + mBaseUri);\n            if (baseSelectedUri.equals(mBaseUri)) {\n                // If the base Uri of the selected Uri is the same as our\n                // content's base Uri, then use the selection!\n                mSelectedId = ContentUris.parseId(mSelectedUri);\n            }\n        }\n        \n        setSortMode(sortMode);\n    }\n\n    @Override public void onRestart() {\n        super.onRestart();\n        doQuery(false, null);\n    }\n    \n    @Override public boolean onOptionsItemSelected(MenuItem item) {\n        if (setSortMode(item.getItemId())) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(Menu.NONE, TRACK_MENU, Menu.NONE, R.string.sort_by_track);\n        menu.add(Menu.NONE, ALBUM_MENU, Menu.NONE, R.string.sort_by_album);\n        menu.add(Menu.NONE, ARTIST_MENU, Menu.NONE, R.string.sort_by_artist);\n        return true;\n    }\n\n    @Override protected void onSaveInstanceState(Bundle icicle) {\n        super.onSaveInstanceState(icicle);\n        // Save list state in the bundle so we can restore it after the\n        // QueryHandler has run\n        icicle.putParcelable(LIST_STATE_KEY, getListView().onSaveInstanceState());\n        icicle.putBoolean(FOCUS_KEY, getListView().hasFocus());\n        icicle.putInt(SORT_MODE_KEY, mSortMode);\n    }\n    \n    @Override public void onPause() {\n        super.onPause();\n        stopMediaPlayer();\n    }\n    \n    @Override public void onStop() {\n        super.onStop();\n        \n        // We don't want the list to display the empty state, since when we\n        // resume it will still be there and show up while the new query is\n        // happening. After the async query finishes in response to onResume()\n        // setLoading(false) will be called.\n        mAdapter.setLoading(true);\n        mAdapter.changeCursor(null);\n    }\n    \n    /**\n     * Changes the current sort order, building the appropriate query string\n     * for the selected order.\n     */\n    boolean setSortMode(int sortMode) {\n        if (sortMode != mSortMode) {\n            switch (sortMode) {\n                case TRACK_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n                    doQuery(false, null);\n                    return true;\n                case ALBUM_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n                case ARTIST_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ARTIST_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n            }\n            \n        }\n        return false;\n    }\n    \n    /**\n     * The first time this is called, we hide the large progress indicator\n     * and show the list view, doing fade animations between them.\n     */\n    void makeListShown() {\n        if (!mListShown) {\n            mListShown = true;\n            mProgressContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_out));\n            mProgressContainer.setVisibility(View.GONE);\n            mListContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_in));\n            mListContainer.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /**\n     * Common method for performing a query of the music database, called for\n     * both top-level queries and filtering.\n     * \n     * @param sync If true, this query should be done synchronously and the\n     * resulting cursor returned.  If false, it will be done asynchronously and\n     * null returned.\n     * @param filterstring If non-null, this is a filter to apply to the query.\n     */\n    Cursor doQuery(boolean sync, String filterstring) {\n        // Cancel any pending queries\n        mQueryHandler.cancelOperation(MY_QUERY_TOKEN);\n        \n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        // We want to show all audio files, even recordings.  Enforcing the\n        // following condition would hide recordings.\n        //where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n        \n        if (sync) {\n            try {\n                return getContentResolver().query(mBaseUri, CURSOR_COLS,\n                        where.toString(), keywords, mSortOrder);\n            } catch (UnsupportedOperationException ex) {\n            }\n        } else {\n            mAdapter.setLoading(true);\n            setProgressBarIndeterminateVisibility(true);\n            mQueryHandler.startQuery(MY_QUERY_TOKEN, null, mBaseUri, CURSOR_COLS,\n                    where.toString(), keywords, mSortOrder);\n        }\n        return null;\n    }\n    \n    @Override protected void onListItemClick(ListView l, View v, int position,\n            long id) {\n        mCursor.moveToPosition(position);\n        if (DBG) Log.v(TAG, \"Click on \" + position + \" (id=\" + id\n                + \", cursid=\"\n                + mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID))\n                + \") in cursor \" + mCursor\n                + \" adapter=\" + l.getAdapter());\n        setSelected(mCursor);\n    }\n    \n    void setSelected(Cursor c) {\n        Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        long newId = mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID));\n        mSelectedUri = ContentUris.withAppendedId(uri, newId);\n        \n        mSelectedId = newId;\n        if (newId != mPlayingId || mMediaPlayer == null) {\n            stopMediaPlayer();\n            mMediaPlayer = new MediaPlayer();\n            try {\n                mMediaPlayer.setDataSource(this, mSelectedUri);\n                mMediaPlayer.setOnCompletionListener(this);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_RING);\n                mMediaPlayer.prepare();\n                mMediaPlayer.start();\n                mPlayingId = newId;\n                getListView().invalidateViews();\n            } catch (IOException e) {\n                Log.w(\"MusicPicker\", \"Unable to play track\", e);\n            }\n        } else if (mMediaPlayer != null) {\n            stopMediaPlayer();\n            getListView().invalidateViews();\n        }\n    }\n    \n    public void onCompletion(MediaPlayer mp) {\n        if (mMediaPlayer == mp) {\n            mp.stop();\n            mp.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n            getListView().invalidateViews();\n        }\n    }\n    \n    void stopMediaPlayer() {\n        if (mMediaPlayer != null) {\n            mMediaPlayer.stop();\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n        }\n    }\n    \n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.okayButton:\n                if (mSelectedId >= 0) {\n                    setResult(RESULT_OK, new Intent().setData(mSelectedUri));\n                    finish();\n                }\n                break;\n\n            case R.id.cancelButton:\n                finish();\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.RadioButton;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.io.IOException;\nimport java.text.Collator;\nimport java.util.Formatter;\nimport java.util.Locale;\n\n/**\n * Activity allowing the user to select a music track on the device, and\n * return it to its caller.  The music picker user interface is fairly\n * extensive, providing information about each track like the music\n * application (title, author, album, duration), as well as the ability to\n * previous tracks and sort them in different orders.\n * \n * <p>This class also illustrates how you can load data from a content\n * provider asynchronously, providing a good UI while doing so, perform\n * indexing of the content for use inside of a {@link FastScrollView}, and\n * perform filtering of the data as the user presses keys.\n */\npublic class MusicPicker extends ListActivity\n        implements View.OnClickListener, MediaPlayer.OnCompletionListener,\n        MusicUtils.Defs {\n    static final boolean DBG = false;\n    static final String TAG = \"MusicPicker\";\n    \n    /** Holds the previous state of the list, to restore after the async\n     * query has completed. */\n    static final String LIST_STATE_KEY = \"liststate\";\n    /** Remember whether the list last had focus for restoring its state. */\n    static final String FOCUS_KEY = \"focused\";\n    /** Remember the last ordering mode for restoring state. */\n    static final String SORT_MODE_KEY = \"sortMode\";\n    \n    /** Arbitrary number, doesn't matter since we only do one query type. */\n    static final int MY_QUERY_TOKEN = 42;\n    \n    /** Menu item to sort the music list by track title. */\n    static final int TRACK_MENU = Menu.FIRST;\n    /** Menu item to sort the music list by album title. */\n    static final int ALBUM_MENU = Menu.FIRST+1;\n    /** Menu item to sort the music list by artist name. */\n    static final int ARTIST_MENU = Menu.FIRST+2;\n    \n    /** These are the columns in the music cursor that we are interested in. */\n    static final String[] CURSOR_COLS = new String[] {\n            MediaStore.Audio.Media._ID,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.TITLE_KEY,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.DURATION,\n            MediaStore.Audio.Media.TRACK\n    };\n    \n    /** Formatting optimization to avoid creating many temporary objects. */\n    static StringBuilder sFormatBuilder = new StringBuilder();\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static final Object[] sTimeArgs = new Object[5];\n\n    /** Uri to the directory of all music being displayed. */\n    Uri mBaseUri;\n    \n    /** This is the adapter used to display all of the tracks. */\n    TrackListAdapter mAdapter;\n    /** Our instance of QueryHandler used to perform async background queries. */\n    QueryHandler mQueryHandler;\n    \n    /** Used to keep track of the last scroll state of the list. */\n    Parcelable mListState = null;\n    /** Used to keep track of whether the list last had focus. */\n    boolean mListHasFocus;\n    \n    /** The current cursor on the music that is being displayed. */\n    Cursor mCursor;\n    /** The actual sort order the user has selected. */\n    int mSortMode = -1;\n    /** SQL order by string describing the currently selected sort order. */\n    String mSortOrder;\n\n    /** Container of the in-screen progress indicator, to be able to hide it\n     * when done loading the initial cursor. */\n    View mProgressContainer;\n    /** Container of the list view hierarchy, to be able to show it when done\n     * loading the initial cursor. */\n    View mListContainer;\n    /** Set to true when the list view has been shown for the first time. */\n    boolean mListShown;\n    \n    /** View holding the okay button. */\n    View mOkayButton;\n    /** View holding the cancel button. */\n    View mCancelButton;\n    \n    /** Which track row ID the user has last selected. */\n    long mSelectedId = -1;\n    /** Completel Uri that the user has last selected. */\n    Uri mSelectedUri;\n    \n    /** If >= 0, we are currently playing a track for preview, and this is its\n     * row ID. */\n    long mPlayingId = -1;\n    \n    /** This is used for playing previews of the music files. */\n    MediaPlayer mMediaPlayer;\n    \n    /**\n     * A special implementation of SimpleCursorAdapter that knows how to bind\n     * our cursor data to our list item structure, and takes care of other\n     * advanced features such as indexing and filtering.\n     */\n    class TrackListAdapter extends SimpleCursorAdapter\n            implements SectionIndexer {\n        final ListView mListView;\n        \n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n\n        private int mIdIdx;\n        private int mTitleIdx;\n        private int mArtistIdx;\n        private int mAlbumIdx;\n        private int mDurationIdx;\n\n        private boolean mLoading = true;\n        private int mIndexerSortMode;\n        private MusicAlphabetIndexer mIndexer;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            RadioButton radio;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, ListView listView, int layout,\n                String[] from, int[] to) {\n            super(context, layout, null, from, to);\n            mListView = listView;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n        }\n\n        /**\n         * The mLoading flag is set while we are performing a background\n         * query, to avoid displaying the \"No music\" empty view during\n         * this time.\n         */\n        public void setLoading(boolean loading) {\n            mLoading = loading;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            if (mLoading) {\n                // We don't want the empty state to show when loading.\n                return false;\n            } else {\n                return super.isEmpty();\n            }\n        }\n        \n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.radio = (RadioButton) v.findViewById(R.id.radio);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            // Update the checkbox of the item, based on which the user last\n            // selected.  Note that doing it this way means we must have the\n            // list view update all of its items when the selected item\n            // changes.\n            final long id = cursor.getLong(mIdIdx);\n            vh.radio.setChecked(id == mSelectedId);\n            if (DBG) Log.v(TAG, \"Binding id=\" + id + \" sel=\" + mSelectedId\n                    + \" playing=\" + mPlayingId + \" cursor=\" + cursor);\n            \n            // Likewise, display the \"now playing\" icon if this item is\n            // currently being previewed for the user.\n            ImageView iv = vh.play_indicator;\n            if (id == mPlayingId) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        /**\n         * This method is called whenever we receive a new cursor due to\n         * an async query, and must take care of plugging the new one in\n         * to the adapter.\n         */\n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            if (DBG) Log.v(TAG, \"Setting cursor to: \" + cursor\n                    + \" from: \" + MusicPicker.this.mCursor);\n            \n            MusicPicker.this.mCursor = cursor;\n            \n            if (cursor != null) {\n                // Retrieve indices of the various columns we are interested in.\n                mIdIdx = cursor.getColumnIndex(MediaStore.Audio.Media._ID);\n                mTitleIdx = cursor.getColumnIndex(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DURATION);\n\n                // If the sort mode has changed, or we haven't yet created an\n                // indexer one, then create a new one that is indexing the\n                // appropriate column based on the sort mode.\n                if (mIndexerSortMode != mSortMode || mIndexer == null) {\n                    mIndexerSortMode = mSortMode;\n                    int idx = mTitleIdx;\n                    switch (mIndexerSortMode) {\n                        case ARTIST_MENU:\n                            idx = mArtistIdx;\n                            break;\n                        case ALBUM_MENU:\n                            idx = mAlbumIdx;\n                            break;\n                    }\n                    mIndexer = new MusicAlphabetIndexer(cursor, idx,\n                            getResources().getString(R.string.fast_scroll_alphabet));\n                    \n                // If we have a valid indexer, but the cursor has changed since\n                // its last use, then point it to the current cursor.\n                } else {\n                    mIndexer.setCursor(cursor);\n                }\n            }\n            \n            // Ensure that the list is shown (and initial progress indicator\n            // hidden) in case this is the first cursor we have gotten.\n            makeListShown();\n        }\n        \n        /**\n         * This method is called from a background thread by the list view\n         * when the user has typed a letter that should result in a filtering\n         * of the displayed items.  It returns a Cursor, when will then be\n         * handed to changeCursor.\n         */\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            if (DBG) Log.v(TAG, \"Getting new cursor...\");\n            return doQuery(true, constraint.toString());\n        }\n        \n        public int getPositionForSection(int section) {\n            Cursor cursor = getCursor();\n            if (cursor == null) {\n                // No cursor, the section doesn't exist so just return 0\n                return 0;\n            }\n            \n            return mIndexer.getPositionForSection(section);\n        }\n\n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n\n        public Object[] getSections() {\n            if (mIndexer != null) {\n                return mIndexer.getSections();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * This is our specialization of AsyncQueryHandler applies new cursors\n     * to our state as they become available.\n     */\n    private final class QueryHandler extends AsyncQueryHandler {\n        public QueryHandler(Context context) {\n            super(context.getContentResolver());\n        }\n\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (!isFinishing()) {\n                // Update the adapter: we are no longer loading, and have\n                // a new cursor for it.\n                mAdapter.setLoading(false);\n                mAdapter.changeCursor(cursor);\n                setProgressBarIndeterminateVisibility(false);\n    \n                // Now that the cursor is populated again, it's possible to restore the list state\n                if (mListState != null) {\n                    getListView().onRestoreInstanceState(mListState);\n                    if (mListHasFocus) {\n                        getListView().requestFocus();\n                    }\n                    mListHasFocus = false;\n                    mListState = null;\n                }\n            } else {\n                cursor.close();\n            }\n        }\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        \n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        \n        int sortMode = TRACK_MENU;\n        if (icicle == null) {\n            mSelectedUri = getIntent().getParcelableExtra(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n        } else {\n            mSelectedUri = (Uri)icicle.getParcelable(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n            // Retrieve list state. This will be applied after the\n            // QueryHandler has run\n            mListState = icicle.getParcelable(LIST_STATE_KEY);\n            mListHasFocus = icicle.getBoolean(FOCUS_KEY);\n            sortMode = icicle.getInt(SORT_MODE_KEY, sortMode);\n        }\n        if (Intent.ACTION_GET_CONTENT.equals(getIntent().getAction())) {\n            mBaseUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        } else {\n            mBaseUri = getIntent().getData();\n            if (mBaseUri == null) {\n                Log.w(\"MusicPicker\", \"No data URI given to PICK action\");\n                finish();\n                return;\n            }\n        }\n        \n        setContentView(R.layout.music_picker);\n\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n\n        final ListView listView = getListView();\n\n        listView.setItemsCanFocus(false);\n        \n        mAdapter = new TrackListAdapter(this, listView,\n                R.layout.music_picker_item, new String[] {},\n                new int[] {});\n\n        setListAdapter(mAdapter);\n        \n        listView.setTextFilterEnabled(true);\n        \n        // We manually save/restore the listview state\n        listView.setSaveEnabled(false);\n\n        mQueryHandler = new QueryHandler(this);\n        \n        mProgressContainer = findViewById(R.id.progressContainer);\n        mListContainer = findViewById(R.id.listContainer);\n        \n        mOkayButton = findViewById(R.id.okayButton);\n        mOkayButton.setOnClickListener(this);\n        mCancelButton = findViewById(R.id.cancelButton);\n        mCancelButton.setOnClickListener(this);\n        \n        // If there is a currently selected Uri, then try to determine who\n        // it is.\n        if (mSelectedUri != null) {\n            Uri.Builder builder = mSelectedUri.buildUpon();\n            String path = mSelectedUri.getEncodedPath();\n            int idx = path.lastIndexOf('/');\n            if (idx >= 0) {\n                path = path.substring(0, idx);\n            }\n            builder.encodedPath(path);\n            Uri baseSelectedUri = builder.build();\n            if (DBG) Log.v(TAG, \"Selected Uri: \" + mSelectedUri);\n            if (DBG) Log.v(TAG, \"Selected base Uri: \" + baseSelectedUri);\n            if (DBG) Log.v(TAG, \"Base Uri: \" + mBaseUri);\n            if (baseSelectedUri.equals(mBaseUri)) {\n                // If the base Uri of the selected Uri is the same as our\n                // content's base Uri, then use the selection!\n                mSelectedId = ContentUris.parseId(mSelectedUri);\n            }\n        }\n        \n        setSortMode(sortMode);\n    }\n\n    @Override public void onRestart() {\n        super.onRestart();\n        doQuery(false, null);\n    }\n    \n    @Override public boolean onOptionsItemSelected(MenuItem item) {\n        if (setSortMode(item.getItemId())) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(Menu.NONE, TRACK_MENU, Menu.NONE, R.string.sort_by_track);\n        menu.add(Menu.NONE, ALBUM_MENU, Menu.NONE, R.string.sort_by_album);\n        menu.add(Menu.NONE, ARTIST_MENU, Menu.NONE, R.string.sort_by_artist);\n        return true;\n    }\n\n    @Override protected void onSaveInstanceState(Bundle icicle) {\n        super.onSaveInstanceState(icicle);\n        // Save list state in the bundle so we can restore it after the\n        // QueryHandler has run\n        icicle.putParcelable(LIST_STATE_KEY, getListView().onSaveInstanceState());\n        icicle.putBoolean(FOCUS_KEY, getListView().hasFocus());\n        icicle.putInt(SORT_MODE_KEY, mSortMode);\n    }\n    \n    @Override public void onPause() {\n        super.onPause();\n        stopMediaPlayer();\n    }\n    \n    @Override public void onStop() {\n        super.onStop();\n        \n        // We don't want the list to display the empty state, since when we\n        // resume it will still be there and show up while the new query is\n        // happening. After the async query finishes in response to onResume()\n        // setLoading(false) will be called.\n        mAdapter.setLoading(true);\n        mAdapter.changeCursor(null);\n    }\n    \n    /**\n     * Changes the current sort order, building the appropriate query string\n     * for the selected order.\n     */\n    boolean setSortMode(int sortMode) {\n        if (sortMode != mSortMode) {\n            switch (sortMode) {\n                case TRACK_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n                    doQuery(false, null);\n                    return true;\n                case ALBUM_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n                case ARTIST_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ARTIST_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n            }\n            \n        }\n        return false;\n    }\n    \n    /**\n     * The first time this is called, we hide the large progress indicator\n     * and show the list view, doing fade animations between them.\n     */\n    void makeListShown() {\n        if (!mListShown) {\n            mListShown = true;\n            mProgressContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_out));\n            mProgressContainer.setVisibility(View.GONE);\n            mListContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_in));\n            mListContainer.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /**\n     * Common method for performing a query of the music database, called for\n     * both top-level queries and filtering.\n     * \n     * @param sync If true, this query should be done synchronously and the\n     * resulting cursor returned.  If false, it will be done asynchronously and\n     * null returned.\n     * @param filterstring If non-null, this is a filter to apply to the query.\n     */\n    Cursor doQuery(boolean sync, String filterstring) {\n        // Cancel any pending queries\n        mQueryHandler.cancelOperation(MY_QUERY_TOKEN);\n        \n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // We want to show all audio files, even recordings.  Enforcing the\n        // following condition would hide recordings.\n        //where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n\n        Uri uri = mBaseUri;\n        if (!TextUtils.isEmpty(filterstring)) {\n            uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filterstring)).build();\n        }\n\n        if (sync) {\n            try {\n                return getContentResolver().query(uri, CURSOR_COLS,\n                        where.toString(), null, mSortOrder);\n            } catch (UnsupportedOperationException ex) {\n            }\n        } else {\n            mAdapter.setLoading(true);\n            setProgressBarIndeterminateVisibility(true);\n            mQueryHandler.startQuery(MY_QUERY_TOKEN, null, uri, CURSOR_COLS,\n                    where.toString(), null, mSortOrder);\n        }\n        return null;\n    }\n    \n    @Override protected void onListItemClick(ListView l, View v, int position,\n            long id) {\n        mCursor.moveToPosition(position);\n        if (DBG) Log.v(TAG, \"Click on \" + position + \" (id=\" + id\n                + \", cursid=\"\n                + mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID))\n                + \") in cursor \" + mCursor\n                + \" adapter=\" + l.getAdapter());\n        setSelected(mCursor);\n    }\n    \n    void setSelected(Cursor c) {\n        Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        long newId = mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID));\n        mSelectedUri = ContentUris.withAppendedId(uri, newId);\n        \n        mSelectedId = newId;\n        if (newId != mPlayingId || mMediaPlayer == null) {\n            stopMediaPlayer();\n            mMediaPlayer = new MediaPlayer();\n            try {\n                mMediaPlayer.setDataSource(this, mSelectedUri);\n                mMediaPlayer.setOnCompletionListener(this);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_RING);\n                mMediaPlayer.prepare();\n                mMediaPlayer.start();\n                mPlayingId = newId;\n                getListView().invalidateViews();\n            } catch (IOException e) {\n                Log.w(\"MusicPicker\", \"Unable to play track\", e);\n            }\n        } else if (mMediaPlayer != null) {\n            stopMediaPlayer();\n            getListView().invalidateViews();\n        }\n    }\n    \n    public void onCompletion(MediaPlayer mp) {\n        if (mMediaPlayer == mp) {\n            mp.stop();\n            mp.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n            getListView().invalidateViews();\n        }\n    }\n    \n    void stopMediaPlayer() {\n        if (mMediaPlayer != null) {\n            mMediaPlayer.stop();\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n        }\n    }\n    \n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.okayButton:\n                if (mSelectedId >= 0) {\n                    setResult(RESULT_OK, new Intent().setData(mSelectedUri));\n                    finish();\n                }\n                break;\n\n            case R.id.cancelButton:\n                finish();\n                break;\n        }\n    }\n}\n","lineNo":602}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        if (mGenre != null) {\n            Uri uri = MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString(), null, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,\n                        where.toString(), null, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString() , null, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1010}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        if (mGenre != null) {\n            Uri uri = MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString(), null, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,\n                        where.toString(), null, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString() , null, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1030}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        if (mGenre != null) {\n            Uri uri = MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString(), null, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,\n                        where.toString(), null, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString() , null, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1039}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        if (mGenre != null) {\n            Uri uri = MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString(), null, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,\n                        where.toString(), null, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString() , null, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1068}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                if (mAdapter != null) {\n                    Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (c.getCount() == 0) {\n                        finish();\n                        return;\n                    }\n                    mAdapter.changeCursor(c);\n                }\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        if (mGenre != null) {\n            Uri uri = MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre));\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString(), null, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(uri,\n                        mCursorCols, where.toString(), null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                if (!TextUtils.isEmpty(filter)) {\n                    uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n                }\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,\n                        where.toString(), null, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n            if (!TextUtils.isEmpty(filter)) {\n                uri = uri.buildUpon().appendQueryParameter(\"filter\", Uri.encode(filter)).build();\n            }\n            ret = queryhandler.doQuery(uri,\n                    mCursorCols, where.toString() , null, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1050}
{}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":457}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        \n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaStore.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaStore.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private ServiceToken mToken;\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        \n        MusicUtils.unbindFromService(mToken);\n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaStore.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaStore.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaStore.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaStore.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaStore.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaStore.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":524}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.RadioButton;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.io.IOException;\nimport java.text.Collator;\nimport java.util.Formatter;\nimport java.util.Locale;\n\n/**\n * Activity allowing the user to select a music track on the device, and\n * return it to its caller.  The music picker user interface is fairly\n * extensive, providing information about each track like the music\n * application (title, author, album, duration), as well as the ability to\n * previous tracks and sort them in different orders.\n * \n * <p>This class also illustrates how you can load data from a content\n * provider asynchronously, providing a good UI while doing so, perform\n * indexing of the content for use inside of a {@link FastScrollView}, and\n * perform filtering of the data as the user presses keys.\n */\npublic class MusicPicker extends ListActivity\n        implements View.OnClickListener, MediaPlayer.OnCompletionListener,\n        MusicUtils.Defs {\n    static final boolean DBG = false;\n    static final String TAG = \"MusicPicker\";\n    \n    /** Holds the previous state of the list, to restore after the async\n     * query has completed. */\n    static final String LIST_STATE_KEY = \"liststate\";\n    /** Remember whether the list last had focus for restoring its state. */\n    static final String FOCUS_KEY = \"focused\";\n    /** Remember the last ordering mode for restoring state. */\n    static final String SORT_MODE_KEY = \"sortMode\";\n    \n    /** Arbitrary number, doesn't matter since we only do one query type. */\n    static final int MY_QUERY_TOKEN = 42;\n    \n    /** Menu item to sort the music list by track title. */\n    static final int TRACK_MENU = Menu.FIRST;\n    /** Menu item to sort the music list by album title. */\n    static final int ALBUM_MENU = Menu.FIRST+1;\n    /** Menu item to sort the music list by artist name. */\n    static final int ARTIST_MENU = Menu.FIRST+2;\n    \n    /** These are the columns in the music cursor that we are interested in. */\n    static final String[] CURSOR_COLS = new String[] {\n            MediaStore.Audio.Media._ID,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.TITLE_KEY,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.DURATION,\n            MediaStore.Audio.Media.TRACK\n    };\n    \n    /** Formatting optimization to avoid creating many temporary objects. */\n    static StringBuilder sFormatBuilder = new StringBuilder();\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static final Object[] sTimeArgs = new Object[5];\n\n    /** Uri to the directory of all music being displayed. */\n    Uri mBaseUri;\n    \n    /** This is the adapter used to display all of the tracks. */\n    TrackListAdapter mAdapter;\n    /** Our instance of QueryHandler used to perform async background queries. */\n    QueryHandler mQueryHandler;\n    \n    /** Used to keep track of the last scroll state of the list. */\n    Parcelable mListState = null;\n    /** Used to keep track of whether the list last had focus. */\n    boolean mListHasFocus;\n    \n    /** The current cursor on the music that is being displayed. */\n    Cursor mCursor;\n    /** The actual sort order the user has selected. */\n    int mSortMode = -1;\n    /** SQL order by string describing the currently selected sort order. */\n    String mSortOrder;\n\n    /** Container of the in-screen progress indicator, to be able to hide it\n     * when done loading the initial cursor. */\n    View mProgressContainer;\n    /** Container of the list view hierarchy, to be able to show it when done\n     * loading the initial cursor. */\n    View mListContainer;\n    /** Set to true when the list view has been shown for the first time. */\n    boolean mListShown;\n    \n    /** View holding the okay button. */\n    View mOkayButton;\n    /** View holding the cancel button. */\n    View mCancelButton;\n    \n    /** Which track row ID the user has last selected. */\n    long mSelectedId = -1;\n    /** Completel Uri that the user has last selected. */\n    Uri mSelectedUri;\n    \n    /** If >= 0, we are currently playing a track for preview, and this is its\n     * row ID. */\n    long mPlayingId = -1;\n    \n    /** This is used for playing previews of the music files. */\n    MediaPlayer mMediaPlayer;\n    \n    /**\n     * A special implementation of SimpleCursorAdapter that knows how to bind\n     * our cursor data to our list item structure, and takes care of other\n     * advanced features such as indexing and filtering.\n     */\n    class TrackListAdapter extends SimpleCursorAdapter\n            implements SectionIndexer {\n        final ListView mListView;\n        \n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n\n        private int mIdIdx;\n        private int mTitleIdx;\n        private int mArtistIdx;\n        private int mAlbumIdx;\n        private int mDurationIdx;\n\n        private boolean mLoading = true;\n        private int mIndexerSortMode;\n        private MusicAlphabetIndexer mIndexer;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            RadioButton radio;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, ListView listView, int layout,\n                String[] from, int[] to) {\n            super(context, layout, null, from, to);\n            mListView = listView;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n        }\n\n        /**\n         * The mLoading flag is set while we are performing a background\n         * query, to avoid displaying the \"No music\" empty view during\n         * this time.\n         */\n        public void setLoading(boolean loading) {\n            mLoading = loading;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            if (mLoading) {\n                // We don't want the empty state to show when loading.\n                return false;\n            } else {\n                return super.isEmpty();\n            }\n        }\n        \n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.radio = (RadioButton) v.findViewById(R.id.radio);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            // Update the checkbox of the item, based on which the user last\n            // selected.  Note that doing it this way means we must have the\n            // list view update all of its items when the selected item\n            // changes.\n            final long id = cursor.getLong(mIdIdx);\n            vh.radio.setChecked(id == mSelectedId);\n            if (DBG) Log.v(TAG, \"Binding id=\" + id + \" sel=\" + mSelectedId\n                    + \" playing=\" + mPlayingId + \" cursor=\" + cursor);\n            \n            // Likewise, display the \"now playing\" icon if this item is\n            // currently being previewed for the user.\n            ImageView iv = vh.play_indicator;\n            if (id == mPlayingId) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        /**\n         * This method is called whenever we receive a new cursor due to\n         * an async query, and must take care of plugging the new one in\n         * to the adapter.\n         */\n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            if (DBG) Log.v(TAG, \"Setting cursor to: \" + cursor\n                    + \" from: \" + MusicPicker.this.mCursor);\n            \n            MusicPicker.this.mCursor = cursor;\n            \n            if (cursor != null) {\n                // Retrieve indices of the various columns we are interested in.\n                mIdIdx = cursor.getColumnIndex(MediaStore.Audio.Media._ID);\n                mTitleIdx = cursor.getColumnIndex(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DURATION);\n\n                // If the sort mode has changed, or we haven't yet created an\n                // indexer one, then create a new one that is indexing the\n                // appropriate column based on the sort mode.\n                if (mIndexerSortMode != mSortMode || mIndexer == null) {\n                    mIndexerSortMode = mSortMode;\n                    int idx = mTitleIdx;\n                    switch (mIndexerSortMode) {\n                        case ARTIST_MENU:\n                            idx = mArtistIdx;\n                            break;\n                        case ALBUM_MENU:\n                            idx = mAlbumIdx;\n                            break;\n                    }\n                    mIndexer = new MusicAlphabetIndexer(cursor, idx,\n                            getResources().getString(R.string.fast_scroll_alphabet));\n                    \n                // If we have a valid indexer, but the cursor has changed since\n                // its last use, then point it to the current cursor.\n                } else {\n                    mIndexer.setCursor(cursor);\n                }\n            }\n            \n            // Ensure that the list is shown (and initial progress indicator\n            // hidden) in case this is the first cursor we have gotten.\n            makeListShown();\n        }\n        \n        /**\n         * This method is called from a background thread by the list view\n         * when the user has typed a letter that should result in a filtering\n         * of the displayed items.  It returns a Cursor, when will then be\n         * handed to changeCursor.\n         */\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            if (DBG) Log.v(TAG, \"Getting new cursor...\");\n            return doQuery(true, constraint.toString());\n        }\n        \n        public int getPositionForSection(int section) {\n            Cursor cursor = getCursor();\n            if (cursor == null) {\n                // No cursor, the section doesn't exist so just return 0\n                return 0;\n            }\n            \n            return mIndexer.getPositionForSection(section);\n        }\n\n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n\n        public Object[] getSections() {\n            if (mIndexer != null) {\n                return mIndexer.getSections();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * This is our specialization of AsyncQueryHandler applies new cursors\n     * to our state as they become available.\n     */\n    private final class QueryHandler extends AsyncQueryHandler {\n        public QueryHandler(Context context) {\n            super(context.getContentResolver());\n        }\n\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (!isFinishing()) {\n                // Update the adapter: we are no longer loading, and have\n                // a new cursor for it.\n                mAdapter.setLoading(false);\n                mAdapter.changeCursor(cursor);\n                setProgressBarIndeterminateVisibility(false);\n    \n                // Now that the cursor is populated again, it's possible to restore the list state\n                if (mListState != null) {\n                    getListView().onRestoreInstanceState(mListState);\n                    if (mListHasFocus) {\n                        getListView().requestFocus();\n                    }\n                    mListHasFocus = false;\n                    mListState = null;\n                }\n            } else {\n                cursor.close();\n            }\n        }\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        \n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        \n        int sortMode = TRACK_MENU;\n        if (icicle == null) {\n            mSelectedUri = getIntent().getParcelableExtra(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n        } else {\n            mSelectedUri = (Uri)icicle.getParcelable(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n            // Retrieve list state. This will be applied after the\n            // QueryHandler has run\n            mListState = icicle.getParcelable(LIST_STATE_KEY);\n            mListHasFocus = icicle.getBoolean(FOCUS_KEY);\n            sortMode = icicle.getInt(SORT_MODE_KEY, sortMode);\n        }\n        if (Intent.ACTION_GET_CONTENT.equals(getIntent().getAction())) {\n            mBaseUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        } else {\n            mBaseUri = getIntent().getData();\n            if (mBaseUri == null) {\n                Log.w(\"MusicPicker\", \"No data URI given to PICK action\");\n                finish();\n                return;\n            }\n        }\n        \n        setContentView(R.layout.music_picker);\n\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n\n        final ListView listView = getListView();\n\n        listView.setItemsCanFocus(false);\n        \n        mAdapter = new TrackListAdapter(this, listView,\n                R.layout.music_picker_item, new String[] {},\n                new int[] {});\n\n        setListAdapter(mAdapter);\n        \n        listView.setTextFilterEnabled(true);\n        \n        // We manually save/restore the listview state\n        listView.setSaveEnabled(false);\n\n        mQueryHandler = new QueryHandler(this);\n        \n        mProgressContainer = findViewById(R.id.progressContainer);\n        mListContainer = findViewById(R.id.listContainer);\n        \n        mOkayButton = findViewById(R.id.okayButton);\n        mOkayButton.setOnClickListener(this);\n        mCancelButton = findViewById(R.id.cancelButton);\n        mCancelButton.setOnClickListener(this);\n        \n        // If there is a currently selected Uri, then try to determine who\n        // it is.\n        if (mSelectedUri != null) {\n            Uri.Builder builder = mSelectedUri.buildUpon();\n            String path = mSelectedUri.getEncodedPath();\n            int idx = path.lastIndexOf('/');\n            if (idx >= 0) {\n                path = path.substring(0, idx);\n            }\n            builder.encodedPath(path);\n            Uri baseSelectedUri = builder.build();\n            if (DBG) Log.v(TAG, \"Selected Uri: \" + mSelectedUri);\n            if (DBG) Log.v(TAG, \"Selected base Uri: \" + baseSelectedUri);\n            if (DBG) Log.v(TAG, \"Base Uri: \" + mBaseUri);\n            if (baseSelectedUri.equals(mBaseUri)) {\n                // If the base Uri of the selected Uri is the same as our\n                // content's base Uri, then use the selection!\n                mSelectedId = ContentUris.parseId(mSelectedUri);\n            }\n        }\n        \n        setSortMode(sortMode);\n    }\n\n    @Override public void onRestart() {\n        super.onRestart();\n        doQuery(false, null);\n    }\n    \n    @Override public boolean onOptionsItemSelected(MenuItem item) {\n        if (setSortMode(item.getItemId())) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(Menu.NONE, TRACK_MENU, Menu.NONE, R.string.sort_by_track);\n        menu.add(Menu.NONE, ALBUM_MENU, Menu.NONE, R.string.sort_by_album);\n        menu.add(Menu.NONE, ARTIST_MENU, Menu.NONE, R.string.sort_by_artist);\n        return true;\n    }\n\n    @Override protected void onSaveInstanceState(Bundle icicle) {\n        super.onSaveInstanceState(icicle);\n        // Save list state in the bundle so we can restore it after the\n        // QueryHandler has run\n        icicle.putParcelable(LIST_STATE_KEY, getListView().onSaveInstanceState());\n        icicle.putBoolean(FOCUS_KEY, getListView().hasFocus());\n        icicle.putInt(SORT_MODE_KEY, mSortMode);\n    }\n    \n    @Override public void onPause() {\n        super.onPause();\n        stopMediaPlayer();\n    }\n    \n    @Override public void onStop() {\n        super.onStop();\n        \n        // We don't want the list to display the empty state, since when we\n        // resume it will still be there and show up while the new query is\n        // happening. After the async query finishes in response to onResume()\n        // setLoading(false) will be called.\n        mAdapter.setLoading(true);\n        mAdapter.changeCursor(null);\n    }\n    \n    /**\n     * Changes the current sort order, building the appropriate query string\n     * for the selected order.\n     */\n    boolean setSortMode(int sortMode) {\n        if (sortMode != mSortMode) {\n            switch (sortMode) {\n                case TRACK_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n                    doQuery(false, null);\n                    return true;\n                case ALBUM_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n                case ARTIST_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ARTIST_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n            }\n            \n        }\n        return false;\n    }\n    \n    /**\n     * The first time this is called, we hide the large progress indicator\n     * and show the list view, doing fade animations between them.\n     */\n    void makeListShown() {\n        if (!mListShown) {\n            mListShown = true;\n            mProgressContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_out));\n            mProgressContainer.setVisibility(View.GONE);\n            mListContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_in));\n            mListContainer.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /**\n     * Common method for performing a query of the music database, called for\n     * both top-level queries and filtering.\n     * \n     * @param sync If true, this query should be done synchronously and the\n     * resulting cursor returned.  If false, it will be done asynchronously and\n     * null returned.\n     * @param filterstring If non-null, this is a filter to apply to the query.\n     */\n    Cursor doQuery(boolean sync, String filterstring) {\n        // Cancel any pending queries\n        mQueryHandler.cancelOperation(MY_QUERY_TOKEN);\n        \n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        // We want to show all audio files, even recordings.  Enforcing the\n        // following condition would hide recordings.\n        //where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n        \n        if (sync) {\n            try {\n                return getContentResolver().query(mBaseUri, CURSOR_COLS,\n                        where.toString(), keywords, mSortOrder);\n            } catch (UnsupportedOperationException ex) {\n            }\n        } else {\n            mAdapter.setLoading(true);\n            setProgressBarIndeterminateVisibility(true);\n            mQueryHandler.startQuery(MY_QUERY_TOKEN, null, mBaseUri, CURSOR_COLS,\n                    where.toString(), keywords, mSortOrder);\n        }\n        return null;\n    }\n    \n    @Override protected void onListItemClick(ListView l, View v, int position,\n            long id) {\n        mCursor.moveToPosition(position);\n        if (DBG) Log.v(TAG, \"Click on \" + position + \" (id=\" + id\n                + \", cursid=\"\n                + mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID))\n                + \") in cursor \" + mCursor\n                + \" adapter=\" + l.getAdapter());\n        setSelected(mCursor);\n    }\n    \n    void setSelected(Cursor c) {\n        Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        long newId = mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID));\n        mSelectedUri = ContentUris.withAppendedId(uri, newId);\n        \n        mSelectedId = newId;\n        if (newId != mPlayingId || mMediaPlayer == null) {\n            stopMediaPlayer();\n            mMediaPlayer = new MediaPlayer();\n            try {\n                mMediaPlayer.setDataSource(this, mSelectedUri);\n                mMediaPlayer.setOnCompletionListener(this);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_RING);\n                mMediaPlayer.prepare();\n                mMediaPlayer.start();\n                mPlayingId = newId;\n                getListView().invalidateViews();\n            } catch (IOException e) {\n                Log.w(\"MusicPicker\", \"Unable to play track\", e);\n            }\n        } else if (mMediaPlayer != null) {\n            stopMediaPlayer();\n            getListView().invalidateViews();\n        }\n    }\n    \n    public void onCompletion(MediaPlayer mp) {\n        if (mMediaPlayer == mp) {\n            mp.stop();\n            mp.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n            getListView().invalidateViews();\n        }\n    }\n    \n    void stopMediaPlayer() {\n        if (mMediaPlayer != null) {\n            mMediaPlayer.stop();\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n        }\n    }\n    \n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.okayButton:\n                if (mSelectedId >= 0) {\n                    setResult(RESULT_OK, new Intent().setData(mSelectedUri));\n                    finish();\n                }\n                break;\n\n            case R.id.cancelButton:\n                finish();\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaPlayer;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.RadioButton;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.io.IOException;\nimport java.text.Collator;\nimport java.util.Formatter;\nimport java.util.Locale;\n\n/**\n * Activity allowing the user to select a music track on the device, and\n * return it to its caller.  The music picker user interface is fairly\n * extensive, providing information about each track like the music\n * application (title, author, album, duration), as well as the ability to\n * previous tracks and sort them in different orders.\n * \n * <p>This class also illustrates how you can load data from a content\n * provider asynchronously, providing a good UI while doing so, perform\n * indexing of the content for use inside of a {@link FastScrollView}, and\n * perform filtering of the data as the user presses keys.\n */\npublic class MusicPicker extends ListActivity\n        implements View.OnClickListener, MediaPlayer.OnCompletionListener,\n        MusicUtils.Defs {\n    static final boolean DBG = false;\n    static final String TAG = \"MusicPicker\";\n    \n    /** Holds the previous state of the list, to restore after the async\n     * query has completed. */\n    static final String LIST_STATE_KEY = \"liststate\";\n    /** Remember whether the list last had focus for restoring its state. */\n    static final String FOCUS_KEY = \"focused\";\n    /** Remember the last ordering mode for restoring state. */\n    static final String SORT_MODE_KEY = \"sortMode\";\n    \n    /** Arbitrary number, doesn't matter since we only do one query type. */\n    static final int MY_QUERY_TOKEN = 42;\n    \n    /** Menu item to sort the music list by track title. */\n    static final int TRACK_MENU = Menu.FIRST;\n    /** Menu item to sort the music list by album title. */\n    static final int ALBUM_MENU = Menu.FIRST+1;\n    /** Menu item to sort the music list by artist name. */\n    static final int ARTIST_MENU = Menu.FIRST+2;\n    \n    /** These are the columns in the music cursor that we are interested in. */\n    static final String[] CURSOR_COLS = new String[] {\n            MediaStore.Audio.Media._ID,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.TITLE_KEY,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.DURATION,\n            MediaStore.Audio.Media.TRACK\n    };\n    \n    /** Formatting optimization to avoid creating many temporary objects. */\n    static StringBuilder sFormatBuilder = new StringBuilder();\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    /** Formatting optimization to avoid creating many temporary objects. */\n    static final Object[] sTimeArgs = new Object[5];\n\n    /** Uri to the directory of all music being displayed. */\n    Uri mBaseUri;\n    \n    /** This is the adapter used to display all of the tracks. */\n    TrackListAdapter mAdapter;\n    /** Our instance of QueryHandler used to perform async background queries. */\n    QueryHandler mQueryHandler;\n    \n    /** Used to keep track of the last scroll state of the list. */\n    Parcelable mListState = null;\n    /** Used to keep track of whether the list last had focus. */\n    boolean mListHasFocus;\n    \n    /** The current cursor on the music that is being displayed. */\n    Cursor mCursor;\n    /** The actual sort order the user has selected. */\n    int mSortMode = -1;\n    /** SQL order by string describing the currently selected sort order. */\n    String mSortOrder;\n\n    /** Container of the in-screen progress indicator, to be able to hide it\n     * when done loading the initial cursor. */\n    View mProgressContainer;\n    /** Container of the list view hierarchy, to be able to show it when done\n     * loading the initial cursor. */\n    View mListContainer;\n    /** Set to true when the list view has been shown for the first time. */\n    boolean mListShown;\n    \n    /** View holding the okay button. */\n    View mOkayButton;\n    /** View holding the cancel button. */\n    View mCancelButton;\n    \n    /** Which track row ID the user has last selected. */\n    long mSelectedId = -1;\n    /** Completel Uri that the user has last selected. */\n    Uri mSelectedUri;\n    \n    /** If >= 0, we are currently playing a track for preview, and this is its\n     * row ID. */\n    long mPlayingId = -1;\n    \n    /** This is used for playing previews of the music files. */\n    MediaPlayer mMediaPlayer;\n    \n    /**\n     * A special implementation of SimpleCursorAdapter that knows how to bind\n     * our cursor data to our list item structure, and takes care of other\n     * advanced features such as indexing and filtering.\n     */\n    class TrackListAdapter extends SimpleCursorAdapter\n            implements SectionIndexer {\n        final ListView mListView;\n        \n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n\n        private int mIdIdx;\n        private int mTitleIdx;\n        private int mArtistIdx;\n        private int mAlbumIdx;\n        private int mDurationIdx;\n\n        private boolean mLoading = true;\n        private int mIndexerSortMode;\n        private MusicAlphabetIndexer mIndexer;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            RadioButton radio;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, ListView listView, int layout,\n                String[] from, int[] to) {\n            super(context, layout, null, from, to);\n            mListView = listView;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n        }\n\n        /**\n         * The mLoading flag is set while we are performing a background\n         * query, to avoid displaying the \"No music\" empty view during\n         * this time.\n         */\n        public void setLoading(boolean loading) {\n            mLoading = loading;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            if (mLoading) {\n                // We don't want the empty state to show when loading.\n                return false;\n            } else {\n                return super.isEmpty();\n            }\n        }\n        \n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.radio = (RadioButton) v.findViewById(R.id.radio);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(\"<unknown>\")) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            // Update the checkbox of the item, based on which the user last\n            // selected.  Note that doing it this way means we must have the\n            // list view update all of its items when the selected item\n            // changes.\n            final long id = cursor.getLong(mIdIdx);\n            vh.radio.setChecked(id == mSelectedId);\n            if (DBG) Log.v(TAG, \"Binding id=\" + id + \" sel=\" + mSelectedId\n                    + \" playing=\" + mPlayingId + \" cursor=\" + cursor);\n            \n            // Likewise, display the \"now playing\" icon if this item is\n            // currently being previewed for the user.\n            ImageView iv = vh.play_indicator;\n            if (id == mPlayingId) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        /**\n         * This method is called whenever we receive a new cursor due to\n         * an async query, and must take care of plugging the new one in\n         * to the adapter.\n         */\n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            if (DBG) Log.v(TAG, \"Setting cursor to: \" + cursor\n                    + \" from: \" + MusicPicker.this.mCursor);\n            \n            MusicPicker.this.mCursor = cursor;\n            \n            if (cursor != null) {\n                // Retrieve indices of the various columns we are interested in.\n                mIdIdx = cursor.getColumnIndex(MediaStore.Audio.Media._ID);\n                mTitleIdx = cursor.getColumnIndex(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DURATION);\n\n                // If the sort mode has changed, or we haven't yet created an\n                // indexer one, then create a new one that is indexing the\n                // appropriate column based on the sort mode.\n                if (mIndexerSortMode != mSortMode || mIndexer == null) {\n                    mIndexerSortMode = mSortMode;\n                    int idx = mTitleIdx;\n                    switch (mIndexerSortMode) {\n                        case ARTIST_MENU:\n                            idx = mArtistIdx;\n                            break;\n                        case ALBUM_MENU:\n                            idx = mAlbumIdx;\n                            break;\n                    }\n                    mIndexer = new MusicAlphabetIndexer(cursor, idx,\n                            getResources().getString(R.string.fast_scroll_alphabet));\n                    \n                // If we have a valid indexer, but the cursor has changed since\n                // its last use, then point it to the current cursor.\n                } else {\n                    mIndexer.setCursor(cursor);\n                }\n            }\n            \n            // Ensure that the list is shown (and initial progress indicator\n            // hidden) in case this is the first cursor we have gotten.\n            makeListShown();\n        }\n        \n        /**\n         * This method is called from a background thread by the list view\n         * when the user has typed a letter that should result in a filtering\n         * of the displayed items.  It returns a Cursor, when will then be\n         * handed to changeCursor.\n         */\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            if (DBG) Log.v(TAG, \"Getting new cursor...\");\n            return doQuery(true, constraint.toString());\n        }\n        \n        public int getPositionForSection(int section) {\n            Cursor cursor = getCursor();\n            if (cursor == null) {\n                // No cursor, the section doesn't exist so just return 0\n                return 0;\n            }\n            \n            return mIndexer.getPositionForSection(section);\n        }\n\n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n\n        public Object[] getSections() {\n            if (mIndexer != null) {\n                return mIndexer.getSections();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * This is our specialization of AsyncQueryHandler applies new cursors\n     * to our state as they become available.\n     */\n    private final class QueryHandler extends AsyncQueryHandler {\n        public QueryHandler(Context context) {\n            super(context.getContentResolver());\n        }\n\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (!isFinishing()) {\n                // Update the adapter: we are no longer loading, and have\n                // a new cursor for it.\n                mAdapter.setLoading(false);\n                mAdapter.changeCursor(cursor);\n                setProgressBarIndeterminateVisibility(false);\n    \n                // Now that the cursor is populated again, it's possible to restore the list state\n                if (mListState != null) {\n                    getListView().onRestoreInstanceState(mListState);\n                    if (mListHasFocus) {\n                        getListView().requestFocus();\n                    }\n                    mListHasFocus = false;\n                    mListState = null;\n                }\n            } else {\n                cursor.close();\n            }\n        }\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        \n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        \n        int sortMode = TRACK_MENU;\n        if (icicle == null) {\n            mSelectedUri = getIntent().getParcelableExtra(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n        } else {\n            mSelectedUri = (Uri)icicle.getParcelable(\n                    RingtoneManager.EXTRA_RINGTONE_EXISTING_URI);\n            // Retrieve list state. This will be applied after the\n            // QueryHandler has run\n            mListState = icicle.getParcelable(LIST_STATE_KEY);\n            mListHasFocus = icicle.getBoolean(FOCUS_KEY);\n            sortMode = icicle.getInt(SORT_MODE_KEY, sortMode);\n        }\n        if (Intent.ACTION_GET_CONTENT.equals(getIntent().getAction())) {\n            mBaseUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        } else {\n            mBaseUri = getIntent().getData();\n            if (mBaseUri == null) {\n                Log.w(\"MusicPicker\", \"No data URI given to PICK action\");\n                finish();\n                return;\n            }\n        }\n        \n        setContentView(R.layout.music_picker);\n\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n\n        final ListView listView = getListView();\n\n        listView.setItemsCanFocus(false);\n        \n        mAdapter = new TrackListAdapter(this, listView,\n                R.layout.music_picker_item, new String[] {},\n                new int[] {});\n\n        setListAdapter(mAdapter);\n        \n        listView.setTextFilterEnabled(true);\n        \n        // We manually save/restore the listview state\n        listView.setSaveEnabled(false);\n\n        mQueryHandler = new QueryHandler(this);\n        \n        mProgressContainer = findViewById(R.id.progressContainer);\n        mListContainer = findViewById(R.id.listContainer);\n        \n        mOkayButton = findViewById(R.id.okayButton);\n        mOkayButton.setOnClickListener(this);\n        mCancelButton = findViewById(R.id.cancelButton);\n        mCancelButton.setOnClickListener(this);\n        \n        // If there is a currently selected Uri, then try to determine who\n        // it is.\n        if (mSelectedUri != null) {\n            Uri.Builder builder = mSelectedUri.buildUpon();\n            String path = mSelectedUri.getEncodedPath();\n            int idx = path.lastIndexOf('/');\n            if (idx >= 0) {\n                path = path.substring(0, idx);\n            }\n            builder.encodedPath(path);\n            Uri baseSelectedUri = builder.build();\n            if (DBG) Log.v(TAG, \"Selected Uri: \" + mSelectedUri);\n            if (DBG) Log.v(TAG, \"Selected base Uri: \" + baseSelectedUri);\n            if (DBG) Log.v(TAG, \"Base Uri: \" + mBaseUri);\n            if (baseSelectedUri.equals(mBaseUri)) {\n                // If the base Uri of the selected Uri is the same as our\n                // content's base Uri, then use the selection!\n                mSelectedId = ContentUris.parseId(mSelectedUri);\n            }\n        }\n        \n        setSortMode(sortMode);\n    }\n\n    @Override public void onRestart() {\n        super.onRestart();\n        doQuery(false, null);\n    }\n    \n    @Override public boolean onOptionsItemSelected(MenuItem item) {\n        if (setSortMode(item.getItemId())) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(Menu.NONE, TRACK_MENU, Menu.NONE, R.string.sort_by_track);\n        menu.add(Menu.NONE, ALBUM_MENU, Menu.NONE, R.string.sort_by_album);\n        menu.add(Menu.NONE, ARTIST_MENU, Menu.NONE, R.string.sort_by_artist);\n        return true;\n    }\n\n    @Override protected void onSaveInstanceState(Bundle icicle) {\n        super.onSaveInstanceState(icicle);\n        // Save list state in the bundle so we can restore it after the\n        // QueryHandler has run\n        icicle.putParcelable(LIST_STATE_KEY, getListView().onSaveInstanceState());\n        icicle.putBoolean(FOCUS_KEY, getListView().hasFocus());\n        icicle.putInt(SORT_MODE_KEY, mSortMode);\n    }\n    \n    @Override public void onPause() {\n        super.onPause();\n        stopMediaPlayer();\n    }\n    \n    @Override public void onStop() {\n        super.onStop();\n        \n        // We don't want the list to display the empty state, since when we\n        // resume it will still be there and show up while the new query is\n        // happening. After the async query finishes in response to onResume()\n        // setLoading(false) will be called.\n        mAdapter.setLoading(true);\n        mAdapter.changeCursor(null);\n    }\n    \n    /**\n     * Changes the current sort order, building the appropriate query string\n     * for the selected order.\n     */\n    boolean setSortMode(int sortMode) {\n        if (sortMode != mSortMode) {\n            switch (sortMode) {\n                case TRACK_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n                    doQuery(false, null);\n                    return true;\n                case ALBUM_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n                case ARTIST_MENU:\n                    mSortMode = sortMode;\n                    mSortOrder = MediaStore.Audio.Media.ARTIST_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.ALBUM_KEY + \" ASC, \"\n                            + MediaStore.Audio.Media.TRACK + \" ASC, \"\n                            + MediaStore.Audio.Media.TITLE_KEY + \" ASC\";\n                    doQuery(false, null);\n                    return true;\n            }\n            \n        }\n        return false;\n    }\n    \n    /**\n     * The first time this is called, we hide the large progress indicator\n     * and show the list view, doing fade animations between them.\n     */\n    void makeListShown() {\n        if (!mListShown) {\n            mListShown = true;\n            mProgressContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_out));\n            mProgressContainer.setVisibility(View.GONE);\n            mListContainer.startAnimation(AnimationUtils.loadAnimation(\n                    this, android.R.anim.fade_in));\n            mListContainer.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /**\n     * Common method for performing a query of the music database, called for\n     * both top-level queries and filtering.\n     * \n     * @param sync If true, this query should be done synchronously and the\n     * resulting cursor returned.  If false, it will be done asynchronously and\n     * null returned.\n     * @param filterstring If non-null, this is a filter to apply to the query.\n     */\n    Cursor doQuery(boolean sync, String filterstring) {\n        // Cancel any pending queries\n        mQueryHandler.cancelOperation(MY_QUERY_TOKEN);\n        \n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        // We want to show all audio files, even recordings.  Enforcing the\n        // following condition would hide recordings.\n        //where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n        \n        if (sync) {\n            try {\n                return getContentResolver().query(mBaseUri, CURSOR_COLS,\n                        where.toString(), keywords, mSortOrder);\n            } catch (UnsupportedOperationException ex) {\n            }\n        } else {\n            mAdapter.setLoading(true);\n            setProgressBarIndeterminateVisibility(true);\n            mQueryHandler.startQuery(MY_QUERY_TOKEN, null, mBaseUri, CURSOR_COLS,\n                    where.toString(), keywords, mSortOrder);\n        }\n        return null;\n    }\n    \n    @Override protected void onListItemClick(ListView l, View v, int position,\n            long id) {\n        mCursor.moveToPosition(position);\n        if (DBG) Log.v(TAG, \"Click on \" + position + \" (id=\" + id\n                + \", cursid=\"\n                + mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID))\n                + \") in cursor \" + mCursor\n                + \" adapter=\" + l.getAdapter());\n        setSelected(mCursor);\n    }\n    \n    void setSelected(Cursor c) {\n        Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n        long newId = mCursor.getLong(mCursor.getColumnIndex(MediaStore.Audio.Media._ID));\n        mSelectedUri = ContentUris.withAppendedId(uri, newId);\n        \n        mSelectedId = newId;\n        if (newId != mPlayingId || mMediaPlayer == null) {\n            stopMediaPlayer();\n            mMediaPlayer = new MediaPlayer();\n            try {\n                mMediaPlayer.setDataSource(this, mSelectedUri);\n                mMediaPlayer.setOnCompletionListener(this);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_RING);\n                mMediaPlayer.prepare();\n                mMediaPlayer.start();\n                mPlayingId = newId;\n                getListView().invalidateViews();\n            } catch (IOException e) {\n                Log.w(\"MusicPicker\", \"Unable to play track\", e);\n            }\n        } else if (mMediaPlayer != null) {\n            stopMediaPlayer();\n            getListView().invalidateViews();\n        }\n    }\n    \n    public void onCompletion(MediaPlayer mp) {\n        if (mMediaPlayer == mp) {\n            mp.stop();\n            mp.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n            getListView().invalidateViews();\n        }\n    }\n    \n    void stopMediaPlayer() {\n        if (mMediaPlayer != null) {\n            mMediaPlayer.stop();\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n            mPlayingId = -1;\n        }\n    }\n    \n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.okayButton:\n                if (mSelectedId >= 0) {\n                    setResult(RESULT_OK, new Intent().setData(mSelectedUri));\n                    finish();\n                }\n                break;\n\n            case R.id.cancelButton:\n                finish();\n                break;\n        }\n    }\n}\n","lineNo":605}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.MusicUtils.ServiceToken;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n    private boolean mUseLastListPos = false;\n    private ServiceToken mToken;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        mToken = MusicUtils.bindToService(this, this);\n\n        // don't set the album art until after the view has been layed out\n        mTrackList.post(new Runnable() {\n\n            public void run() {\n                setAlbumArtBackground();\n            }\n        });\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            if (mUseLastListPos) {\n                mLastListPosCourse = lv.getFirstVisiblePosition();\n                View cv = lv.getChildAt(0);\n                if (cv != null) {\n                    mLastListPosFine = cv.getTop();\n                }\n            }\n            if (mEditMode) {\n                // clear the listeners so we won't get any more callbacks\n                ((TouchInterceptor) lv).setDropListener(null);\n                ((TouchInterceptor) lv).setRemoveListener(null);\n            }\n        }\n\n        MusicUtils.unbindFromService(mToken);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // If we have an adapter and didn't send it off to another activity yet, we should\n        // close its cursor, which we do by assigning a null cursor to it. Doing this\n        // instead of closing the cursor directly keeps the framework from accessing\n        // the closed cursor later.\n        if (!mAdapterSent && mAdapter != null) {\n            mAdapter.changeCursor(null);\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        mUseLastListPos = MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0 && mUseLastListPos) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setAlbumArtBackground() {\n        try {\n            long albumid = Long.valueOf(mAlbumId);\n            Bitmap bm = MusicUtils.getArtwork(TrackBrowserActivity.this, -1, albumid, false);\n            if (bm != null) {\n                MusicUtils.setBackground(mTrackList, bm);\n                mTrackList.setCacheColorHint(0);\n                return;\n            }\n        } catch (Exception ex) {\n        }\n        mTrackList.setBackgroundResource(0);\n        mTrackList.setCacheColorHint(0xff000000);\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaStore.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                MediaStore.Audio.Playlists.Members.moveItem(getContentResolver(),\n                        Long.valueOf(mPlaylist), from, to);\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        if (v == null) {\n            Log.d(LOGTAG, \"No view when removing playlist item \" + which);\n            return;\n        }\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                // The service could disappear while the broadcast was in flight,\n                // so check to see if it's still valid\n                if (MusicUtils.sService == null) {\n                    finish();\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaStore.UNKNOWN_STRING.equals(album) &&\n                MediaStore.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaStore.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                String key = MediaStore.Audio.keyFor(searchWords[i]);\n                key = key.replace(\"\\\\\", \"\\\\\\\\\");\n                key = key.replace(\"%\", \"\\\\%\");\n                key = key.replace(\"_\", \"\\\\_\");\n                keywords[i] = '%' + key + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ? ESCAPE '\\\\'\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null || newPosition >= mNowPlaying.length) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaStore.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (mActivity.isFinishing() && cursor != null) {\n                cursor.close();\n                cursor = null;\n            }\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1014}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.MediaStore;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\n\npublic class CreatePlaylist extends Activity\n{\n    private EditText mPlaylist;\n    private TextView mPrompt;\n    private Button mSaveButton;\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.create_playlist);\n        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT,\n                                    WindowManager.LayoutParams.WRAP_CONTENT);\n\n        mPrompt = (TextView)findViewById(R.id.prompt);\n        mPlaylist = (EditText)findViewById(R.id.playlist);\n        mSaveButton = (Button) findViewById(R.id.create);\n        mSaveButton.setOnClickListener(mOpenClicked);\n\n        ((Button)findViewById(R.id.cancel)).setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                finish();\n            }\n        });\n        \n        String defaultname = icicle != null ? icicle.getString(\"defaultname\") : makePlaylistName();\n        if (defaultname == null) {\n            finish();\n            return;\n        }\n        String promptformat = getString(R.string.create_playlist_create_text_prompt);\n        String prompt = String.format(promptformat, defaultname);\n        mPrompt.setText(prompt);\n        mPlaylist.setText(defaultname);\n        mPlaylist.setSelection(defaultname.length());\n        mPlaylist.addTextChangedListener(mTextWatcher);\n    }\n    \n    TextWatcher mTextWatcher = new TextWatcher() {\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n            // don't care about this one\n        }\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\n            // check if playlist with current name exists already, and warn the user if so.\n            if (idForplaylist(mPlaylist.getText().toString()) >= 0) {\n                mSaveButton.setText(R.string.create_playlist_overwrite_text);\n            } else {\n                mSaveButton.setText(R.string.create_playlist_create_text);\n            }\n        };\n        public void afterTextChanged(Editable s) {\n            // don't care about this one\n        }\n    };\n    \n    private int idForplaylist(String name) {\n        Cursor c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                new String[] { MediaStore.Audio.Playlists._ID },\n                MediaStore.Audio.Playlists.NAME + \"=?\",\n                new String[] { name },\n                MediaStore.Audio.Playlists.NAME);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            if (!c.isAfterLast()) {\n                id = c.getInt(0);\n            }\n        }\n        c.close();\n        return id;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        outcicle.putString(\"defaultname\", mPlaylist.getText().toString());\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    private String makePlaylistName() {\n\n        String template = getString(R.string.new_playlist_name_template);\n        int num = 1;\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = getContentResolver();\n        String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n        Cursor c = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n            cols, whereclause, null,\n            MediaStore.Audio.Playlists.NAME);\n\n        if (c == null) {\n            return null;\n        }\n        \n        String suggestedname;\n        suggestedname = String.format(template, num++);\n        \n        // Need to loop until we've made 1 full pass through without finding a match.\n        // Looping more than once shouldn't happen very often, but will happen if\n        // you have playlists named \"New Playlist 1\"/10/2/3/4/5/6/7/8/9, where\n        // making only one pass would result in \"New Playlist 10\" being erroneously\n        // picked for the new name.\n        boolean done = false;\n        while (!done) {\n            done = true;\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String playlistname = c.getString(0);\n                if (playlistname.compareToIgnoreCase(suggestedname) == 0) {\n                    suggestedname = String.format(template, num++);\n                    done = false;\n                }\n                c.moveToNext();\n            }\n        }\n        c.close();\n        return suggestedname;\n    }\n    \n    private View.OnClickListener mOpenClicked = new View.OnClickListener() {\n        public void onClick(View v) {\n            String name = mPlaylist.getText().toString();\n            if (name != null && name.length() > 0) {\n                ContentResolver resolver = getContentResolver();\n                int id = idForplaylist(name);\n                Uri uri;\n                if (id >= 0) {\n                    uri = ContentUris.withAppendedId(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, id);\n                    MusicUtils.clearPlaylist(CreatePlaylist.this, id);\n                } else {\n                    ContentValues values = new ContentValues(1);\n                    values.put(MediaStore.Audio.Playlists.NAME, name);\n                    uri = resolver.insert(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, values);\n                }\n                setResult(RESULT_OK, (new Intent()).setData(uri));\n                finish();\n            }\n        }\n    };\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.MediaStore;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\n\npublic class CreatePlaylist extends Activity\n{\n    private EditText mPlaylist;\n    private TextView mPrompt;\n    private Button mSaveButton;\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.create_playlist);\n        getWindow().setLayout(WindowManager.LayoutParams.MATCH_PARENT,\n                                    WindowManager.LayoutParams.WRAP_CONTENT);\n\n        mPrompt = (TextView)findViewById(R.id.prompt);\n        mPlaylist = (EditText)findViewById(R.id.playlist);\n        mSaveButton = (Button) findViewById(R.id.create);\n        mSaveButton.setOnClickListener(mOpenClicked);\n\n        ((Button)findViewById(R.id.cancel)).setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                finish();\n            }\n        });\n        \n        String defaultname = icicle != null ? icicle.getString(\"defaultname\") : makePlaylistName();\n        if (defaultname == null) {\n            finish();\n            return;\n        }\n        String promptformat = getString(R.string.create_playlist_create_text_prompt);\n        String prompt = String.format(promptformat, defaultname);\n        mPrompt.setText(prompt);\n        mPlaylist.setText(defaultname);\n        mPlaylist.setSelection(defaultname.length());\n        mPlaylist.addTextChangedListener(mTextWatcher);\n    }\n    \n    TextWatcher mTextWatcher = new TextWatcher() {\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n            // don't care about this one\n        }\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\n            String newText = mPlaylist.getText().toString();\n            if (newText.trim().length() == 0) {\n                mSaveButton.setEnabled(false);\n            } else {\n                mSaveButton.setEnabled(true);\n                // check if playlist with current name exists already, and warn the user if so.\n                if (idForplaylist(newText) >= 0) {\n                    mSaveButton.setText(R.string.create_playlist_overwrite_text);\n                } else {\n                    mSaveButton.setText(R.string.create_playlist_create_text);\n                }\n            }\n        };\n        public void afterTextChanged(Editable s) {\n            // don't care about this one\n        }\n    };\n    \n    private int idForplaylist(String name) {\n        Cursor c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                new String[] { MediaStore.Audio.Playlists._ID },\n                MediaStore.Audio.Playlists.NAME + \"=?\",\n                new String[] { name },\n                MediaStore.Audio.Playlists.NAME);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            if (!c.isAfterLast()) {\n                id = c.getInt(0);\n            }\n        }\n        c.close();\n        return id;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        outcicle.putString(\"defaultname\", mPlaylist.getText().toString());\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    private String makePlaylistName() {\n\n        String template = getString(R.string.new_playlist_name_template);\n        int num = 1;\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = getContentResolver();\n        String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n        Cursor c = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n            cols, whereclause, null,\n            MediaStore.Audio.Playlists.NAME);\n\n        if (c == null) {\n            return null;\n        }\n        \n        String suggestedname;\n        suggestedname = String.format(template, num++);\n        \n        // Need to loop until we've made 1 full pass through without finding a match.\n        // Looping more than once shouldn't happen very often, but will happen if\n        // you have playlists named \"New Playlist 1\"/10/2/3/4/5/6/7/8/9, where\n        // making only one pass would result in \"New Playlist 10\" being erroneously\n        // picked for the new name.\n        boolean done = false;\n        while (!done) {\n            done = true;\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String playlistname = c.getString(0);\n                if (playlistname.compareToIgnoreCase(suggestedname) == 0) {\n                    suggestedname = String.format(template, num++);\n                    done = false;\n                }\n                c.moveToNext();\n            }\n        }\n        c.close();\n        return suggestedname;\n    }\n    \n    private View.OnClickListener mOpenClicked = new View.OnClickListener() {\n        public void onClick(View v) {\n            String name = mPlaylist.getText().toString();\n            if (name != null && name.length() > 0) {\n                ContentResolver resolver = getContentResolver();\n                int id = idForplaylist(name);\n                Uri uri;\n                if (id >= 0) {\n                    uri = ContentUris.withAppendedId(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, id);\n                    MusicUtils.clearPlaylist(CreatePlaylist.this, id);\n                } else {\n                    ContentValues values = new ContentValues(1);\n                    values.put(MediaStore.Audio.Playlists.NAME, name);\n                    uri = resolver.insert(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, values);\n                }\n                setResult(RESULT_OK, (new Intent()).setData(uri));\n                finish();\n            }\n        }\n    };\n}\n","lineNo":83}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.ContextWrapper;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ColorMatrixColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.widget.TabWidget;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int QUEUE = 12;\n        public final static int CHILD_MENU_BASE = 13; // this should be the last item\n    }\n\n    public static String makeAlbumsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are two formats for the albums/songs information:\n        // \"N Song(s)\"  - used for unknown artist/album\n        // \"N Album(s)\" - used for known albums\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        Resources r = context.getResources();\n        if (isUnknown) {\n            if (numsongs == 1) {\n                songs_albums.append(context.getString(R.string.onesong));\n            } else {\n                String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numsongs));\n                songs_albums.append(sFormatBuilder);\n            }\n        } else {\n            String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numalbums));\n            songs_albums.append(sFormatBuilder);\n            songs_albums.append(context.getString(R.string.albumsongseparator));\n        }\n        return songs_albums.toString();\n    }\n\n    /**\n     * This is now only used for the query screen\n     */\n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static class ServiceToken {\n        ContextWrapper mWrappedContext;\n        ServiceToken(ContextWrapper context) {\n            mWrappedContext = context;\n        }\n    }\n\n    public static ServiceToken bindToService(Context context) {\n        return bindToService(context, null);\n    }\n\n    public static ServiceToken bindToService(Context context, ServiceConnection callback) {\n        ContextWrapper cw = new ContextWrapper(context);\n        cw.startService(new Intent(cw, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {\n            sConnectionMap.put(cw, sb);\n            return new ServiceToken(cw);\n        }\n        return null;\n    }\n\n    public static void unbindFromService(ServiceToken token) {\n        ContextWrapper cw = token.mWrappedContext;\n        ServiceBinder sb = sConnectionMap.remove(cw);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        cw.unbindService(sb);\n        if (sConnectionMap.isEmpty()) {\n            // presumably there is nobody interested in the service at this point,\n            // so don't hang on to the ServiceConnection\n            sService = null;\n        }\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static long getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    public static void togglePartyShuffle() {\n        if (sService != null) {\n            int shuffle = getCurrentShuffleMode();\n            try {\n                if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                } else {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n    \n    public static void setPartyShuffleMenuIcon(Menu menu) {\n        MenuItem item = menu.findItem(Defs.PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static long [] sEmptyList = new long[0];\n\n    public static long [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        long [] list = new long[len];\n        cursor.moveToFirst();\n        int colidx = -1;\n        try {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        } catch (IllegalArgumentException ex) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getLong(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static long [] getSongListForArtist(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForAlbum(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        long [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static long [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getLong(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        \n        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid);\n        context.getContentResolver().delete(uri, null, null);\n        return;\n    }\n    \n    public static void deleteTracks(Context context, long [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    long id = c.getLong(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    long artIndex = c.getLong(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, long [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private static ContentValues[] sContentValuesCache = null;\n\n    /**\n     * @param ids The source array containing all the ids to be added to the playlist\n     * @param offset Where in the 'ids' array we start reading\n     * @param len How many items to copy during this pass\n     * @param base The play order offset to use for this pass\n     */\n    private static void makeInsertItems(long[] ids, int offset, int len, int base) {\n        // adjust 'len' if would extend beyond the end of the source array\n        if (offset + len > ids.length) {\n            len = ids.length - offset;\n        }\n        // allocate the ContentValues array, or reallocate if it is the wrong size\n        if (sContentValuesCache == null || sContentValuesCache.length != len) {\n            sContentValuesCache = new ContentValues[len];\n        }\n        // fill in the ContentValues array with the right values for this pass\n        for (int i = 0; i < len; i++) {\n            if (sContentValuesCache[i] == null) {\n                sContentValuesCache[i] = new ContentValues();\n            }\n\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, base + offset + i);\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[offset + i]);\n        }\n    }\n    \n    public static void addToPlaylist(Context context, long [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n            int numinserted = 0;\n            for (int i = 0; i < size; i += 1000) {\n                makeInsertItems(ids, i, 1000, base);\n                numinserted += resolver.bulkInsert(uri, sContentValuesCache);\n            }\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, numinserted, numinserted);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder, int limit) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            if (limit > 0) {\n                uri = uri.buildUpon().appendQueryParameter(\"limit\", \"\" + limit).build();\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        return query(context, uri, projection, selection, selectionArgs, sortOrder, 0);\n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    private static String mLastSdStatus;\n\n    public static void displayDatabaseError(Activity a) {\n        if (a.isFinishing()) {\n            // When switching tabs really fast, we can end up with a null\n            // cursor (not sure why), which will bring us here.\n            // Don't bother showing an error message in that case.\n            return;\n        }\n\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED) ||\n                status.equals(Environment.MEDIA_UNMOUNTED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else if (!TextUtils.equals(mLastSdStatus, status)) {\n            mLastSdStatus = status;\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.buttonbar);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n    \n    public static void hideDatabaseError(Activity a) {\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(\n                secs < 3600 ? R.string.durationformatshort : R.string.durationformatlong);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, long [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        long [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, long [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            long curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                long [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, force_shuffle ? -1 : position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(context, MediaPlaybackActivity.class)\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Long, Drawable> sArtCache = new HashMap<Long, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, long artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, long album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel border on the right side in the ImageView\n        // used to display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 1;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        // Bitmap.createScaledBitmap() can return the same bitmap\n                        if (tmp != b) b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     * This method always returns the default album art icon when no album art is found.\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id) {\n        return getArtwork(context, song_id, album_id, true);\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id,\n            boolean allowdefault) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            if (song_id >= 0) {\n                Bitmap bm = getArtworkFromFile(context, song_id, -1);\n                if (bm != null) {\n                    return bm;\n                }\n            }\n            if (allowdefault) {\n                return getDefaultArtwork(context);\n            }\n            return null;\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, song_id, album_id);\n                if (bm != null) {\n                    if (bm.getConfig() == null) {\n                        bm = bm.copy(Bitmap.Config.RGB_565, false);\n                        if (bm == null && allowdefault) {\n                            return getDefaultArtwork(context);\n                        }\n                    }\n                } else if (allowdefault) {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, long songid, long albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (albumid < 0 && songid < 0) {\n            throw new IllegalArgumentException(\"Must specify an album or a song id\");\n        }\n\n        try {\n            if (albumid < 0) {\n                Uri uri = Uri.parse(\"content://media/external/audio/media/\" + songid + \"/albumart\");\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            } else {\n                Uri uri = ContentUris.withAppendedId(sArtworkUri, albumid);\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            }\n        } catch (FileNotFoundException ex) {\n            //\n        }\n        if (bm != null) {\n            mCachedBit = bm;\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n    \n    static int sActiveTabIndex = -1;\n    \n    static boolean updateButtonBar(Activity a, int highlight) {\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        boolean withtabs = false;\n        Intent intent = a.getIntent();\n        if (intent != null) {\n            withtabs = intent.getBooleanExtra(\"withtabs\", false);\n        }\n        \n        if (highlight == 0 || !withtabs) {\n            ll.setVisibility(View.GONE);\n            return withtabs;\n        } else if (withtabs) {\n            ll.setVisibility(View.VISIBLE);\n        }\n        for (int i = ll.getChildCount() - 1; i >= 0; i--) {\n            \n            View v = ll.getChildAt(i);\n            boolean isActive = (v.getId() == highlight);\n            if (isActive) {\n                ll.setCurrentTab(i);\n                sActiveTabIndex = i;\n            }\n            v.setTag(i);\n            v.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\n                public void onFocusChange(View v, boolean hasFocus) {\n                    if (hasFocus) {\n                        for (int i = 0; i < ll.getTabCount(); i++) {\n                            if (ll.getChildTabViewAt(i) == v) {\n                                ll.setCurrentTab(i);\n                                processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                                break;\n                            }\n                        }\n                    }\n                }});\n            \n            v.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                }});\n        }\n        return withtabs;\n    }\n\n    static void processTabClick(Activity a, View v, int current) {\n        int id = v.getId();\n        if (id == current) {\n            return;\n        }\n\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        ll.setCurrentTab((Integer) v.getTag());\n\n        activateTab(a, id);\n        if (id != R.id.nowplayingtab) {\n            setIntPref(a, \"activetab\", id);\n        }\n    }\n    \n    static void activateTab(Activity a, int id) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        switch (id) {\n            case R.id.artisttab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                break;\n            case R.id.albumtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                break;\n            case R.id.songtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                break;\n            case R.id.playlisttab:\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                break;\n            case R.id.nowplayingtab:\n                intent = new Intent(a, MediaPlaybackActivity.class);\n                a.startActivity(intent);\n                // fall through and return\n            default:\n                return;\n        }\n        intent.putExtra(\"withtabs\", true);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        a.startActivity(intent);\n        a.finish();\n        a.overridePendingTransition(0, 0);\n    }\n    \n    static void updateNowPlaying(Activity a) {\n        View nowPlayingView = a.findViewById(R.id.nowplaying);\n        if (nowPlayingView == null) {\n            return;\n        }\n        try {\n            boolean withtabs = false;\n            Intent intent = a.getIntent();\n            if (intent != null) {\n                withtabs = intent.getBooleanExtra(\"withtabs\", false);\n            }\n            if (true && MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                TextView title = (TextView) nowPlayingView.findViewById(R.id.title);\n                TextView artist = (TextView) nowPlayingView.findViewById(R.id.artist);\n                title.setText(MusicUtils.sService.getTrackName());\n                String artistName = MusicUtils.sService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = a.getString(R.string.unknown_artist_name);\n                }\n                artist.setText(artistName);\n                //mNowPlayingView.setOnFocusChangeListener(mFocuser);\n                //mNowPlayingView.setOnClickListener(this);\n                nowPlayingView.setVisibility(View.VISIBLE);\n                nowPlayingView.setOnClickListener(new View.OnClickListener() {\n\n                    public void onClick(View v) {\n                        Context c = v.getContext();\n                        c.startActivity(new Intent(c, MediaPlaybackActivity.class));\n                    }});\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        nowPlayingView.setVisibility(View.GONE);\n    }\n\n    static void setBackground(View v, Bitmap bm) {\n\n        if (bm == null) {\n            v.setBackgroundResource(0);\n            return;\n        }\n\n        int vwidth = v.getWidth();\n        int vheight = v.getHeight();\n        int bwidth = bm.getWidth();\n        int bheight = bm.getHeight();\n        float scalex = (float) vwidth / bwidth;\n        float scaley = (float) vheight / bheight;\n        float scale = Math.max(scalex, scaley) * 1.3f;\n\n        Bitmap.Config config = Bitmap.Config.ARGB_8888;\n        Bitmap bg = Bitmap.createBitmap(vwidth, vheight, config);\n        Canvas c = new Canvas(bg);\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        ColorMatrix greymatrix = new ColorMatrix();\n        greymatrix.setSaturation(0);\n        ColorMatrix darkmatrix = new ColorMatrix();\n        darkmatrix.setScale(.3f, .3f, .3f, 1.0f);\n        greymatrix.postConcat(darkmatrix);\n        ColorFilter filter = new ColorMatrixColorFilter(greymatrix);\n        paint.setColorFilter(filter);\n        Matrix matrix = new Matrix();\n        matrix.setTranslate(-bwidth/2, -bheight/2); // move bitmap center to origin\n        matrix.postRotate(10);\n        matrix.postScale(scale, scale);\n        matrix.postTranslate(vwidth/2, vheight/2);  // Move bitmap center to view center\n        c.drawBitmap(bm, matrix, paint);\n        v.setBackgroundDrawable(new BitmapDrawable(bg));\n    }\n\n    static int getCardId(Context context) {\n        ContentResolver res = context.getContentResolver();\n        Cursor c = res.query(Uri.parse(\"content://media/external/fs_id\"), null, null, null, null);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            id = c.getInt(0);\n            c.close();\n        }\n        return id;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.ContextWrapper;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ColorMatrixColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.widget.TabWidget;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int QUEUE = 12;\n        public final static int CHILD_MENU_BASE = 13; // this should be the last item\n    }\n\n    public static String makeAlbumsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are two formats for the albums/songs information:\n        // \"N Song(s)\"  - used for unknown artist/album\n        // \"N Album(s)\" - used for known albums\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        Resources r = context.getResources();\n        if (isUnknown) {\n            if (numsongs == 1) {\n                songs_albums.append(context.getString(R.string.onesong));\n            } else {\n                String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numsongs));\n                songs_albums.append(sFormatBuilder);\n            }\n        } else {\n            String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numalbums));\n            songs_albums.append(sFormatBuilder);\n            songs_albums.append(context.getString(R.string.albumsongseparator));\n        }\n        return songs_albums.toString();\n    }\n\n    /**\n     * This is now only used for the query screen\n     */\n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static class ServiceToken {\n        ContextWrapper mWrappedContext;\n        ServiceToken(ContextWrapper context) {\n            mWrappedContext = context;\n        }\n    }\n\n    public static ServiceToken bindToService(Activity context) {\n        return bindToService(context, null);\n    }\n\n    public static ServiceToken bindToService(Activity context, ServiceConnection callback) {\n        Activity realActivity = context.getParent();\n        if (realActivity == null) {\n            realActivity = context;\n        }\n        ContextWrapper cw = new ContextWrapper(realActivity);\n        cw.startService(new Intent(cw, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {\n            sConnectionMap.put(cw, sb);\n            return new ServiceToken(cw);\n        }\n        Log.e(\"Music\", \"Failed to bind to service\");\n        return null;\n    }\n\n    public static void unbindFromService(ServiceToken token) {\n        if (token == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind with null token\");\n            return;\n        }\n        ContextWrapper cw = token.mWrappedContext;\n        ServiceBinder sb = sConnectionMap.remove(cw);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        cw.unbindService(sb);\n        if (sConnectionMap.isEmpty()) {\n            // presumably there is nobody interested in the service at this point,\n            // so don't hang on to the ServiceConnection\n            sService = null;\n        }\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static long getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    public static void togglePartyShuffle() {\n        if (sService != null) {\n            int shuffle = getCurrentShuffleMode();\n            try {\n                if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                } else {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n    \n    public static void setPartyShuffleMenuIcon(Menu menu) {\n        MenuItem item = menu.findItem(Defs.PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static long [] sEmptyList = new long[0];\n\n    public static long [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        long [] list = new long[len];\n        cursor.moveToFirst();\n        int colidx = -1;\n        try {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        } catch (IllegalArgumentException ex) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getLong(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static long [] getSongListForArtist(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForAlbum(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        long [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static long [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getLong(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        \n        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid);\n        context.getContentResolver().delete(uri, null, null);\n        return;\n    }\n    \n    public static void deleteTracks(Context context, long [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    long id = c.getLong(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    long artIndex = c.getLong(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, long [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private static ContentValues[] sContentValuesCache = null;\n\n    /**\n     * @param ids The source array containing all the ids to be added to the playlist\n     * @param offset Where in the 'ids' array we start reading\n     * @param len How many items to copy during this pass\n     * @param base The play order offset to use for this pass\n     */\n    private static void makeInsertItems(long[] ids, int offset, int len, int base) {\n        // adjust 'len' if would extend beyond the end of the source array\n        if (offset + len > ids.length) {\n            len = ids.length - offset;\n        }\n        // allocate the ContentValues array, or reallocate if it is the wrong size\n        if (sContentValuesCache == null || sContentValuesCache.length != len) {\n            sContentValuesCache = new ContentValues[len];\n        }\n        // fill in the ContentValues array with the right values for this pass\n        for (int i = 0; i < len; i++) {\n            if (sContentValuesCache[i] == null) {\n                sContentValuesCache[i] = new ContentValues();\n            }\n\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, base + offset + i);\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[offset + i]);\n        }\n    }\n    \n    public static void addToPlaylist(Context context, long [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n            int numinserted = 0;\n            for (int i = 0; i < size; i += 1000) {\n                makeInsertItems(ids, i, 1000, base);\n                numinserted += resolver.bulkInsert(uri, sContentValuesCache);\n            }\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, numinserted, numinserted);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder, int limit) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            if (limit > 0) {\n                uri = uri.buildUpon().appendQueryParameter(\"limit\", \"\" + limit).build();\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        return query(context, uri, projection, selection, selectionArgs, sortOrder, 0);\n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    private static String mLastSdStatus;\n\n    public static void displayDatabaseError(Activity a) {\n        if (a.isFinishing()) {\n            // When switching tabs really fast, we can end up with a null\n            // cursor (not sure why), which will bring us here.\n            // Don't bother showing an error message in that case.\n            return;\n        }\n\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED) ||\n                status.equals(Environment.MEDIA_UNMOUNTED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else if (!TextUtils.equals(mLastSdStatus, status)) {\n            mLastSdStatus = status;\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.buttonbar);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n    \n    public static void hideDatabaseError(Activity a) {\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(\n                secs < 3600 ? R.string.durationformatshort : R.string.durationformatlong);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, long [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        long [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, long [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            long curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                long [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, force_shuffle ? -1 : position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(context, MediaPlaybackActivity.class)\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Long, Drawable> sArtCache = new HashMap<Long, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, long artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, long album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel border on the right side in the ImageView\n        // used to display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 1;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        // Bitmap.createScaledBitmap() can return the same bitmap\n                        if (tmp != b) b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     * This method always returns the default album art icon when no album art is found.\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id) {\n        return getArtwork(context, song_id, album_id, true);\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id,\n            boolean allowdefault) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            if (song_id >= 0) {\n                Bitmap bm = getArtworkFromFile(context, song_id, -1);\n                if (bm != null) {\n                    return bm;\n                }\n            }\n            if (allowdefault) {\n                return getDefaultArtwork(context);\n            }\n            return null;\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, song_id, album_id);\n                if (bm != null) {\n                    if (bm.getConfig() == null) {\n                        bm = bm.copy(Bitmap.Config.RGB_565, false);\n                        if (bm == null && allowdefault) {\n                            return getDefaultArtwork(context);\n                        }\n                    }\n                } else if (allowdefault) {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, long songid, long albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (albumid < 0 && songid < 0) {\n            throw new IllegalArgumentException(\"Must specify an album or a song id\");\n        }\n\n        try {\n            if (albumid < 0) {\n                Uri uri = Uri.parse(\"content://media/external/audio/media/\" + songid + \"/albumart\");\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            } else {\n                Uri uri = ContentUris.withAppendedId(sArtworkUri, albumid);\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            }\n        } catch (FileNotFoundException ex) {\n            //\n        }\n        if (bm != null) {\n            mCachedBit = bm;\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n    \n    static int sActiveTabIndex = -1;\n    \n    static boolean updateButtonBar(Activity a, int highlight) {\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        boolean withtabs = false;\n        Intent intent = a.getIntent();\n        if (intent != null) {\n            withtabs = intent.getBooleanExtra(\"withtabs\", false);\n        }\n        \n        if (highlight == 0 || !withtabs) {\n            ll.setVisibility(View.GONE);\n            return withtabs;\n        } else if (withtabs) {\n            ll.setVisibility(View.VISIBLE);\n        }\n        for (int i = ll.getChildCount() - 1; i >= 0; i--) {\n            \n            View v = ll.getChildAt(i);\n            boolean isActive = (v.getId() == highlight);\n            if (isActive) {\n                ll.setCurrentTab(i);\n                sActiveTabIndex = i;\n            }\n            v.setTag(i);\n            v.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\n                public void onFocusChange(View v, boolean hasFocus) {\n                    if (hasFocus) {\n                        for (int i = 0; i < ll.getTabCount(); i++) {\n                            if (ll.getChildTabViewAt(i) == v) {\n                                ll.setCurrentTab(i);\n                                processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                                break;\n                            }\n                        }\n                    }\n                }});\n            \n            v.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                }});\n        }\n        return withtabs;\n    }\n\n    static void processTabClick(Activity a, View v, int current) {\n        int id = v.getId();\n        if (id == current) {\n            return;\n        }\n\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        ll.setCurrentTab((Integer) v.getTag());\n\n        activateTab(a, id);\n        if (id != R.id.nowplayingtab) {\n            setIntPref(a, \"activetab\", id);\n        }\n    }\n    \n    static void activateTab(Activity a, int id) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        switch (id) {\n            case R.id.artisttab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                break;\n            case R.id.albumtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                break;\n            case R.id.songtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                break;\n            case R.id.playlisttab:\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                break;\n            case R.id.nowplayingtab:\n                intent = new Intent(a, MediaPlaybackActivity.class);\n                a.startActivity(intent);\n                // fall through and return\n            default:\n                return;\n        }\n        intent.putExtra(\"withtabs\", true);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        a.startActivity(intent);\n        a.finish();\n        a.overridePendingTransition(0, 0);\n    }\n    \n    static void updateNowPlaying(Activity a) {\n        View nowPlayingView = a.findViewById(R.id.nowplaying);\n        if (nowPlayingView == null) {\n            return;\n        }\n        try {\n            boolean withtabs = false;\n            Intent intent = a.getIntent();\n            if (intent != null) {\n                withtabs = intent.getBooleanExtra(\"withtabs\", false);\n            }\n            if (true && MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                TextView title = (TextView) nowPlayingView.findViewById(R.id.title);\n                TextView artist = (TextView) nowPlayingView.findViewById(R.id.artist);\n                title.setText(MusicUtils.sService.getTrackName());\n                String artistName = MusicUtils.sService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = a.getString(R.string.unknown_artist_name);\n                }\n                artist.setText(artistName);\n                //mNowPlayingView.setOnFocusChangeListener(mFocuser);\n                //mNowPlayingView.setOnClickListener(this);\n                nowPlayingView.setVisibility(View.VISIBLE);\n                nowPlayingView.setOnClickListener(new View.OnClickListener() {\n\n                    public void onClick(View v) {\n                        Context c = v.getContext();\n                        c.startActivity(new Intent(c, MediaPlaybackActivity.class));\n                    }});\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        nowPlayingView.setVisibility(View.GONE);\n    }\n\n    static void setBackground(View v, Bitmap bm) {\n\n        if (bm == null) {\n            v.setBackgroundResource(0);\n            return;\n        }\n\n        int vwidth = v.getWidth();\n        int vheight = v.getHeight();\n        int bwidth = bm.getWidth();\n        int bheight = bm.getHeight();\n        float scalex = (float) vwidth / bwidth;\n        float scaley = (float) vheight / bheight;\n        float scale = Math.max(scalex, scaley) * 1.3f;\n\n        Bitmap.Config config = Bitmap.Config.ARGB_8888;\n        Bitmap bg = Bitmap.createBitmap(vwidth, vheight, config);\n        Canvas c = new Canvas(bg);\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        ColorMatrix greymatrix = new ColorMatrix();\n        greymatrix.setSaturation(0);\n        ColorMatrix darkmatrix = new ColorMatrix();\n        darkmatrix.setScale(.3f, .3f, .3f, 1.0f);\n        greymatrix.postConcat(darkmatrix);\n        ColorFilter filter = new ColorMatrixColorFilter(greymatrix);\n        paint.setColorFilter(filter);\n        Matrix matrix = new Matrix();\n        matrix.setTranslate(-bwidth/2, -bheight/2); // move bitmap center to origin\n        matrix.postRotate(10);\n        matrix.postScale(scale, scale);\n        matrix.postTranslate(vwidth/2, vheight/2);  // Move bitmap center to view center\n        c.drawBitmap(bm, matrix, paint);\n        v.setBackgroundDrawable(new BitmapDrawable(bg));\n    }\n\n    static int getCardId(Context context) {\n        ContentResolver res = context.getContentResolver();\n        Cursor c = res.query(Uri.parse(\"content://media/external/fs_id\"), null, null, null, null);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            id = c.getInt(0);\n            c.close();\n        }\n        return id;\n    }\n}\n","lineNo":167}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ColorMatrixColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.widget.TabWidget;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int QUEUE = 12;\n        public final static int CHILD_MENU_BASE = 13; // this should be the last item\n    }\n\n    public static String makeAlbumsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are two formats for the albums/songs information:\n        // \"N Song(s)\"  - used for unknown artist/album\n        // \"N Album(s)\" - used for known albums\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        Resources r = context.getResources();\n        if (isUnknown) {\n            if (numsongs == 1) {\n                songs_albums.append(context.getString(R.string.onesong));\n            } else {\n                String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numsongs));\n                songs_albums.append(sFormatBuilder);\n            }\n        } else {\n            String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numalbums));\n            songs_albums.append(sFormatBuilder);\n            songs_albums.append(context.getString(R.string.albumsongseparator));\n        }\n        return songs_albums.toString();\n    }\n\n    /**\n     * This is now only used for the query screen\n     */\n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static boolean bindToService(Context context) {\n        return bindToService(context, null);\n    }\n\n    public static boolean bindToService(Context context, ServiceConnection callback) {\n        context.startService(new Intent(context, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        sConnectionMap.put(context, sb);\n        return context.bindService((new Intent()).setClass(context,\n                MediaPlaybackService.class), sb, 0);\n    }\n    \n    public static void unbindFromService(Context context) {\n        ServiceBinder sb = (ServiceBinder) sConnectionMap.remove(context);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        context.unbindService(sb);\n        if (sConnectionMap.isEmpty()) {\n            // presumably there is nobody interested in the service at this point,\n            // so don't hang on to the ServiceConnection\n            sService = null;\n        }\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static long getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    public static void togglePartyShuffle() {\n        if (sService != null) {\n            int shuffle = getCurrentShuffleMode();\n            try {\n                if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                } else {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n    \n    public static void setPartyShuffleMenuIcon(Menu menu) {\n        MenuItem item = menu.findItem(Defs.PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static long [] sEmptyList = new long[0];\n    \n    public static long [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        long [] list = new long[len];\n        cursor.moveToFirst();\n        int colidx = -1;\n        try {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        } catch (IllegalArgumentException ex) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getLong(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static long [] getSongListForArtist(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForAlbum(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        long [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static long [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getLong(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        \n        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid);\n        context.getContentResolver().delete(uri, null, null);\n        return;\n    }\n    \n    public static void deleteTracks(Context context, long [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    long id = c.getLong(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    long artIndex = c.getLong(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, long [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    public static void addToPlaylist(Context context, long [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentValues values [] = new ContentValues[size];\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n\n            for (int i = 0; i < size; i++) {\n                values[i] = new ContentValues();\n                values[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + i));\n                values[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[i]);\n            }\n            resolver.bulkInsert(uri, values);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, size, Integer.valueOf(size));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder, int limit) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            if (limit > 0) {\n                uri = uri.buildUpon().appendQueryParameter(\"limit\", \"\" + limit).build();\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        return query(context, uri, projection, selection, selectionArgs, sortOrder, 0);\n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    private static String mLastSdStatus;\n\n    public static void displayDatabaseError(Activity a) {\n        if (a.isFinishing()) {\n            // When switching tabs really fast, we can end up with a null\n            // cursor (not sure why), which will bring us here.\n            // Don't bother showing an error message in that case.\n            return;\n        }\n\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED) ||\n                status.equals(Environment.MEDIA_UNMOUNTED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else if (!TextUtils.equals(mLastSdStatus, status)) {\n            mLastSdStatus = status;\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.buttonbar);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n    \n    public static void hideDatabaseError(Activity a) {\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(\n                secs < 3600 ? R.string.durationformatshort : R.string.durationformatlong);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, long [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        long [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, long [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            long curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                long [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, force_shuffle ? -1 : position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(context, MediaPlaybackActivity.class)\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Long, Drawable> sArtCache = new HashMap<Long, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, long artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, long album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel border on the right side in the ImageView\n        // used to display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 1;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        // Bitmap.createScaledBitmap() can return the same bitmap\n                        if (tmp != b) b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     * This method always returns the default album art icon when no album art is found.\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id) {\n        return getArtwork(context, song_id, album_id, true);\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id,\n            boolean allowdefault) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            if (song_id >= 0) {\n                Bitmap bm = getArtworkFromFile(context, song_id, -1);\n                if (bm != null) {\n                    return bm;\n                }\n            }\n            if (allowdefault) {\n                return getDefaultArtwork(context);\n            }\n            return null;\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, song_id, album_id);\n                if (bm != null) {\n                    if (bm.getConfig() == null) {\n                        bm = bm.copy(Bitmap.Config.RGB_565, false);\n                        if (bm == null && allowdefault) {\n                            return getDefaultArtwork(context);\n                        }\n                    }\n                } else if (allowdefault) {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, long songid, long albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (albumid < 0 && songid < 0) {\n            throw new IllegalArgumentException(\"Must specify an album or a song id\");\n        }\n\n        try {\n            if (albumid < 0) {\n                Uri uri = Uri.parse(\"content://media/external/audio/media/\" + songid + \"/albumart\");\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            } else {\n                Uri uri = ContentUris.withAppendedId(sArtworkUri, albumid);\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            }\n        } catch (FileNotFoundException ex) {\n            //\n        }\n        if (bm != null) {\n            mCachedBit = bm;\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n    \n    static int sActiveTabIndex = -1;\n    \n    static boolean updateButtonBar(Activity a, int highlight) {\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        boolean withtabs = false;\n        Intent intent = a.getIntent();\n        if (intent != null) {\n            withtabs = intent.getBooleanExtra(\"withtabs\", false);\n        }\n        \n        if (highlight == 0 || !withtabs) {\n            ll.setVisibility(View.GONE);\n            return withtabs;\n        } else if (withtabs) {\n            ll.setVisibility(View.VISIBLE);\n        }\n        for (int i = ll.getChildCount() - 1; i >= 0; i--) {\n            \n            View v = ll.getChildAt(i);\n            boolean isActive = (v.getId() == highlight);\n            if (isActive) {\n                ll.setCurrentTab(i);\n                sActiveTabIndex = i;\n            }\n            v.setTag(i);\n            v.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\n                public void onFocusChange(View v, boolean hasFocus) {\n                    if (hasFocus) {\n                        for (int i = 0; i < ll.getTabCount(); i++) {\n                            if (ll.getChildTabViewAt(i) == v) {\n                                ll.setCurrentTab(i);\n                                processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                                break;\n                            }\n                        }\n                    }\n                }});\n            \n            v.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                }});\n        }\n        return withtabs;\n    }\n\n    static void processTabClick(Activity a, View v, int current) {\n        int id = v.getId();\n        if (id == current) {\n            return;\n        }\n\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        ll.setCurrentTab((Integer) v.getTag());\n\n        activateTab(a, id);\n        if (id != R.id.nowplayingtab) {\n            setIntPref(a, \"activetab\", id);\n        }\n    }\n    \n    static void activateTab(Activity a, int id) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        switch (id) {\n            case R.id.artisttab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                break;\n            case R.id.albumtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                break;\n            case R.id.songtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                break;\n            case R.id.playlisttab:\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                break;\n            case R.id.nowplayingtab:\n                intent = new Intent(a, MediaPlaybackActivity.class);\n                a.startActivity(intent);\n                // fall through and return\n            default:\n                return;\n        }\n        intent.putExtra(\"withtabs\", true);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        a.startActivity(intent);\n        a.finish();\n        a.overridePendingTransition(0, 0);\n    }\n    \n    static void updateNowPlaying(Activity a) {\n        View nowPlayingView = a.findViewById(R.id.nowplaying);\n        if (nowPlayingView == null) {\n            return;\n        }\n        try {\n            boolean withtabs = false;\n            Intent intent = a.getIntent();\n            if (intent != null) {\n                withtabs = intent.getBooleanExtra(\"withtabs\", false);\n            }\n            if (true && MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                TextView title = (TextView) nowPlayingView.findViewById(R.id.title);\n                TextView artist = (TextView) nowPlayingView.findViewById(R.id.artist);\n                title.setText(MusicUtils.sService.getTrackName());\n                String artistName = MusicUtils.sService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = a.getString(R.string.unknown_artist_name);\n                }\n                artist.setText(artistName);\n                //mNowPlayingView.setOnFocusChangeListener(mFocuser);\n                //mNowPlayingView.setOnClickListener(this);\n                nowPlayingView.setVisibility(View.VISIBLE);\n                nowPlayingView.setOnClickListener(new View.OnClickListener() {\n\n                    public void onClick(View v) {\n                        Context c = v.getContext();\n                        c.startActivity(new Intent(c, MediaPlaybackActivity.class));\n                    }});\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        nowPlayingView.setVisibility(View.GONE);\n    }\n\n    static void setBackground(View v, Bitmap bm) {\n\n        if (bm == null) {\n            v.setBackgroundResource(0);\n            return;\n        }\n\n        int vwidth = v.getWidth();\n        int vheight = v.getHeight();\n        int bwidth = bm.getWidth();\n        int bheight = bm.getHeight();\n        float scalex = (float) vwidth / bwidth;\n        float scaley = (float) vheight / bheight;\n        float scale = Math.max(scalex, scaley) * 1.3f;\n\n        Bitmap.Config config = Bitmap.Config.ARGB_8888;\n        Bitmap bg = Bitmap.createBitmap(vwidth, vheight, config);\n        Canvas c = new Canvas(bg);\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        ColorMatrix greymatrix = new ColorMatrix();\n        greymatrix.setSaturation(0);\n        ColorMatrix darkmatrix = new ColorMatrix();\n        darkmatrix.setScale(.3f, .3f, .3f, 1.0f);\n        greymatrix.postConcat(darkmatrix);\n        ColorFilter filter = new ColorMatrixColorFilter(greymatrix);\n        paint.setColorFilter(filter);\n        Matrix matrix = new Matrix();\n        matrix.setTranslate(-bwidth/2, -bheight/2); // move bitmap center to origin\n        matrix.postRotate(10);\n        matrix.postScale(scale, scale);\n        matrix.postTranslate(vwidth/2, vheight/2);  // Move bitmap center to view center\n        c.drawBitmap(bm, matrix, paint);\n        v.setBackgroundDrawable(new BitmapDrawable(bg));\n    }\n\n    static int getCardId(Context context) {\n        ContentResolver res = context.getContentResolver();\n        Cursor c = res.query(Uri.parse(\"content://media/external/fs_id\"), null, null, null, null);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            id = c.getInt(0);\n            c.close();\n        }\n        return id;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.ContextWrapper;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ColorMatrixColorFilter;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.widget.TabWidget;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int QUEUE = 12;\n        public final static int CHILD_MENU_BASE = 13; // this should be the last item\n    }\n\n    public static String makeAlbumsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are two formats for the albums/songs information:\n        // \"N Song(s)\"  - used for unknown artist/album\n        // \"N Album(s)\" - used for known albums\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        Resources r = context.getResources();\n        if (isUnknown) {\n            if (numsongs == 1) {\n                songs_albums.append(context.getString(R.string.onesong));\n            } else {\n                String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numsongs));\n                songs_albums.append(sFormatBuilder);\n            }\n        } else {\n            String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numalbums));\n            songs_albums.append(sFormatBuilder);\n            songs_albums.append(context.getString(R.string.albumsongseparator));\n        }\n        return songs_albums.toString();\n    }\n\n    /**\n     * This is now only used for the query screen\n     */\n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static class ServiceToken {\n        ContextWrapper mWrappedContext;\n        ServiceToken(ContextWrapper context) {\n            mWrappedContext = context;\n        }\n    }\n\n    public static ServiceToken bindToService(Context context) {\n        return bindToService(context, null);\n    }\n\n    public static ServiceToken bindToService(Context context, ServiceConnection callback) {\n        ContextWrapper cw = new ContextWrapper(context);\n        cw.startService(new Intent(cw, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {\n            sConnectionMap.put(cw, sb);\n            return new ServiceToken(cw);\n        }\n        return null;\n    }\n\n    public static void unbindFromService(ServiceToken token) {\n        ContextWrapper cw = token.mWrappedContext;\n        ServiceBinder sb = sConnectionMap.remove(cw);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        cw.unbindService(sb);\n        if (sConnectionMap.isEmpty()) {\n            // presumably there is nobody interested in the service at this point,\n            // so don't hang on to the ServiceConnection\n            sService = null;\n        }\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static long getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static long getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    public static void togglePartyShuffle() {\n        if (sService != null) {\n            int shuffle = getCurrentShuffleMode();\n            try {\n                if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                } else {\n                    sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n    \n    public static void setPartyShuffleMenuIcon(Menu menu) {\n        MenuItem item = menu.findItem(Defs.PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static long [] sEmptyList = new long[0];\n\n    public static long [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        long [] list = new long[len];\n        cursor.moveToFirst();\n        int colidx = -1;\n        try {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        } catch (IllegalArgumentException ex) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getLong(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static long [] getSongListForArtist(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForAlbum(Context context, long id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static long [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            long [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        long [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static long [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getLong(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getLong(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        \n        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid);\n        context.getContentResolver().delete(uri, null, null);\n        return;\n    }\n    \n    public static void deleteTracks(Context context, long [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    long id = c.getLong(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    long artIndex = c.getLong(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, long [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private static ContentValues[] sContentValuesCache = null;\n\n    /**\n     * @param ids The source array containing all the ids to be added to the playlist\n     * @param offset Where in the 'ids' array we start reading\n     * @param len How many items to copy during this pass\n     * @param base The play order offset to use for this pass\n     */\n    private static void makeInsertItems(long[] ids, int offset, int len, int base) {\n        // adjust 'len' if would extend beyond the end of the source array\n        if (offset + len > ids.length) {\n            len = ids.length - offset;\n        }\n        // allocate the ContentValues array, or reallocate if it is the wrong size\n        if (sContentValuesCache == null || sContentValuesCache.length != len) {\n            sContentValuesCache = new ContentValues[len];\n        }\n        // fill in the ContentValues array with the right values for this pass\n        for (int i = 0; i < len; i++) {\n            if (sContentValuesCache[i] == null) {\n                sContentValuesCache[i] = new ContentValues();\n            }\n\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, base + offset + i);\n            sContentValuesCache[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[offset + i]);\n        }\n    }\n    \n    public static void addToPlaylist(Context context, long [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n            int numinserted = 0;\n            for (int i = 0; i < size; i += 1000) {\n                makeInsertItems(ids, i, 1000, base);\n                numinserted += resolver.bulkInsert(uri, sContentValuesCache);\n            }\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, numinserted, numinserted);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder, int limit) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            if (limit > 0) {\n                uri = uri.buildUpon().appendQueryParameter(\"limit\", \"\" + limit).build();\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        return query(context, uri, projection, selection, selectionArgs, sortOrder, 0);\n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    private static String mLastSdStatus;\n\n    public static void displayDatabaseError(Activity a) {\n        if (a.isFinishing()) {\n            // When switching tabs really fast, we can end up with a null\n            // cursor (not sure why), which will bring us here.\n            // Don't bother showing an error message in that case.\n            return;\n        }\n\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED) ||\n                status.equals(Environment.MEDIA_UNMOUNTED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else if (!TextUtils.equals(mLastSdStatus, status)) {\n            mLastSdStatus = status;\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.buttonbar);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n    \n    public static void hideDatabaseError(Activity a) {\n        View v = a.findViewById(R.id.sd_message);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(R.id.sd_icon);\n        if (v != null) {\n            v.setVisibility(View.GONE);\n        }\n        v = a.findViewById(android.R.id.list);\n        if (v != null) {\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(\n                secs < 3600 ? R.string.durationformatshort : R.string.durationformatlong);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, long [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        long [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, long [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            long curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                long [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, force_shuffle ? -1 : position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(context, MediaPlaybackActivity.class)\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Long, Drawable> sArtCache = new HashMap<Long, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, long artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, long album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel border on the right side in the ImageView\n        // used to display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 1;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        // Bitmap.createScaledBitmap() can return the same bitmap\n                        if (tmp != b) b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     * This method always returns the default album art icon when no album art is found.\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id) {\n        return getArtwork(context, song_id, album_id, true);\n    }\n\n    /** Get album art for specified album. You should not pass in the album id\n     * for the \"unknown\" album here (use -1 instead)\n     */\n    public static Bitmap getArtwork(Context context, long song_id, long album_id,\n            boolean allowdefault) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            if (song_id >= 0) {\n                Bitmap bm = getArtworkFromFile(context, song_id, -1);\n                if (bm != null) {\n                    return bm;\n                }\n            }\n            if (allowdefault) {\n                return getDefaultArtwork(context);\n            }\n            return null;\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, song_id, album_id);\n                if (bm != null) {\n                    if (bm.getConfig() == null) {\n                        bm = bm.copy(Bitmap.Config.RGB_565, false);\n                        if (bm == null && allowdefault) {\n                            return getDefaultArtwork(context);\n                        }\n                    }\n                } else if (allowdefault) {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, long songid, long albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (albumid < 0 && songid < 0) {\n            throw new IllegalArgumentException(\"Must specify an album or a song id\");\n        }\n\n        try {\n            if (albumid < 0) {\n                Uri uri = Uri.parse(\"content://media/external/audio/media/\" + songid + \"/albumart\");\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            } else {\n                Uri uri = ContentUris.withAppendedId(sArtworkUri, albumid);\n                ParcelFileDescriptor pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                if (pfd != null) {\n                    FileDescriptor fd = pfd.getFileDescriptor();\n                    bm = BitmapFactory.decodeFileDescriptor(fd);\n                }\n            }\n        } catch (FileNotFoundException ex) {\n            //\n        }\n        if (bm != null) {\n            mCachedBit = bm;\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n    \n    static int sActiveTabIndex = -1;\n    \n    static boolean updateButtonBar(Activity a, int highlight) {\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        boolean withtabs = false;\n        Intent intent = a.getIntent();\n        if (intent != null) {\n            withtabs = intent.getBooleanExtra(\"withtabs\", false);\n        }\n        \n        if (highlight == 0 || !withtabs) {\n            ll.setVisibility(View.GONE);\n            return withtabs;\n        } else if (withtabs) {\n            ll.setVisibility(View.VISIBLE);\n        }\n        for (int i = ll.getChildCount() - 1; i >= 0; i--) {\n            \n            View v = ll.getChildAt(i);\n            boolean isActive = (v.getId() == highlight);\n            if (isActive) {\n                ll.setCurrentTab(i);\n                sActiveTabIndex = i;\n            }\n            v.setTag(i);\n            v.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\n                public void onFocusChange(View v, boolean hasFocus) {\n                    if (hasFocus) {\n                        for (int i = 0; i < ll.getTabCount(); i++) {\n                            if (ll.getChildTabViewAt(i) == v) {\n                                ll.setCurrentTab(i);\n                                processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                                break;\n                            }\n                        }\n                    }\n                }});\n            \n            v.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    processTabClick((Activity)ll.getContext(), v, ll.getChildAt(sActiveTabIndex).getId());\n                }});\n        }\n        return withtabs;\n    }\n\n    static void processTabClick(Activity a, View v, int current) {\n        int id = v.getId();\n        if (id == current) {\n            return;\n        }\n\n        final TabWidget ll = (TabWidget) a.findViewById(R.id.buttonbar);\n        ll.setCurrentTab((Integer) v.getTag());\n\n        activateTab(a, id);\n        if (id != R.id.nowplayingtab) {\n            setIntPref(a, \"activetab\", id);\n        }\n    }\n    \n    static void activateTab(Activity a, int id) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        switch (id) {\n            case R.id.artisttab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                break;\n            case R.id.albumtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                break;\n            case R.id.songtab:\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                break;\n            case R.id.playlisttab:\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                break;\n            case R.id.nowplayingtab:\n                intent = new Intent(a, MediaPlaybackActivity.class);\n                a.startActivity(intent);\n                // fall through and return\n            default:\n                return;\n        }\n        intent.putExtra(\"withtabs\", true);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        a.startActivity(intent);\n        a.finish();\n        a.overridePendingTransition(0, 0);\n    }\n    \n    static void updateNowPlaying(Activity a) {\n        View nowPlayingView = a.findViewById(R.id.nowplaying);\n        if (nowPlayingView == null) {\n            return;\n        }\n        try {\n            boolean withtabs = false;\n            Intent intent = a.getIntent();\n            if (intent != null) {\n                withtabs = intent.getBooleanExtra(\"withtabs\", false);\n            }\n            if (true && MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                TextView title = (TextView) nowPlayingView.findViewById(R.id.title);\n                TextView artist = (TextView) nowPlayingView.findViewById(R.id.artist);\n                title.setText(MusicUtils.sService.getTrackName());\n                String artistName = MusicUtils.sService.getArtistName();\n                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = a.getString(R.string.unknown_artist_name);\n                }\n                artist.setText(artistName);\n                //mNowPlayingView.setOnFocusChangeListener(mFocuser);\n                //mNowPlayingView.setOnClickListener(this);\n                nowPlayingView.setVisibility(View.VISIBLE);\n                nowPlayingView.setOnClickListener(new View.OnClickListener() {\n\n                    public void onClick(View v) {\n                        Context c = v.getContext();\n                        c.startActivity(new Intent(c, MediaPlaybackActivity.class));\n                    }});\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        nowPlayingView.setVisibility(View.GONE);\n    }\n\n    static void setBackground(View v, Bitmap bm) {\n\n        if (bm == null) {\n            v.setBackgroundResource(0);\n            return;\n        }\n\n        int vwidth = v.getWidth();\n        int vheight = v.getHeight();\n        int bwidth = bm.getWidth();\n        int bheight = bm.getHeight();\n        float scalex = (float) vwidth / bwidth;\n        float scaley = (float) vheight / bheight;\n        float scale = Math.max(scalex, scaley) * 1.3f;\n\n        Bitmap.Config config = Bitmap.Config.ARGB_8888;\n        Bitmap bg = Bitmap.createBitmap(vwidth, vheight, config);\n        Canvas c = new Canvas(bg);\n        Paint paint = new Paint();\n        paint.setAntiAlias(true);\n        paint.setFilterBitmap(true);\n        ColorMatrix greymatrix = new ColorMatrix();\n        greymatrix.setSaturation(0);\n        ColorMatrix darkmatrix = new ColorMatrix();\n        darkmatrix.setScale(.3f, .3f, .3f, 1.0f);\n        greymatrix.postConcat(darkmatrix);\n        ColorFilter filter = new ColorMatrixColorFilter(greymatrix);\n        paint.setColorFilter(filter);\n        Matrix matrix = new Matrix();\n        matrix.setTranslate(-bwidth/2, -bheight/2); // move bitmap center to origin\n        matrix.postRotate(10);\n        matrix.postScale(scale, scale);\n        matrix.postTranslate(vwidth/2, vheight/2);  // Move bitmap center to view center\n        c.drawBitmap(bm, matrix, paint);\n        v.setBackgroundDrawable(new BitmapDrawable(bg));\n    }\n\n    static int getCardId(Context context) {\n        ContentResolver res = context.getContentResolver();\n        Cursor c = res.query(Uri.parse(\"content://media/external/fs_id\"), null, null, null, null);\n        int id = -1;\n        if (c != null) {\n            c.moveToFirst();\n            id = c.getInt(0);\n            c.close();\n        }\n        return id;\n    }\n}\n","lineNo":167}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            mLastListPosFine = lv.getChildAt(0).getTop();\n        }\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaFile.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaFile.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            MusicUtils.updateNowPlaying(AlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.albumtab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(\n                    mAlbumCursor.getColumnIndex(MediaStore.Audio.Albums.ARTIST));\n            if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                mCurrentArtistNameForAlbum.equals(MediaFile.UNKNOWN_STRING);\n        mIsUnknownAlbum = mCurrentAlbumName == null ||\n                mCurrentAlbumName.equals(MediaFile.UNKNOWN_STRING);\n        if (mIsUnknownAlbum) {\n            menu.setHeaderTitle(getString(R.string.unknown_album_name));\n        } else {\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n        if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = \"\";\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = \"\";\n        if (!mIsUnknownAlbum) {\n            query = mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            title = mCurrentAlbumName;\n        }\n        if(!mIsUnknownArtist) {\n            query = query + \" \" + mCurrentArtistNameForAlbum;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            title = title + \" \" + mCurrentArtistNameForAlbum;\n        }\n        // Since we hide the 'search' menu item when both album and artist are\n        // unknown, the query and title strings will have at least one of those.\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(context.getResources(), b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            long aid = cursor.getLong(0);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                Drawable d = MusicUtils.getCachedArtwork(context, aid, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":159}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public void onTabClick(View v) {\n        MusicUtils.processTabClick(this, v, R.id.artisttab);\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            mLastListPosFine = lv.getChildAt(0).getTop();\n        }\n        \n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaFile.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaFile.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaFile.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaFile.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaFile.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaFile.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    boolean mIsUnknownArtist;\n    boolean mIsUnknownAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public void onTabClick(View v) {\n        MusicUtils.processTabClick(this, v, R.id.artisttab);\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this, this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        ExpandableListView lv = getExpandableListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        ExpandableListView lv = getExpandableListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        \n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        setListAdapter(null);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n            MusicUtils.updateNowPlaying(ArtistAlbumBrowserActivity.this);\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            ExpandableListView elv = getExpandableListView();\n            elv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.artisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album == null || album.equals(MediaFile.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            mIsUnknownArtist = mCurrentArtistName == null ||\n                    mCurrentArtistName.equals(MediaFile.UNKNOWN_STRING);\n            mIsUnknownAlbum = true;\n            if (mIsUnknownArtist) {\n                menu.setHeaderTitle(getString(R.string.unknown_artist_name));\n            } else {\n                menu.setHeaderTitle(mCurrentArtistName);\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mIsUnknownArtist = mCurrentArtistNameForAlbum == null ||\n                    mCurrentArtistNameForAlbum.equals(MediaFile.UNKNOWN_STRING);\n            mIsUnknownAlbum = mCurrentAlbumName == null ||\n                    mCurrentAlbumName.equals(MediaFile.UNKNOWN_STRING);\n            if (mIsUnknownAlbum) {\n                menu.setHeaderTitle(getString(R.string.unknown_album_name));\n            } else {\n                menu.setHeaderTitle(mCurrentAlbumName);\n            }\n            if (!mIsUnknownAlbum || !mIsUnknownArtist) {\n                menu.add(0, SEARCH, 0, R.string.search_title);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                long [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            if (mIsUnknownAlbum) {\n                title = query = mCurrentArtistNameForAlbum;\n            } else {\n                title = query = mCurrentAlbumName;\n                if (!mIsUnknownArtist) {\n                    query = query + \" \" + mCurrentArtistNameForAlbum;\n                }\n            }\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Long.parseLong(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Long.parseLong(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Long.parseLong(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = artist == null || artist.equals(MediaFile.UNKNOWN_STRING);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            long currentartistid = MusicUtils.getCurrentArtistId();\n            long artistid = cursor.getLong(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name == null || name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                long artIndex = cursor.getLong(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            long currentalbumid = MusicUtils.getCurrentAlbumId();\n            long aid = cursor.getLong(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            long id = groupCursor.getLong(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (mArtistName == null || mArtistName.equals(MediaFile.UNKNOWN_STRING)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (MediaStore.Audio.Albums.ARTIST.equals(name)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        MusicUtils.updateNowPlaying(this);\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        finish();\n    }\n}\n\n","lineNo":165}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\n\nimport com.android.internal.database.ArrayListCursor;\n\nimport android.database.Cursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    private boolean mCreateShortcut;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    long id = Long.parseLong(intent.getExtras().getString(\"playlist\"));\n                    if (id == RECENTLY_ADDED_PLAYLIST) {\n                        playRecentlyAdded();\n                    } else if (id == PODCASTS_PLAYLIST) {\n                        playPodcasts();\n                    } else if (id == ALL_SONGS_PLAYLIST) {\n                        long [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                        if (list != null) {\n                            MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                        }\n                    } else {\n                        MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                    }\n                    finish();\n                    return;\n                }\n                MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            mLastListPosFine = lv.getChildAt(0).getTop();\n        }\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }        \n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n        MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n    public void init(Cursor cursor) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else if (mAdapter != null) {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.ic_launcher_shortcut_music_playlist));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        ArrayList<ArrayList> autoplaylists = new ArrayList<ArrayList>();\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylists.add(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylists.add(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylists.add(podcasts);\n            }\n        }\n\n        ArrayListCursor autoplaylistscursor = new ArrayListCursor(mCols, autoplaylists);\n        \n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getPlaylistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\n\nimport com.android.internal.database.ArrayListCursor;\n\nimport android.database.Cursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    private boolean mCreateShortcut;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    long id = Long.parseLong(intent.getExtras().getString(\"playlist\"));\n                    if (id == RECENTLY_ADDED_PLAYLIST) {\n                        playRecentlyAdded();\n                    } else if (id == PODCASTS_PLAYLIST) {\n                        playPodcasts();\n                    } else if (id == ALL_SONGS_PLAYLIST) {\n                        long [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                        if (list != null) {\n                            MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                        }\n                    } else {\n                        MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                    }\n                    finish();\n                    return;\n                }\n                MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }        \n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n        MusicUtils.updateNowPlaying(PlaylistBrowserActivity.this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    };\n    public void init(Cursor cursor) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // restore previous position\n        if (mLastListPosCourse >= 0) {\n            getListView().setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            mLastListPosCourse = -1;\n        }\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.playlisttab);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else if (mAdapter != null) {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.ic_launcher_shortcut_music_playlist));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            long [] list = new long[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getLong(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        ArrayList<ArrayList> autoplaylists = new ArrayList<ArrayList>();\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylists.add(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylists.add(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylists.add(podcasts);\n            }\n        }\n\n        ArrayListCursor autoplaylistscursor = new ArrayListCursor(mCols, autoplaylists);\n        \n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getPlaylistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","lineNo":180}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            mLastListPosFine = lv.getChildAt(0).getTop();\n        }\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaFile.UNKNOWN_STRING.equals(album) &&\n                MediaFile.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaFile.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaFile.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n    private static int mLastListPosCourse = -1;\n    private static int mLastListPosFine = -1;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        Intent intent = getIntent();\n        if (intent != null) {\n            if (intent.getBooleanExtra(\"withtabs\", false)) {\n                requestWindowFeature(Window.FEATURE_NO_TITLE);\n            }\n        }\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = intent.getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        MusicUtils.updateButtonBar(this, R.id.songtab);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor, false);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n        if (!mEditMode) {\n            MusicUtils.updateNowPlaying(this);\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        ListView lv = getListView();\n        if (lv != null) {\n            mLastListPosCourse = lv.getFirstVisiblePosition();\n            View cv = lv.getChildAt(0);\n            if (cv != null) {\n                mLastListPosFine = cv.getTop();\n            }\n        }\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        // Because we pass the adapter to the next activity, we need to make\n        // sure it doesn't keep a reference to this activity. We can do this\n        // by clearing its DatasetObservers, which setListAdapter(null) does.\n        setListAdapter(null);\n        mAdapter = null;\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            if (mAdapter != null) {\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor, boolean isLimited) {\n\n        if (mAdapter == null) {\n            return;\n        }\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        // Restore previous position\n        if (mLastListPosCourse >= 0) {\n            ListView lv = getListView();\n            // this hack is needed because otherwise the position doesn't change\n            // for the 2nd (non-limited) cursor\n            lv.setAdapter(lv.getAdapter());\n            lv.setSelectionFromTop(mLastListPosCourse, mLastListPosFine);\n            if (!isLimited) {\n                mLastListPosCourse = -1;\n            }\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        MusicUtils.updateButtonBar(this, R.id.songtab);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n            if (!mEditMode) {\n                MusicUtils.updateNowPlaying(TrackBrowserActivity.this);\n            }\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaFile.UNKNOWN_STRING.equals(album) &&\n                MediaFile.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentTrackName;\n        if (MediaFile.UNKNOWN_STRING.equals(mCurrentArtistNameForAlbum)) {\n            query = mCurrentTrackName;\n        } else {\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentTrackName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        }\n        if (MediaFile.UNKNOWN_STRING.equals(mCurrentAlbumName)) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        // When selecting a track from the queue, just jump there instead of\n        // reloading the queue. This is both faster, and prevents accidentally\n        // dropping out of party shuffle.\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            if (MusicUtils.sService != null) {\n                try {\n                    MusicUtils.sService.setQueuePosition(position);\n                    return;\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MusicUtils.setPartyShuffleMenuIcon(menu);\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case PARTY_SHUFFLE:\n                MusicUtils.togglePartyShuffle();\n                break;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret, false);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor, cookie != null);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":239}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mDeviceHasNoDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasNoDpad = (getResources().getConfiguration().navigation != \n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n        } catch (RemoteException ex) {\n            return true;\n        }\n        \n        boolean knownartist =\n            (artist != null) && !MediaFile.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaFile.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0 && !mOneShot) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", getString(R.string.delete_song_desc,\n                                mService.getTrackName()));\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                if (! ContentResolver.SCHEME_CONTENT.equals(scheme) ||\n                        ! MediaStore.AUTHORITY.equals(uri.getAuthority())) {\n                    mOneShot = true;\n                }\n                mService.stop();\n                mService.openFile(filename, mOneShot);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.KeyguardManager;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mDeviceHasDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasDpad = (getResources().getConfiguration().navigation ==\n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        long audioid;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n            audioid = mService.getAudioId();\n        } catch (RemoteException ex) {\n            return true;\n        }\n\n        if (MediaFile.UNKNOWN_STRING.equals(album) &&\n                MediaFile.UNKNOWN_STRING.equals(artist) &&\n                song != null &&\n                song.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        if (audioid < 0) {\n            return false;\n        }\n\n        Cursor c = MusicUtils.query(this,\n                ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, audioid),\n                new String[] {MediaStore.Audio.Media.IS_MUSIC}, null, null, null);\n        boolean ismusic = true;\n        if (c != null) {\n            if (c.moveToFirst()) {\n                ismusic = c.getInt(0) != 0;\n            }\n            c.close();\n        }\n        if (!ismusic) {\n            return false;\n        }\n\n        boolean knownartist =\n            (artist != null) && !MediaFile.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaFile.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0 && !mOneShot) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            // these next two are in a separate group, so they can be shown/hidden as needed\n            // based on the keyguard state\n            menu.add(1, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short)\n                    .setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(1, DELETE_ITEM, 0, R.string.delete_item)\n                    .setIcon(R.drawable.ic_menu_delete);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);\n        menu.setGroupVisible(1, !km.inKeyguardRestrictedInputMode());\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        long [] list = new long[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", getString(R.string.delete_song_desc,\n                                mService.getTrackName()));\n                        b.putLongArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    long [] list = new long[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (!useDpadMusicControl()) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    private boolean useDpadMusicControl() {\n        if (mDeviceHasDpad && (mPrevButton.isFocused() ||\n                mNextButton.isFocused() ||\n                mPauseButton.isFocused())) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (!useDpadMusicControl()) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                if (! ContentResolver.SCHEME_CONTENT.equals(scheme) ||\n                        ! MediaStore.AUTHORITY.equals(uri.getAuthority())) {\n                    mOneShot = true;\n                }\n                mService.stop();\n                mService.openFile(filename, mOneShot);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private static class AlbumSongIdWrapper {\n        public long albumid;\n        public long songid;\n        AlbumSongIdWrapper(long aid, long sid) {\n            albumid = aid;\n            songid = sid;\n        }\n    }\n    \n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            long songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(-1, -1)).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                long albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, new AlbumSongIdWrapper(albumid, songid)).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private long mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg)\n        {\n            long albumid = ((AlbumSongIdWrapper) msg.obj).albumid;\n            long songid = ((AlbumSongIdWrapper) msg.obj).songid;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":1280}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor) {\n\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaFile.UNKNOWN_STRING.equals(album) &&\n                MediaFile.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    startQuery(0, null, uri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor);\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private static final int Q_SELECTED = CHILD_MENU_BASE;\n    private static final int Q_ALL = CHILD_MENU_BASE + 1;\n    private static final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private static final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private static final int REMOVE = CHILD_MENU_BASE + 5;\n    private static final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID,\n                MediaStore.Audio.Media.IS_MUSIC\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            }\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiverSafe(mNowPlayingListener);\n            } else {\n                unregisterReceiverSafe(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiverSafe(mScanListener);\n        super.onDestroy();\n    }\n    \n    /**\n     * Unregister a receiver, but eat the exception that is thrown if the\n     * receiver was never registered to begin with. This is a little easier\n     * than keeping track of whether the receivers have actually been\n     * registered by the time onDestroy() is called.\n     */\n    private void unregisterReceiverSafe(BroadcastReceiver receiver) {\n        try {\n            unregisterReceiver(receiver);\n        } catch (IllegalArgumentException e) {\n            // ignore\n        }\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getTrackCursor(mAdapter.getQueryHandler(), null, true);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor) {\n\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName == null || fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    long toidx = mTrackCursor.getLong(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    // Cursor should be positioned on the entry to be checked\n    // Returns false if the entry matches the naming pattern used for recordings,\n    // or if it is marked as not music in the database.\n    private boolean isMusic(Cursor c) {\n        int titleidx = c.getColumnIndex(MediaStore.Audio.Media.TITLE);\n        int albumidx = c.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n        int artistidx = c.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n\n        String title = c.getString(titleidx);\n        String album = c.getString(albumidx);\n        String artist = c.getString(artistidx);\n        if (MediaFile.UNKNOWN_STRING.equals(album) &&\n                MediaFile.UNKNOWN_STRING.equals(artist) &&\n                title != null &&\n                title.startsWith(\"recording\")) {\n            // not music\n            return false;\n        }\n\n        int ismusic_idx = c.getColumnIndex(MediaStore.Audio.Media.IS_MUSIC);\n        boolean ismusic = true;\n        if (ismusic_idx >= 0) {\n            ismusic = mTrackCursor.getInt(ismusic_idx) != 0;\n        }\n        return ismusic;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getLong(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        // only add the 'search' menu if the selected item is music\n        if (isMusic(mTrackCursor)) {\n            menu.add(0, SEARCH, 0, R.string.search_title);\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                long [] list = new long[] { mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                long [] list = new long[] { mSelectedId };\n                long playlist = item.getIntent().getLongExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                long [] list = new long[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putLongArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null, true);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = new long[] { mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        long [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,\n            boolean async) {\n\n        if (queryhandler == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n\n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = queryhandler.doQuery(MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                    Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder, async);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString(), keywords,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = queryhandler.doQuery(MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist)), mPlaylistMemberCols,\n                        where.toString(), keywords, mSortOrder, async);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = queryhandler.doQuery(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, where.toString() , keywords, mSortOrder, async);\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async) {\n            init(ret);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new long[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getLong(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    long trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new long[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            long newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private long[] mNowPlaying;\n        private long[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private TrackQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        static class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class TrackQueryHandler extends AsyncQueryHandler {\n\n            class QueryArgs {\n                public Uri uri;\n                public String [] projection;\n                public String selection;\n                public String [] selectionArgs;\n                public String orderBy;\n            }\n\n            TrackQueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            public Cursor doQuery(Uri uri, String[] projection,\n                    String selection, String[] selectionArgs,\n                    String orderBy, boolean async) {\n                if (async) {\n                    // Get 100 results first, which is enough to allow the user to start scrolling,\n                    // while still being very fast.\n                    Uri limituri = uri.buildUpon().appendQueryParameter(\"limit\", \"100\").build();\n                    QueryArgs args = new QueryArgs();\n                    args.uri = uri;\n                    args.projection = projection;\n                    args.selection = selection;\n                    args.selectionArgs = selectionArgs;\n                    args.orderBy = orderBy;\n\n                    startQuery(0, args, limituri, projection, selection, selectionArgs, orderBy);\n                    return null;\n                }\n                return MusicUtils.query(mActivity,\n                        uri, projection, selection, selectionArgs, orderBy);\n            }\n\n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor);\n                if (token == 0 && cookie != null && cursor != null && cursor.getCount() >= 100) {\n                    QueryArgs args = (QueryArgs) cookie;\n                    startQuery(1, null, args.uri, args.projection, args.selection,\n                            args.selectionArgs, args.orderBy);\n                }\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new TrackQueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public TrackQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            long id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getLong(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(mQueryHandler, s, false);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1294}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.media.MediaPlayer;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.os.PowerManager.WakeLock;\nimport android.provider.MediaStore;\nimport android.telephony.PhoneStateListener;\nimport android.telephony.TelephonyManager;\nimport android.util.Log;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Provides \"background\" audio playback capabilities, allowing the\n * user to switch between activities without stopping playback.\n */\npublic class MediaPlaybackService extends Service {\n    /** used to specify whether enqueue() should start playing\n     * the new list of files right away, next or once all the currently\n     * queued files have been played\n     */\n    public static final int NOW = 1;\n    public static final int NEXT = 2;\n    public static final int LAST = 3;\n    public static final int PLAYBACKSERVICE_STATUS = 1;\n    \n    public static final int SHUFFLE_NONE = 0;\n    public static final int SHUFFLE_NORMAL = 1;\n    public static final int SHUFFLE_AUTO = 2;\n    \n    public static final int REPEAT_NONE = 0;\n    public static final int REPEAT_CURRENT = 1;\n    public static final int REPEAT_ALL = 2;\n\n    public static final String PLAYSTATE_CHANGED = \"com.android.music.playstatechanged\";\n    public static final String META_CHANGED = \"com.android.music.metachanged\";\n    public static final String QUEUE_CHANGED = \"com.android.music.queuechanged\";\n    public static final String PLAYBACK_COMPLETE = \"com.android.music.playbackcomplete\";\n    public static final String ASYNC_OPEN_COMPLETE = \"com.android.music.asyncopencomplete\";\n\n    public static final String SERVICECMD = \"com.android.music.musicservicecommand\";\n    public static final String CMDNAME = \"command\";\n    public static final String CMDTOGGLEPAUSE = \"togglepause\";\n    public static final String CMDSTOP = \"stop\";\n    public static final String CMDPAUSE = \"pause\";\n    public static final String CMDPREVIOUS = \"previous\";\n    public static final String CMDNEXT = \"next\";\n\n    public static final String TOGGLEPAUSE_ACTION = \"com.android.music.musicservicecommand.togglepause\";\n    public static final String PAUSE_ACTION = \"com.android.music.musicservicecommand.pause\";\n    public static final String PREVIOUS_ACTION = \"com.android.music.musicservicecommand.previous\";\n    public static final String NEXT_ACTION = \"com.android.music.musicservicecommand.next\";\n\n    private static final int TRACK_ENDED = 1;\n    private static final int RELEASE_WAKELOCK = 2;\n    private static final int SERVER_DIED = 3;\n    private static final int FADEIN = 4;\n    private static final int MAX_HISTORY_SIZE = 10;\n    \n    private MultiPlayer mPlayer;\n    private String mFileToPlay;\n    private int mShuffleMode = SHUFFLE_NONE;\n    private int mRepeatMode = REPEAT_NONE;\n    private int mMediaMountedCount = 0;\n    private int [] mAutoShuffleList = null;\n    private boolean mOneShot;\n    private int [] mPlayList = null;\n    private int mPlayListLen = 0;\n    private Vector<Integer> mHistory = new Vector<Integer>(MAX_HISTORY_SIZE);\n    private Cursor mCursor;\n    private int mPlayPos = -1;\n    private static final String LOGTAG = \"MediaPlaybackService\";\n    private final Shuffler mRand = new Shuffler();\n    private int mOpenFailedCounter = 0;\n    String[] mCursorCols = new String[] {\n            \"audio._id AS _id\",             // index must match IDCOLIDX below\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE,\n            MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.IS_PODCAST, // index must match PODCASTCOLIDX below\n            MediaStore.Audio.Media.BOOKMARK    // index must match BOOKMARKCOLIDX below\n    };\n    private final static int IDCOLIDX = 0;\n    private final static int PODCASTCOLIDX = 8;\n    private final static int BOOKMARKCOLIDX = 9;\n    private BroadcastReceiver mUnmountReceiver = null;\n    private WakeLock mWakeLock;\n    private int mServiceStartId = -1;\n    private boolean mServiceInUse = false;\n    private boolean mResumeAfterCall = false;\n    private boolean mIsSupposedToBePlaying = false;\n    private boolean mQuietMode = false;\n    \n    private SharedPreferences mPreferences;\n    // We use this to distinguish between different cards when saving/restoring playlists.\n    // This will have to change if we want to support multiple simultaneous cards.\n    private int mCardId;\n    \n    private MediaAppWidgetProvider mAppWidgetProvider = MediaAppWidgetProvider.getInstance();\n    \n    // interval after which we stop the service when idle\n    private static final int IDLE_DELAY = 60000; \n\n    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {\n        @Override\n        public void onCallStateChanged(int state, String incomingNumber) {\n            if (state == TelephonyManager.CALL_STATE_RINGING) {\n                AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n                int ringvolume = audioManager.getStreamVolume(AudioManager.STREAM_RING);\n                if (ringvolume > 0) {\n                    mResumeAfterCall = (isPlaying() || mResumeAfterCall) && (getAudioId() >= 0);\n                    pause();\n                }\n            } else if (state == TelephonyManager.CALL_STATE_OFFHOOK) {\n                // pause the music while a conversation is in progress\n                mResumeAfterCall = (isPlaying() || mResumeAfterCall) && (getAudioId() >= 0);\n                pause();\n            } else if (state == TelephonyManager.CALL_STATE_IDLE) {\n                // start playing again\n                if (mResumeAfterCall) {\n                    // resume playback only if music was playing\n                    // when the call was answered\n                    startAndFadeIn();\n                    mResumeAfterCall = false;\n                }\n            }\n        }\n    };\n    \n    private void startAndFadeIn() {\n        mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n    }\n    \n    private Handler mMediaplayerHandler = new Handler() {\n        float mCurrentVolume = 1.0f;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case FADEIN:\n                    if (!isPlaying()) {\n                        mCurrentVolume = 0f;\n                        mPlayer.setVolume(mCurrentVolume);\n                        play();\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n                    } else {\n                        mCurrentVolume += 0.01f;\n                        if (mCurrentVolume < 1.0f) {\n                            mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n                        } else {\n                            mCurrentVolume = 1.0f;\n                        }\n                        mPlayer.setVolume(mCurrentVolume);\n                    }\n                    break;\n                case SERVER_DIED:\n                    if (mIsSupposedToBePlaying) {\n                        next(true);\n                    } else {\n                        // the server died when we were idle, so just\n                        // reopen the same song (it will start again\n                        // from the beginning though when the user\n                        // restarts)\n                        openCurrent();\n                    }\n                    break;\n                case TRACK_ENDED:\n                    if (mRepeatMode == REPEAT_CURRENT) {\n                        seek(0);\n                        play();\n                    } else if (!mOneShot) {\n                        next(false);\n                    } else {\n                        notifyChange(PLAYBACK_COMPLETE);\n                        mIsSupposedToBePlaying = false;\n                    }\n                    break;\n                case RELEASE_WAKELOCK:\n                    mWakeLock.release();\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                prev();\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                seek(0);\n            } else if (MediaAppWidgetProvider.CMDAPPWIDGETUPDATE.equals(cmd)) {\n                // Someone asked us to refresh a set of specific widgets, probably\n                // because they were just added.\n                int[] appWidgetIds = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);\n                mAppWidgetProvider.performUpdate(MediaPlaybackService.this, appWidgetIds);\n            }\n        }\n    };\n\n    public MediaPlaybackService() {\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        mPreferences = getSharedPreferences(\"Music\", MODE_WORLD_READABLE | MODE_WORLD_WRITEABLE);\n        mCardId = FileUtils.getFatVolumeId(Environment.getExternalStorageDirectory().getPath());\n        \n        registerExternalStorageListener();\n\n        // Needs to be done in this thread, since otherwise ApplicationContext.getPowerManager() crashes.\n        mPlayer = new MultiPlayer();\n        mPlayer.setHandler(mMediaplayerHandler);\n\n        // Clear leftover notification in case this service previously got killed while playing\n        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n        nm.cancel(PLAYBACKSERVICE_STATUS);\n        \n        reloadQueue();\n        \n        IntentFilter commandFilter = new IntentFilter();\n        commandFilter.addAction(SERVICECMD);\n        commandFilter.addAction(TOGGLEPAUSE_ACTION);\n        commandFilter.addAction(PAUSE_ACTION);\n        commandFilter.addAction(NEXT_ACTION);\n        commandFilter.addAction(PREVIOUS_ACTION);\n        registerReceiver(mIntentReceiver, commandFilter);\n        \n        TelephonyManager tmgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n        tmgr.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);\n        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);\n        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, this.getClass().getName());\n        mWakeLock.setReferenceCounted(false);\n\n        // If the service was idle, but got killed before it stopped itself, the\n        // system will relaunch it. Make sure it gets stopped again in that case.\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n\n    @Override\n    public void onDestroy() {\n        // Check that we're not being destroyed while something is still playing.\n        if (isPlaying()) {\n            Log.e(\"MediaPlaybackService\", \"Service being destroyed while still playing.\");\n        }\n        // release all MediaPlayer resources, including the native player and wakelocks\n        mPlayer.release();\n        mPlayer = null;\n        \n        // make sure there aren't any other messages coming\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mMediaplayerHandler.removeCallbacksAndMessages(null);\n\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n\n        TelephonyManager tmgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n        tmgr.listen(mPhoneStateListener, 0);\n\n        unregisterReceiver(mIntentReceiver);\n        if (mUnmountReceiver != null) {\n            unregisterReceiver(mUnmountReceiver);\n            mUnmountReceiver = null;\n        }\n        mWakeLock.release();\n        super.onDestroy();\n    }\n    \n    private final char hexdigits [] = new char [] {\n            '0', '1', '2', '3',\n            '4', '5', '6', '7',\n            '8', '9', 'a', 'b',\n            'c', 'd', 'e', 'f'\n    };\n\n    private void saveQueue(boolean full) {\n        if (mOneShot) {\n            return;\n        }\n        Editor ed = mPreferences.edit();\n        //long start = System.currentTimeMillis();\n        if (full) {\n            StringBuilder q = new StringBuilder();\n            \n            // The current playlist is saved as a list of \"reverse hexadecimal\"\n            // numbers, which we can generate faster than normal decimal or\n            // hexadecimal numbers, which in turn allows us to save the playlist\n            // more often without worrying too much about performance.\n            // (saving the full state takes about 40 ms under no-load conditions\n            // on the phone)\n            int len = mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                int n = mPlayList[i];\n                if (n == 0) {\n                    q.append(\"0;\");\n                } else {\n                    while (n != 0) {\n                        int digit = n & 0xf;\n                        n >>= 4;\n                        q.append(hexdigits[digit]);\n                    }\n                    q.append(\";\");\n                }\n            }\n            //Log.i(\"@@@@ service\", \"created queue string in \" + (System.currentTimeMillis() - start) + \" ms\");\n            ed.putString(\"queue\", q.toString());\n            ed.putInt(\"cardid\", mCardId);\n        }\n        ed.putInt(\"curpos\", mPlayPos);\n        if (mPlayer.isInitialized()) {\n            ed.putLong(\"seekpos\", mPlayer.position());\n        }\n        ed.putInt(\"repeatmode\", mRepeatMode);\n        ed.putInt(\"shufflemode\", mShuffleMode);\n        ed.commit();\n  \n        //Log.i(\"@@@@ service\", \"saved state in \" + (System.currentTimeMillis() - start) + \" ms\");\n    }\n\n    private void reloadQueue() {\n        String q = null;\n        \n        boolean newstyle = false;\n        int id = mCardId;\n        if (mPreferences.contains(\"cardid\")) {\n            newstyle = true;\n            id = mPreferences.getInt(\"cardid\", ~mCardId);\n        }\n        if (id == mCardId) {\n            // Only restore the saved playlist if the card is still\n            // the same one as when the playlist was saved\n            q = mPreferences.getString(\"queue\", \"\");\n        }\n        int qlen = q != null ? q.length() : 0;\n        if (qlen > 1) {\n            //Log.i(\"@@@@ service\", \"loaded queue: \" + q);\n            int plen = 0;\n            int n = 0;\n            int shift = 0;\n            for (int i = 0; i < qlen; i++) {\n                char c = q.charAt(i);\n                if (c == ';') {\n                    ensurePlayListCapacity(plen + 1);\n                    mPlayList[plen] = n;\n                    plen++;\n                    n = 0;\n                    shift = 0;\n                } else {\n                    if (c >= '0' && c <= '9') {\n                        n += ((c - '0') << shift);\n                    } else if (c >= 'a' && c <= 'f') {\n                        n += ((10 + c - 'a') << shift);\n                    } else {\n                        // bogus playlist data\n                        plen = 0;\n                        break;\n                    }\n                    shift += 4;\n                }\n            }\n            mPlayListLen = plen;\n\n            int pos = mPreferences.getInt(\"curpos\", 0);\n            if (pos < 0 || pos >= mPlayListLen) {\n                // The saved playlist is bogus, discard it\n                mPlayListLen = 0;\n                return;\n            }\n            mPlayPos = pos;\n            \n            // When reloadQueue is called in response to a card-insertion,\n            // we might not be able to query the media provider right away.\n            // To deal with this, try querying for the current file, and if\n            // that fails, wait a while and try again. If that too fails,\n            // assume there is a problem and don't restore the state.\n            Cursor c = MusicUtils.query(this,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] {\"_id\"}, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            if (c == null || c.getCount() == 0) {\n                // wait a bit and try again\n                SystemClock.sleep(3000);\n                c = getContentResolver().query(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            }\n            if (c != null) {\n                c.close();\n            }\n\n            // Make sure we don't auto-skip to the next song, since that\n            // also starts playback. What could happen in that case is:\n            // - music is paused\n            // - go to UMS and delete some files, including the currently playing one\n            // - come back from UMS\n            // (time passes)\n            // - music app is killed for some reason (out of memory)\n            // - music service is restarted, service restores state, doesn't find\n            //   the \"current\" file, goes to the next and: playback starts on its\n            //   own, potentially at some random inconvenient time.\n            mOpenFailedCounter = 20;\n            mQuietMode = true;\n            openCurrent();\n            mQuietMode = false;\n            if (!mPlayer.isInitialized()) {\n                // couldn't restore the saved state\n                mPlayListLen = 0;\n                return;\n            }\n            \n            long seekpos = mPreferences.getLong(\"seekpos\", 0);\n            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);\n            \n            int repmode = mPreferences.getInt(\"repeatmode\", REPEAT_NONE);\n            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {\n                repmode = REPEAT_NONE;\n            }\n            mRepeatMode = repmode;\n\n            int shufmode = mPreferences.getInt(\"shufflemode\", SHUFFLE_NONE);\n            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {\n                shufmode = SHUFFLE_NONE;\n            }\n            if (shufmode == SHUFFLE_AUTO) {\n                if (! makeAutoShuffleList()) {\n                    shufmode = SHUFFLE_NONE;\n                }\n            }\n            mShuffleMode = shufmode;\n        }\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n        return mBinder;\n    }\n\n    @Override\n    public void onRebind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n    }\n\n    @Override\n    public void onStart(Intent intent, int startId) {\n        mServiceStartId = startId;\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        \n        String action = intent.getAction();\n        String cmd = intent.getStringExtra(\"command\");\n        \n        if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n            next(true);\n        } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n            prev();\n        } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n            if (isPlaying()) {\n                pause();\n            } else {\n                play();\n            }\n        } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n            pause();\n        } else if (CMDSTOP.equals(cmd)) {\n            pause();\n            seek(0);\n        }\n        \n        // make sure the service will shut down on its own if it was\n        // just started but not bound to and nothing is playing\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n    \n    @Override\n    public boolean onUnbind(Intent intent) {\n        mServiceInUse = false;\n\n        // Take a snapshot of the current playlist\n        saveQueue(true);\n\n        if (isPlaying() || mResumeAfterCall) {\n            // something is currently playing, or will be playing once \n            // an in-progress call ends, so don't stop the service now.\n            return true;\n        }\n        \n        // If there is a playlist but playback is paused, then wait a while\n        // before stopping the service, so that pause/resume isn't slow.\n        // Also delay stopping the service if we're transitioning between tracks.\n        if (mPlayListLen > 0  || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n            Message msg = mDelayedStopHandler.obtainMessage();\n            mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n            return true;\n        }\n        \n        // No active playlist, OK to stop the service right now\n        stopSelf(mServiceStartId);\n        return true;\n    }\n    \n    private Handler mDelayedStopHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            // Check again to make sure nothing is playing right now\n            if (isPlaying() || mResumeAfterCall || mServiceInUse\n                    || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n                return;\n            }\n            // save the queue again, because it might have changed\n            // since the user exited the music app (because of\n            // party-shuffle or because the play-position changed)\n            saveQueue(true);\n            stopSelf(mServiceStartId);\n        }\n    };\n    \n    /**\n     * Called when we receive a ACTION_MEDIA_EJECT notification.\n     *\n     * @param storagePath path to mount point for the removed media\n     */\n    public void closeExternalStorageFiles(String storagePath) {\n        // stop playback and clean up if the SD card is going to be unmounted.\n        stop(true);\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n    }\n\n    /**\n     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.\n     * The intent will call closeExternalStorageFiles() if the external media\n     * is going to be ejected, so applications can clean up any files they have open.\n     */\n    public void registerExternalStorageListener() {\n        if (mUnmountReceiver == null) {\n            mUnmountReceiver = new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    String action = intent.getAction();\n                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {\n                        saveQueue(true);\n                        mOneShot = true; // This makes us not save the state again later,\n                                         // which would be wrong because the song ids and\n                                         // card id might not match. \n                        closeExternalStorageFiles(intent.getData().getPath());\n                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n                        mMediaMountedCount++;\n                        mCardId = FileUtils.getFatVolumeId(intent.getData().getPath());\n                        reloadQueue();\n                        notifyChange(QUEUE_CHANGED);\n                        notifyChange(META_CHANGED);\n                    }\n                }\n            };\n            IntentFilter iFilter = new IntentFilter();\n            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);\n            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);\n            iFilter.addDataScheme(\"file\");\n            registerReceiver(mUnmountReceiver, iFilter);\n        }\n    }\n\n    /**\n     * Notify the change-receivers that something has changed.\n     * The intent that is sent contains the following data\n     * for the currently playing track:\n     * \"id\" - Integer: the database row ID\n     * \"artist\" - String: the name of the artist\n     * \"album\" - String: the name of the album\n     * \"track\" - String: the name of the track\n     * The intent has an action that is one of\n     * \"com.android.music.metachanged\"\n     * \"com.android.music.queuechanged\",\n     * \"com.android.music.playbackcomplete\"\n     * \"com.android.music.playstatechanged\"\n     * respectively indicating that a new track has\n     * started playing, that the playback queue has\n     * changed, that playback has stopped because\n     * the last file in the list has been played,\n     * or that the play-state changed (paused/resumed).\n     */\n    private void notifyChange(String what) {\n        \n        Intent i = new Intent(what);\n        i.putExtra(\"id\", Integer.valueOf(getAudioId()));\n        i.putExtra(\"artist\", getArtistName());\n        i.putExtra(\"album\",getAlbumName());\n        i.putExtra(\"track\", getTrackName());\n        sendBroadcast(i);\n        \n        if (what.equals(QUEUE_CHANGED)) {\n            saveQueue(true);\n        } else {\n            saveQueue(false);\n        }\n        \n        // Share this notification directly with our widgets\n        mAppWidgetProvider.notifyChange(this, what);\n    }\n\n    private void ensurePlayListCapacity(int size) {\n        if (mPlayList == null || size > mPlayList.length) {\n            // reallocate at 2x requested size so we don't\n            // need to grow and copy the array for every\n            // insert\n            int [] newlist = new int[size * 2];\n            int len = mPlayList != null ? mPlayList.length : mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                newlist[i] = mPlayList[i];\n            }\n            mPlayList = newlist;\n        }\n        // FIXME: shrink the array when the needed size is much smaller\n        // than the allocated size\n    }\n    \n    // insert the list of songs at the specified position in the playlist\n    private void addToPlayList(int [] list, int position) {\n        int addlen = list.length;\n        if (position < 0) { // overwrite\n            mPlayListLen = 0;\n            position = 0;\n        }\n        ensurePlayListCapacity(mPlayListLen + addlen);\n        if (position > mPlayListLen) {\n            position = mPlayListLen;\n        }\n        \n        // move part of list after insertion point\n        int tailsize = mPlayListLen - position;\n        for (int i = tailsize ; i > 0 ; i--) {\n            mPlayList[position + i] = mPlayList[position + i - addlen]; \n        }\n        \n        // copy list into playlist\n        for (int i = 0; i < addlen; i++) {\n            mPlayList[position + i] = list[i];\n        }\n        mPlayListLen += addlen;\n    }\n    \n    /**\n     * Appends a list of tracks to the current playlist.\n     * If nothing is playing currently, playback will be started at\n     * the first track.\n     * If the action is NOW, playback will switch to the first of\n     * the new tracks immediately.\n     * @param list The list of tracks to append.\n     * @param action NOW, NEXT or LAST\n     */\n    public void enqueue(int [] list, int action) {\n        synchronized(this) {\n            if (action == NEXT && mPlayPos + 1 < mPlayListLen) {\n                addToPlayList(list, mPlayPos + 1);\n                notifyChange(QUEUE_CHANGED);\n            } else {\n                // action == LAST || action == NOW || mPlayPos + 1 == mPlayListLen\n                addToPlayList(list, Integer.MAX_VALUE);\n                notifyChange(QUEUE_CHANGED);\n                if (action == NOW) {\n                    mPlayPos = mPlayListLen - list.length;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                }\n            }\n            if (mPlayPos < 0) {\n                mPlayPos = 0;\n                openCurrent();\n                play();\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    /**\n     * Replaces the current playlist with a new list,\n     * and prepares for starting playback at the specified\n     * position in the list, or a random position if the\n     * specified position is 0.\n     * @param list The new list of tracks.\n     */\n    public void open(int [] list, int position) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                mShuffleMode = SHUFFLE_NORMAL;\n            }\n            int oldId = getAudioId();\n            int listlength = list.length;\n            boolean newlist = true;\n            if (mPlayListLen == listlength) {\n                // possible fast path: list might be the same\n                newlist = false;\n                for (int i = 0; i < listlength; i++) {\n                    if (list[i] != mPlayList[i]) {\n                        newlist = true;\n                        break;\n                    }\n                }\n            }\n            if (newlist) {\n                addToPlayList(list, -1);\n                notifyChange(QUEUE_CHANGED);\n            }\n            int oldpos = mPlayPos;\n            if (position >= 0) {\n                mPlayPos = position;\n            } else {\n                mPlayPos = mRand.nextInt(mPlayListLen);\n            }\n            mHistory.clear();\n\n            saveBookmarkIfNeeded();\n            openCurrent();\n            if (oldId != getAudioId()) {\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n    \n    /**\n     * Moves the item at index1 to index2.\n     * @param index1\n     * @param index2\n     */\n    public void moveQueueItem(int index1, int index2) {\n        synchronized (this) {\n            if (index1 >= mPlayListLen) {\n                index1 = mPlayListLen - 1;\n            }\n            if (index2 >= mPlayListLen) {\n                index2 = mPlayListLen - 1;\n            }\n            if (index1 < index2) {\n                int tmp = mPlayList[index1];\n                for (int i = index1; i < index2; i++) {\n                    mPlayList[i] = mPlayList[i+1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index1 && mPlayPos <= index2) {\n                        mPlayPos--;\n                }\n            } else if (index2 < index1) {\n                int tmp = mPlayList[index1];\n                for (int i = index1; i > index2; i--) {\n                    mPlayList[i] = mPlayList[i-1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index2 && mPlayPos <= index1) {\n                        mPlayPos++;\n                }\n            }\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    /**\n     * Returns the current play list\n     * @return An array of integers containing the IDs of the tracks in the play list\n     */\n    public int [] getQueue() {\n        synchronized (this) {\n            int len = mPlayListLen;\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                list[i] = mPlayList[i];\n            }\n            return list;\n        }\n    }\n\n    private void openCurrent() {\n        synchronized (this) {\n            if (mCursor != null) {\n                mCursor.close();\n                mCursor = null;\n            }\n            if (mPlayListLen == 0) {\n                return;\n            }\n            stop(false);\n\n            String id = String.valueOf(mPlayList[mPlayPos]);\n            \n            mCursor = getContentResolver().query(\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, \"_id=\" + id , null, null);\n            if (mCursor != null) {\n                mCursor.moveToFirst();\n                open(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + \"/\" + id, false);\n                // go to bookmark if needed\n                if (isPodcast()) {\n                    long bookmark = getBookmark();\n                    // Start playing a little bit before the bookmark,\n                    // so it's easier to get back in to the narrative.\n                    seek(bookmark - 5000);\n                }\n            }\n        }\n    }\n\n    public void openAsync(String path) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            mRepeatMode = REPEAT_NONE;\n            ensurePlayListCapacity(1);\n            mPlayListLen = 1;\n            mPlayPos = -1;\n            \n            mFileToPlay = path;\n            mCursor = null;\n            mPlayer.setDataSourceAsync(mFileToPlay);\n            mOneShot = true;\n        }\n    }\n    \n    /**\n     * Opens the specified file and readies it for playback.\n     *\n     * @param path The full path of the file to be opened.\n     * @param oneshot when set to true, playback will stop after this file completes, instead\n     * of moving on to the next track in the list \n     */\n    public void open(String path, boolean oneshot) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            if (oneshot) {\n                mRepeatMode = REPEAT_NONE;\n                ensurePlayListCapacity(1);\n                mPlayListLen = 1;\n                mPlayPos = -1;\n            }\n            \n            // if mCursor is null, try to associate path with a database cursor\n            if (mCursor == null) {\n\n                ContentResolver resolver = getContentResolver();\n                Uri uri;\n                String where;\n                String selectionArgs[];\n                if (path.startsWith(\"content://media/\")) {\n                    uri = Uri.parse(path);\n                    where = null;\n                    selectionArgs = null;\n                } else {\n                   uri = MediaStore.Audio.Media.getContentUriForPath(path);\n                   where = MediaStore.Audio.Media.DATA + \"=?\";\n                   selectionArgs = new String[] { path };\n                }\n                \n                try {\n                    mCursor = resolver.query(uri, mCursorCols, where, selectionArgs, null);\n                    if  (mCursor != null) {\n                        if (mCursor.getCount() == 0) {\n                            mCursor.close();\n                            mCursor = null;\n                        } else {\n                            mCursor.moveToNext();\n                            ensurePlayListCapacity(1);\n                            mPlayListLen = 1;\n                            mPlayList[0] = mCursor.getInt(IDCOLIDX);\n                            mPlayPos = 0;\n                        }\n                    }\n                } catch (UnsupportedOperationException ex) {\n                }\n            }\n            mFileToPlay = path;\n            mPlayer.setDataSource(mFileToPlay);\n            mOneShot = oneshot;\n            if (! mPlayer.isInitialized()) {\n                stop(true);\n                if (mOpenFailedCounter++ < 10 &&  mPlayListLen > 1) {\n                    // beware: this ends up being recursive because next() calls open() again.\n                    next(false);\n                }\n                if (! mPlayer.isInitialized() && mOpenFailedCounter != 0) {\n                    // need to make sure we only shows this once\n                    mOpenFailedCounter = 0;\n                    if (!mQuietMode) {\n                        Toast.makeText(this, R.string.playback_failed, Toast.LENGTH_SHORT).show();\n                    }\n                }\n            } else {\n                mOpenFailedCounter = 0;\n            }\n        }\n    }\n\n    /**\n     * Starts playback of a previously opened file.\n     */\n    public void play() {\n        if (mPlayer.isInitialized()) {\n            // if we are at the end of the song, go to the next song first\n            if (mRepeatMode != REPEAT_CURRENT &&\n                mPlayer.position() >= mPlayer.duration() - 2000) {\n                next(true);\n            }\n\n            mPlayer.start();\n            setForeground(true);\n\n            NotificationManager nm = (NotificationManager)\n            getSystemService(Context.NOTIFICATION_SERVICE);\n    \n            RemoteViews views = new RemoteViews(getPackageName(), R.layout.statusbar);\n            views.setImageViewResource(R.id.icon, R.drawable.stat_notify_musicplayer);\n            if (getAudioId() < 0) {\n                // streaming\n                views.setTextViewText(R.id.trackname, getPath());\n                views.setTextViewText(R.id.artistalbum, null);\n            } else {\n                String artist = getArtistName();\n                views.setTextViewText(R.id.trackname, getTrackName());\n                if (artist == null || artist.equals(MediaFile.UNKNOWN_STRING)) {\n                    artist = getString(R.string.unknown_artist_name);\n                }\n                String album = getAlbumName();\n                if (album == null || album.equals(MediaFile.UNKNOWN_STRING)) {\n                    album = getString(R.string.unknown_album_name);\n                }\n                \n                views.setTextViewText(R.id.artistalbum,\n                        getString(R.string.notification_artist_album, artist, album)\n                        );\n            }\n            \n            Notification status = new Notification();\n            status.contentView = views;\n            status.flags |= Notification.FLAG_ONGOING_EVENT;\n            status.icon = R.drawable.stat_notify_musicplayer;\n            status.contentIntent = PendingIntent.getActivity(this, 0,\n                    new Intent(\"com.android.music.PLAYBACK_VIEWER\"), 0);\n            nm.notify(PLAYBACKSERVICE_STATUS, status);\n            if (!mIsSupposedToBePlaying) {\n                notifyChange(PLAYSTATE_CHANGED);\n            }\n            mIsSupposedToBePlaying = true;\n        } else if (mPlayListLen <= 0) {\n            // This is mostly so that if you press 'play' on a bluetooth headset\n            // without every having played anything before, it will still play\n            // something.\n            setShuffleMode(SHUFFLE_AUTO);\n        }\n    }\n    \n    private void stop(boolean remove_status_icon) {\n        if (mPlayer.isInitialized()) {\n            mPlayer.stop();\n        }\n        mFileToPlay = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n        if (remove_status_icon) {\n            gotoIdleState();\n        }\n        setForeground(false);\n        if (remove_status_icon) {\n            mIsSupposedToBePlaying = false;\n        }\n    }\n\n    /**\n     * Stops playback.\n     */\n    public void stop() {\n        stop(true);\n    }\n\n    /**\n     * Pauses playback (call play() to resume)\n     */\n    public void pause() {\n        synchronized(this) {\n            if (isPlaying()) {\n                mPlayer.pause();\n                gotoIdleState();\n                setForeground(false);\n                mIsSupposedToBePlaying = false;\n                notifyChange(PLAYSTATE_CHANGED);\n                saveBookmarkIfNeeded();\n            }\n        }\n    }\n\n    /** Returns whether something is currently playing\n     *\n     * @return true if something is playing (or will be playing shortly, in case\n     * we're currently transitioning between tracks), false if not.\n     */\n    public boolean isPlaying() {\n        return mIsSupposedToBePlaying;\n    }\n\n    /*\n      Desired behavior for prev/next/shuffle:\n\n      - NEXT will move to the next track in the list when not shuffling, and to\n        a track randomly picked from the not-yet-played tracks when shuffling.\n        If all tracks have already been played, pick from the full set, but\n        avoid picking the previously played track if possible.\n      - when shuffling, PREV will go to the previously played track. Hitting PREV\n        again will go to the track played before that, etc. When the start of the\n        history has been reached, PREV is a no-op.\n        When not shuffling, PREV will go to the sequentially previous track (the\n        difference with the shuffle-case is mainly that when not shuffling, the\n        user can back up to tracks that are not in the history).\n\n        Example:\n        When playing an album with 10 tracks from the start, and enabling shuffle\n        while playing track 5, the remaining tracks (6-10) will be shuffled, e.g.\n        the final play order might be 1-2-3-4-5-8-10-6-9-7.\n        When hitting 'prev' 8 times while playing track 7 in this example, the\n        user will go to tracks 9-6-10-8-5-4-3-2. If the user then hits 'next',\n        a random track will be picked again. If at any time user disables shuffling\n        the next/previous track will be picked in sequential order again.\n     */\n\n    public void prev() {\n        synchronized (this) {\n            if (mOneShot) {\n                // we were playing a specific file not part of a playlist, so there is no 'previous'\n                seek(0);\n                play();\n                return;\n            }\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // go to previously-played track and remove it from the history\n                int histsize = mHistory.size();\n                if (histsize == 0) {\n                    // prev is a no-op\n                    return;\n                }\n                Integer pos = mHistory.remove(histsize - 1);\n                mPlayPos = pos.intValue();\n            } else {\n                if (mPlayPos > 0) {\n                    mPlayPos--;\n                } else {\n                    mPlayPos = mPlayListLen - 1;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void next(boolean force) {\n        synchronized (this) {\n            if (mOneShot) {\n                // we were playing a specific file not part of a playlist, so there is no 'next'\n                seek(0);\n                play();\n                return;\n            }\n\n            if (mPlayListLen <= 0) {\n                return;\n            }\n\n            // Store the current file in the history, but keep the history at a\n            // reasonable size\n            if (mPlayPos >= 0) {\n                mHistory.add(Integer.valueOf(mPlayPos));\n            }\n            if (mHistory.size() > MAX_HISTORY_SIZE) {\n                mHistory.removeElementAt(0);\n            }\n\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // Pick random next track from the not-yet-played ones\n                // TODO: make it work right after adding/removing items in the queue.\n\n                int numTracks = mPlayListLen;\n                int[] tracks = new int[numTracks];\n                for (int i=0;i < numTracks; i++) {\n                    tracks[i] = i;\n                }\n\n                int numHistory = mHistory.size();\n                int numUnplayed = numTracks;\n                for (int i=0;i < numHistory; i++) {\n                    int idx = mHistory.get(i).intValue();\n                    if (idx < numTracks && tracks[idx] >= 0) {\n                        numUnplayed--;\n                        tracks[idx] = -1;\n                    }\n                }\n\n                // 'numUnplayed' now indicates how many tracks have not yet\n                // been played, and 'tracks' contains the indices of those\n                // tracks.\n                if (numUnplayed <=0) {\n                    // everything's already been played\n                    if (mRepeatMode == REPEAT_ALL || force) {\n                        //pick from full set\n                        numUnplayed = numTracks;\n                        for (int i=0;i < numTracks; i++) {\n                            tracks[i] = i;\n                        }\n                    } else {\n                        // all done\n                        gotoIdleState();\n                        return;\n                    }\n                }\n                int skip = mRand.nextInt(numUnplayed);\n                int cnt = -1;\n                while (true) {\n                    while (tracks[++cnt] < 0)\n                        ;\n                    skip--;\n                    if (skip < 0) {\n                        break;\n                    }\n                }\n                mPlayPos = cnt;\n            } else if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n                mPlayPos++;\n            } else {\n                if (mPlayPos >= mPlayListLen - 1) {\n                    // we're at the end of the list\n                    if (mRepeatMode == REPEAT_NONE && !force) {\n                        // all done\n                        gotoIdleState();\n                        notifyChange(PLAYBACK_COMPLETE);\n                        mIsSupposedToBePlaying = false;\n                        return;\n                    } else if (mRepeatMode == REPEAT_ALL || force) {\n                        mPlayPos = 0;\n                    }\n                } else {\n                    mPlayPos++;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    private void gotoIdleState() {\n        NotificationManager nm =\n            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n        nm.cancel(PLAYBACKSERVICE_STATUS);\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n    \n    private void saveBookmarkIfNeeded() {\n        try {\n            if (isPodcast()) {\n                long pos = position();\n                long bookmark = getBookmark();\n                long duration = duration();\n                if ((pos < bookmark && (pos + 10000) > bookmark) ||\n                        (pos > bookmark && (pos - 10000) < bookmark)) {\n                    // The existing bookmark is close to the current\n                    // position, so don't update it.\n                    return;\n                }\n                if (pos < 15000 || (pos + 10000) > duration) {\n                    // if we're near the start or end, clear the bookmark\n                    pos = 0;\n                }\n                \n                // write 'pos' to the bookmark field\n                ContentValues values = new ContentValues();\n                values.put(MediaStore.Audio.Media.BOOKMARK, pos);\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursor.getLong(IDCOLIDX));\n                getContentResolver().update(uri, values, null, null);\n            }\n        } catch (SQLiteException ex) {\n        }\n    }\n\n    // Make sure there are at least 5 items after the currently playing item\n    // and no more than 10 items before.\n    private void doAutoShuffleUpdate() {\n        boolean notify = false;\n        // remove old entries\n        if (mPlayPos > 10) {\n            removeTracks(0, mPlayPos - 9);\n            notify = true;\n        }\n        // add new entries if needed\n        int to_add = 7 - (mPlayListLen - (mPlayPos < 0 ? -1 : mPlayPos));\n        for (int i = 0; i < to_add; i++) {\n            // pick something at random from the list\n            int idx = mRand.nextInt(mAutoShuffleList.length);\n            Integer which = mAutoShuffleList[idx];\n            ensurePlayListCapacity(mPlayListLen + 1);\n            mPlayList[mPlayListLen++] = which;\n            notify = true;\n        }\n        if (notify) {\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    // A simple variation of Random that makes sure that the\n    // value it returns is not equal to the value it returned\n    // previously, unless the interval is 1.\n    private static class Shuffler {\n        private int mPrevious;\n        private Random mRandom = new Random();\n        public int nextInt(int interval) {\n            int ret;\n            do {\n                ret = mRandom.nextInt(interval);\n            } while (ret == mPrevious && interval > 1);\n            mPrevious = ret;\n            return ret;\n        }\n    };\n\n    private boolean makeAutoShuffleList() {\n        ContentResolver res = getContentResolver();\n        Cursor c = null;\n        try {\n            c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                    null, null);\n            if (c == null || c.getCount() == 0) {\n                return false;\n            }\n            int len = c.getCount();\n            int[] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getInt(0);\n            }\n            mAutoShuffleList = list;\n            return true;\n        } catch (RuntimeException ex) {\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Removes the range of tracks specified from the play list. If a file within the range is\n     * the file currently being played, playback will move to the next file after the\n     * range. \n     * @param first The first file to be removed\n     * @param last The last file to be removed\n     * @return the number of tracks deleted\n     */\n    public int removeTracks(int first, int last) {\n        int numremoved = removeTracksInternal(first, last);\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    private int removeTracksInternal(int first, int last) {\n        synchronized (this) {\n            if (last < first) return 0;\n            if (first < 0) first = 0;\n            if (last >= mPlayListLen) last = mPlayListLen - 1;\n\n            boolean gotonext = false;\n            if (first <= mPlayPos && mPlayPos <= last) {\n                mPlayPos = first;\n                gotonext = true;\n            } else if (mPlayPos > last) {\n                mPlayPos -= (last - first + 1);\n            }\n            int num = mPlayListLen - last - 1;\n            for (int i = 0; i < num; i++) {\n                mPlayList[first + i] = mPlayList[last + 1 + i];\n            }\n            mPlayListLen -= last - first + 1;\n            \n            if (gotonext) {\n                if (mPlayListLen == 0) {\n                    stop(true);\n                    mPlayPos = -1;\n                } else {\n                    if (mPlayPos >= mPlayListLen) {\n                        mPlayPos = 0;\n                    }\n                    boolean wasPlaying = isPlaying();\n                    stop(false);\n                    openCurrent();\n                    if (wasPlaying) {\n                        play();\n                    }\n                }\n            }\n            return last - first + 1;\n        }\n    }\n    \n    /**\n     * Removes all instances of the track with the given id\n     * from the playlist.\n     * @param id The id to be removed\n     * @return how many instances of the track were removed\n     */\n    public int removeTrack(int id) {\n        int numremoved = 0;\n        synchronized (this) {\n            for (int i = 0; i < mPlayListLen; i++) {\n                if (mPlayList[i] == id) {\n                    numremoved += removeTracksInternal(i, i);\n                    i--;\n                }\n            }\n        }\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    public void setShuffleMode(int shufflemode) {\n        synchronized(this) {\n            if (mShuffleMode == shufflemode && mPlayListLen > 0) {\n                return;\n            }\n            mShuffleMode = shufflemode;\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                if (makeAutoShuffleList()) {\n                    mPlayListLen = 0;\n                    doAutoShuffleUpdate();\n                    mPlayPos = 0;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                } else {\n                    // failed to build a list of files to shuffle\n                    mShuffleMode = SHUFFLE_NONE;\n                }\n            }\n            saveQueue(false);\n        }\n    }\n    public int getShuffleMode() {\n        return mShuffleMode;\n    }\n    \n    public void setRepeatMode(int repeatmode) {\n        synchronized(this) {\n            mRepeatMode = repeatmode;\n            saveQueue(false);\n        }\n    }\n    public int getRepeatMode() {\n        return mRepeatMode;\n    }\n\n    public int getMediaMountedCount() {\n        return mMediaMountedCount;\n    }\n\n    /**\n     * Returns the path of the currently playing file, or null if\n     * no file is currently playing.\n     */\n    public String getPath() {\n        return mFileToPlay;\n    }\n    \n    /**\n     * Returns the rowid of the currently playing file, or -1 if\n     * no file is currently playing.\n     */\n    public int getAudioId() {\n        synchronized (this) {\n            if (mPlayPos >= 0 && mPlayer.isInitialized()) {\n                return mPlayList[mPlayPos];\n            }\n        }\n        return -1;\n    }\n    \n    /**\n     * Returns the position in the queue \n     * @return the position in the queue\n     */\n    public int getQueuePosition() {\n        synchronized(this) {\n            return mPlayPos;\n        }\n    }\n    \n    /**\n     * Starts playing the track at the given position in the queue.\n     * @param pos The position in the queue of the track that will be played.\n     */\n    public void setQueuePosition(int pos) {\n        synchronized(this) {\n            stop(false);\n            mPlayPos = pos;\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public String getArtistName() {\n        synchronized(this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));\n        }\n    }\n    \n    public int getArtistId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID));\n        }\n    }\n\n    public String getAlbumName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM));\n        }\n    }\n\n    public int getAlbumId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID));\n        }\n    }\n\n    public String getTrackName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));\n        }\n    }\n\n    private boolean isPodcast() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return false;\n            }\n            return (mCursor.getInt(PODCASTCOLIDX) > 0);\n        }\n    }\n    \n    private long getBookmark() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return 0;\n            }\n            return mCursor.getLong(BOOKMARKCOLIDX);\n        }\n    }\n    \n    /**\n     * Returns the duration of the file in milliseconds.\n     * Currently this method returns -1 for the duration of MIDI files.\n     */\n    public long duration() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.duration();\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the current playback position in milliseconds\n     */\n    public long position() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.position();\n        }\n        return -1;\n    }\n\n    /**\n     * Seeks to the position specified.\n     *\n     * @param pos The position to seek to, in milliseconds\n     */\n    public long seek(long pos) {\n        if (mPlayer.isInitialized()) {\n            if (pos < 0) pos = 0;\n            if (pos > mPlayer.duration()) pos = mPlayer.duration();\n            return mPlayer.seek(pos);\n        }\n        return -1;\n    }\n\n    /**\n     * Provides a unified interface for dealing with midi files and\n     * other media files.\n     */\n    private class MultiPlayer {\n        private MediaPlayer mMediaPlayer = new MediaPlayer();\n        private Handler mHandler;\n        private boolean mIsInitialized = false;\n\n        public MultiPlayer() {\n            mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n        }\n\n        public void setDataSourceAsync(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setDataSource(path);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.setOnPreparedListener(preparedlistener);\n                mMediaPlayer.prepareAsync();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            \n            mIsInitialized = true;\n        }\n        \n        public void setDataSource(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setOnPreparedListener(null);\n                if (path.startsWith(\"content://\")) {\n                    mMediaPlayer.setDataSource(MediaPlaybackService.this, Uri.parse(path));\n                } else {\n                    mMediaPlayer.setDataSource(path);\n                }\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.prepare();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            \n            mIsInitialized = true;\n        }\n        \n        public boolean isInitialized() {\n            return mIsInitialized;\n        }\n\n        public void start() {\n            mMediaPlayer.start();\n        }\n\n        public void stop() {\n            mMediaPlayer.reset();\n            mIsInitialized = false;\n        }\n\n        /**\n         * You CANNOT use this player anymore after calling release()\n         */\n        public void release() {\n            stop();\n            mMediaPlayer.release();\n        }\n        \n        public void pause() {\n            mMediaPlayer.pause();\n        }\n        \n        public void setHandler(Handler handler) {\n            mHandler = handler;\n        }\n\n        MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n            public void onCompletion(MediaPlayer mp) {\n                // Acquire a temporary wakelock, since when we return from\n                // this callback the MediaPlayer will release its wakelock\n                // and allow the device to go to sleep.\n                // This temporary wakelock is released when the RELEASE_WAKELOCK\n                // message is processed, but just in case, put a timeout on it.\n                mWakeLock.acquire(30000);\n                mHandler.sendEmptyMessage(TRACK_ENDED);\n                mHandler.sendEmptyMessage(RELEASE_WAKELOCK);\n            }\n        };\n\n        MediaPlayer.OnPreparedListener preparedlistener = new MediaPlayer.OnPreparedListener() {\n            public void onPrepared(MediaPlayer mp) {\n                notifyChange(ASYNC_OPEN_COMPLETE);\n            }\n        };\n \n        MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() {\n            public boolean onError(MediaPlayer mp, int what, int extra) {\n                switch (what) {\n                case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                    mIsInitialized = false;\n                    mMediaPlayer.release();\n                    // Creating a new MediaPlayer and settings its wakemode does not\n                    // require the media service, so it's OK to do this now, while the\n                    // service is still being restarted\n                    mMediaPlayer = new MediaPlayer(); \n                    mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n                    mHandler.sendMessageDelayed(mHandler.obtainMessage(SERVER_DIED), 2000);\n                    return true;\n                default:\n                    break;\n                }\n                return false;\n           }\n        };\n\n        public long duration() {\n            return mMediaPlayer.getDuration();\n        }\n\n        public long position() {\n            return mMediaPlayer.getCurrentPosition();\n        }\n\n        public long seek(long whereto) {\n            mMediaPlayer.seekTo((int) whereto);\n            return whereto;\n        }\n\n        public void setVolume(float vol) {\n            mMediaPlayer.setVolume(vol, vol);\n        }\n    }\n\n    /*\n     * By making this a static class with a WeakReference to the Service, we\n     * ensure that the Service can be GCd even when the system process still\n     * has a remote reference to the stub.\n     */\n    static class ServiceStub extends IMediaPlaybackService.Stub {\n        WeakReference<MediaPlaybackService> mService;\n        \n        ServiceStub(MediaPlaybackService service) {\n            mService = new WeakReference<MediaPlaybackService>(service);\n        }\n\n        public void openFileAsync(String path)\n        {\n            mService.get().openAsync(path);\n        }\n        public void openFile(String path, boolean oneShot)\n        {\n            mService.get().open(path, oneShot);\n        }\n        public void open(int [] list, int position) {\n            mService.get().open(list, position);\n        }\n        public int getQueuePosition() {\n            return mService.get().getQueuePosition();\n        }\n        public void setQueuePosition(int index) {\n            mService.get().setQueuePosition(index);\n        }\n        public boolean isPlaying() {\n            return mService.get().isPlaying();\n        }\n        public void stop() {\n            mService.get().stop();\n        }\n        public void pause() {\n            mService.get().pause();\n        }\n        public void play() {\n            mService.get().play();\n        }\n        public void prev() {\n            mService.get().prev();\n        }\n        public void next() {\n            mService.get().next(true);\n        }\n        public String getTrackName() {\n            return mService.get().getTrackName();\n        }\n        public String getAlbumName() {\n            return mService.get().getAlbumName();\n        }\n        public int getAlbumId() {\n            return mService.get().getAlbumId();\n        }\n        public String getArtistName() {\n            return mService.get().getArtistName();\n        }\n        public int getArtistId() {\n            return mService.get().getArtistId();\n        }\n        public void enqueue(int [] list , int action) {\n            mService.get().enqueue(list, action);\n        }\n        public int [] getQueue() {\n            return mService.get().getQueue();\n        }\n        public void moveQueueItem(int from, int to) {\n            mService.get().moveQueueItem(from, to);\n        }\n        public String getPath() {\n            return mService.get().getPath();\n        }\n        public int getAudioId() {\n            return mService.get().getAudioId();\n        }\n        public long position() {\n            return mService.get().position();\n        }\n        public long duration() {\n            return mService.get().duration();\n        }\n        public long seek(long pos) {\n            return mService.get().seek(pos);\n        }\n        public void setShuffleMode(int shufflemode) {\n            mService.get().setShuffleMode(shufflemode);\n        }\n        public int getShuffleMode() {\n            return mService.get().getShuffleMode();\n        }\n        public int removeTracks(int first, int last) {\n            return mService.get().removeTracks(first, last);\n        }\n        public int removeTrack(int id) {\n            return mService.get().removeTrack(id);\n        }\n        public void setRepeatMode(int repeatmode) {\n            mService.get().setRepeatMode(repeatmode);\n        }\n        public int getRepeatMode() {\n            return mService.get().getRepeatMode();\n        }\n        public int getMediaMountedCount() {\n            return mService.get().getMediaMountedCount();\n        }\n\n    }\n    \n    private final IBinder mBinder = new ServiceStub(this);\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.media.MediaPlayer;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.os.PowerManager.WakeLock;\nimport android.provider.MediaStore;\nimport android.telephony.PhoneStateListener;\nimport android.telephony.TelephonyManager;\nimport android.util.Log;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Provides \"background\" audio playback capabilities, allowing the\n * user to switch between activities without stopping playback.\n */\npublic class MediaPlaybackService extends Service {\n    /** used to specify whether enqueue() should start playing\n     * the new list of files right away, next or once all the currently\n     * queued files have been played\n     */\n    public static final int NOW = 1;\n    public static final int NEXT = 2;\n    public static final int LAST = 3;\n    public static final int PLAYBACKSERVICE_STATUS = 1;\n    \n    public static final int SHUFFLE_NONE = 0;\n    public static final int SHUFFLE_NORMAL = 1;\n    public static final int SHUFFLE_AUTO = 2;\n    \n    public static final int REPEAT_NONE = 0;\n    public static final int REPEAT_CURRENT = 1;\n    public static final int REPEAT_ALL = 2;\n\n    public static final String PLAYSTATE_CHANGED = \"com.android.music.playstatechanged\";\n    public static final String META_CHANGED = \"com.android.music.metachanged\";\n    public static final String QUEUE_CHANGED = \"com.android.music.queuechanged\";\n    public static final String PLAYBACK_COMPLETE = \"com.android.music.playbackcomplete\";\n    public static final String ASYNC_OPEN_COMPLETE = \"com.android.music.asyncopencomplete\";\n\n    public static final String SERVICECMD = \"com.android.music.musicservicecommand\";\n    public static final String CMDNAME = \"command\";\n    public static final String CMDTOGGLEPAUSE = \"togglepause\";\n    public static final String CMDSTOP = \"stop\";\n    public static final String CMDPAUSE = \"pause\";\n    public static final String CMDPREVIOUS = \"previous\";\n    public static final String CMDNEXT = \"next\";\n\n    public static final String TOGGLEPAUSE_ACTION = \"com.android.music.musicservicecommand.togglepause\";\n    public static final String PAUSE_ACTION = \"com.android.music.musicservicecommand.pause\";\n    public static final String PREVIOUS_ACTION = \"com.android.music.musicservicecommand.previous\";\n    public static final String NEXT_ACTION = \"com.android.music.musicservicecommand.next\";\n\n    private static final int TRACK_ENDED = 1;\n    private static final int RELEASE_WAKELOCK = 2;\n    private static final int SERVER_DIED = 3;\n    private static final int FADEIN = 4;\n    private static final int MAX_HISTORY_SIZE = 10;\n    \n    private MultiPlayer mPlayer;\n    private String mFileToPlay;\n    private int mShuffleMode = SHUFFLE_NONE;\n    private int mRepeatMode = REPEAT_NONE;\n    private int mMediaMountedCount = 0;\n    private int [] mAutoShuffleList = null;\n    private boolean mOneShot;\n    private int [] mPlayList = null;\n    private int mPlayListLen = 0;\n    private Vector<Integer> mHistory = new Vector<Integer>(MAX_HISTORY_SIZE);\n    private Cursor mCursor;\n    private int mPlayPos = -1;\n    private static final String LOGTAG = \"MediaPlaybackService\";\n    private final Shuffler mRand = new Shuffler();\n    private int mOpenFailedCounter = 0;\n    String[] mCursorCols = new String[] {\n            \"audio._id AS _id\",             // index must match IDCOLIDX below\n            MediaStore.Audio.Media.ARTIST,\n            MediaStore.Audio.Media.ALBUM,\n            MediaStore.Audio.Media.TITLE,\n            MediaStore.Audio.Media.DATA,\n            MediaStore.Audio.Media.MIME_TYPE,\n            MediaStore.Audio.Media.ALBUM_ID,\n            MediaStore.Audio.Media.ARTIST_ID,\n            MediaStore.Audio.Media.IS_PODCAST, // index must match PODCASTCOLIDX below\n            MediaStore.Audio.Media.BOOKMARK    // index must match BOOKMARKCOLIDX below\n    };\n    private final static int IDCOLIDX = 0;\n    private final static int PODCASTCOLIDX = 8;\n    private final static int BOOKMARKCOLIDX = 9;\n    private BroadcastReceiver mUnmountReceiver = null;\n    private WakeLock mWakeLock;\n    private int mServiceStartId = -1;\n    private boolean mServiceInUse = false;\n    private boolean mResumeAfterCall = false;\n    private boolean mIsSupposedToBePlaying = false;\n    private boolean mQuietMode = false;\n    \n    private SharedPreferences mPreferences;\n    // We use this to distinguish between different cards when saving/restoring playlists.\n    // This will have to change if we want to support multiple simultaneous cards.\n    private int mCardId;\n    \n    private MediaAppWidgetProvider mAppWidgetProvider = MediaAppWidgetProvider.getInstance();\n    \n    // interval after which we stop the service when idle\n    private static final int IDLE_DELAY = 60000; \n\n    private PhoneStateListener mPhoneStateListener = new PhoneStateListener() {\n        @Override\n        public void onCallStateChanged(int state, String incomingNumber) {\n            if (state == TelephonyManager.CALL_STATE_RINGING) {\n                AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\n                int ringvolume = audioManager.getStreamVolume(AudioManager.STREAM_RING);\n                if (ringvolume > 0) {\n                    mResumeAfterCall = (isPlaying() || mResumeAfterCall) && (getAudioId() >= 0);\n                    pause();\n                }\n            } else if (state == TelephonyManager.CALL_STATE_OFFHOOK) {\n                // pause the music while a conversation is in progress\n                mResumeAfterCall = (isPlaying() || mResumeAfterCall) && (getAudioId() >= 0);\n                pause();\n            } else if (state == TelephonyManager.CALL_STATE_IDLE) {\n                // start playing again\n                if (mResumeAfterCall) {\n                    // resume playback only if music was playing\n                    // when the call was answered\n                    startAndFadeIn();\n                    mResumeAfterCall = false;\n                }\n            }\n        }\n    };\n    \n    private void startAndFadeIn() {\n        mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n    }\n    \n    private Handler mMediaplayerHandler = new Handler() {\n        float mCurrentVolume = 1.0f;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case FADEIN:\n                    if (!isPlaying()) {\n                        mCurrentVolume = 0f;\n                        mPlayer.setVolume(mCurrentVolume);\n                        play();\n                        mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n                    } else {\n                        mCurrentVolume += 0.01f;\n                        if (mCurrentVolume < 1.0f) {\n                            mMediaplayerHandler.sendEmptyMessageDelayed(FADEIN, 10);\n                        } else {\n                            mCurrentVolume = 1.0f;\n                        }\n                        mPlayer.setVolume(mCurrentVolume);\n                    }\n                    break;\n                case SERVER_DIED:\n                    if (mIsSupposedToBePlaying) {\n                        next(true);\n                    } else {\n                        // the server died when we were idle, so just\n                        // reopen the same song (it will start again\n                        // from the beginning though when the user\n                        // restarts)\n                        openCurrent();\n                    }\n                    break;\n                case TRACK_ENDED:\n                    if (mRepeatMode == REPEAT_CURRENT) {\n                        seek(0);\n                        play();\n                    } else if (!mOneShot) {\n                        next(false);\n                    } else {\n                        notifyChange(PLAYBACK_COMPLETE);\n                        mIsSupposedToBePlaying = false;\n                    }\n                    break;\n                case RELEASE_WAKELOCK:\n                    mWakeLock.release();\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String cmd = intent.getStringExtra(\"command\");\n            if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n                next(true);\n            } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n                prev();\n            } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n                if (isPlaying()) {\n                    pause();\n                } else {\n                    play();\n                }\n            } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n                pause();\n            } else if (CMDSTOP.equals(cmd)) {\n                pause();\n                seek(0);\n            } else if (MediaAppWidgetProvider.CMDAPPWIDGETUPDATE.equals(cmd)) {\n                // Someone asked us to refresh a set of specific widgets, probably\n                // because they were just added.\n                int[] appWidgetIds = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);\n                mAppWidgetProvider.performUpdate(MediaPlaybackService.this, appWidgetIds);\n            }\n        }\n    };\n\n    public MediaPlaybackService() {\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        \n        mPreferences = getSharedPreferences(\"Music\", MODE_WORLD_READABLE | MODE_WORLD_WRITEABLE);\n        mCardId = FileUtils.getFatVolumeId(Environment.getExternalStorageDirectory().getPath());\n        \n        registerExternalStorageListener();\n\n        // Needs to be done in this thread, since otherwise ApplicationContext.getPowerManager() crashes.\n        mPlayer = new MultiPlayer();\n        mPlayer.setHandler(mMediaplayerHandler);\n\n        // Clear leftover notification in case this service previously got killed while playing\n        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n        nm.cancel(PLAYBACKSERVICE_STATUS);\n        \n        reloadQueue();\n        \n        IntentFilter commandFilter = new IntentFilter();\n        commandFilter.addAction(SERVICECMD);\n        commandFilter.addAction(TOGGLEPAUSE_ACTION);\n        commandFilter.addAction(PAUSE_ACTION);\n        commandFilter.addAction(NEXT_ACTION);\n        commandFilter.addAction(PREVIOUS_ACTION);\n        registerReceiver(mIntentReceiver, commandFilter);\n        \n        TelephonyManager tmgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n        tmgr.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);\n        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);\n        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, this.getClass().getName());\n        mWakeLock.setReferenceCounted(false);\n\n        // If the service was idle, but got killed before it stopped itself, the\n        // system will relaunch it. Make sure it gets stopped again in that case.\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n\n    @Override\n    public void onDestroy() {\n        // Check that we're not being destroyed while something is still playing.\n        if (isPlaying()) {\n            Log.e(\"MediaPlaybackService\", \"Service being destroyed while still playing.\");\n        }\n        // release all MediaPlayer resources, including the native player and wakelocks\n        mPlayer.release();\n        mPlayer = null;\n        \n        // make sure there aren't any other messages coming\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mMediaplayerHandler.removeCallbacksAndMessages(null);\n\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n\n        TelephonyManager tmgr = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n        tmgr.listen(mPhoneStateListener, 0);\n\n        unregisterReceiver(mIntentReceiver);\n        if (mUnmountReceiver != null) {\n            unregisterReceiver(mUnmountReceiver);\n            mUnmountReceiver = null;\n        }\n        mWakeLock.release();\n        super.onDestroy();\n    }\n    \n    private final char hexdigits [] = new char [] {\n            '0', '1', '2', '3',\n            '4', '5', '6', '7',\n            '8', '9', 'a', 'b',\n            'c', 'd', 'e', 'f'\n    };\n\n    private void saveQueue(boolean full) {\n        if (mOneShot) {\n            return;\n        }\n        Editor ed = mPreferences.edit();\n        //long start = System.currentTimeMillis();\n        if (full) {\n            StringBuilder q = new StringBuilder();\n            \n            // The current playlist is saved as a list of \"reverse hexadecimal\"\n            // numbers, which we can generate faster than normal decimal or\n            // hexadecimal numbers, which in turn allows us to save the playlist\n            // more often without worrying too much about performance.\n            // (saving the full state takes about 40 ms under no-load conditions\n            // on the phone)\n            int len = mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                int n = mPlayList[i];\n                if (n == 0) {\n                    q.append(\"0;\");\n                } else {\n                    while (n != 0) {\n                        int digit = n & 0xf;\n                        n >>= 4;\n                        q.append(hexdigits[digit]);\n                    }\n                    q.append(\";\");\n                }\n            }\n            //Log.i(\"@@@@ service\", \"created queue string in \" + (System.currentTimeMillis() - start) + \" ms\");\n            ed.putString(\"queue\", q.toString());\n            ed.putInt(\"cardid\", mCardId);\n        }\n        ed.putInt(\"curpos\", mPlayPos);\n        if (mPlayer.isInitialized()) {\n            ed.putLong(\"seekpos\", mPlayer.position());\n        }\n        ed.putInt(\"repeatmode\", mRepeatMode);\n        ed.putInt(\"shufflemode\", mShuffleMode);\n        ed.commit();\n  \n        //Log.i(\"@@@@ service\", \"saved state in \" + (System.currentTimeMillis() - start) + \" ms\");\n    }\n\n    private void reloadQueue() {\n        String q = null;\n        \n        boolean newstyle = false;\n        int id = mCardId;\n        if (mPreferences.contains(\"cardid\")) {\n            newstyle = true;\n            id = mPreferences.getInt(\"cardid\", ~mCardId);\n        }\n        if (id == mCardId) {\n            // Only restore the saved playlist if the card is still\n            // the same one as when the playlist was saved\n            q = mPreferences.getString(\"queue\", \"\");\n        }\n        int qlen = q != null ? q.length() : 0;\n        if (qlen > 1) {\n            //Log.i(\"@@@@ service\", \"loaded queue: \" + q);\n            int plen = 0;\n            int n = 0;\n            int shift = 0;\n            for (int i = 0; i < qlen; i++) {\n                char c = q.charAt(i);\n                if (c == ';') {\n                    ensurePlayListCapacity(plen + 1);\n                    mPlayList[plen] = n;\n                    plen++;\n                    n = 0;\n                    shift = 0;\n                } else {\n                    if (c >= '0' && c <= '9') {\n                        n += ((c - '0') << shift);\n                    } else if (c >= 'a' && c <= 'f') {\n                        n += ((10 + c - 'a') << shift);\n                    } else {\n                        // bogus playlist data\n                        plen = 0;\n                        break;\n                    }\n                    shift += 4;\n                }\n            }\n            mPlayListLen = plen;\n\n            int pos = mPreferences.getInt(\"curpos\", 0);\n            if (pos < 0 || pos >= mPlayListLen) {\n                // The saved playlist is bogus, discard it\n                mPlayListLen = 0;\n                return;\n            }\n            mPlayPos = pos;\n            \n            // When reloadQueue is called in response to a card-insertion,\n            // we might not be able to query the media provider right away.\n            // To deal with this, try querying for the current file, and if\n            // that fails, wait a while and try again. If that too fails,\n            // assume there is a problem and don't restore the state.\n            Cursor c = MusicUtils.query(this,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] {\"_id\"}, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            if (c == null || c.getCount() == 0) {\n                // wait a bit and try again\n                SystemClock.sleep(3000);\n                c = getContentResolver().query(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, \"_id=\" + mPlayList[mPlayPos] , null, null);\n            }\n            if (c != null) {\n                c.close();\n            }\n\n            // Make sure we don't auto-skip to the next song, since that\n            // also starts playback. What could happen in that case is:\n            // - music is paused\n            // - go to UMS and delete some files, including the currently playing one\n            // - come back from UMS\n            // (time passes)\n            // - music app is killed for some reason (out of memory)\n            // - music service is restarted, service restores state, doesn't find\n            //   the \"current\" file, goes to the next and: playback starts on its\n            //   own, potentially at some random inconvenient time.\n            mOpenFailedCounter = 20;\n            mQuietMode = true;\n            openCurrent();\n            mQuietMode = false;\n            if (!mPlayer.isInitialized()) {\n                // couldn't restore the saved state\n                mPlayListLen = 0;\n                return;\n            }\n            \n            long seekpos = mPreferences.getLong(\"seekpos\", 0);\n            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);\n            \n            int repmode = mPreferences.getInt(\"repeatmode\", REPEAT_NONE);\n            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {\n                repmode = REPEAT_NONE;\n            }\n            mRepeatMode = repmode;\n\n            int shufmode = mPreferences.getInt(\"shufflemode\", SHUFFLE_NONE);\n            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {\n                shufmode = SHUFFLE_NONE;\n            }\n            if (shufmode == SHUFFLE_AUTO) {\n                if (! makeAutoShuffleList()) {\n                    shufmode = SHUFFLE_NONE;\n                }\n            }\n            mShuffleMode = shufmode;\n        }\n    }\n    \n    @Override\n    public IBinder onBind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n        return mBinder;\n    }\n\n    @Override\n    public void onRebind(Intent intent) {\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        mServiceInUse = true;\n    }\n\n    @Override\n    public void onStart(Intent intent, int startId) {\n        mServiceStartId = startId;\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        \n        String action = intent.getAction();\n        String cmd = intent.getStringExtra(\"command\");\n        \n        if (CMDNEXT.equals(cmd) || NEXT_ACTION.equals(action)) {\n            next(true);\n        } else if (CMDPREVIOUS.equals(cmd) || PREVIOUS_ACTION.equals(action)) {\n            prev();\n        } else if (CMDTOGGLEPAUSE.equals(cmd) || TOGGLEPAUSE_ACTION.equals(action)) {\n            if (isPlaying()) {\n                pause();\n            } else {\n                play();\n            }\n        } else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {\n            pause();\n        } else if (CMDSTOP.equals(cmd)) {\n            pause();\n            seek(0);\n        }\n        \n        // make sure the service will shut down on its own if it was\n        // just started but not bound to and nothing is playing\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n    \n    @Override\n    public boolean onUnbind(Intent intent) {\n        mServiceInUse = false;\n\n        // Take a snapshot of the current playlist\n        saveQueue(true);\n\n        if (isPlaying() || mResumeAfterCall) {\n            // something is currently playing, or will be playing once \n            // an in-progress call ends, so don't stop the service now.\n            return true;\n        }\n        \n        // If there is a playlist but playback is paused, then wait a while\n        // before stopping the service, so that pause/resume isn't slow.\n        // Also delay stopping the service if we're transitioning between tracks.\n        if (mPlayListLen > 0  || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n            Message msg = mDelayedStopHandler.obtainMessage();\n            mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n            return true;\n        }\n        \n        // No active playlist, OK to stop the service right now\n        stopSelf(mServiceStartId);\n        return true;\n    }\n    \n    private Handler mDelayedStopHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            // Check again to make sure nothing is playing right now\n            if (isPlaying() || mResumeAfterCall || mServiceInUse\n                    || mMediaplayerHandler.hasMessages(TRACK_ENDED)) {\n                return;\n            }\n            // save the queue again, because it might have changed\n            // since the user exited the music app (because of\n            // party-shuffle or because the play-position changed)\n            saveQueue(true);\n            stopSelf(mServiceStartId);\n        }\n    };\n    \n    /**\n     * Called when we receive a ACTION_MEDIA_EJECT notification.\n     *\n     * @param storagePath path to mount point for the removed media\n     */\n    public void closeExternalStorageFiles(String storagePath) {\n        // stop playback and clean up if the SD card is going to be unmounted.\n        stop(true);\n        notifyChange(QUEUE_CHANGED);\n        notifyChange(META_CHANGED);\n    }\n\n    /**\n     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.\n     * The intent will call closeExternalStorageFiles() if the external media\n     * is going to be ejected, so applications can clean up any files they have open.\n     */\n    public void registerExternalStorageListener() {\n        if (mUnmountReceiver == null) {\n            mUnmountReceiver = new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    String action = intent.getAction();\n                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {\n                        saveQueue(true);\n                        mOneShot = true; // This makes us not save the state again later,\n                                         // which would be wrong because the song ids and\n                                         // card id might not match. \n                        closeExternalStorageFiles(intent.getData().getPath());\n                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n                        mMediaMountedCount++;\n                        mCardId = FileUtils.getFatVolumeId(intent.getData().getPath());\n                        reloadQueue();\n                        notifyChange(QUEUE_CHANGED);\n                        notifyChange(META_CHANGED);\n                    }\n                }\n            };\n            IntentFilter iFilter = new IntentFilter();\n            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);\n            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);\n            iFilter.addDataScheme(\"file\");\n            registerReceiver(mUnmountReceiver, iFilter);\n        }\n    }\n\n    /**\n     * Notify the change-receivers that something has changed.\n     * The intent that is sent contains the following data\n     * for the currently playing track:\n     * \"id\" - Integer: the database row ID\n     * \"artist\" - String: the name of the artist\n     * \"album\" - String: the name of the album\n     * \"track\" - String: the name of the track\n     * The intent has an action that is one of\n     * \"com.android.music.metachanged\"\n     * \"com.android.music.queuechanged\",\n     * \"com.android.music.playbackcomplete\"\n     * \"com.android.music.playstatechanged\"\n     * respectively indicating that a new track has\n     * started playing, that the playback queue has\n     * changed, that playback has stopped because\n     * the last file in the list has been played,\n     * or that the play-state changed (paused/resumed).\n     */\n    private void notifyChange(String what) {\n        \n        Intent i = new Intent(what);\n        i.putExtra(\"id\", Integer.valueOf(getAudioId()));\n        i.putExtra(\"artist\", getArtistName());\n        i.putExtra(\"album\",getAlbumName());\n        i.putExtra(\"track\", getTrackName());\n        sendBroadcast(i);\n        \n        if (what.equals(QUEUE_CHANGED)) {\n            saveQueue(true);\n        } else {\n            saveQueue(false);\n        }\n        \n        // Share this notification directly with our widgets\n        mAppWidgetProvider.notifyChange(this, what);\n    }\n\n    private void ensurePlayListCapacity(int size) {\n        if (mPlayList == null || size > mPlayList.length) {\n            // reallocate at 2x requested size so we don't\n            // need to grow and copy the array for every\n            // insert\n            int [] newlist = new int[size * 2];\n            int len = mPlayList != null ? mPlayList.length : mPlayListLen;\n            for (int i = 0; i < len; i++) {\n                newlist[i] = mPlayList[i];\n            }\n            mPlayList = newlist;\n        }\n        // FIXME: shrink the array when the needed size is much smaller\n        // than the allocated size\n    }\n    \n    // insert the list of songs at the specified position in the playlist\n    private void addToPlayList(int [] list, int position) {\n        int addlen = list.length;\n        if (position < 0) { // overwrite\n            mPlayListLen = 0;\n            position = 0;\n        }\n        ensurePlayListCapacity(mPlayListLen + addlen);\n        if (position > mPlayListLen) {\n            position = mPlayListLen;\n        }\n        \n        // move part of list after insertion point\n        int tailsize = mPlayListLen - position;\n        for (int i = tailsize ; i > 0 ; i--) {\n            mPlayList[position + i] = mPlayList[position + i - addlen]; \n        }\n        \n        // copy list into playlist\n        for (int i = 0; i < addlen; i++) {\n            mPlayList[position + i] = list[i];\n        }\n        mPlayListLen += addlen;\n    }\n    \n    /**\n     * Appends a list of tracks to the current playlist.\n     * If nothing is playing currently, playback will be started at\n     * the first track.\n     * If the action is NOW, playback will switch to the first of\n     * the new tracks immediately.\n     * @param list The list of tracks to append.\n     * @param action NOW, NEXT or LAST\n     */\n    public void enqueue(int [] list, int action) {\n        synchronized(this) {\n            if (action == NEXT && mPlayPos + 1 < mPlayListLen) {\n                addToPlayList(list, mPlayPos + 1);\n                notifyChange(QUEUE_CHANGED);\n            } else {\n                // action == LAST || action == NOW || mPlayPos + 1 == mPlayListLen\n                addToPlayList(list, Integer.MAX_VALUE);\n                notifyChange(QUEUE_CHANGED);\n                if (action == NOW) {\n                    mPlayPos = mPlayListLen - list.length;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                }\n            }\n            if (mPlayPos < 0) {\n                mPlayPos = 0;\n                openCurrent();\n                play();\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n\n    /**\n     * Replaces the current playlist with a new list,\n     * and prepares for starting playback at the specified\n     * position in the list, or a random position if the\n     * specified position is 0.\n     * @param list The new list of tracks.\n     */\n    public void open(int [] list, int position) {\n        synchronized (this) {\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                mShuffleMode = SHUFFLE_NORMAL;\n            }\n            int oldId = getAudioId();\n            int listlength = list.length;\n            boolean newlist = true;\n            if (mPlayListLen == listlength) {\n                // possible fast path: list might be the same\n                newlist = false;\n                for (int i = 0; i < listlength; i++) {\n                    if (list[i] != mPlayList[i]) {\n                        newlist = true;\n                        break;\n                    }\n                }\n            }\n            if (newlist) {\n                addToPlayList(list, -1);\n                notifyChange(QUEUE_CHANGED);\n            }\n            int oldpos = mPlayPos;\n            if (position >= 0) {\n                mPlayPos = position;\n            } else {\n                mPlayPos = mRand.nextInt(mPlayListLen);\n            }\n            mHistory.clear();\n\n            saveBookmarkIfNeeded();\n            openCurrent();\n            if (oldId != getAudioId()) {\n                notifyChange(META_CHANGED);\n            }\n        }\n    }\n    \n    /**\n     * Moves the item at index1 to index2.\n     * @param index1\n     * @param index2\n     */\n    public void moveQueueItem(int index1, int index2) {\n        synchronized (this) {\n            if (index1 >= mPlayListLen) {\n                index1 = mPlayListLen - 1;\n            }\n            if (index2 >= mPlayListLen) {\n                index2 = mPlayListLen - 1;\n            }\n            if (index1 < index2) {\n                int tmp = mPlayList[index1];\n                for (int i = index1; i < index2; i++) {\n                    mPlayList[i] = mPlayList[i+1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index1 && mPlayPos <= index2) {\n                        mPlayPos--;\n                }\n            } else if (index2 < index1) {\n                int tmp = mPlayList[index1];\n                for (int i = index1; i > index2; i--) {\n                    mPlayList[i] = mPlayList[i-1];\n                }\n                mPlayList[index2] = tmp;\n                if (mPlayPos == index1) {\n                    mPlayPos = index2;\n                } else if (mPlayPos >= index2 && mPlayPos <= index1) {\n                        mPlayPos++;\n                }\n            }\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    /**\n     * Returns the current play list\n     * @return An array of integers containing the IDs of the tracks in the play list\n     */\n    public int [] getQueue() {\n        synchronized (this) {\n            int len = mPlayListLen;\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                list[i] = mPlayList[i];\n            }\n            return list;\n        }\n    }\n\n    private void openCurrent() {\n        synchronized (this) {\n            if (mCursor != null) {\n                mCursor.close();\n                mCursor = null;\n            }\n            if (mPlayListLen == 0) {\n                return;\n            }\n            stop(false);\n\n            String id = String.valueOf(mPlayList[mPlayPos]);\n            \n            mCursor = getContentResolver().query(\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCursorCols, \"_id=\" + id , null, null);\n            if (mCursor != null) {\n                mCursor.moveToFirst();\n                open(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + \"/\" + id, false);\n                // go to bookmark if needed\n                if (isPodcast()) {\n                    long bookmark = getBookmark();\n                    // Start playing a little bit before the bookmark,\n                    // so it's easier to get back in to the narrative.\n                    seek(bookmark - 5000);\n                }\n            }\n        }\n    }\n\n    public void openAsync(String path) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            mRepeatMode = REPEAT_NONE;\n            ensurePlayListCapacity(1);\n            mPlayListLen = 1;\n            mPlayPos = -1;\n            \n            mFileToPlay = path;\n            mCursor = null;\n            mPlayer.setDataSourceAsync(mFileToPlay);\n            mOneShot = true;\n        }\n    }\n    \n    /**\n     * Opens the specified file and readies it for playback.\n     *\n     * @param path The full path of the file to be opened.\n     * @param oneshot when set to true, playback will stop after this file completes, instead\n     * of moving on to the next track in the list \n     */\n    public void open(String path, boolean oneshot) {\n        synchronized (this) {\n            if (path == null) {\n                return;\n            }\n            \n            if (oneshot) {\n                mRepeatMode = REPEAT_NONE;\n                ensurePlayListCapacity(1);\n                mPlayListLen = 1;\n                mPlayPos = -1;\n            }\n            \n            // if mCursor is null, try to associate path with a database cursor\n            if (mCursor == null) {\n\n                ContentResolver resolver = getContentResolver();\n                Uri uri;\n                String where;\n                String selectionArgs[];\n                if (path.startsWith(\"content://media/\")) {\n                    uri = Uri.parse(path);\n                    where = null;\n                    selectionArgs = null;\n                } else {\n                   uri = MediaStore.Audio.Media.getContentUriForPath(path);\n                   where = MediaStore.Audio.Media.DATA + \"=?\";\n                   selectionArgs = new String[] { path };\n                }\n                \n                try {\n                    mCursor = resolver.query(uri, mCursorCols, where, selectionArgs, null);\n                    if  (mCursor != null) {\n                        if (mCursor.getCount() == 0) {\n                            mCursor.close();\n                            mCursor = null;\n                        } else {\n                            mCursor.moveToNext();\n                            ensurePlayListCapacity(1);\n                            mPlayListLen = 1;\n                            mPlayList[0] = mCursor.getInt(IDCOLIDX);\n                            mPlayPos = 0;\n                        }\n                    }\n                } catch (UnsupportedOperationException ex) {\n                }\n            }\n            mFileToPlay = path;\n            mPlayer.setDataSource(mFileToPlay);\n            mOneShot = oneshot;\n            if (! mPlayer.isInitialized()) {\n                stop(true);\n                if (mOpenFailedCounter++ < 10 &&  mPlayListLen > 1) {\n                    // beware: this ends up being recursive because next() calls open() again.\n                    next(false);\n                }\n                if (! mPlayer.isInitialized() && mOpenFailedCounter != 0) {\n                    // need to make sure we only shows this once\n                    mOpenFailedCounter = 0;\n                    if (!mQuietMode) {\n                        Toast.makeText(this, R.string.playback_failed, Toast.LENGTH_SHORT).show();\n                    }\n                }\n            } else {\n                mOpenFailedCounter = 0;\n            }\n        }\n    }\n\n    /**\n     * Starts playback of a previously opened file.\n     */\n    public void play() {\n        if (mPlayer.isInitialized()) {\n            // if we are at the end of the song, go to the next song first\n            long duration = mPlayer.duration();\n            if (mRepeatMode != REPEAT_CURRENT && duration > 2000 &&\n                mPlayer.position() >= duration - 2000) {\n                next(true);\n            }\n\n            mPlayer.start();\n            setForeground(true);\n\n            NotificationManager nm = (NotificationManager)\n            getSystemService(Context.NOTIFICATION_SERVICE);\n    \n            RemoteViews views = new RemoteViews(getPackageName(), R.layout.statusbar);\n            views.setImageViewResource(R.id.icon, R.drawable.stat_notify_musicplayer);\n            if (getAudioId() < 0) {\n                // streaming\n                views.setTextViewText(R.id.trackname, getPath());\n                views.setTextViewText(R.id.artistalbum, null);\n            } else {\n                String artist = getArtistName();\n                views.setTextViewText(R.id.trackname, getTrackName());\n                if (artist == null || artist.equals(MediaFile.UNKNOWN_STRING)) {\n                    artist = getString(R.string.unknown_artist_name);\n                }\n                String album = getAlbumName();\n                if (album == null || album.equals(MediaFile.UNKNOWN_STRING)) {\n                    album = getString(R.string.unknown_album_name);\n                }\n                \n                views.setTextViewText(R.id.artistalbum,\n                        getString(R.string.notification_artist_album, artist, album)\n                        );\n            }\n            \n            Notification status = new Notification();\n            status.contentView = views;\n            status.flags |= Notification.FLAG_ONGOING_EVENT;\n            status.icon = R.drawable.stat_notify_musicplayer;\n            status.contentIntent = PendingIntent.getActivity(this, 0,\n                    new Intent(\"com.android.music.PLAYBACK_VIEWER\"), 0);\n            nm.notify(PLAYBACKSERVICE_STATUS, status);\n            if (!mIsSupposedToBePlaying) {\n                notifyChange(PLAYSTATE_CHANGED);\n            }\n            mIsSupposedToBePlaying = true;\n        } else if (mPlayListLen <= 0) {\n            // This is mostly so that if you press 'play' on a bluetooth headset\n            // without every having played anything before, it will still play\n            // something.\n            setShuffleMode(SHUFFLE_AUTO);\n        }\n    }\n    \n    private void stop(boolean remove_status_icon) {\n        if (mPlayer.isInitialized()) {\n            mPlayer.stop();\n        }\n        mFileToPlay = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n        if (remove_status_icon) {\n            gotoIdleState();\n        }\n        setForeground(false);\n        if (remove_status_icon) {\n            mIsSupposedToBePlaying = false;\n        }\n    }\n\n    /**\n     * Stops playback.\n     */\n    public void stop() {\n        stop(true);\n    }\n\n    /**\n     * Pauses playback (call play() to resume)\n     */\n    public void pause() {\n        synchronized(this) {\n            if (isPlaying()) {\n                mPlayer.pause();\n                gotoIdleState();\n                setForeground(false);\n                mIsSupposedToBePlaying = false;\n                notifyChange(PLAYSTATE_CHANGED);\n                saveBookmarkIfNeeded();\n            }\n        }\n    }\n\n    /** Returns whether something is currently playing\n     *\n     * @return true if something is playing (or will be playing shortly, in case\n     * we're currently transitioning between tracks), false if not.\n     */\n    public boolean isPlaying() {\n        return mIsSupposedToBePlaying;\n    }\n\n    /*\n      Desired behavior for prev/next/shuffle:\n\n      - NEXT will move to the next track in the list when not shuffling, and to\n        a track randomly picked from the not-yet-played tracks when shuffling.\n        If all tracks have already been played, pick from the full set, but\n        avoid picking the previously played track if possible.\n      - when shuffling, PREV will go to the previously played track. Hitting PREV\n        again will go to the track played before that, etc. When the start of the\n        history has been reached, PREV is a no-op.\n        When not shuffling, PREV will go to the sequentially previous track (the\n        difference with the shuffle-case is mainly that when not shuffling, the\n        user can back up to tracks that are not in the history).\n\n        Example:\n        When playing an album with 10 tracks from the start, and enabling shuffle\n        while playing track 5, the remaining tracks (6-10) will be shuffled, e.g.\n        the final play order might be 1-2-3-4-5-8-10-6-9-7.\n        When hitting 'prev' 8 times while playing track 7 in this example, the\n        user will go to tracks 9-6-10-8-5-4-3-2. If the user then hits 'next',\n        a random track will be picked again. If at any time user disables shuffling\n        the next/previous track will be picked in sequential order again.\n     */\n\n    public void prev() {\n        synchronized (this) {\n            if (mOneShot) {\n                // we were playing a specific file not part of a playlist, so there is no 'previous'\n                seek(0);\n                play();\n                return;\n            }\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // go to previously-played track and remove it from the history\n                int histsize = mHistory.size();\n                if (histsize == 0) {\n                    // prev is a no-op\n                    return;\n                }\n                Integer pos = mHistory.remove(histsize - 1);\n                mPlayPos = pos.intValue();\n            } else {\n                if (mPlayPos > 0) {\n                    mPlayPos--;\n                } else {\n                    mPlayPos = mPlayListLen - 1;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public void next(boolean force) {\n        synchronized (this) {\n            if (mOneShot) {\n                // we were playing a specific file not part of a playlist, so there is no 'next'\n                seek(0);\n                play();\n                return;\n            }\n\n            if (mPlayListLen <= 0) {\n                return;\n            }\n\n            // Store the current file in the history, but keep the history at a\n            // reasonable size\n            if (mPlayPos >= 0) {\n                mHistory.add(Integer.valueOf(mPlayPos));\n            }\n            if (mHistory.size() > MAX_HISTORY_SIZE) {\n                mHistory.removeElementAt(0);\n            }\n\n            if (mShuffleMode == SHUFFLE_NORMAL) {\n                // Pick random next track from the not-yet-played ones\n                // TODO: make it work right after adding/removing items in the queue.\n\n                int numTracks = mPlayListLen;\n                int[] tracks = new int[numTracks];\n                for (int i=0;i < numTracks; i++) {\n                    tracks[i] = i;\n                }\n\n                int numHistory = mHistory.size();\n                int numUnplayed = numTracks;\n                for (int i=0;i < numHistory; i++) {\n                    int idx = mHistory.get(i).intValue();\n                    if (idx < numTracks && tracks[idx] >= 0) {\n                        numUnplayed--;\n                        tracks[idx] = -1;\n                    }\n                }\n\n                // 'numUnplayed' now indicates how many tracks have not yet\n                // been played, and 'tracks' contains the indices of those\n                // tracks.\n                if (numUnplayed <=0) {\n                    // everything's already been played\n                    if (mRepeatMode == REPEAT_ALL || force) {\n                        //pick from full set\n                        numUnplayed = numTracks;\n                        for (int i=0;i < numTracks; i++) {\n                            tracks[i] = i;\n                        }\n                    } else {\n                        // all done\n                        gotoIdleState();\n                        return;\n                    }\n                }\n                int skip = mRand.nextInt(numUnplayed);\n                int cnt = -1;\n                while (true) {\n                    while (tracks[++cnt] < 0)\n                        ;\n                    skip--;\n                    if (skip < 0) {\n                        break;\n                    }\n                }\n                mPlayPos = cnt;\n            } else if (mShuffleMode == SHUFFLE_AUTO) {\n                doAutoShuffleUpdate();\n                mPlayPos++;\n            } else {\n                if (mPlayPos >= mPlayListLen - 1) {\n                    // we're at the end of the list\n                    if (mRepeatMode == REPEAT_NONE && !force) {\n                        // all done\n                        gotoIdleState();\n                        notifyChange(PLAYBACK_COMPLETE);\n                        mIsSupposedToBePlaying = false;\n                        return;\n                    } else if (mRepeatMode == REPEAT_ALL || force) {\n                        mPlayPos = 0;\n                    }\n                } else {\n                    mPlayPos++;\n                }\n            }\n            saveBookmarkIfNeeded();\n            stop(false);\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n    \n    private void gotoIdleState() {\n        NotificationManager nm =\n            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n        nm.cancel(PLAYBACKSERVICE_STATUS);\n        mDelayedStopHandler.removeCallbacksAndMessages(null);\n        Message msg = mDelayedStopHandler.obtainMessage();\n        mDelayedStopHandler.sendMessageDelayed(msg, IDLE_DELAY);\n    }\n    \n    private void saveBookmarkIfNeeded() {\n        try {\n            if (isPodcast()) {\n                long pos = position();\n                long bookmark = getBookmark();\n                long duration = duration();\n                if ((pos < bookmark && (pos + 10000) > bookmark) ||\n                        (pos > bookmark && (pos - 10000) < bookmark)) {\n                    // The existing bookmark is close to the current\n                    // position, so don't update it.\n                    return;\n                }\n                if (pos < 15000 || (pos + 10000) > duration) {\n                    // if we're near the start or end, clear the bookmark\n                    pos = 0;\n                }\n                \n                // write 'pos' to the bookmark field\n                ContentValues values = new ContentValues();\n                values.put(MediaStore.Audio.Media.BOOKMARK, pos);\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursor.getLong(IDCOLIDX));\n                getContentResolver().update(uri, values, null, null);\n            }\n        } catch (SQLiteException ex) {\n        }\n    }\n\n    // Make sure there are at least 5 items after the currently playing item\n    // and no more than 10 items before.\n    private void doAutoShuffleUpdate() {\n        boolean notify = false;\n        // remove old entries\n        if (mPlayPos > 10) {\n            removeTracks(0, mPlayPos - 9);\n            notify = true;\n        }\n        // add new entries if needed\n        int to_add = 7 - (mPlayListLen - (mPlayPos < 0 ? -1 : mPlayPos));\n        for (int i = 0; i < to_add; i++) {\n            // pick something at random from the list\n            int idx = mRand.nextInt(mAutoShuffleList.length);\n            Integer which = mAutoShuffleList[idx];\n            ensurePlayListCapacity(mPlayListLen + 1);\n            mPlayList[mPlayListLen++] = which;\n            notify = true;\n        }\n        if (notify) {\n            notifyChange(QUEUE_CHANGED);\n        }\n    }\n\n    // A simple variation of Random that makes sure that the\n    // value it returns is not equal to the value it returned\n    // previously, unless the interval is 1.\n    private static class Shuffler {\n        private int mPrevious;\n        private Random mRandom = new Random();\n        public int nextInt(int interval) {\n            int ret;\n            do {\n                ret = mRandom.nextInt(interval);\n            } while (ret == mPrevious && interval > 1);\n            mPrevious = ret;\n            return ret;\n        }\n    };\n\n    private boolean makeAutoShuffleList() {\n        ContentResolver res = getContentResolver();\n        Cursor c = null;\n        try {\n            c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                    null, null);\n            if (c == null || c.getCount() == 0) {\n                return false;\n            }\n            int len = c.getCount();\n            int[] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getInt(0);\n            }\n            mAutoShuffleList = list;\n            return true;\n        } catch (RuntimeException ex) {\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Removes the range of tracks specified from the play list. If a file within the range is\n     * the file currently being played, playback will move to the next file after the\n     * range. \n     * @param first The first file to be removed\n     * @param last The last file to be removed\n     * @return the number of tracks deleted\n     */\n    public int removeTracks(int first, int last) {\n        int numremoved = removeTracksInternal(first, last);\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    private int removeTracksInternal(int first, int last) {\n        synchronized (this) {\n            if (last < first) return 0;\n            if (first < 0) first = 0;\n            if (last >= mPlayListLen) last = mPlayListLen - 1;\n\n            boolean gotonext = false;\n            if (first <= mPlayPos && mPlayPos <= last) {\n                mPlayPos = first;\n                gotonext = true;\n            } else if (mPlayPos > last) {\n                mPlayPos -= (last - first + 1);\n            }\n            int num = mPlayListLen - last - 1;\n            for (int i = 0; i < num; i++) {\n                mPlayList[first + i] = mPlayList[last + 1 + i];\n            }\n            mPlayListLen -= last - first + 1;\n            \n            if (gotonext) {\n                if (mPlayListLen == 0) {\n                    stop(true);\n                    mPlayPos = -1;\n                } else {\n                    if (mPlayPos >= mPlayListLen) {\n                        mPlayPos = 0;\n                    }\n                    boolean wasPlaying = isPlaying();\n                    stop(false);\n                    openCurrent();\n                    if (wasPlaying) {\n                        play();\n                    }\n                }\n            }\n            return last - first + 1;\n        }\n    }\n    \n    /**\n     * Removes all instances of the track with the given id\n     * from the playlist.\n     * @param id The id to be removed\n     * @return how many instances of the track were removed\n     */\n    public int removeTrack(int id) {\n        int numremoved = 0;\n        synchronized (this) {\n            for (int i = 0; i < mPlayListLen; i++) {\n                if (mPlayList[i] == id) {\n                    numremoved += removeTracksInternal(i, i);\n                    i--;\n                }\n            }\n        }\n        if (numremoved > 0) {\n            notifyChange(QUEUE_CHANGED);\n        }\n        return numremoved;\n    }\n    \n    public void setShuffleMode(int shufflemode) {\n        synchronized(this) {\n            if (mShuffleMode == shufflemode && mPlayListLen > 0) {\n                return;\n            }\n            mShuffleMode = shufflemode;\n            if (mShuffleMode == SHUFFLE_AUTO) {\n                if (makeAutoShuffleList()) {\n                    mPlayListLen = 0;\n                    doAutoShuffleUpdate();\n                    mPlayPos = 0;\n                    openCurrent();\n                    play();\n                    notifyChange(META_CHANGED);\n                    return;\n                } else {\n                    // failed to build a list of files to shuffle\n                    mShuffleMode = SHUFFLE_NONE;\n                }\n            }\n            saveQueue(false);\n        }\n    }\n    public int getShuffleMode() {\n        return mShuffleMode;\n    }\n    \n    public void setRepeatMode(int repeatmode) {\n        synchronized(this) {\n            mRepeatMode = repeatmode;\n            saveQueue(false);\n        }\n    }\n    public int getRepeatMode() {\n        return mRepeatMode;\n    }\n\n    public int getMediaMountedCount() {\n        return mMediaMountedCount;\n    }\n\n    /**\n     * Returns the path of the currently playing file, or null if\n     * no file is currently playing.\n     */\n    public String getPath() {\n        return mFileToPlay;\n    }\n    \n    /**\n     * Returns the rowid of the currently playing file, or -1 if\n     * no file is currently playing.\n     */\n    public int getAudioId() {\n        synchronized (this) {\n            if (mPlayPos >= 0 && mPlayer.isInitialized()) {\n                return mPlayList[mPlayPos];\n            }\n        }\n        return -1;\n    }\n    \n    /**\n     * Returns the position in the queue \n     * @return the position in the queue\n     */\n    public int getQueuePosition() {\n        synchronized(this) {\n            return mPlayPos;\n        }\n    }\n    \n    /**\n     * Starts playing the track at the given position in the queue.\n     * @param pos The position in the queue of the track that will be played.\n     */\n    public void setQueuePosition(int pos) {\n        synchronized(this) {\n            stop(false);\n            mPlayPos = pos;\n            openCurrent();\n            play();\n            notifyChange(META_CHANGED);\n        }\n    }\n\n    public String getArtistName() {\n        synchronized(this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));\n        }\n    }\n    \n    public int getArtistId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID));\n        }\n    }\n\n    public String getAlbumName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM));\n        }\n    }\n\n    public int getAlbumId() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return -1;\n            }\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID));\n        }\n    }\n\n    public String getTrackName() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return null;\n            }\n            return mCursor.getString(mCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));\n        }\n    }\n\n    private boolean isPodcast() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return false;\n            }\n            return (mCursor.getInt(PODCASTCOLIDX) > 0);\n        }\n    }\n    \n    private long getBookmark() {\n        synchronized (this) {\n            if (mCursor == null) {\n                return 0;\n            }\n            return mCursor.getLong(BOOKMARKCOLIDX);\n        }\n    }\n    \n    /**\n     * Returns the duration of the file in milliseconds.\n     * Currently this method returns -1 for the duration of MIDI files.\n     */\n    public long duration() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.duration();\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the current playback position in milliseconds\n     */\n    public long position() {\n        if (mPlayer.isInitialized()) {\n            return mPlayer.position();\n        }\n        return -1;\n    }\n\n    /**\n     * Seeks to the position specified.\n     *\n     * @param pos The position to seek to, in milliseconds\n     */\n    public long seek(long pos) {\n        if (mPlayer.isInitialized()) {\n            if (pos < 0) pos = 0;\n            if (pos > mPlayer.duration()) pos = mPlayer.duration();\n            return mPlayer.seek(pos);\n        }\n        return -1;\n    }\n\n    /**\n     * Provides a unified interface for dealing with midi files and\n     * other media files.\n     */\n    private class MultiPlayer {\n        private MediaPlayer mMediaPlayer = new MediaPlayer();\n        private Handler mHandler;\n        private boolean mIsInitialized = false;\n\n        public MultiPlayer() {\n            mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n        }\n\n        public void setDataSourceAsync(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setDataSource(path);\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.setOnPreparedListener(preparedlistener);\n                mMediaPlayer.prepareAsync();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            \n            mIsInitialized = true;\n        }\n        \n        public void setDataSource(String path) {\n            try {\n                mMediaPlayer.reset();\n                mMediaPlayer.setOnPreparedListener(null);\n                if (path.startsWith(\"content://\")) {\n                    mMediaPlayer.setDataSource(MediaPlaybackService.this, Uri.parse(path));\n                } else {\n                    mMediaPlayer.setDataSource(path);\n                }\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.prepare();\n            } catch (IOException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            } catch (IllegalArgumentException ex) {\n                // TODO: notify the user why the file couldn't be opened\n                mIsInitialized = false;\n                return;\n            }\n            mMediaPlayer.setOnCompletionListener(listener);\n            mMediaPlayer.setOnErrorListener(errorListener);\n            \n            mIsInitialized = true;\n        }\n        \n        public boolean isInitialized() {\n            return mIsInitialized;\n        }\n\n        public void start() {\n            mMediaPlayer.start();\n        }\n\n        public void stop() {\n            mMediaPlayer.reset();\n            mIsInitialized = false;\n        }\n\n        /**\n         * You CANNOT use this player anymore after calling release()\n         */\n        public void release() {\n            stop();\n            mMediaPlayer.release();\n        }\n        \n        public void pause() {\n            mMediaPlayer.pause();\n        }\n        \n        public void setHandler(Handler handler) {\n            mHandler = handler;\n        }\n\n        MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener() {\n            public void onCompletion(MediaPlayer mp) {\n                // Acquire a temporary wakelock, since when we return from\n                // this callback the MediaPlayer will release its wakelock\n                // and allow the device to go to sleep.\n                // This temporary wakelock is released when the RELEASE_WAKELOCK\n                // message is processed, but just in case, put a timeout on it.\n                mWakeLock.acquire(30000);\n                mHandler.sendEmptyMessage(TRACK_ENDED);\n                mHandler.sendEmptyMessage(RELEASE_WAKELOCK);\n            }\n        };\n\n        MediaPlayer.OnPreparedListener preparedlistener = new MediaPlayer.OnPreparedListener() {\n            public void onPrepared(MediaPlayer mp) {\n                notifyChange(ASYNC_OPEN_COMPLETE);\n            }\n        };\n \n        MediaPlayer.OnErrorListener errorListener = new MediaPlayer.OnErrorListener() {\n            public boolean onError(MediaPlayer mp, int what, int extra) {\n                switch (what) {\n                case MediaPlayer.MEDIA_ERROR_SERVER_DIED:\n                    mIsInitialized = false;\n                    mMediaPlayer.release();\n                    // Creating a new MediaPlayer and settings its wakemode does not\n                    // require the media service, so it's OK to do this now, while the\n                    // service is still being restarted\n                    mMediaPlayer = new MediaPlayer(); \n                    mMediaPlayer.setWakeMode(MediaPlaybackService.this, PowerManager.PARTIAL_WAKE_LOCK);\n                    mHandler.sendMessageDelayed(mHandler.obtainMessage(SERVER_DIED), 2000);\n                    return true;\n                default:\n                    break;\n                }\n                return false;\n           }\n        };\n\n        public long duration() {\n            return mMediaPlayer.getDuration();\n        }\n\n        public long position() {\n            return mMediaPlayer.getCurrentPosition();\n        }\n\n        public long seek(long whereto) {\n            mMediaPlayer.seekTo((int) whereto);\n            return whereto;\n        }\n\n        public void setVolume(float vol) {\n            mMediaPlayer.setVolume(vol, vol);\n        }\n    }\n\n    /*\n     * By making this a static class with a WeakReference to the Service, we\n     * ensure that the Service can be GCd even when the system process still\n     * has a remote reference to the stub.\n     */\n    static class ServiceStub extends IMediaPlaybackService.Stub {\n        WeakReference<MediaPlaybackService> mService;\n        \n        ServiceStub(MediaPlaybackService service) {\n            mService = new WeakReference<MediaPlaybackService>(service);\n        }\n\n        public void openFileAsync(String path)\n        {\n            mService.get().openAsync(path);\n        }\n        public void openFile(String path, boolean oneShot)\n        {\n            mService.get().open(path, oneShot);\n        }\n        public void open(int [] list, int position) {\n            mService.get().open(list, position);\n        }\n        public int getQueuePosition() {\n            return mService.get().getQueuePosition();\n        }\n        public void setQueuePosition(int index) {\n            mService.get().setQueuePosition(index);\n        }\n        public boolean isPlaying() {\n            return mService.get().isPlaying();\n        }\n        public void stop() {\n            mService.get().stop();\n        }\n        public void pause() {\n            mService.get().pause();\n        }\n        public void play() {\n            mService.get().play();\n        }\n        public void prev() {\n            mService.get().prev();\n        }\n        public void next() {\n            mService.get().next(true);\n        }\n        public String getTrackName() {\n            return mService.get().getTrackName();\n        }\n        public String getAlbumName() {\n            return mService.get().getAlbumName();\n        }\n        public int getAlbumId() {\n            return mService.get().getAlbumId();\n        }\n        public String getArtistName() {\n            return mService.get().getArtistName();\n        }\n        public int getArtistId() {\n            return mService.get().getArtistId();\n        }\n        public void enqueue(int [] list , int action) {\n            mService.get().enqueue(list, action);\n        }\n        public int [] getQueue() {\n            return mService.get().getQueue();\n        }\n        public void moveQueueItem(int from, int to) {\n            mService.get().moveQueueItem(from, to);\n        }\n        public String getPath() {\n            return mService.get().getPath();\n        }\n        public int getAudioId() {\n            return mService.get().getAudioId();\n        }\n        public long position() {\n            return mService.get().position();\n        }\n        public long duration() {\n            return mService.get().duration();\n        }\n        public long seek(long pos) {\n            return mService.get().seek(pos);\n        }\n        public void setShuffleMode(int shufflemode) {\n            mService.get().setShuffleMode(shufflemode);\n        }\n        public int getShuffleMode() {\n            return mService.get().getShuffleMode();\n        }\n        public int removeTracks(int first, int last) {\n            return mService.get().removeTracks(first, last);\n        }\n        public int removeTrack(int id) {\n            return mService.get().removeTrack(id);\n        }\n        public void setRepeatMode(int repeatmode) {\n            mService.get().setRepeatMode(repeatmode);\n        }\n        public int getRepeatMode() {\n            return mService.get().getRepeatMode();\n        }\n        public int getMediaMountedCount() {\n            return mService.get().getMediaMountedCount();\n        }\n\n    }\n    \n    private final IBinder mBinder = new ServiceStub(this);\n}\n","lineNo":979}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mDeviceHasNoDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasNoDpad = (getResources().getConfiguration().navigation != \n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n        } catch (RemoteException ex) {\n            return true;\n        }\n        \n        boolean knownartist =\n            (artist != null) && !MediaFile.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaFile.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0 && !mOneShot) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", getString(R.string.delete_song_desc,\n                                mService.getTrackName()));\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                if (! ContentResolver.SCHEME_CONTENT.equals(scheme) ||\n                        ! MediaStore.AUTHORITY.equals(uri.getAuthority())) {\n                    mOneShot = true;\n                }\n                mService.stop();\n                mService.openFile(filename, mOneShot);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mDeviceHasNoDpad;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (ImageView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mDeviceHasNoDpad = (getResources().getConfiguration().navigation != \n            Configuration.NAVIGATION_DPAD);\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n        } catch (RemoteException ex) {\n            return true;\n        }\n        \n        boolean knownartist =\n            (artist != null) && !MediaFile.UNKNOWN_STRING.equals(artist);\n\n        boolean knownalbum =\n            (album != null) && !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist;\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            if ((song == null) || MediaFile.UNKNOWN_STRING.equals(song)) {\n                // A popup of the form \"Search for null/'' using ...\" is pretty\n                // unhelpful, plus, we won't find any way to buy it anyway.\n                return true;\n            }\n\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n            mFromTouch = true;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromuser) {\n            if (!fromuser || (mService == null)) return;\n            long now = SystemClock.elapsedRealtime();\n            if ((now - mLastSeekEventTime) > 250) {\n                mLastSeekEventTime = now;\n                mPosOverride = mDuration * progress / 1000;\n                try {\n                    mService.seek(mPosOverride);\n                } catch (RemoteException ex) {\n                }\n\n                // trackball event, allow progress updates\n                if (!mFromTouch) {\n                    refreshNow();\n                    mPosOverride = -1;\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n            mFromTouch = false;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        mService = null;\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, or\n        // if we're in one shot mode. In most cases, these menu items are not\n        // useful in those modes, so for consistency we never show them in these\n        // modes, instead of tailoring them to the specific file being played.\n        if (MusicUtils.getCurrentAudioId() >= 0 && !mOneShot) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n            menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", getString(R.string.delete_song_desc,\n                                mService.getTrackName()));\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mDeviceHasNoDpad) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mDeviceHasNoDpad) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                if (! ContentResolver.SCHEME_CONTENT.equals(scheme) ||\n                        ! MediaStore.AUTHORITY.equals(uri.getAuthority())) {\n                    mOneShot = true;\n                }\n                mService.stop();\n                mService.openFile(filename, mOneShot);\n                mService.play();\n                setIntent(new Intent());\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private ImageView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private boolean mFromTouch = false;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setImageBitmap((Bitmap)msg.obj);\n                    mAlbum.getDrawable().setDither(true);\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            int songid = mService.getAudioId(); \n            if (songid < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                // Once we can get album art and meta data from MediaPlayer, we\n                // can show that info again when streaming.\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, -1).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, songid).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            int songid = msg.arg2;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, songid, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private static class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":1223}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        ListView lv = getListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(3);\n            if (MediaFile.UNKNOWN_STRING.equals(fancyName))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n    \n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        menu.setHeaderTitle(mCurrentAlbumName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mHasHeader) {\n            position --;\n        }\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_KEY,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mNumSongsIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mNumSongsIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.duration = (TextView) v.findViewById(R.id.duration);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (MediaFile.UNKNOWN_STRING.equals(name)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getAlbumCursor(null, constraint.toString());\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n    private boolean mHasHeader = false;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Adapter;\nimport android.widget.AlphabetIndexer;\nimport android.widget.CursorAdapter;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\n\npublic class AlbumBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private AlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public AlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mArtistId = icicle.getString(\"artist\");\n        } else {\n            mArtistId = getIntent().getStringExtra(\"artist\");\n        }\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        ListView lv = getListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (AlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new AlbumListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mAlbumCursor,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_albums);\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mAlbumCursor = mAdapter.getCursor();\n            if (mAlbumCursor != null) {\n                init(mAlbumCursor);\n            } else {\n                getAlbumCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"artist\", mArtistId);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(AlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getAlbumCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mAlbumCursor\n\n        if (mAlbumCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        CharSequence fancyName = \"\";\n        if (mAlbumCursor != null && mAlbumCursor.getCount() > 0) {\n            mAlbumCursor.moveToFirst();\n            fancyName = mAlbumCursor.getString(3);\n            if (MediaFile.UNKNOWN_STRING.equals(fancyName))\n                fancyName = getText(R.string.unknown_artist_name);\n        }\n\n        if (mArtistId != null && fancyName != null)\n            setTitle(fancyName);\n        else\n            setTitle(R.string.albums_title);\n    }\n    \n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mAlbumCursor.moveToPosition(mi.position);\n        mCurrentAlbumId = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));\n        mCurrentAlbumName = mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n        mCurrentArtistNameForAlbum = mAlbumCursor.getString(\n                mAlbumCursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST));\n        menu.setHeaderTitle(mCurrentAlbumName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the selected album\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            case DELETE_ITEM: {\n                int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                String f = getString(R.string.delete_album_desc); \n                String desc = String.format(f, mCurrentAlbumName);\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            case SEARCH:\n                doSearch();\n                return true;\n\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getAlbumCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mHasHeader) {\n            position --;\n        }\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", Long.valueOf(id).toString());\n        intent.putExtra(\"artist\", mArtistId);\n        startActivity(intent);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n\n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID},\n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Albums.ALBUM + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n            \n        String[] cols = new String[] {\n                MediaStore.Audio.Albums._ID,\n                MediaStore.Audio.Albums.ALBUM,\n                MediaStore.Audio.Albums.ALBUM_KEY,\n                MediaStore.Audio.Albums.ARTIST,\n                MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                MediaStore.Audio.Albums.ALBUM_ART\n        };\n        Cursor ret = null;\n        if (mArtistId != null) {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Artists.Albums.getContentUri(\"external\",\n                                Long.valueOf(mArtistId)),\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        } else {\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,\n                        cols, whereclause, keywords, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            }\n        }\n        return ret;\n    }\n    \n    static class AlbumListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mAlbumIdx;\n        private int mArtistIdx;\n        private int mNumSongsIdx;\n        private int mAlbumArtIndex;\n        private final Resources mResources;\n        private final StringBuilder mStringBuilder = new StringBuilder();\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final String mAlbumSongSeparator;\n        private final Object[] mFormatArgs = new Object[1];\n        private AlphabetIndexer mIndexer;\n        private AlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        AlbumListAdapter(Context context, AlbumBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n            \n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n\n            Bitmap b = BitmapFactory.decodeResource(r, R.drawable.albumart_mp_unknown_list);\n            mDefaultAlbumIcon = new BitmapDrawable(b);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n        }\n\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ARTIST);\n                mNumSongsIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS);\n                mAlbumArtIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ART);\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mAlbumIdx, mResources.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(AlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n           View v = super.newView(context, cursor, parent);\n           ViewHolder vh = new ViewHolder();\n           vh.line1 = (TextView) v.findViewById(R.id.line1);\n           vh.line2 = (TextView) v.findViewById(R.id.line2);\n           vh.duration = (TextView) v.findViewById(R.id.duration);\n           vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n           vh.icon = (ImageView) v.findViewById(R.id.icon);\n           vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n           vh.icon.setPadding(0, 0, 1, 0);\n           v.setTag(vh);\n           return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(mAlbumIdx);\n            String displayname = name;\n            boolean unknown = name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n            \n            name = cursor.getString(mArtistIdx);\n            displayname = name;\n            if (MediaFile.UNKNOWN_STRING.equals(name)) {\n                displayname = mUnknownArtist;\n            }\n            vh.line2.setText(displayname);\n\n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(mAlbumArtIndex);\n            if (unknown || art == null || art.length() == 0) {\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n            \n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mAlbumCursor) {\n                mActivity.mAlbumCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getAlbumCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int section) {\n            return mIndexer.getPositionForSection(section);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n\n    private Cursor mAlbumCursor;\n    private String mArtistId;\n    private boolean mHasHeader = false;\n}\n\n","lineNo":609}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.CursorAdapter;\nimport android.widget.CursorTreeAdapter;\nimport android.widget.ExpandableListAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public ArtistAlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        ExpandableListView lv = getExpandableListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album.equals(MediaFile.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            menu.setHeaderTitle(mCurrentArtistName);\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                int [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            title = mCurrentAlbumName;\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = MediaFile.UNKNOWN_STRING.equals(artist);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            int currentartistid = MusicUtils.getCurrentArtistId();\n            int artistid = cursor.getInt(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n            int first = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.FIRST_YEAR));\n            int last = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.LAST_YEAR));\n\n            if (first == 0) {\n                first = last;\n            }\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            int id = groupCursor.getInt(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.FIRST_YEAR,\n                    MediaStore.Audio.Albums.LAST_YEAR,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (MediaFile.UNKNOWN_STRING.equals(mArtistName)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (name.equals(MediaStore.Audio.Albums.ARTIST)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getArtistCursor(null, constraint.toString());\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.CursorAdapter;\nimport android.widget.CursorTreeAdapter;\nimport android.widget.ExpandableListAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public ArtistAlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        ExpandableListView lv = getExpandableListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.artists_title);\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album.equals(MediaFile.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            menu.setHeaderTitle(mCurrentArtistName);\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                int [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            title = mCurrentAlbumName;\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(0, 0, 1, 0);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = MediaFile.UNKNOWN_STRING.equals(artist);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            int currentartistid = MusicUtils.getCurrentArtistId();\n            int artistid = cursor.getInt(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n            int first = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.FIRST_YEAR));\n            int last = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.LAST_YEAR));\n\n            if (first == 0) {\n                first = last;\n            }\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (unknown || art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            int id = groupCursor.getInt(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.FIRST_YEAR,\n                    MediaStore.Audio.Albums.LAST_YEAR,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (MediaFile.UNKNOWN_STRING.equals(mArtistName)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (name.equals(MediaStore.Audio.Albums.ARTIST)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getArtistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n}\n\n","lineNo":790}
{"Smelly Sample":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.gadget.GadgetManager;\nimport android.gadget.GadgetProvider;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.os.SystemClock;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends GadgetProvider {\n    static final String TAG = \"MusicGadgetProvider\";\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    @Override\n    public void onUpdate(Context context, GadgetManager gadgetManager, int[] gadgetIds) {\n        defaultGadget(context, gadgetIds);\n        \n        // Send broadcast intent to any running MediaPlaybackService so it can\n        // wrap around with an immediate update.\n        Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n        updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                MediaGadgetProvider.CMDGADGETUPDATE);\n        updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n        updateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        context.sendBroadcast(updateIntent);\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    static void defaultGadget(Context context, int[] gadgetIds) {\n        final RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.gadget);\n\n        linkButtons(context, views, false /* not from service */);\n        pushUpdate(context, gadgetIds, views);\n    }\n    \n    private static void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        final GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            final ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     * @param metaChanged\n     */\n    static void updateAllGadgets(MediaPlaybackService service, int[] gadgetIds) {\n        final Resources res = service.getResources();\n        final RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.gadget);\n        \n        final int track = service.getQueuePosition() + 1;\n        final String titleName = service.getTrackName();\n        final String artistName = service.getArtistName();\n        final String albumName = service.getAlbumName();\n        \n        int albumId = service.getAlbumId();\n        if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n            albumId = -1;\n        }\n        \n        // Try loading album artwork and resize if found\n        Bitmap artwork = MusicUtils.getArtwork(service, albumId, false);\n        if (artwork != null) {\n            artwork = scaleArtwork(artwork, service);\n            views.setImageViewBitmap(R.id.artwork, artwork);\n            views.setViewVisibility(R.id.artwork, View.VISIBLE);\n            views.setViewVisibility(R.id.no_artwork, View.GONE);\n        } else {\n            views.setViewVisibility(R.id.artwork, View.GONE);\n            views.setViewVisibility(R.id.no_artwork, View.VISIBLE);\n        }\n        \n        // Format title string with track number\n        final String titleString = res.getString(R.string.gadget_track_num_title, track, titleName);\n        \n        views.setTextViewText(R.id.title, titleString);\n        views.setTextViewText(R.id.artist, artistName);\n        \n        // Set chronometer to correct value\n        final boolean playing = service.isPlaying();\n        final long start = SystemClock.elapsedRealtime() - service.position();\n        final long end = start + service.duration();\n        \n        views.setChronometer(android.R.id.text1, start, null, playing);\n        views.setLong(R.id.progress_group, \"setDurationBase\", end);\n\n        // Set correct drawable for pause state\n        views.setImageViewResource(R.id.control_play, playing ?\n                R.drawable.gadget_pause : R.drawable.gadget_play);\n\n        // Link actions buttons to intents\n        linkButtons(service, views, true /* not from service */);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n\n    /**\n     * Link up various button actions using {@link PendingIntents}.\n     * \n     * @param fromService If false, {@link MediaPlaybackService} isn't running,\n     *            and we should link the play button to start that service.\n     *            Otherwise, we assume the service is awake and send broadcast\n     *            Intents instead.\n     */\n    private static void linkButtons(Context context, RemoteViews views, boolean fromService) {\n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        intent = new Intent(context, MediaPlaybackActivity.class);\n        pendingIntent = PendingIntent.getActivity(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.PREVIOUS_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_prev, pendingIntent);\n\n        // Use broadcast to trigger play/pause, otherwise \n        if (fromService) {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            pendingIntent = PendingIntent.getBroadcast(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        } else {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            intent.setComponent(new ComponentName(context, MediaPlaybackService.class));\n            pendingIntent = PendingIntent.getService(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        }\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n    }\n    \n    /**\n     * Scale and chop given album artwork to prepare as gadget background.\n     */\n    private static Bitmap scaleArtwork(Bitmap bitmap, Context context) {\n        final int cutoutSize = (int) context.getResources().getDimension(R.dimen.gadget_cutout);\n        final int srcWidth = bitmap.getWidth();\n        final int srcHeight = bitmap.getHeight();\n        final int srcDiameter = Math.min(srcWidth, srcHeight);\n        \n        // Figure out best circle size\n        final Rect src = new Rect((srcWidth - srcDiameter) / 2,\n                (srcHeight - srcDiameter) / 2, srcDiameter, srcDiameter);\n        final Rect dest = new Rect(0, 0, cutoutSize, cutoutSize);\n        \n        final Bitmap thumb = Bitmap.createBitmap(cutoutSize, cutoutSize,\n                Bitmap.Config.ARGB_8888);\n\n        final Canvas canvas = new Canvas(thumb);\n        final Paint paint = new Paint();\n        \n        paint.setAntiAlias(true);\n        \n        // Draw a mask circle using default paint\n        final int radius = cutoutSize / 2;\n        canvas.drawCircle(radius, radius, radius, paint);\n        \n        paint.setDither(false);\n        paint.setFilterBitmap(true);\n        paint.setAlpha(96);\n        \n        // Draw the actual album art, using the mask circle from earlier. Using\n        // this approach allows us to alpha-blend the circle edges, which isn't\n        // possible with Canvas.clipPath()\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        canvas.drawBitmap(bitmap, src, dest, paint);\n        \n        return thumb;\n    }\n    \n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.gadget.GadgetManager;\nimport android.gadget.GadgetProvider;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.os.Environment;\nimport android.os.SystemClock;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends GadgetProvider {\n    static final String TAG = \"MusicGadgetProvider\";\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    static final ComponentName THIS_GADGET =\n        new ComponentName(\"com.android.music\",\n                \"com.android.music.MediaGadgetProvider\");\n    \n    private static MediaGadgetProvider sInstance;\n    \n    static synchronized MediaGadgetProvider getInstance() {\n        if (sInstance == null) {\n            sInstance = new MediaGadgetProvider();\n        }\n        return sInstance;\n    }\n\n    @Override\n    public void onUpdate(Context context, GadgetManager gadgetManager, int[] gadgetIds) {\n        defaultGadget(context, gadgetIds);\n        \n        // Send broadcast intent to any running MediaPlaybackService so it can\n        // wrap around with an immediate update.\n        Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n        updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                MediaGadgetProvider.CMDGADGETUPDATE);\n        updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n        updateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        context.sendBroadcast(updateIntent);\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    private void defaultGadget(Context context, int[] gadgetIds) {\n        final Resources res = context.getResources();\n        final RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.gadget);\n        \n        views.setTextViewText(R.id.title, res.getText(R.string.emptyplaylist));\n\n        linkButtons(context, views, false /* not playing */);\n        pushUpdate(context, gadgetIds, views);\n    }\n    \n    private void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        final GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            final ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Check against {@link GadgetManager} if there are any instances of this gadget.\n     */\n    private boolean hasInstances(Context context) {\n        GadgetManager gadgetManager = GadgetManager.getInstance(context);\n        int[] gadgetIds = gadgetManager.getGadgetIds(THIS_GADGET);\n        return (gadgetIds.length > 0);\n    }\n\n    /**\n     * Handle a change notification coming over from {@link MediaPlaybackService}\n     */\n    void notifyChange(MediaPlaybackService service, String what) {\n        if (hasInstances(service)) {\n            if (MediaPlaybackService.PLAYBACK_COMPLETE.equals(what) ||\n                    MediaPlaybackService.META_CHANGED.equals(what) ||\n                    MediaPlaybackService.PLAYSTATE_CHANGED.equals(what)) {\n                performUpdate(service, null);\n            }\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     */\n    void performUpdate(MediaPlaybackService service, int[] gadgetIds) {\n        final Resources res = service.getResources();\n        final RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.gadget);\n        \n        final int track = service.getQueuePosition() + 1;\n        final String titleName = service.getTrackName();\n        final String artistName = service.getArtistName();\n        \n        // Format title string with track number, or show SD card message\n        CharSequence titleString = \"\";\n        String status = Environment.getExternalStorageState();\n        if (titleName != null) {\n            titleString = res.getString(R.string.gadget_track_num_title, track, titleName);\n        } else if (status.equals(Environment.MEDIA_SHARED) ||\n                status.equals(Environment.MEDIA_UNMOUNTED)) {\n            titleString = res.getText(R.string.sdcard_busy_title);\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            titleString = res.getText(R.string.sdcard_missing_title);\n        } else {\n            titleString = res.getText(R.string.emptyplaylist);\n        }\n        \n        views.setTextViewText(R.id.title, titleString);\n        views.setTextViewText(R.id.artist, artistName);\n        \n        // Set correct drawable for pause state\n        final boolean playing = service.isPlaying();\n        views.setImageViewResource(R.id.control_play, playing ?\n                R.drawable.gadget_pause : R.drawable.gadget_play);\n\n        // Link actions buttons to intents\n        linkButtons(service, views, playing);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n\n    /**\n     * Link up various button actions using {@link PendingIntents}.\n     * \n     * @param playerActive True if player is active in background, which means\n     *            gadget click will launch {@link MediaPlaybackActivity},\n     *            otherwise we launch {@link MusicBrowserActivity}.\n     */\n    private void linkButtons(Context context, RemoteViews views, boolean playerActive) {\n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        final ComponentName serviceName = new ComponentName(context, MediaPlaybackService.class);\n        \n        if (playerActive) {\n            intent = new Intent(context, MediaPlaybackActivity.class);\n            pendingIntent = PendingIntent.getActivity(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        } else {\n            intent = new Intent(context, MusicBrowserActivity.class);\n            pendingIntent = PendingIntent.getActivity(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        }\n        \n        intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n        intent.setComponent(serviceName);\n        pendingIntent = PendingIntent.getService(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        intent.setComponent(serviceName);\n        pendingIntent = PendingIntent.getService(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n    }\n}\n","lineNo":177}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\n\nimport com.android.internal.database.ArrayListCursor;\n\nimport android.database.Cursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n\n    private boolean mCreateShortcut;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    long id = Long.parseLong(intent.getExtras().getString(\"playlist\"));\n                    if (id == RECENTLY_ADDED_PLAYLIST) {\n                        playRecentlyAdded();\n                    } else if (id == PODCASTS_PLAYLIST) {\n                        playPodcasts();\n                    } else if (id == ALL_SONGS_PLAYLIST) {\n                        int [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                        if (list != null) {\n                            MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                        }\n                    } else {\n                        MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                    }\n                    finish();\n                }\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }        \n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n    public void init(Cursor cursor) {\n\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(\n                    R.drawable.ic_menu_music_library);\n            menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(\n                    R.drawable.ic_menu_playback).setVisible(MusicUtils.isMusicLoaded());\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.app_music));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getInt(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getInt(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        ArrayList<ArrayList> autoplaylists = new ArrayList<ArrayList>();\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylists.add(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylists.add(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylists.add(podcasts);\n            }\n        }\n\n        ArrayListCursor autoplaylistscursor = new ArrayListCursor(mCols, autoplaylists);\n        \n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getPlaylistCursor(null, constraint.toString());\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\n\nimport android.app.ListActivity;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\n\nimport com.android.internal.database.ArrayListCursor;\n\nimport android.database.Cursor;\nimport android.database.MergeCursor;\nimport android.database.sqlite.SQLiteException;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\npublic class PlaylistBrowserActivity extends ListActivity\n    implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private static final String TAG = \"PlaylistBrowserActivity\";\n    private static final int DELETE_PLAYLIST = CHILD_MENU_BASE + 1;\n    private static final int EDIT_PLAYLIST = CHILD_MENU_BASE + 2;\n    private static final int RENAME_PLAYLIST = CHILD_MENU_BASE + 3;\n    private static final int CHANGE_WEEKS = CHILD_MENU_BASE + 4;\n    private static final long RECENTLY_ADDED_PLAYLIST = -1;\n    private static final long ALL_SONGS_PLAYLIST = -2;\n    private static final long PODCASTS_PLAYLIST = -3;\n    private PlaylistListAdapter mAdapter;\n    boolean mAdapterSent;\n\n    private boolean mCreateShortcut;\n\n    public PlaylistBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n\n        final Intent intent = getIntent();\n        final String action = intent.getAction();\n        if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {\n            mCreateShortcut = true;\n        }\n\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                if (Intent.ACTION_VIEW.equals(action)) {\n                    long id = Long.parseLong(intent.getExtras().getString(\"playlist\"));\n                    if (id == RECENTLY_ADDED_PLAYLIST) {\n                        playRecentlyAdded();\n                    } else if (id == PODCASTS_PLAYLIST) {\n                        playPodcasts();\n                    } else if (id == ALL_SONGS_PLAYLIST) {\n                        int [] list = MusicUtils.getAllSongs(PlaylistBrowserActivity.this);\n                        if (list != null) {\n                            MusicUtils.playAll(PlaylistBrowserActivity.this, list, 0);\n                        }\n                    } else {\n                        MusicUtils.playPlaylist(PlaylistBrowserActivity.this, id);\n                    }\n                    finish();\n                }\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n        \n        });\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (PlaylistListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new PlaylistListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    mPlaylistCursor,\n                    new String[] { MediaStore.Audio.Playlists.NAME},\n                    new int[] { android.R.id.text1 });\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_playlists);\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mPlaylistCursor = mAdapter.getCursor();\n            // If mPlaylistCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mPlaylistCursor != null) {\n                init(mPlaylistCursor);\n            } else {\n                setTitle(R.string.working_playlists);\n                getPlaylistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        PlaylistListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }        \n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(PlaylistBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            getPlaylistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n    public void init(Cursor cursor) {\n\n        mAdapter.changeCursor(cursor);\n\n        if (mPlaylistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n    }\n\n    private void setTitle() {\n        setTitle(R.string.playlists_title);\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        if (!mCreateShortcut) {\n            menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(\n                    R.drawable.ic_menu_music_library);\n            menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(\n                    R.drawable.ic_menu_playback).setVisible(MusicUtils.isMusicLoaded());\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        if (mCreateShortcut) {\n            return;\n        }\n\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n\n        if (mi.id >= 0 /*|| mi.id == PODCASTS_PLAYLIST*/) {\n            menu.add(0, DELETE_PLAYLIST, 0, R.string.delete_playlist_menu);\n        }\n\n        if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n            menu.add(0, EDIT_PLAYLIST, 0, R.string.edit_playlist_menu);\n        }\n\n        if (mi.id >= 0) {\n            menu.add(0, RENAME_PLAYLIST, 0, R.string.rename_playlist_menu);\n        }\n\n        mPlaylistCursor.moveToPosition(mi.position);\n        menu.setHeaderTitle(mPlaylistCursor.getString(mPlaylistCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Playlists.NAME)));\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) item.getMenuInfo();\n        switch (item.getItemId()) {\n            case PLAY_SELECTION:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    playRecentlyAdded();\n                } else if (mi.id == PODCASTS_PLAYLIST) {\n                    playPodcasts();\n                } else {\n                    MusicUtils.playPlaylist(this, mi.id);\n                }\n                break;\n            case DELETE_PLAYLIST:\n                Uri uri = ContentUris.withAppendedId(\n                        MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, mi.id);\n                getContentResolver().delete(uri, null, null);\n                Toast.makeText(this, R.string.playlist_deleted_message, Toast.LENGTH_SHORT).show();\n                if (mPlaylistCursor.getCount() == 0) {\n                    setTitle(R.string.no_playlists_title);\n                }\n                break;\n            case EDIT_PLAYLIST:\n                if (mi.id == RECENTLY_ADDED_PLAYLIST) {\n                    Intent intent = new Intent();\n                    intent.setClass(this, WeekSelector.class);\n                    startActivityForResult(intent, CHANGE_WEEKS);\n                    return true;\n                } else {\n                    Log.e(TAG, \"should not be here\");\n                }\n                break;\n            case RENAME_PLAYLIST:\n                Intent intent = new Intent();\n                intent.setClass(this, RenamePlaylist.class);\n                intent.putExtra(\"rename\", mi.id);\n                startActivityForResult(intent, RENAME_PLAYLIST);\n                break;\n        }\n        return true;\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getPlaylistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n\n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mCreateShortcut) {\n            final Intent shortcut = new Intent();\n            shortcut.setAction(Intent.ACTION_VIEW);\n            shortcut.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/playlist\");\n            shortcut.putExtra(\"playlist\", String.valueOf(id));\n\n            final Intent intent = new Intent();\n            intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcut);\n            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, ((TextView) v.findViewById(R.id.line1)).getText());\n            intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(\n                    this, R.drawable.app_music));\n\n            setResult(RESULT_OK, intent);\n            finish();\n            return;\n        }\n        if (id == RECENTLY_ADDED_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"recentlyadded\");\n            startActivity(intent);\n        } else if (id == PODCASTS_PLAYLIST) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", \"podcasts\");\n            startActivity(intent);\n        } else {\n            Intent intent = new Intent(Intent.ACTION_EDIT);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"playlist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        }\n    }\n\n    private void playRecentlyAdded() {\n        // do a query for all songs added in the last X weeks\n        int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        String where = MediaStore.MediaColumns.DATE_ADDED + \">\" + (System.currentTimeMillis() / 1000 - X);\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getInt(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private void playPodcasts() {\n        // do a query for all files that are podcasts\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID};\n        Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, MediaStore.Audio.Media.IS_PODCAST + \"=1\",\n                null, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            // Todo: show a message\n            return;\n        }\n        try {\n            int len = cursor.getCount();\n            int [] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                cursor.moveToNext();\n                list[i] = cursor.getInt(0);\n            }\n            MusicUtils.playAll(this, list, 0);\n        } catch (SQLiteException ex) {\n        } finally {\n            cursor.close();\n        }\n    }\n\n    \n    String[] mCols = new String[] {\n            MediaStore.Audio.Playlists._ID,\n            MediaStore.Audio.Playlists.NAME\n    };\n\n    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Playlists.NAME + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + searchWords[i] + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Playlists.NAME + \" LIKE ?\");\n            }\n        }\n        \n        String whereclause = where.toString();\n        \n        \n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n            return null;\n        }\n        Cursor c = null;\n        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);\n        \n        return mergedCursor(c);\n    }\n    \n    private Cursor mergedCursor(Cursor c) {\n        if (c == null) {\n            return null;\n        }\n        if (c instanceof MergeCursor) {\n            // this shouldn't happen, but fail gracefully\n            Log.d(\"PlaylistBrowserActivity\", \"Already wrapped\");\n            return c;\n        }\n        ArrayList<ArrayList> autoplaylists = new ArrayList<ArrayList>();\n        if (mCreateShortcut) {\n            ArrayList<Object> all = new ArrayList<Object>(2);\n            all.add(ALL_SONGS_PLAYLIST);\n            all.add(getString(R.string.play_all));\n            autoplaylists.add(all);\n        }\n        ArrayList<Object> recent = new ArrayList<Object>(2);\n        recent.add(RECENTLY_ADDED_PLAYLIST);\n        recent.add(getString(R.string.recentlyadded));\n        autoplaylists.add(recent);\n        \n        // check if there are any podcasts\n        Cursor counter = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {\"count(*)\"}, \"is_podcast=1\", null, null);\n        if (counter != null) {\n            counter.moveToFirst();\n            int numpodcasts = counter.getInt(0);\n            counter.close();\n            if (numpodcasts > 0) {\n                ArrayList<Object> podcasts = new ArrayList<Object>(2);\n                podcasts.add(PODCASTS_PLAYLIST);\n                podcasts.add(getString(R.string.podcasts_listitem));\n                autoplaylists.add(podcasts);\n            }\n        }\n\n        ArrayListCursor autoplaylistscursor = new ArrayListCursor(mCols, autoplaylists);\n        \n        Cursor cc = new MergeCursor(new Cursor [] {autoplaylistscursor, c});\n        return cc;\n    }\n    \n    static class PlaylistListAdapter extends SimpleCursorAdapter {\n        int mTitleIdx;\n        int mIdIdx;\n        private PlaylistBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                if (cursor != null) {\n                    cursor = mActivity.mergedCursor(cursor);\n                }\n                mActivity.init(cursor);\n            }\n        }\n\n        PlaylistListAdapter(Context context, PlaylistBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.NAME);\n                mIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists._ID);\n            }\n        }\n\n        public void setActivity(PlaylistBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv = (TextView) view.findViewById(R.id.line1);\n            \n            String name = cursor.getString(mTitleIdx);\n            tv.setText(name);\n            \n            long id = cursor.getLong(mIdIdx);\n            \n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            if (id == RECENTLY_ADDED_PLAYLIST) {\n                iv.setImageResource(R.drawable.ic_mp_playlist_recently_added_list);\n            } else {\n                iv.setImageResource(R.drawable.ic_mp_playlist_list);\n            }\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n\n            iv = (ImageView) view.findViewById(R.id.play_indicator);\n            iv.setVisibility(View.GONE);\n\n            view.findViewById(R.id.line2).setVisibility(View.GONE);\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mPlaylistCursor) {\n                mActivity.mPlaylistCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getPlaylistCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n    \n    private Cursor mPlaylistCursor;\n}\n\n","lineNo":590}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\n\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ViewGroup.OnHierarchyChangeListener;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.util.ArrayList;\n\npublic class QueryBrowserActivity extends ListActivity implements MusicUtils.Defs\n{\n    private final static int PLAY_NOW = 0;\n    private final static int ADD_TO_QUEUE = 1;\n    private final static int PLAY_NEXT = 2;\n    private final static int PLAY_ARTIST = 3;\n    private final static int EXPLORE_ARTIST = 4;\n    private final static int PLAY_ALBUM = 5;\n    private final static int EXPLORE_ALBUM = 6;\n    private final static int REQUERY = 3;\n    private QueryListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private String mFilterString = \"\";\n\n    public QueryBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this);\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n        \n        if (icicle == null) {\n            Intent intent = getIntent();\n            \n            if (intent.getAction().equals(Intent.ACTION_VIEW)) {\n                // this is something we got from the search bar\n                Uri uri = intent.getData();\n                String path = uri.toString();\n                if (path.startsWith(\"content://media/external/audio/media/\")) {\n                    // This is a specific file\n                    String id = uri.getLastPathSegment();\n                    int [] list = new int[] { Integer.valueOf(id) };\n                    MusicUtils.playAll(this, list, 0);\n                    finish();\n                    return;\n                } else if (path.startsWith(\"content://media/external/audio/albums/\")) {\n                    // This is an album, show the songs on it\n                    Intent i = new Intent(Intent.ACTION_PICK);\n                    i.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                    i.putExtra(\"album\", uri.getLastPathSegment());\n                    startActivity(i);\n                    finish();\n                    return;\n                } else if (path.startsWith(\"content://media/external/audio/artists/\")) {\n                    // This is an artist, show the albums for that artist\n                    Intent i = new Intent(Intent.ACTION_PICK);\n                    i.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                    i.putExtra(\"artist\", uri.getLastPathSegment());\n                    startActivity(i);\n                    finish();\n                    return;\n                }\n            }\n            mFilterString = intent.getStringExtra(SearchManager.QUERY);\n        }\n\n        setContentView(R.layout.query_activity);\n        mTrackList = getListView();\n        mTrackList.setTextFilterEnabled(true);\n        mAdapter = (QueryListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            mAdapter = new QueryListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            if (TextUtils.isEmpty(mFilterString)) {\n                getQueryCursor(mAdapter.getQueryHandler(), null);\n            } else {\n                mTrackList.setFilterText(mFilterString);\n                mFilterString = null;\n            }\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mQueryCursor = mAdapter.getCursor();\n            if (mQueryCursor != null) {\n                init(mQueryCursor);\n            } else {\n                getQueryCursor(mAdapter.getQueryHandler(), mFilterString);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n        if (!mAdapterSent && mAdapter != null) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up, and when the\n     * sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(QueryBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getQueryCursor(mAdapter.getQueryHandler(), null);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getQueryCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n    \n    public void init(Cursor c) {\n        \n        mAdapter.changeCursor(c);\n\n        if (mQueryCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            setListAdapter(null);\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        MusicUtils.hideDatabaseError(this);\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        // Dialog doesn't allow us to wait for a result, so we need to store\n        // the info we need for when the dialog posts its result\n        mQueryCursor.moveToPosition(position);\n        if (mQueryCursor.isBeforeFirst() || mQueryCursor.isAfterLast()) {\n            return;\n        }\n        String selectedType = mQueryCursor.getString(mQueryCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.MIME_TYPE));\n        \n        if (\"artist\".equals(selectedType)) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n            intent.putExtra(\"artist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        } else if (\"album\".equals(selectedType)) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"album\", Long.valueOf(id).toString());\n            startActivity(intent);\n        } else if (position >= 0 && id >= 0){\n            int [] list = new int[] { (int) id };\n            MusicUtils.playAll(this, list, 0);\n        } else {\n            Log.e(\"QueryBrowser\", \"invalid position/id: \" + position + \"/\" + id);\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case USE_AS_RINGTONE: {\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mTrackList.getSelectedItemId());\n                return true;\n            }\n\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getQueryCursor(AsyncQueryHandler async, String filter) {\n        if (filter == null) {\n            filter = \"\";\n        }\n        String[] ccols = new String[] {\n                \"_id\",   // this will be the artist, album or track ID\n                MediaStore.Audio.Media.MIME_TYPE, // mimetype of audio file, or \"artist\" or \"album\"\n                SearchManager.SUGGEST_COLUMN_TEXT_1,\n                \"data1\",\n                \"data2\"\n        };\n\n        Uri search = Uri.parse(\"content://media/external/audio/\" + \n                SearchManager.SUGGEST_URI_PATH_QUERY + \"/\" + Uri.encode(filter));\n        \n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, search, ccols, null, null, null);\n        } else {\n            ret = MusicUtils.query(this, search, ccols, null, null, null);\n        }\n        return ret;\n    }\n    \n    static class QueryListAdapter extends SimpleCursorAdapter {\n        private QueryBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                mActivity.init(cursor);\n            }\n        }\n\n        QueryListAdapter(Context context, QueryBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n\n        public void setActivity(QueryBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv1 = (TextView) view.findViewById(R.id.line1);\n            TextView tv2 = (TextView) view.findViewById(R.id.line2);\n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            if (p == null) {\n                // seen this happen, not sure why\n                DatabaseUtils.dumpCursor(cursor);\n                return;\n            }\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            \n            String mimetype = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Media.MIME_TYPE));\n            \n            if (mimetype == null) {\n                mimetype = \"audio/\";\n            }\n            if (mimetype.equals(\"artist\")) {\n                iv.setImageResource(R.drawable.ic_mp_artist_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                String displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                tv1.setText(displayname);\n\n                int numalbums = cursor.getInt(cursor.getColumnIndexOrThrow(\"data1\"));\n                int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(\"data2\"));\n                \n                String songs_albums = MusicUtils.makeAlbumsSongsLabel(context,\n                        numalbums, numsongs, name.equals(MediaFile.UNKNOWN_STRING));\n                \n                tv2.setText(songs_albums);\n            \n            } else if (mimetype.equals(\"album\")) {\n                iv.setImageResource(R.drawable.albumart_mp_unknown_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                String displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_album_name);\n                }\n                tv1.setText(displayname);\n                \n                name = cursor.getString(cursor.getColumnIndexOrThrow(\"data1\"));\n                displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                tv2.setText(displayname);\n                \n            } else if(mimetype.startsWith(\"audio/\") ||\n                    mimetype.equals(\"application/ogg\") ||\n                    mimetype.equals(\"application/x-ogg\")) {\n                iv.setImageResource(R.drawable.ic_mp_song_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                tv1.setText(name);\n\n                String displayname = cursor.getString(cursor.getColumnIndexOrThrow(\"data1\"));\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                name = cursor.getString(cursor.getColumnIndexOrThrow(\"data2\"));\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    name = context.getString(R.string.unknown_artist_name);\n                }\n                tv2.setText(displayname + \" - \" + name);\n            }\n        }\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mQueryCursor) {\n                mActivity.mQueryCursor = cursor;\n                super.changeCursor(cursor);\n            }\n        }\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getQueryCursor(null, constraint.toString());\n        }\n    }\n\n    private ListView mTrackList;\n    private Cursor mQueryCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\n\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ViewGroup.OnHierarchyChangeListener;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\n\nimport java.util.ArrayList;\n\npublic class QueryBrowserActivity extends ListActivity implements MusicUtils.Defs\n{\n    private final static int PLAY_NOW = 0;\n    private final static int ADD_TO_QUEUE = 1;\n    private final static int PLAY_NEXT = 2;\n    private final static int PLAY_ARTIST = 3;\n    private final static int EXPLORE_ARTIST = 4;\n    private final static int PLAY_ALBUM = 5;\n    private final static int EXPLORE_ALBUM = 6;\n    private final static int REQUERY = 3;\n    private QueryListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private String mFilterString = \"\";\n\n    public QueryBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        MusicUtils.bindToService(this);\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n        \n        if (icicle == null) {\n            Intent intent = getIntent();\n            \n            if (intent.getAction().equals(Intent.ACTION_VIEW)) {\n                // this is something we got from the search bar\n                Uri uri = intent.getData();\n                String path = uri.toString();\n                if (path.startsWith(\"content://media/external/audio/media/\")) {\n                    // This is a specific file\n                    String id = uri.getLastPathSegment();\n                    int [] list = new int[] { Integer.valueOf(id) };\n                    MusicUtils.playAll(this, list, 0);\n                    finish();\n                    return;\n                } else if (path.startsWith(\"content://media/external/audio/albums/\")) {\n                    // This is an album, show the songs on it\n                    Intent i = new Intent(Intent.ACTION_PICK);\n                    i.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                    i.putExtra(\"album\", uri.getLastPathSegment());\n                    startActivity(i);\n                    finish();\n                    return;\n                } else if (path.startsWith(\"content://media/external/audio/artists/\")) {\n                    // This is an artist, show the albums for that artist\n                    Intent i = new Intent(Intent.ACTION_PICK);\n                    i.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                    i.putExtra(\"artist\", uri.getLastPathSegment());\n                    startActivity(i);\n                    finish();\n                    return;\n                }\n            }\n            mFilterString = intent.getStringExtra(SearchManager.QUERY);\n        }\n\n        setContentView(R.layout.query_activity);\n        mTrackList = getListView();\n        mTrackList.setTextFilterEnabled(true);\n        mAdapter = (QueryListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            mAdapter = new QueryListAdapter(\n                    getApplication(),\n                    this,\n                    R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            if (TextUtils.isEmpty(mFilterString)) {\n                getQueryCursor(mAdapter.getQueryHandler(), null);\n            } else {\n                mTrackList.setFilterText(mFilterString);\n                mFilterString = null;\n            }\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mQueryCursor = mAdapter.getCursor();\n            if (mQueryCursor != null) {\n                init(mQueryCursor);\n            } else {\n                getQueryCursor(mAdapter.getQueryHandler(), mFilterString);\n            }\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n        if (!mAdapterSent && mAdapter != null) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up, and when the\n     * sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(QueryBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getQueryCursor(mAdapter.getQueryHandler(), null);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getQueryCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n        }\n    }\n    \n    public void init(Cursor c) {\n        \n        mAdapter.changeCursor(c);\n\n        if (mQueryCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            setListAdapter(null);\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        MusicUtils.hideDatabaseError(this);\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        // Dialog doesn't allow us to wait for a result, so we need to store\n        // the info we need for when the dialog posts its result\n        mQueryCursor.moveToPosition(position);\n        if (mQueryCursor.isBeforeFirst() || mQueryCursor.isAfterLast()) {\n            return;\n        }\n        String selectedType = mQueryCursor.getString(mQueryCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.MIME_TYPE));\n        \n        if (\"artist\".equals(selectedType)) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n            intent.putExtra(\"artist\", Long.valueOf(id).toString());\n            startActivity(intent);\n        } else if (\"album\".equals(selectedType)) {\n            Intent intent = new Intent(Intent.ACTION_PICK);\n            intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n            intent.putExtra(\"album\", Long.valueOf(id).toString());\n            startActivity(intent);\n        } else if (position >= 0 && id >= 0){\n            int [] list = new int[] { (int) id };\n            MusicUtils.playAll(this, list, 0);\n        } else {\n            Log.e(\"QueryBrowser\", \"invalid position/id: \" + position + \"/\" + id);\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case USE_AS_RINGTONE: {\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mTrackList.getSelectedItemId());\n                return true;\n            }\n\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private Cursor getQueryCursor(AsyncQueryHandler async, String filter) {\n        if (filter == null) {\n            filter = \"\";\n        }\n        String[] ccols = new String[] {\n                \"_id\",   // this will be the artist, album or track ID\n                MediaStore.Audio.Media.MIME_TYPE, // mimetype of audio file, or \"artist\" or \"album\"\n                SearchManager.SUGGEST_COLUMN_TEXT_1,\n                \"data1\",\n                \"data2\"\n        };\n\n        Uri search = Uri.parse(\"content://media/external/audio/\" + \n                SearchManager.SUGGEST_URI_PATH_QUERY + \"/\" + Uri.encode(filter));\n        \n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, search, ccols, null, null, null);\n        } else {\n            ret = MusicUtils.query(this, search, ccols, null, null, null);\n        }\n        return ret;\n    }\n    \n    static class QueryListAdapter extends SimpleCursorAdapter {\n        private QueryBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                mActivity.init(cursor);\n            }\n        }\n\n        QueryListAdapter(Context context, QueryBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n\n        public void setActivity(QueryBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            TextView tv1 = (TextView) view.findViewById(R.id.line1);\n            TextView tv2 = (TextView) view.findViewById(R.id.line2);\n            ImageView iv = (ImageView) view.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            if (p == null) {\n                // seen this happen, not sure why\n                DatabaseUtils.dumpCursor(cursor);\n                return;\n            }\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            \n            String mimetype = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Media.MIME_TYPE));\n            \n            if (mimetype == null) {\n                mimetype = \"audio/\";\n            }\n            if (mimetype.equals(\"artist\")) {\n                iv.setImageResource(R.drawable.ic_mp_artist_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                String displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                tv1.setText(displayname);\n\n                int numalbums = cursor.getInt(cursor.getColumnIndexOrThrow(\"data1\"));\n                int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(\"data2\"));\n                \n                String songs_albums = MusicUtils.makeAlbumsSongsLabel(context,\n                        numalbums, numsongs, name.equals(MediaFile.UNKNOWN_STRING));\n                \n                tv2.setText(songs_albums);\n            \n            } else if (mimetype.equals(\"album\")) {\n                iv.setImageResource(R.drawable.albumart_mp_unknown_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                String displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_album_name);\n                }\n                tv1.setText(displayname);\n                \n                name = cursor.getString(cursor.getColumnIndexOrThrow(\"data1\"));\n                displayname = name;\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                tv2.setText(displayname);\n                \n            } else if(mimetype.startsWith(\"audio/\") ||\n                    mimetype.equals(\"application/ogg\") ||\n                    mimetype.equals(\"application/x-ogg\")) {\n                iv.setImageResource(R.drawable.ic_mp_song_list);\n                String name = cursor.getString(cursor.getColumnIndexOrThrow(\n                        SearchManager.SUGGEST_COLUMN_TEXT_1));\n                tv1.setText(name);\n\n                String displayname = cursor.getString(cursor.getColumnIndexOrThrow(\"data1\"));\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    displayname = context.getString(R.string.unknown_artist_name);\n                }\n                name = cursor.getString(cursor.getColumnIndexOrThrow(\"data2\"));\n                if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                    name = context.getString(R.string.unknown_artist_name);\n                }\n                tv2.setText(displayname + \" - \" + name);\n            }\n        }\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mQueryCursor) {\n                mActivity.mQueryCursor = cursor;\n                super.changeCursor(cursor);\n            }\n        }\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getQueryCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n    }\n\n    private ListView mTrackList;\n    private Cursor mQueryCursor;\n}\n\n","lineNo":405}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private final int Q_SELECTED = CHILD_MENU_BASE;\n    private final int Q_ALL = CHILD_MENU_BASE + 1;\n    private final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private final int REMOVE = CHILD_MENU_BASE + 5;\n    private final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID\n        };\n\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            //((TouchInterceptor) mTrackList).setDragListener(mDragListener);\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiver(mNowPlayingListener);\n            } else {\n                unregisterReceiver(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n   }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getTrackCursor(mAdapter.getQueryHandler(), null);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor) {\n\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DragListener mDragListener =\n        new TouchInterceptor.DragListener() {\n        public void drag(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            }\n        }\n    };\n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getInt(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = new int[] { (int) mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = new int[] { (int) mSelectedId };\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                int [] list = new int[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = new int[] { (int) mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(AsyncQueryHandler async, String filter) {\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                        Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\", Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                    ret = null;\n                 } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                }\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                    ret = null;\n                 } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                }\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                    ret = null;\n                } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                }\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n            }\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async != null) {\n            init(ret);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new int[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getInt(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    int trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            int newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private int[] mNowPlaying;\n        private int[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mAlbumIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor);\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            int id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getInt(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getTrackCursor(null, constraint.toString());\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs, ServiceConnection\n{\n    private final int Q_SELECTED = CHILD_MENU_BASE;\n    private final int Q_ALL = CHILD_MENU_BASE + 1;\n    private final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private final int REMOVE = CHILD_MENU_BASE + 5;\n    private final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private TrackListAdapter mAdapter;\n    private boolean mAdapterSent = false;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID\n        };\n\n        setContentView(R.layout.media_picker_activity);\n        mTrackList = getListView();\n        mTrackList.setOnCreateContextMenuListener(this);\n        if (mEditMode) {\n            //((TouchInterceptor) mTrackList).setDragListener(mDragListener);\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n            mTrackList.setCacheColorHint(0);\n        } else {\n            mTrackList.setTextFilterEnabled(true);\n        }\n        mAdapter = (TrackListAdapter) getLastNonConfigurationInstance();\n        \n        if (mAdapter != null) {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n        }\n        MusicUtils.bindToService(this, this);\n    }\n\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new TrackListAdapter(\n                    getApplication(), // need to use application context to avoid leaks\n                    this,\n                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                    null, // cursor\n                    new String[] {},\n                    new int[] {},\n                    \"nowplaying\".equals(mPlaylist),\n                    mPlaylist != null &&\n                    !(mPlaylist.equals(\"podcasts\") || mPlaylist.equals(\"recentlyadded\")));\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_songs);\n            getTrackCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mTrackCursor = mAdapter.getCursor();\n            // If mTrackCursor is null, this can be because it doesn't have\n            // a cursor yet (because the initial query that sets its cursor\n            // is still in progress), or because the query failed.\n            // In order to not flash the error dialog at the user for the\n            // first case, simply retry the query when the cursor is null.\n            // Worst case, we end up doing the same query twice.\n            if (mTrackCursor != null) {\n                init(mTrackCursor);\n            } else {\n                setTitle(R.string.working_songs);\n                getTrackCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n    \n    public void onServiceDisconnected(ComponentName name) {\n        // we can't really function without the service, so don't\n        finish();\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        TrackListAdapter a = mAdapter;\n        mAdapterSent = true;\n        return a;\n    }\n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiver(mNowPlayingListener);\n            } else {\n                unregisterReceiver(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        \n        // if we didn't send the adapter off to another activity, we should\n        // close the cursor\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n   }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up or finishes, and\n     * when the sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (Intent.ACTION_MEDIA_SCANNER_STARTED.equals(action) ||\n                    Intent.ACTION_MEDIA_SCANNER_FINISHED.equals(action)) {\n                MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            }\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            getTrackCursor(mAdapter.getQueryHandler(), null);\n            // if the query results in a null cursor, onQueryComplete() will\n            // call init(), which will post a delayed message to this handler\n            // in order to try again.\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor) {\n\n        mAdapter.changeCursor(newCursor); // also sets mTrackCursor\n        \n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n        \n        MusicUtils.hideDatabaseError(this);\n        setTitle();\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n\n        CharSequence fancyName = null;\n        if (mAlbumId != null) {\n            int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n            if (numresults > 0) {\n                mTrackCursor.moveToFirst();\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n                if (fancyName.equals(MediaFile.UNKNOWN_STRING)) {\n                    fancyName = getString(R.string.unknown_album_name);\n                }\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                    fancyName = getText(R.string.partyshuffle_title);\n                } else {\n                    fancyName = getText(R.string.nowplaying_title);\n                }\n            } else if (mPlaylist.equals(\"podcasts\")){\n                fancyName = getText(R.string.podcasts_title);\n            } else if (mPlaylist.equals(\"recentlyadded\")){\n                fancyName = getText(R.string.recentlyadded_title);\n            } else {\n                String [] cols = new String [] {\n                MediaStore.Audio.Playlists.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n        } else if (mGenre != null) {\n            String [] cols = new String [] {\n            MediaStore.Audio.Genres.NAME\n            };\n            Cursor cursor = MusicUtils.query(this,\n                    ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                    cols, null, null, null);\n            if (cursor != null) {\n                if (cursor.getCount() != 0) {\n                    cursor.moveToFirst();\n                    fancyName = cursor.getString(0);\n                }\n                cursor.deactivate();\n            }\n        }\n\n        if (fancyName != null) {\n            setTitle(fancyName);\n        } else {\n            setTitle(R.string.tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DragListener mDragListener =\n        new TouchInterceptor.DragListener() {\n        public void drag(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            }\n        }\n    };\n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                Cursor c = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (c.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                mAdapter.changeCursor(c);\n            }\n        }\n    };\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getInt(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = new int[] { (int) mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = new int[] { (int) mSelectedId };\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                int [] list = new int[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(com.android.internal.R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(android.R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(com.android.internal.R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = new int[] { (int) mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(AsyncQueryHandler async, String filter) {\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                        Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\", Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else if (mPlaylist.equals(\"podcasts\")) {\n                where.append(\" AND \" + MediaStore.Audio.Media.IS_PODCAST + \"=1\");\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                    ret = null;\n                 } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                }\n            } else if (mPlaylist.equals(\"recentlyadded\")) {\n                // do a query for all songs added in the last X weeks\n                int X = MusicUtils.getIntPref(this, \"numweeks\", 2) * (3600 * 24 * 7);\n                where.append(\" AND \" + MediaStore.MediaColumns.DATE_ADDED + \">\");\n                where.append(System.currentTimeMillis() / 1000 - X);\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                    ret = null;\n                 } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, mCursorCols,\n                            where.toString(), keywords, MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                }\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                    ret = null;\n                } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                }\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            if (mArtistId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + mArtistId);\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n            }\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.\n        if (ret != null && async != null) {\n            init(ret);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new int[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getInt(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    int trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            int newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private int[] mNowPlaying;\n        private int[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    static class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        int mTitleIdx;\n        int mArtistIdx;\n        int mAlbumIdx;\n        int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        \n        private TrackBrowserActivity mActivity = null;\n        private AsyncQueryHandler mQueryHandler;\n        private String mConstraint = null;\n        private boolean mConstraintIsValid = false;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete: \" + cursor.getCount() + \"   \" + mActivity);\n                mActivity.init(cursor);\n            }\n        }\n        \n        TrackListAdapter(Context context, TrackBrowserActivity currentactivity,\n                int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mActivity = currentactivity;\n            getColumnIndices(cursor);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mQueryHandler = new QueryHandler(context.getContentResolver());\n        }\n        \n        public void setActivity(TrackBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n                mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n                mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n                try {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                            MediaStore.Audio.Playlists.Members.AUDIO_ID);\n                } catch (IllegalArgumentException ex) {\n                    mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n                }\n                \n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else if (!mActivity.mEditMode) {\n                    String alpha = mActivity.getString(\n                            com.android.internal.R.string.fast_scroll_alphabet);\n                \n                    mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, alpha);\n                }\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mActivity.mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            int id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlist\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getInt(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mTrackCursor) {\n                mActivity.mTrackCursor = cursor;\n                super.changeCursor(cursor);\n                getColumnIndices(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            String s = constraint.toString();\n            if (mConstraintIsValid && (\n                    (s == null && mConstraint == null) ||\n                    (s != null && s.equals(mConstraint)))) {\n                return getCursor();\n            }\n            Cursor c = mActivity.getTrackCursor(null, s);\n            mConstraint = s;\n            mConstraintIsValid = true;\n            return c;\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n}\n\n","lineNo":1429}
{"Smelly Sample":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.gadget.GadgetManager;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends BroadcastReceiver {\n    static final String TAG = \"MusicGadgetProvider\";\n    static final boolean LOGD = Config.LOGD || false;\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (GadgetManager.ACTION_GADGET_ENABLED.equals(action)) {\n            if (LOGD) Log.d(TAG, \"ENABLED\");\n        } else if (GadgetManager.ACTION_GADGET_DISABLED.equals(action)) {\n            if (LOGD) Log.d(TAG, \"DISABLED\");\n        } else if (GadgetManager.ACTION_GADGET_UPDATE.equals(action)) {\n            if (LOGD) Log.d(TAG, \"UPDATE\");\n            int[] gadgetIds = intent.getIntArrayExtra(GadgetManager.EXTRA_GADGET_IDS);\n            \n            defaultGadget(context, gadgetIds);\n            \n            // Send broadcast intent to any running MediaPlaybackService so it can\n            // wrap around with an immediate update.\n            Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n            updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                    MediaGadgetProvider.CMDGADGETUPDATE);\n            updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n            context.sendBroadcast(updateIntent);\n        }\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    static void defaultGadget(Context context, int[] gadgetIds) {\n        \n        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.album_gadget);\n\n        // Link up default touch to launch media player\n        Intent intent = new Intent(context, MediaPlaybackActivity.class);\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n\n        // And hide other action buttons\n        views.setViewVisibility(R.id.control_play, View.GONE);\n        views.setViewVisibility(R.id.control_next, View.GONE);\n        \n        pushUpdate(context, gadgetIds, views);\n\n    }\n    \n    private static void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     * @param metaChanged\n     */\n    static void updateAllGadgets(MediaPlaybackService service,\n            boolean metaChanged, int[] gadgetIds) {\n        RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.album_gadget);\n        \n        // Currently force metaChanged to make sure artwork is pushed to surface\n        // TODO: make GadgetHostView accept partial RemoteView updates so\n        // we can enable this optimization\n        if (metaChanged || true) {\n            String albumName = service.getAlbumName();\n            int albumId = service.getAlbumId();\n            if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                albumId = -1;\n            }\n            Bitmap artwork = MusicUtils.getArtwork(service, albumId);\n            \n            // If nothing found, pull out default artwork\n            if (artwork == null) {\n                artwork = BitmapFactory.decodeResource(service.getResources(),\n                        R.drawable.albumart_mp_unknown);\n            }\n            \n            if (artwork != null) {\n                artwork = scaleArtwork(artwork, service);\n                views.setImageViewBitmap(R.id.artwork, artwork);\n            }\n        }\n        \n        boolean playing = service.isPlaying();\n        views.setImageViewResource(R.id.control_play, playing ?\n                android.R.drawable.ic_media_pause : android.R.drawable.ic_media_play);\n        \n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        intent = new Intent(service, MusicBrowserActivity.class);\n        pendingIntent = PendingIntent.getActivity(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        views.setViewVisibility(R.id.control_play, View.VISIBLE);\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n        views.setViewVisibility(R.id.control_next, View.VISIBLE);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n    \n    private static final int ARTWORK_SIZE = 175;\n    \n    /**\n     * Rescale given album artwork to a specific size for gadget display.\n     */\n    private static Bitmap scaleArtwork(Bitmap bitmap, Context context) {\n        if (bitmap == null) {\n            return null;\n        }\n        final Bitmap thumb = Bitmap.createBitmap(ARTWORK_SIZE, ARTWORK_SIZE,\n                Bitmap.Config.RGB_565);\n        \n        final Canvas canvas = new Canvas();\n        canvas.setBitmap(thumb);\n        \n        final Paint paint = new Paint();\n        paint.setDither(false);\n        paint.setFilterBitmap(true);\n        \n        Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());\n        Rect dest = new Rect(0, 0, thumb.getWidth(), thumb.getHeight());\n        \n        canvas.drawBitmap(bitmap, src, dest, paint);\n        \n        return thumb;\n    }\n    \n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.gadget.GadgetManager;\nimport android.gadget.GadgetProvider;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.os.SystemClock;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends GadgetProvider {\n    static final String TAG = \"MusicGadgetProvider\";\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    @Override\n    public void onUpdate(Context context, GadgetManager gadgetManager, int[] gadgetIds) {\n        defaultGadget(context, gadgetIds);\n        \n        // Send broadcast intent to any running MediaPlaybackService so it can\n        // wrap around with an immediate update.\n        Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n        updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                MediaGadgetProvider.CMDGADGETUPDATE);\n        updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n        updateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        context.sendBroadcast(updateIntent);\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    static void defaultGadget(Context context, int[] gadgetIds) {\n        final RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.gadget);\n\n        linkButtons(context, views, false /* not from service */);\n        pushUpdate(context, gadgetIds, views);\n    }\n    \n    private static void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        final GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            final ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     * @param metaChanged\n     */\n    static void updateAllGadgets(MediaPlaybackService service, int[] gadgetIds) {\n        final Resources res = service.getResources();\n        final RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.gadget);\n        \n        final int track = service.getQueuePosition() + 1;\n        final String titleName = service.getTrackName();\n        final String artistName = service.getArtistName();\n        final String albumName = service.getAlbumName();\n        \n        int albumId = service.getAlbumId();\n        if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n            albumId = -1;\n        }\n        \n        // Try loading album artwork and resize if found\n        Bitmap artwork = MusicUtils.getArtwork(service, albumId, false);\n        if (artwork != null) {\n            artwork = scaleArtwork(artwork, service);\n            views.setImageViewBitmap(R.id.artwork, artwork);\n            views.setViewVisibility(R.id.artwork, View.VISIBLE);\n            views.setViewVisibility(R.id.no_artwork, View.GONE);\n        } else {\n            views.setViewVisibility(R.id.artwork, View.GONE);\n            views.setViewVisibility(R.id.no_artwork, View.VISIBLE);\n        }\n        \n        // Format title string with track number\n        final String titleString = res.getString(R.string.gadget_track_num_title, track, titleName);\n        \n        views.setTextViewText(R.id.title, titleString);\n        views.setTextViewText(R.id.artist, artistName);\n        \n        // Set chronometer to correct value\n        final boolean playing = service.isPlaying();\n        final long start = SystemClock.elapsedRealtime() - service.position();\n        final long end = start + service.duration();\n        \n        views.setChronometer(android.R.id.text1, start, null, playing);\n        views.setLong(R.id.progress_group, \"setDurationBase\", end);\n\n        // Set correct drawable for pause state\n        views.setImageViewResource(R.id.control_play, playing ?\n                R.drawable.gadget_pause : R.drawable.gadget_play);\n\n        // Link actions buttons to intents\n        linkButtons(service, views, true /* not from service */);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n\n    /**\n     * Link up various button actions using {@link PendingIntents}.\n     * \n     * @param fromService If false, {@link MediaPlaybackService} isn't running,\n     *            and we should link the play button to start that service.\n     *            Otherwise, we assume the service is awake and send broadcast\n     *            Intents instead.\n     */\n    private static void linkButtons(Context context, RemoteViews views, boolean fromService) {\n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        intent = new Intent(context, MediaPlaybackActivity.class);\n        pendingIntent = PendingIntent.getActivity(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.PREVIOUS_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_prev, pendingIntent);\n\n        // Use broadcast to trigger play/pause, otherwise \n        if (fromService) {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            pendingIntent = PendingIntent.getBroadcast(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        } else {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            intent.setComponent(new ComponentName(context, MediaPlaybackService.class));\n            pendingIntent = PendingIntent.getService(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        }\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n    }\n    \n    /**\n     * Scale and chop given album artwork to prepare as gadget background.\n     */\n    private static Bitmap scaleArtwork(Bitmap bitmap, Context context) {\n        final int cutoutSize = (int) context.getResources().getDimension(R.dimen.gadget_cutout);\n        final int srcWidth = bitmap.getWidth();\n        final int srcHeight = bitmap.getHeight();\n        final int srcDiameter = Math.min(srcWidth, srcHeight);\n        \n        // Figure out best circle size\n        final Rect src = new Rect((srcWidth - srcDiameter) / 2,\n                (srcHeight - srcDiameter) / 2, srcDiameter, srcDiameter);\n        final Rect dest = new Rect(0, 0, cutoutSize, cutoutSize);\n        \n        final Bitmap thumb = Bitmap.createBitmap(cutoutSize, cutoutSize,\n                Bitmap.Config.ARGB_8888);\n\n        final Canvas canvas = new Canvas(thumb);\n        final Paint paint = new Paint();\n        \n        paint.setAntiAlias(true);\n        \n        // Draw a mask circle using default paint\n        final int radius = cutoutSize / 2;\n        canvas.drawCircle(radius, radius, radius, paint);\n        \n        paint.setDither(false);\n        paint.setFilterBitmap(true);\n        paint.setAlpha(96);\n        \n        // Draw the actual album art, using the mask circle from earlier. Using\n        // this approach allows us to alpha-blend the circle edges, which isn't\n        // possible with Canvas.clipPath()\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        canvas.drawBitmap(bitmap, src, dest, paint);\n        \n        return thumb;\n    }\n    \n}\n","lineNo":189}
{"Smelly Sample":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.gadget.GadgetManager;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends BroadcastReceiver {\n    static final String TAG = \"MusicGadgetProvider\";\n    static final boolean LOGD = Config.LOGD || false;\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (GadgetManager.ACTION_GADGET_ENABLED.equals(action)) {\n            if (LOGD) Log.d(TAG, \"ENABLED\");\n        } else if (GadgetManager.ACTION_GADGET_DISABLED.equals(action)) {\n            if (LOGD) Log.d(TAG, \"DISABLED\");\n        } else if (GadgetManager.ACTION_GADGET_UPDATE.equals(action)) {\n            if (LOGD) Log.d(TAG, \"UPDATE\");\n            int[] gadgetIds = intent.getIntArrayExtra(GadgetManager.EXTRA_GADGET_IDS);\n            \n            defaultGadget(context, gadgetIds);\n            \n            // Send broadcast intent to any running MediaPlaybackService so it can\n            // wrap around with an immediate update.\n            Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n            updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                    MediaGadgetProvider.CMDGADGETUPDATE);\n            updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n            context.sendBroadcast(updateIntent);\n        }\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    static void defaultGadget(Context context, int[] gadgetIds) {\n        \n        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.album_gadget);\n\n        // Link up default touch to launch media player\n        Intent intent = new Intent(context, MediaPlaybackActivity.class);\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n\n        // And hide other action buttons\n        views.setViewVisibility(R.id.control_play, View.GONE);\n        views.setViewVisibility(R.id.control_next, View.GONE);\n        \n        pushUpdate(context, gadgetIds, views);\n\n    }\n    \n    private static void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     * @param metaChanged\n     */\n    static void updateAllGadgets(MediaPlaybackService service,\n            boolean metaChanged, int[] gadgetIds) {\n        RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.album_gadget);\n        \n        // Currently force metaChanged to make sure artwork is pushed to surface\n        // TODO: make GadgetHostView accept partial RemoteView updates so\n        // we can enable this optimization\n        if (metaChanged || true) {\n            String albumName = service.getAlbumName();\n            int albumId = service.getAlbumId();\n            if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                albumId = -1;\n            }\n            Bitmap artwork = MusicUtils.getArtwork(service, albumId);\n            \n            // If nothing found, pull out default artwork\n            if (artwork == null) {\n                artwork = BitmapFactory.decodeResource(service.getResources(),\n                        R.drawable.albumart_mp_unknown);\n            }\n            \n            if (artwork != null) {\n                artwork = scaleArtwork(artwork, service);\n                views.setImageViewBitmap(R.id.artwork, artwork);\n            }\n        }\n        \n        boolean playing = service.isPlaying();\n        views.setImageViewResource(R.id.control_play, playing ?\n                android.R.drawable.ic_media_pause : android.R.drawable.ic_media_play);\n        \n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        intent = new Intent(service, MusicBrowserActivity.class);\n        pendingIntent = PendingIntent.getActivity(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        views.setViewVisibility(R.id.control_play, View.VISIBLE);\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(service,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n        views.setViewVisibility(R.id.control_next, View.VISIBLE);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n    \n    private static final int ARTWORK_SIZE = 175;\n    \n    /**\n     * Rescale given album artwork to a specific size for gadget display.\n     */\n    private static Bitmap scaleArtwork(Bitmap bitmap, Context context) {\n        if (bitmap == null) {\n            return null;\n        }\n        final Bitmap thumb = Bitmap.createBitmap(ARTWORK_SIZE, ARTWORK_SIZE,\n                Bitmap.Config.RGB_565);\n        \n        final Canvas canvas = new Canvas();\n        canvas.setBitmap(thumb);\n        \n        final Paint paint = new Paint();\n        paint.setDither(false);\n        paint.setFilterBitmap(true);\n        \n        Rect src = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());\n        Rect dest = new Rect(0, 0, thumb.getWidth(), thumb.getHeight());\n        \n        canvas.drawBitmap(bitmap, src, dest, paint);\n        \n        return thumb;\n    }\n    \n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.gadget.GadgetManager;\nimport android.gadget.GadgetProvider;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.Rect;\nimport android.media.MediaFile;\nimport android.os.SystemClock;\nimport android.util.Config;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\n/**\n * Simple gadget to show currently playing album art along\n * with play/pause and next track buttons.  \n */\npublic class MediaGadgetProvider extends GadgetProvider {\n    static final String TAG = \"MusicGadgetProvider\";\n    \n    public static final String CMDGADGETUPDATE = \"gadgetupdate\";\n    \n    @Override\n    public void onUpdate(Context context, GadgetManager gadgetManager, int[] gadgetIds) {\n        defaultGadget(context, gadgetIds);\n        \n        // Send broadcast intent to any running MediaPlaybackService so it can\n        // wrap around with an immediate update.\n        Intent updateIntent = new Intent(MediaPlaybackService.SERVICECMD);\n        updateIntent.putExtra(MediaPlaybackService.CMDNAME,\n                MediaGadgetProvider.CMDGADGETUPDATE);\n        updateIntent.putExtra(GadgetManager.EXTRA_GADGET_IDS, gadgetIds);\n        updateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        context.sendBroadcast(updateIntent);\n    }\n    \n    /**\n     * Initialize given gadgets to default state, where we launch Music on default click\n     * and hide actions if service not running.\n     */\n    static void defaultGadget(Context context, int[] gadgetIds) {\n        final RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.gadget);\n\n        linkButtons(context, views, false /* not from service */);\n        pushUpdate(context, gadgetIds, views);\n    }\n    \n    private static void pushUpdate(Context context, int[] gadgetIds, RemoteViews views) {\n        // Update specific list of gadgetIds if given, otherwise default to all\n        final GadgetManager gm = GadgetManager.getInstance(context);\n        if (gadgetIds != null) {\n            gm.updateGadget(gadgetIds, views);\n        } else {\n            final ComponentName thisGadget = new ComponentName(context,\n                    MediaGadgetProvider.class);\n            gm.updateGadget(thisGadget, views);\n        }\n    }\n    \n    /**\n     * Update all active gadget instances by pushing changes \n     * @param metaChanged\n     */\n    static void updateAllGadgets(MediaPlaybackService service, int[] gadgetIds) {\n        final Resources res = service.getResources();\n        final RemoteViews views = new RemoteViews(service.getPackageName(), R.layout.gadget);\n        \n        final int track = service.getQueuePosition() + 1;\n        final String titleName = service.getTrackName();\n        final String artistName = service.getArtistName();\n        final String albumName = service.getAlbumName();\n        \n        int albumId = service.getAlbumId();\n        if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n            albumId = -1;\n        }\n        \n        // Try loading album artwork and resize if found\n        Bitmap artwork = MusicUtils.getArtwork(service, albumId, false);\n        if (artwork != null) {\n            artwork = scaleArtwork(artwork, service);\n            views.setImageViewBitmap(R.id.artwork, artwork);\n            views.setViewVisibility(R.id.artwork, View.VISIBLE);\n            views.setViewVisibility(R.id.no_artwork, View.GONE);\n        } else {\n            views.setViewVisibility(R.id.artwork, View.GONE);\n            views.setViewVisibility(R.id.no_artwork, View.VISIBLE);\n        }\n        \n        // Format title string with track number\n        final String titleString = res.getString(R.string.gadget_track_num_title, track, titleName);\n        \n        views.setTextViewText(R.id.title, titleString);\n        views.setTextViewText(R.id.artist, artistName);\n        \n        // Set chronometer to correct value\n        final boolean playing = service.isPlaying();\n        final long start = SystemClock.elapsedRealtime() - service.position();\n        final long end = start + service.duration();\n        \n        views.setChronometer(android.R.id.text1, start, null, playing);\n        views.setLong(R.id.progress_group, \"setDurationBase\", end);\n\n        // Set correct drawable for pause state\n        views.setImageViewResource(R.id.control_play, playing ?\n                R.drawable.gadget_pause : R.drawable.gadget_play);\n\n        // Link actions buttons to intents\n        linkButtons(service, views, true /* not from service */);\n        \n        pushUpdate(service, gadgetIds, views);\n    }\n\n    /**\n     * Link up various button actions using {@link PendingIntents}.\n     * \n     * @param fromService If false, {@link MediaPlaybackService} isn't running,\n     *            and we should link the play button to start that service.\n     *            Otherwise, we assume the service is awake and send broadcast\n     *            Intents instead.\n     */\n    private static void linkButtons(Context context, RemoteViews views, boolean fromService) {\n        // Connect up various buttons and touch events\n        Intent intent;\n        PendingIntent pendingIntent;\n        \n        intent = new Intent(context, MediaPlaybackActivity.class);\n        pendingIntent = PendingIntent.getActivity(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.album_gadget, pendingIntent);\n        \n        intent = new Intent(MediaPlaybackService.PREVIOUS_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_prev, pendingIntent);\n\n        // Use broadcast to trigger play/pause, otherwise \n        if (fromService) {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            pendingIntent = PendingIntent.getBroadcast(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        } else {\n            intent = new Intent(MediaPlaybackService.TOGGLEPAUSE_ACTION);\n            intent.setComponent(new ComponentName(context, MediaPlaybackService.class));\n            pendingIntent = PendingIntent.getService(context,\n                    0 /* no requestCode */, intent, 0 /* no flags */);\n            views.setOnClickPendingIntent(R.id.control_play, pendingIntent);\n        }\n        \n        intent = new Intent(MediaPlaybackService.NEXT_ACTION);\n        pendingIntent = PendingIntent.getBroadcast(context,\n                0 /* no requestCode */, intent, 0 /* no flags */);\n        views.setOnClickPendingIntent(R.id.control_next, pendingIntent);\n    }\n    \n    /**\n     * Scale and chop given album artwork to prepare as gadget background.\n     */\n    private static Bitmap scaleArtwork(Bitmap bitmap, Context context) {\n        final int cutoutSize = (int) context.getResources().getDimension(R.dimen.gadget_cutout);\n        final int srcWidth = bitmap.getWidth();\n        final int srcHeight = bitmap.getHeight();\n        final int srcDiameter = Math.min(srcWidth, srcHeight);\n        \n        // Figure out best circle size\n        final Rect src = new Rect((srcWidth - srcDiameter) / 2,\n                (srcHeight - srcDiameter) / 2, srcDiameter, srcDiameter);\n        final Rect dest = new Rect(0, 0, cutoutSize, cutoutSize);\n        \n        final Bitmap thumb = Bitmap.createBitmap(cutoutSize, cutoutSize,\n                Bitmap.Config.ARGB_8888);\n\n        final Canvas canvas = new Canvas(thumb);\n        final Paint paint = new Paint();\n        \n        paint.setAntiAlias(true);\n        \n        // Draw a mask circle using default paint\n        final int radius = cutoutSize / 2;\n        canvas.drawCircle(radius, radius, radius, paint);\n        \n        paint.setDither(false);\n        paint.setFilterBitmap(true);\n        paint.setAlpha(96);\n        \n        // Draw the actual album art, using the mask circle from earlier. Using\n        // this approach allows us to alpha-blend the circle edges, which isn't\n        // possible with Canvas.clipPath()\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        canvas.drawBitmap(bitmap, src, dest, paint);\n        \n        return thumb;\n    }\n    \n}\n","lineNo":190}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Bitmap;\nimport android.graphics.PixelFormat;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.view.GestureDetector;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.GestureDetector.SimpleOnGestureListener;\nimport android.widget.AdapterView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\n\npublic class TouchInterceptor extends ListView {\n    \n    private View mDragView;\n    private WindowManager mWindowManager;\n    private WindowManager.LayoutParams mWindowParams;\n    private int mDragPos;      // which item is being dragged\n    private int mFirstDragPos; // where was the dragged item originally\n    private int mDragPoint;    // at what offset inset the item did the user grab it\n    private int mCoordOffset;  // the difference between screen coordinates and coordinates in this view\n    private DragListener mDragListener;\n    private DropListener mDropListener;\n    private RemoveListener mRemoveListener;\n    private int mUpperBound;\n    private int mLowerBound;\n    private int mHeight;\n    private GestureDetector mGestureDetector;\n    private static final int FLING = 0;\n    private static final int SLIDE = 1;\n    private int mRemoveMode = -1;\n    private Rect mTempRect = new Rect();\n    private Bitmap mDragBitmap;\n    private final int mTouchSlop;\n\n    public TouchInterceptor(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        SharedPreferences pref = context.getSharedPreferences(\"Music\", 3);\n        mRemoveMode = pref.getInt(\"deletemode\", -1);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n    \n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (mRemoveListener != null && mGestureDetector == null) {\n            if (mRemoveMode == FLING) {\n                mGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n                    @Override\n                    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\n                            float velocityY) {\n                        if (mDragView != null) {\n                            if (velocityX > 1000) {\n                                Rect r = mTempRect;\n                                mDragView.getDrawingRect(r);\n                                if ( e2.getX() > r.right * 2 / 3) {\n                                    // fast fling right with release near the right edge of the screen\n                                    stopDragging();\n                                    mRemoveListener.remove(mFirstDragPos);\n                                    unExpandViews(true);\n                                }\n                            }\n                            // flinging while dragging should have no effect\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n            }\n        }\n        if (mDragListener != null || mDropListener != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    int itemnum = pointToPosition(x, y);\n                    if (itemnum == AdapterView.INVALID_POSITION) {\n                        break;\n                    }\n                    ViewGroup item = (ViewGroup) getChildAt(itemnum - getFirstVisiblePosition());\n                    mDragPoint = y - item.getTop();\n                    mCoordOffset = ((int)ev.getRawY()) - y;\n                    View dragger = item.findViewById(R.id.icon);\n                    Rect r = mTempRect;\n                    dragger.getDrawingRect(r);\n                    if (x < r.right) {\n                        item.setDrawingCacheEnabled(true);\n                        // Create a copy of the drawing cache so that it does not get recycled\n                        // by the framework when the list tries to clean up memory\n                        Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());\n                        startDragging(bitmap, y);\n                        mDragPos = itemnum;\n                        mFirstDragPos = mDragPos;\n                        mHeight = getHeight();\n                        int touchSlop = mTouchSlop;\n                        mUpperBound = Math.min(y - touchSlop, mHeight / 3);\n                        mLowerBound = Math.max(y + touchSlop, mHeight * 2 /3);\n                        return false;\n                    }\n                    mDragView = null;\n                    break;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n    \n    /*\n     * pointToPosition() doesn't consider invisible views, but we\n     * need to, so implement a slightly different version.\n     */\n    private int myPointToPosition(int x, int y) {\n        Rect frame = mTempRect;\n        final int count = getChildCount();\n        for (int i = count - 1; i >= 0; i--) {\n            final View child = getChildAt(i);\n            child.getHitRect(frame);\n            if (frame.contains(x, y)) {\n                return getFirstVisiblePosition() + i;\n            }\n        }\n        return INVALID_POSITION;\n    }\n    \n    private int getItemForPosition(int y) {\n        int pos = myPointToPosition(0, y - mDragPoint - 32);\n        if (pos >= 0) {\n            if (pos <= mFirstDragPos) {\n                pos += 1;\n            }\n        } else if ((y - mDragPoint) < 0) {\n            pos = 0;\n        }\n        return pos;\n    }\n    \n    private void adjustScrollBounds(int y) {\n        if (y >= mHeight / 3) {\n            mUpperBound = mHeight / 3;\n        }\n        if (y <= mHeight * 2 / 3) {\n            mLowerBound = mHeight * 2 / 3;\n        }\n    }\n\n    /*\n     * Restore size and visibility for all listitems\n     */\n    private void unExpandViews(boolean deletion) {\n        for (int i = 0;; i++) {\n            View v = getChildAt(i);\n            if (v == null) {\n                if (deletion) {\n                    // HACK force update of mItemCount\n                    int position = getFirstVisiblePosition();\n                    int y = getChildAt(0).getTop();\n                    setAdapter(getAdapter());\n                    setSelectionFromTop(position, y);\n                    // end hack\n                }\n                layoutChildren(); // force children to be recreated where needed\n                v = getChildAt(i);\n                if (v == null) {\n                    break;\n                }\n            }\n            ViewGroup.LayoutParams params = v.getLayoutParams();\n            params.height = 64;\n            v.setLayoutParams(params);\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /* Adjust visibility and size to make it appear as though\n     * an item is being dragged around and other items are making\n     * room for it:\n     * If dropping the item would result in it still being in the\n     * same place, then make the dragged listitem's size normal,\n     * but make the item invisible.\n     * Otherwise, if the dragged listitem is still on screen, make\n     * it as small as possible and expand the item below the insert\n     * point.\n     * If the dragged item is not on screen, only expand the item\n     * below the current insertpoint.\n     */\n    private void doExpansion() {\n        int childnum = mDragPos - getFirstVisiblePosition();\n        if (mDragPos > mFirstDragPos) {\n            childnum++;\n        }\n        View v = getChildAt(childnum);\n        if (v== null) {\n            return;\n        }\n        View first = getChildAt(mFirstDragPos - getFirstVisiblePosition());\n\n        for (int i = 0;; i++) {\n            View vv = getChildAt(i);\n            if (vv == null) {\n                break;\n            }\n            int height = 64;\n            int visibility = View.VISIBLE;\n            if (vv.equals(first)) {\n                // processing the item that is being dragged\n                if (mDragPos == mFirstDragPos) {\n                    // hovering over the original location\n                    visibility = View.INVISIBLE;\n                } else {\n                    // not hovering over it\n                    height = 1;\n                }\n            } else if (i == (mDragPos - getFirstVisiblePosition() + (mDragPos > mFirstDragPos ? 1 : 0))) {\n                height = 128;\n            }\n            ViewGroup.LayoutParams params = vv.getLayoutParams();\n            params.height = height;\n            vv.setLayoutParams(params);\n            vv.setVisibility(visibility);\n        }\n    }\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mGestureDetector != null) {\n            mGestureDetector.onTouchEvent(ev);\n        }\n        if ((mDragListener != null || mDropListener != null) && mDragView != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    Rect r = mTempRect;\n                    mDragView.getDrawingRect(r);\n                    stopDragging();\n                    if (mRemoveMode == SLIDE && ev.getX() > r.right * 3 / 4) {\n                        if (mRemoveListener != null) {\n                            mRemoveListener.remove(mFirstDragPos);\n                        }\n                        unExpandViews(true);\n                    } else {\n                        if (mDropListener != null) {\n                            mDropListener.drop(mFirstDragPos, mDragPos);\n                        }\n                        unExpandViews(false);\n                    }\n                    break;\n                    \n                case MotionEvent.ACTION_MOVE:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    dragView(x, y);\n                    int itemnum = getItemForPosition(y);\n                    if (itemnum >= 0) {\n                        if (true || itemnum != mDragPos) {\n                            if (mDragListener != null) {\n                                mDragListener.drag(mDragPos, itemnum);\n                            }\n                            mDragPos = itemnum;\n                            doExpansion();\n                        }\n                        int speed = 0;\n                        adjustScrollBounds(y);\n                        if (y > mLowerBound) {\n                            // scroll the list up a bit\n                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;\n                        } else if (y < mUpperBound) {\n                            // scroll the list down a bit\n                            speed = y < mUpperBound / 2 ? -16 : -4;\n                        }\n                        if (speed != 0) {\n                            int ref = pointToPosition(0, mHeight / 2);\n                            if (ref == AdapterView.INVALID_POSITION) {\n                                //we hit a divider or an invisible view, check somewhere else\n                                ref = pointToPosition(0, mHeight / 2 + getDividerHeight() + 64);\n                            }\n                            View v = getChildAt(ref - getFirstVisiblePosition());\n                            if (v!= null) {\n                                int pos = v.getTop();\n                                setSelectionFromTop(ref, pos - speed);\n                            }\n                        }\n                    }\n                    break;\n            }\n            return true;\n        }\n        return super.onTouchEvent(ev);\n    }\n    \n    private void startDragging(Bitmap bm, int y) {\n        mWindowParams = new WindowManager.LayoutParams();\n        mWindowParams.gravity = Gravity.TOP;\n        mWindowParams.x = 0;\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n\n        mWindowParams.height = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.width = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE\n                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE\n                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON\n                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;\n        mWindowParams.format = PixelFormat.TRANSLUCENT;\n        mWindowParams.windowAnimations = 0;\n        \n        ImageView v = new ImageView(mContext);\n        int backGroundColor = mContext.getResources().getColor(R.color.dragndrop_background);\n        v.setBackgroundColor(backGroundColor);\n        v.setImageBitmap(bm);\n\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n        }\n        mDragBitmap = bm;\n\n        mWindowManager = (WindowManager)mContext.getSystemService(\"window\");\n        mWindowManager.addView(v, mWindowParams);\n        mDragView = v;\n    }\n    \n    private void dragView(int x, int y) {\n        if (mRemoveMode == SLIDE) {\n            float alpha = 1.0f;\n            int width = mDragView.getWidth();\n            if (x > width / 2) {\n                alpha = ((float)(width - x)) / (width / 2);\n            }\n            mWindowParams.alpha = alpha;\n        }\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n        mWindowManager.updateViewLayout(mDragView, mWindowParams);\n    }\n    \n    private void stopDragging() {\n        WindowManager wm = (WindowManager)mContext.getSystemService(\"window\");\n        wm.removeView(mDragView);\n        mDragView = null;\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n            mDragBitmap = null;\n        }\n    }\n    \n    public void setDragListener(DragListener l) {\n        mDragListener = l;\n    }\n    \n    public void setDropListener(DropListener l) {\n        mDropListener = l;\n    }\n    \n    public void setRemoveListener(RemoveListener l) {\n        mRemoveListener = l;\n    }\n\n    public interface DragListener {\n        void drag(int from, int to);\n    }\n    public interface DropListener {\n        void drop(int from, int to);\n    }\n    public interface RemoveListener {\n        void remove(int which);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Bitmap;\nimport android.graphics.PixelFormat;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.view.GestureDetector;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.GestureDetector.SimpleOnGestureListener;\nimport android.widget.AdapterView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\n\npublic class TouchInterceptor extends ListView {\n    \n    private View mDragView;\n    private WindowManager mWindowManager;\n    private WindowManager.LayoutParams mWindowParams;\n    private int mDragPos;      // which item is being dragged\n    private int mFirstDragPos; // where was the dragged item originally\n    private int mDragPoint;    // at what offset inside the item did the user grab it\n    private int mCoordOffset;  // the difference between screen coordinates and coordinates in this view\n    private DragListener mDragListener;\n    private DropListener mDropListener;\n    private RemoveListener mRemoveListener;\n    private int mUpperBound;\n    private int mLowerBound;\n    private int mHeight;\n    private GestureDetector mGestureDetector;\n    private static final int FLING = 0;\n    private static final int SLIDE = 1;\n    private int mRemoveMode = -1;\n    private Rect mTempRect = new Rect();\n    private Bitmap mDragBitmap;\n    private final int mTouchSlop;\n\n    public TouchInterceptor(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        SharedPreferences pref = context.getSharedPreferences(\"Music\", 3);\n        mRemoveMode = pref.getInt(\"deletemode\", -1);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n    \n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (mRemoveListener != null && mGestureDetector == null) {\n            if (mRemoveMode == FLING) {\n                mGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n                    @Override\n                    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\n                            float velocityY) {\n                        if (mDragView != null) {\n                            if (velocityX > 1000) {\n                                Rect r = mTempRect;\n                                mDragView.getDrawingRect(r);\n                                if ( e2.getX() > r.right * 2 / 3) {\n                                    // fast fling right with release near the right edge of the screen\n                                    stopDragging();\n                                    mRemoveListener.remove(mFirstDragPos);\n                                    unExpandViews(true);\n                                }\n                            }\n                            // flinging while dragging should have no effect\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n            }\n        }\n        if (mDragListener != null || mDropListener != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    int itemnum = pointToPosition(x, y);\n                    if (itemnum == AdapterView.INVALID_POSITION) {\n                        break;\n                    }\n                    ViewGroup item = (ViewGroup) getChildAt(itemnum - getFirstVisiblePosition());\n                    mDragPoint = y - item.getTop();\n                    mCoordOffset = ((int)ev.getRawY()) - y;\n                    View dragger = item.findViewById(R.id.icon);\n                    Rect r = mTempRect;\n                    dragger.getDrawingRect(r);\n                    if (x < r.right) {\n                        item.setDrawingCacheEnabled(true);\n                        // Create a copy of the drawing cache so that it does not get recycled\n                        // by the framework when the list tries to clean up memory\n                        Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());\n                        startDragging(bitmap, y);\n                        mDragPos = itemnum;\n                        mFirstDragPos = mDragPos;\n                        mHeight = getHeight();\n                        int touchSlop = mTouchSlop;\n                        mUpperBound = Math.min(y - touchSlop, mHeight / 3);\n                        mLowerBound = Math.max(y + touchSlop, mHeight * 2 /3);\n                        return false;\n                    }\n                    mDragView = null;\n                    break;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n    \n    /*\n     * pointToPosition() doesn't consider invisible views, but we\n     * need to, so implement a slightly different version.\n     */\n    private int myPointToPosition(int x, int y) {\n        Rect frame = mTempRect;\n        final int count = getChildCount();\n        for (int i = count - 1; i >= 0; i--) {\n            final View child = getChildAt(i);\n            child.getHitRect(frame);\n            if (frame.contains(x, y)) {\n                return getFirstVisiblePosition() + i;\n            }\n        }\n        return INVALID_POSITION;\n    }\n    \n    private int getItemForPosition(int y) {\n        int adjustedy = y - mDragPoint - 32;\n        int pos = myPointToPosition(0, adjustedy);\n        if (pos >= 0) {\n            if (pos <= mFirstDragPos) {\n                pos += 1;\n            }\n        } else if (adjustedy < 0) {\n            pos = 0;\n        }\n        return pos;\n    }\n    \n    private void adjustScrollBounds(int y) {\n        if (y >= mHeight / 3) {\n            mUpperBound = mHeight / 3;\n        }\n        if (y <= mHeight * 2 / 3) {\n            mLowerBound = mHeight * 2 / 3;\n        }\n    }\n\n    /*\n     * Restore size and visibility for all listitems\n     */\n    private void unExpandViews(boolean deletion) {\n        for (int i = 0;; i++) {\n            View v = getChildAt(i);\n            if (v == null) {\n                if (deletion) {\n                    // HACK force update of mItemCount\n                    int position = getFirstVisiblePosition();\n                    int y = getChildAt(0).getTop();\n                    setAdapter(getAdapter());\n                    setSelectionFromTop(position, y);\n                    // end hack\n                }\n                layoutChildren(); // force children to be recreated where needed\n                v = getChildAt(i);\n                if (v == null) {\n                    break;\n                }\n            }\n            ViewGroup.LayoutParams params = v.getLayoutParams();\n            params.height = 64;\n            v.setLayoutParams(params);\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /* Adjust visibility and size to make it appear as though\n     * an item is being dragged around and other items are making\n     * room for it:\n     * If dropping the item would result in it still being in the\n     * same place, then make the dragged listitem's size normal,\n     * but make the item invisible.\n     * Otherwise, if the dragged listitem is still on screen, make\n     * it as small as possible and expand the item below the insert\n     * point.\n     * If the dragged item is not on screen, only expand the item\n     * below the current insertpoint.\n     */\n    private void doExpansion() {\n        int childnum = mDragPos - getFirstVisiblePosition();\n        if (mDragPos > mFirstDragPos) {\n            childnum++;\n        }\n\n        View first = getChildAt(mFirstDragPos - getFirstVisiblePosition());\n\n        for (int i = 0;; i++) {\n            View vv = getChildAt(i);\n            if (vv == null) {\n                break;\n            }\n            int height = 64;\n            int visibility = View.VISIBLE;\n            if (vv.equals(first)) {\n                // processing the item that is being dragged\n                if (mDragPos == mFirstDragPos) {\n                    // hovering over the original location\n                    visibility = View.INVISIBLE;\n                } else {\n                    // not hovering over it\n                    height = 1;\n                }\n            } else if (i == childnum) {\n                if (mDragPos < getCount() - 1) {\n                    height = 128;\n                }\n            }\n            ViewGroup.LayoutParams params = vv.getLayoutParams();\n            params.height = height;\n            vv.setLayoutParams(params);\n            vv.setVisibility(visibility);\n        }\n    }\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mGestureDetector != null) {\n            mGestureDetector.onTouchEvent(ev);\n        }\n        if ((mDragListener != null || mDropListener != null) && mDragView != null) {\n            int action = ev.getAction(); \n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    Rect r = mTempRect;\n                    mDragView.getDrawingRect(r);\n                    stopDragging();\n                    if (mRemoveMode == SLIDE && ev.getX() > r.right * 3 / 4) {\n                        if (mRemoveListener != null) {\n                            mRemoveListener.remove(mFirstDragPos);\n                        }\n                        unExpandViews(true);\n                    } else {\n                        if (mDropListener != null && mDragPos >= 0 && mDragPos < getCount()) {\n                            mDropListener.drop(mFirstDragPos, mDragPos);\n                        }\n                        unExpandViews(false);\n                    }\n                    break;\n                    \n                case MotionEvent.ACTION_DOWN:\n                case MotionEvent.ACTION_MOVE:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    dragView(x, y);\n                    int itemnum = getItemForPosition(y);\n                    if (itemnum >= 0) {\n                        if (action == MotionEvent.ACTION_DOWN || itemnum != mDragPos) {\n                            if (mDragListener != null) {\n                                mDragListener.drag(mDragPos, itemnum);\n                            }\n                            mDragPos = itemnum;\n                            doExpansion();\n                        }\n                        int speed = 0;\n                        adjustScrollBounds(y);\n                        if (y > mLowerBound) {\n                            // scroll the list up a bit\n                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;\n                        } else if (y < mUpperBound) {\n                            // scroll the list down a bit\n                            speed = y < mUpperBound / 2 ? -16 : -4;\n                        }\n                        if (speed != 0) {\n                            int ref = pointToPosition(0, mHeight / 2);\n                            if (ref == AdapterView.INVALID_POSITION) {\n                                //we hit a divider or an invisible view, check somewhere else\n                                ref = pointToPosition(0, mHeight / 2 + getDividerHeight() + 64);\n                            }\n                            View v = getChildAt(ref - getFirstVisiblePosition());\n                            if (v!= null) {\n                                int pos = v.getTop();\n                                setSelectionFromTop(ref, pos - speed);\n                            }\n                        }\n                    }\n                    break;\n            }\n            return true;\n        }\n        return super.onTouchEvent(ev);\n    }\n    \n    private void startDragging(Bitmap bm, int y) {\n        mWindowParams = new WindowManager.LayoutParams();\n        mWindowParams.gravity = Gravity.TOP;\n        mWindowParams.x = 0;\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n\n        mWindowParams.height = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.width = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE\n                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE\n                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON\n                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;\n        mWindowParams.format = PixelFormat.TRANSLUCENT;\n        mWindowParams.windowAnimations = 0;\n        \n        ImageView v = new ImageView(mContext);\n        int backGroundColor = mContext.getResources().getColor(R.color.dragndrop_background);\n        v.setBackgroundColor(backGroundColor);\n        v.setImageBitmap(bm);\n\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n        }\n        mDragBitmap = bm;\n\n        mWindowManager = (WindowManager)mContext.getSystemService(\"window\");\n        mWindowManager.addView(v, mWindowParams);\n        mDragView = v;\n    }\n    \n    private void dragView(int x, int y) {\n        if (mRemoveMode == SLIDE) {\n            float alpha = 1.0f;\n            int width = mDragView.getWidth();\n            if (x > width / 2) {\n                alpha = ((float)(width - x)) / (width / 2);\n            }\n            mWindowParams.alpha = alpha;\n        }\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n        mWindowManager.updateViewLayout(mDragView, mWindowParams);\n    }\n    \n    private void stopDragging() {\n        WindowManager wm = (WindowManager)mContext.getSystemService(\"window\");\n        wm.removeView(mDragView);\n        mDragView = null;\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n            mDragBitmap = null;\n        }\n    }\n    \n    public void setDragListener(DragListener l) {\n        mDragListener = l;\n    }\n    \n    public void setDropListener(DropListener l) {\n        mDropListener = l;\n    }\n    \n    public void setRemoveListener(RemoveListener l) {\n        mRemoveListener = l;\n    }\n\n    public interface DragListener {\n        void drag(int from, int to);\n    }\n    public interface DropListener {\n        void drop(int from, int to);\n    }\n    public interface RemoveListener {\n        void remove(int which);\n    }\n}\n","lineNo":149}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Bitmap;\nimport android.graphics.PixelFormat;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.view.GestureDetector;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.GestureDetector.SimpleOnGestureListener;\nimport android.widget.AdapterView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\n\npublic class TouchInterceptor extends ListView {\n    \n    private View mDragView;\n    private WindowManager mWindowManager;\n    private WindowManager.LayoutParams mWindowParams;\n    private int mDragPos;      // which item is being dragged\n    private int mFirstDragPos; // where was the dragged item originally\n    private int mDragPoint;    // at what offset inset the item did the user grab it\n    private int mCoordOffset;  // the difference between screen coordinates and coordinates in this view\n    private DragListener mDragListener;\n    private DropListener mDropListener;\n    private RemoveListener mRemoveListener;\n    private int mUpperBound;\n    private int mLowerBound;\n    private int mHeight;\n    private GestureDetector mGestureDetector;\n    private static final int FLING = 0;\n    private static final int SLIDE = 1;\n    private int mRemoveMode = -1;\n    private Rect mTempRect = new Rect();\n    private Bitmap mDragBitmap;\n    private final int mTouchSlop;\n\n    public TouchInterceptor(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        SharedPreferences pref = context.getSharedPreferences(\"Music\", 3);\n        mRemoveMode = pref.getInt(\"deletemode\", -1);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n    \n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (mRemoveListener != null && mGestureDetector == null) {\n            if (mRemoveMode == FLING) {\n                mGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n                    @Override\n                    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\n                            float velocityY) {\n                        if (mDragView != null) {\n                            if (velocityX > 1000) {\n                                Rect r = mTempRect;\n                                mDragView.getDrawingRect(r);\n                                if ( e2.getX() > r.right * 2 / 3) {\n                                    // fast fling right with release near the right edge of the screen\n                                    stopDragging();\n                                    mRemoveListener.remove(mFirstDragPos);\n                                    unExpandViews(true);\n                                }\n                            }\n                            // flinging while dragging should have no effect\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n            }\n        }\n        if (mDragListener != null || mDropListener != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    int itemnum = pointToPosition(x, y);\n                    if (itemnum == AdapterView.INVALID_POSITION) {\n                        break;\n                    }\n                    ViewGroup item = (ViewGroup) getChildAt(itemnum - getFirstVisiblePosition());\n                    mDragPoint = y - item.getTop();\n                    mCoordOffset = ((int)ev.getRawY()) - y;\n                    View dragger = item.findViewById(R.id.icon);\n                    Rect r = mTempRect;\n                    dragger.getDrawingRect(r);\n                    if (x < r.right) {\n                        item.setDrawingCacheEnabled(true);\n                        // Create a copy of the drawing cache so that it does not get recycled\n                        // by the framework when the list tries to clean up memory\n                        Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());\n                        startDragging(bitmap, y);\n                        mDragPos = itemnum;\n                        mFirstDragPos = mDragPos;\n                        mHeight = getHeight();\n                        int touchSlop = mTouchSlop;\n                        mUpperBound = Math.min(y - touchSlop, mHeight / 3);\n                        mLowerBound = Math.max(y + touchSlop, mHeight * 2 /3);\n                        return false;\n                    }\n                    mDragView = null;\n                    break;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n    \n    /*\n     * pointToPosition() doesn't consider invisible views, but we\n     * need to, so implement a slightly different version.\n     */\n    private int myPointToPosition(int x, int y) {\n        Rect frame = mTempRect;\n        final int count = getChildCount();\n        for (int i = count - 1; i >= 0; i--) {\n            final View child = getChildAt(i);\n            child.getHitRect(frame);\n            if (frame.contains(x, y)) {\n                return getFirstVisiblePosition() + i;\n            }\n        }\n        return INVALID_POSITION;\n    }\n    \n    private int getItemForPosition(int y) {\n        int pos = myPointToPosition(0, y - mDragPoint - 32);\n        if (pos >= 0) {\n            if (pos <= mFirstDragPos) {\n                pos += 1;\n            }\n        } else if ((y - mDragPoint) < 0) {\n            pos = 0;\n        }\n        return pos;\n    }\n    \n    private void adjustScrollBounds(int y) {\n        if (y >= mHeight / 3) {\n            mUpperBound = mHeight / 3;\n        }\n        if (y <= mHeight * 2 / 3) {\n            mLowerBound = mHeight * 2 / 3;\n        }\n    }\n\n    /*\n     * Restore size and visibility for all listitems\n     */\n    private void unExpandViews(boolean deletion) {\n        for (int i = 0;; i++) {\n            View v = getChildAt(i);\n            if (v == null) {\n                if (deletion) {\n                    // HACK force update of mItemCount\n                    int position = getFirstVisiblePosition();\n                    int y = getChildAt(0).getTop();\n                    setAdapter(getAdapter());\n                    setSelectionFromTop(position, y);\n                    // end hack\n                }\n                layoutChildren(); // force children to be recreated where needed\n                v = getChildAt(i);\n                if (v == null) {\n                    break;\n                }\n            }\n            ViewGroup.LayoutParams params = v.getLayoutParams();\n            params.height = 64;\n            v.setLayoutParams(params);\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /* Adjust visibility and size to make it appear as though\n     * an item is being dragged around and other items are making\n     * room for it:\n     * If dropping the item would result in it still being in the\n     * same place, then make the dragged listitem's size normal,\n     * but make the item invisible.\n     * Otherwise, if the dragged listitem is still on screen, make\n     * it as small as possible and expand the item below the insert\n     * point.\n     * If the dragged item is not on screen, only expand the item\n     * below the current insertpoint.\n     */\n    private void doExpansion() {\n        int childnum = mDragPos - getFirstVisiblePosition();\n        if (mDragPos > mFirstDragPos) {\n            childnum++;\n        }\n        View v = getChildAt(childnum);\n        if (v== null) {\n            return;\n        }\n        View first = getChildAt(mFirstDragPos - getFirstVisiblePosition());\n\n        for (int i = 0;; i++) {\n            View vv = getChildAt(i);\n            if (vv == null) {\n                break;\n            }\n            int height = 64;\n            int visibility = View.VISIBLE;\n            if (vv.equals(first)) {\n                // processing the item that is being dragged\n                if (mDragPos == mFirstDragPos) {\n                    // hovering over the original location\n                    visibility = View.INVISIBLE;\n                } else {\n                    // not hovering over it\n                    height = 1;\n                }\n            } else if (i == (mDragPos - getFirstVisiblePosition() + (mDragPos > mFirstDragPos ? 1 : 0))) {\n                height = 128;\n            }\n            ViewGroup.LayoutParams params = vv.getLayoutParams();\n            params.height = height;\n            vv.setLayoutParams(params);\n            vv.setVisibility(visibility);\n        }\n    }\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mGestureDetector != null) {\n            mGestureDetector.onTouchEvent(ev);\n        }\n        if ((mDragListener != null || mDropListener != null) && mDragView != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    Rect r = mTempRect;\n                    mDragView.getDrawingRect(r);\n                    stopDragging();\n                    if (mRemoveMode == SLIDE && ev.getX() > r.right * 3 / 4) {\n                        if (mRemoveListener != null) {\n                            mRemoveListener.remove(mFirstDragPos);\n                        }\n                        unExpandViews(true);\n                    } else {\n                        if (mDropListener != null) {\n                            mDropListener.drop(mFirstDragPos, mDragPos);\n                        }\n                        unExpandViews(false);\n                    }\n                    break;\n                    \n                case MotionEvent.ACTION_MOVE:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    dragView(x, y);\n                    int itemnum = getItemForPosition(y);\n                    if (itemnum >= 0) {\n                        if (true || itemnum != mDragPos) {\n                            if (mDragListener != null) {\n                                mDragListener.drag(mDragPos, itemnum);\n                            }\n                            mDragPos = itemnum;\n                            doExpansion();\n                        }\n                        int speed = 0;\n                        adjustScrollBounds(y);\n                        if (y > mLowerBound) {\n                            // scroll the list up a bit\n                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;\n                        } else if (y < mUpperBound) {\n                            // scroll the list down a bit\n                            speed = y < mUpperBound / 2 ? -16 : -4;\n                        }\n                        if (speed != 0) {\n                            int ref = pointToPosition(0, mHeight / 2);\n                            if (ref == AdapterView.INVALID_POSITION) {\n                                //we hit a divider or an invisible view, check somewhere else\n                                ref = pointToPosition(0, mHeight / 2 + getDividerHeight() + 64);\n                            }\n                            View v = getChildAt(ref - getFirstVisiblePosition());\n                            if (v!= null) {\n                                int pos = v.getTop();\n                                setSelectionFromTop(ref, pos - speed);\n                            }\n                        }\n                    }\n                    break;\n            }\n            return true;\n        }\n        return super.onTouchEvent(ev);\n    }\n    \n    private void startDragging(Bitmap bm, int y) {\n        mWindowParams = new WindowManager.LayoutParams();\n        mWindowParams.gravity = Gravity.TOP;\n        mWindowParams.x = 0;\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n\n        mWindowParams.height = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.width = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE\n                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE\n                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON\n                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;\n        mWindowParams.format = PixelFormat.TRANSLUCENT;\n        mWindowParams.windowAnimations = 0;\n        \n        ImageView v = new ImageView(mContext);\n        int backGroundColor = mContext.getResources().getColor(R.color.dragndrop_background);\n        v.setBackgroundColor(backGroundColor);\n        v.setImageBitmap(bm);\n\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n        }\n        mDragBitmap = bm;\n\n        mWindowManager = (WindowManager)mContext.getSystemService(\"window\");\n        mWindowManager.addView(v, mWindowParams);\n        mDragView = v;\n    }\n    \n    private void dragView(int x, int y) {\n        if (mRemoveMode == SLIDE) {\n            float alpha = 1.0f;\n            int width = mDragView.getWidth();\n            if (x > width / 2) {\n                alpha = ((float)(width - x)) / (width / 2);\n            }\n            mWindowParams.alpha = alpha;\n        }\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n        mWindowManager.updateViewLayout(mDragView, mWindowParams);\n    }\n    \n    private void stopDragging() {\n        WindowManager wm = (WindowManager)mContext.getSystemService(\"window\");\n        wm.removeView(mDragView);\n        mDragView = null;\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n            mDragBitmap = null;\n        }\n    }\n    \n    public void setDragListener(DragListener l) {\n        mDragListener = l;\n    }\n    \n    public void setDropListener(DropListener l) {\n        mDropListener = l;\n    }\n    \n    public void setRemoveListener(RemoveListener l) {\n        mRemoveListener = l;\n    }\n\n    public interface DragListener {\n        void drag(int from, int to);\n    }\n    public interface DropListener {\n        void drop(int from, int to);\n    }\n    public interface RemoveListener {\n        void remove(int which);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.graphics.Bitmap;\nimport android.graphics.PixelFormat;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.view.GestureDetector;\nimport android.view.Gravity;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.WindowManager;\nimport android.view.GestureDetector.SimpleOnGestureListener;\nimport android.widget.AdapterView;\nimport android.widget.ImageView;\nimport android.widget.ListAdapter;\nimport android.widget.ListView;\n\npublic class TouchInterceptor extends ListView {\n    \n    private View mDragView;\n    private WindowManager mWindowManager;\n    private WindowManager.LayoutParams mWindowParams;\n    private int mDragPos;      // which item is being dragged\n    private int mFirstDragPos; // where was the dragged item originally\n    private int mDragPoint;    // at what offset inside the item did the user grab it\n    private int mCoordOffset;  // the difference between screen coordinates and coordinates in this view\n    private DragListener mDragListener;\n    private DropListener mDropListener;\n    private RemoveListener mRemoveListener;\n    private int mUpperBound;\n    private int mLowerBound;\n    private int mHeight;\n    private GestureDetector mGestureDetector;\n    private static final int FLING = 0;\n    private static final int SLIDE = 1;\n    private int mRemoveMode = -1;\n    private Rect mTempRect = new Rect();\n    private Bitmap mDragBitmap;\n    private final int mTouchSlop;\n\n    public TouchInterceptor(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        SharedPreferences pref = context.getSharedPreferences(\"Music\", 3);\n        mRemoveMode = pref.getInt(\"deletemode\", -1);\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n    }\n    \n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (mRemoveListener != null && mGestureDetector == null) {\n            if (mRemoveMode == FLING) {\n                mGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n                    @Override\n                    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\n                            float velocityY) {\n                        if (mDragView != null) {\n                            if (velocityX > 1000) {\n                                Rect r = mTempRect;\n                                mDragView.getDrawingRect(r);\n                                if ( e2.getX() > r.right * 2 / 3) {\n                                    // fast fling right with release near the right edge of the screen\n                                    stopDragging();\n                                    mRemoveListener.remove(mFirstDragPos);\n                                    unExpandViews(true);\n                                }\n                            }\n                            // flinging while dragging should have no effect\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n            }\n        }\n        if (mDragListener != null || mDropListener != null) {\n            switch (ev.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    int itemnum = pointToPosition(x, y);\n                    if (itemnum == AdapterView.INVALID_POSITION) {\n                        break;\n                    }\n                    ViewGroup item = (ViewGroup) getChildAt(itemnum - getFirstVisiblePosition());\n                    mDragPoint = y - item.getTop();\n                    mCoordOffset = ((int)ev.getRawY()) - y;\n                    View dragger = item.findViewById(R.id.icon);\n                    Rect r = mTempRect;\n                    dragger.getDrawingRect(r);\n                    if (x < r.right) {\n                        item.setDrawingCacheEnabled(true);\n                        // Create a copy of the drawing cache so that it does not get recycled\n                        // by the framework when the list tries to clean up memory\n                        Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());\n                        startDragging(bitmap, y);\n                        mDragPos = itemnum;\n                        mFirstDragPos = mDragPos;\n                        mHeight = getHeight();\n                        int touchSlop = mTouchSlop;\n                        mUpperBound = Math.min(y - touchSlop, mHeight / 3);\n                        mLowerBound = Math.max(y + touchSlop, mHeight * 2 /3);\n                        return false;\n                    }\n                    mDragView = null;\n                    break;\n            }\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n    \n    /*\n     * pointToPosition() doesn't consider invisible views, but we\n     * need to, so implement a slightly different version.\n     */\n    private int myPointToPosition(int x, int y) {\n        Rect frame = mTempRect;\n        final int count = getChildCount();\n        for (int i = count - 1; i >= 0; i--) {\n            final View child = getChildAt(i);\n            child.getHitRect(frame);\n            if (frame.contains(x, y)) {\n                return getFirstVisiblePosition() + i;\n            }\n        }\n        return INVALID_POSITION;\n    }\n    \n    private int getItemForPosition(int y) {\n        int adjustedy = y - mDragPoint - 32;\n        int pos = myPointToPosition(0, adjustedy);\n        if (pos >= 0) {\n            if (pos <= mFirstDragPos) {\n                pos += 1;\n            }\n        } else if (adjustedy < 0) {\n            pos = 0;\n        }\n        return pos;\n    }\n    \n    private void adjustScrollBounds(int y) {\n        if (y >= mHeight / 3) {\n            mUpperBound = mHeight / 3;\n        }\n        if (y <= mHeight * 2 / 3) {\n            mLowerBound = mHeight * 2 / 3;\n        }\n    }\n\n    /*\n     * Restore size and visibility for all listitems\n     */\n    private void unExpandViews(boolean deletion) {\n        for (int i = 0;; i++) {\n            View v = getChildAt(i);\n            if (v == null) {\n                if (deletion) {\n                    // HACK force update of mItemCount\n                    int position = getFirstVisiblePosition();\n                    int y = getChildAt(0).getTop();\n                    setAdapter(getAdapter());\n                    setSelectionFromTop(position, y);\n                    // end hack\n                }\n                layoutChildren(); // force children to be recreated where needed\n                v = getChildAt(i);\n                if (v == null) {\n                    break;\n                }\n            }\n            ViewGroup.LayoutParams params = v.getLayoutParams();\n            params.height = 64;\n            v.setLayoutParams(params);\n            v.setVisibility(View.VISIBLE);\n        }\n    }\n    \n    /* Adjust visibility and size to make it appear as though\n     * an item is being dragged around and other items are making\n     * room for it:\n     * If dropping the item would result in it still being in the\n     * same place, then make the dragged listitem's size normal,\n     * but make the item invisible.\n     * Otherwise, if the dragged listitem is still on screen, make\n     * it as small as possible and expand the item below the insert\n     * point.\n     * If the dragged item is not on screen, only expand the item\n     * below the current insertpoint.\n     */\n    private void doExpansion() {\n        int childnum = mDragPos - getFirstVisiblePosition();\n        if (mDragPos > mFirstDragPos) {\n            childnum++;\n        }\n\n        View first = getChildAt(mFirstDragPos - getFirstVisiblePosition());\n\n        for (int i = 0;; i++) {\n            View vv = getChildAt(i);\n            if (vv == null) {\n                break;\n            }\n            int height = 64;\n            int visibility = View.VISIBLE;\n            if (vv.equals(first)) {\n                // processing the item that is being dragged\n                if (mDragPos == mFirstDragPos) {\n                    // hovering over the original location\n                    visibility = View.INVISIBLE;\n                } else {\n                    // not hovering over it\n                    height = 1;\n                }\n            } else if (i == childnum) {\n                if (mDragPos < getCount() - 1) {\n                    height = 128;\n                }\n            }\n            ViewGroup.LayoutParams params = vv.getLayoutParams();\n            params.height = height;\n            vv.setLayoutParams(params);\n            vv.setVisibility(visibility);\n        }\n    }\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (mGestureDetector != null) {\n            mGestureDetector.onTouchEvent(ev);\n        }\n        if ((mDragListener != null || mDropListener != null) && mDragView != null) {\n            int action = ev.getAction(); \n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    Rect r = mTempRect;\n                    mDragView.getDrawingRect(r);\n                    stopDragging();\n                    if (mRemoveMode == SLIDE && ev.getX() > r.right * 3 / 4) {\n                        if (mRemoveListener != null) {\n                            mRemoveListener.remove(mFirstDragPos);\n                        }\n                        unExpandViews(true);\n                    } else {\n                        if (mDropListener != null && mDragPos >= 0 && mDragPos < getCount()) {\n                            mDropListener.drop(mFirstDragPos, mDragPos);\n                        }\n                        unExpandViews(false);\n                    }\n                    break;\n                    \n                case MotionEvent.ACTION_DOWN:\n                case MotionEvent.ACTION_MOVE:\n                    int x = (int) ev.getX();\n                    int y = (int) ev.getY();\n                    dragView(x, y);\n                    int itemnum = getItemForPosition(y);\n                    if (itemnum >= 0) {\n                        if (action == MotionEvent.ACTION_DOWN || itemnum != mDragPos) {\n                            if (mDragListener != null) {\n                                mDragListener.drag(mDragPos, itemnum);\n                            }\n                            mDragPos = itemnum;\n                            doExpansion();\n                        }\n                        int speed = 0;\n                        adjustScrollBounds(y);\n                        if (y > mLowerBound) {\n                            // scroll the list up a bit\n                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;\n                        } else if (y < mUpperBound) {\n                            // scroll the list down a bit\n                            speed = y < mUpperBound / 2 ? -16 : -4;\n                        }\n                        if (speed != 0) {\n                            int ref = pointToPosition(0, mHeight / 2);\n                            if (ref == AdapterView.INVALID_POSITION) {\n                                //we hit a divider or an invisible view, check somewhere else\n                                ref = pointToPosition(0, mHeight / 2 + getDividerHeight() + 64);\n                            }\n                            View v = getChildAt(ref - getFirstVisiblePosition());\n                            if (v!= null) {\n                                int pos = v.getTop();\n                                setSelectionFromTop(ref, pos - speed);\n                            }\n                        }\n                    }\n                    break;\n            }\n            return true;\n        }\n        return super.onTouchEvent(ev);\n    }\n    \n    private void startDragging(Bitmap bm, int y) {\n        mWindowParams = new WindowManager.LayoutParams();\n        mWindowParams.gravity = Gravity.TOP;\n        mWindowParams.x = 0;\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n\n        mWindowParams.height = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.width = WindowManager.LayoutParams.WRAP_CONTENT;\n        mWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE\n                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE\n                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON\n                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;\n        mWindowParams.format = PixelFormat.TRANSLUCENT;\n        mWindowParams.windowAnimations = 0;\n        \n        ImageView v = new ImageView(mContext);\n        int backGroundColor = mContext.getResources().getColor(R.color.dragndrop_background);\n        v.setBackgroundColor(backGroundColor);\n        v.setImageBitmap(bm);\n\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n        }\n        mDragBitmap = bm;\n\n        mWindowManager = (WindowManager)mContext.getSystemService(\"window\");\n        mWindowManager.addView(v, mWindowParams);\n        mDragView = v;\n    }\n    \n    private void dragView(int x, int y) {\n        if (mRemoveMode == SLIDE) {\n            float alpha = 1.0f;\n            int width = mDragView.getWidth();\n            if (x > width / 2) {\n                alpha = ((float)(width - x)) / (width / 2);\n            }\n            mWindowParams.alpha = alpha;\n        }\n        mWindowParams.y = y - mDragPoint + mCoordOffset;\n        mWindowManager.updateViewLayout(mDragView, mWindowParams);\n    }\n    \n    private void stopDragging() {\n        WindowManager wm = (WindowManager)mContext.getSystemService(\"window\");\n        wm.removeView(mDragView);\n        mDragView = null;\n        if (mDragBitmap != null) {\n            mDragBitmap.recycle();\n            mDragBitmap = null;\n        }\n    }\n    \n    public void setDragListener(DragListener l) {\n        mDragListener = l;\n    }\n    \n    public void setDropListener(DropListener l) {\n        mDropListener = l;\n    }\n    \n    public void setRemoveListener(RemoveListener l) {\n        mRemoveListener = l;\n    }\n\n    public interface DragListener {\n        void drag(int from, int to);\n    }\n    public interface DropListener {\n        void drop(int from, int to);\n    }\n    public interface RemoveListener {\n        void remove(int which);\n    }\n}\n","lineNo":252}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int SLOP = ViewConfiguration.getTouchSlop();\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > SLOP) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        \n        CharSequence artist = mArtistName.getText();\n        CharSequence album = mAlbumName.getText();\n        CharSequence song = mTrackName.getText();\n        \n        if (view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist.toString();\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mAlbumName.getParent())) {\n            title = album;\n            query = artist + \" \" + album;\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent())) {\n            title = song;\n            query = artist + \" \" + song;\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n        } catch (RemoteException ex) {\n            return true;\n        }\n        \n        boolean knownartist = !MediaFile.UNKNOWN_STRING.equals(artist);\n        boolean knownalbum = !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist.toString();\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":284}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int SLOP = ViewConfiguration.getTouchSlop();\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > SLOP) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        \n        CharSequence artist = mArtistName.getText();\n        CharSequence album = mAlbumName.getText();\n        CharSequence song = mTrackName.getText();\n        \n        if (view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist.toString();\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mAlbumName.getParent())) {\n            title = album;\n            query = artist + \" \" + album;\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent())) {\n            title = song;\n            query = artist + \" \" + song;\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n    private int mTouchSlop;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n\n        mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > mTouchSlop) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        String artist;\n        String album;\n        String song;\n        \n        try {\n            artist = mService.getArtistName();\n            album = mService.getAlbumName();\n            song = mService.getTrackName();\n        } catch (RemoteException ex) {\n            return true;\n        }\n        \n        boolean knownartist = !MediaFile.UNKNOWN_STRING.equals(artist);\n        boolean knownalbum = !MediaFile.UNKNOWN_STRING.equals(album);\n        \n        if (knownartist && view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist.toString();\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (knownalbum && view.equals(mAlbumName.getParent())) {\n            title = album;\n            if (knownartist) {\n                query = artist + \" \" + album;\n            } else {\n                query = album;\n            }\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent()) || !knownartist || !knownalbum) {\n            title = song;\n            if (knownartist) {\n                query = artist + \" \" + song;\n            } else {\n                query = song;\n            }\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        if(knownartist) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        }\n        if(knownalbum) {\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        }\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(android.R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":285}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.CursorAdapter;\nimport android.widget.CursorTreeAdapter;\nimport android.widget.ExpandableListAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public ArtistAlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        ExpandableListView lv = getExpandableListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n                setTitle();\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            setTitle();\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n    }\n\n    private void setTitle() {\n      if (mArtistCursor != null && mArtistCursor.getCount() > 0) {\n        setTitle(R.string.artists_title);\n    } else {\n        setTitle(R.string.no_artists_title);\n    }\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        mArtistCursor.moveToPosition(groupPosition);\n        mCurrentArtistId = Long.valueOf(id).toString();\n        intent.putExtra(\"artist\", mCurrentArtistId);\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            menu.setHeaderTitle(mCurrentArtistName);\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                int [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            title = mCurrentAlbumName;\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n                mActivity.setTitle();\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(1, 1, 1, 1);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(1, 1, 1, 1);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = MediaFile.UNKNOWN_STRING.equals(artist);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsSongsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            int currentartistid = MusicUtils.getCurrentArtistId();\n            int artistid = cursor.getInt(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            if (name.equals(MediaFile.UNKNOWN_STRING)) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n            int first = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.FIRST_YEAR));\n            int last = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.LAST_YEAR));\n\n            if (first == 0) {\n                first = last;\n            }\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            if (first != 0 && last != 0) {\n                builder.append(\"\\n\");\n                \n                builder.append(first);\n                if (first != last) {\n                    builder.append('-');\n                    builder.append(last);\n                } else {\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            int id = groupCursor.getInt(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.FIRST_YEAR,\n                    MediaStore.Audio.Albums.LAST_YEAR,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (MediaFile.UNKNOWN_STRING.equals(mArtistName)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (name.equals(MediaStore.Audio.Albums.ARTIST)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getArtistCursor(null, constraint.toString());\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport com.android.music.QueryBrowserActivity.QueryListAdapter.QueryHandler;\n\nimport android.app.ExpandableListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.CursorAdapter;\nimport android.widget.CursorTreeAdapter;\nimport android.widget.ExpandableListAdapter;\nimport android.widget.ExpandableListView;\nimport android.widget.ImageView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorTreeAdapter;\nimport android.widget.TextView;\nimport android.widget.ExpandableListView.ExpandableListContextMenuInfo;\n\nimport java.text.Collator;\n\n\npublic class ArtistAlbumBrowserActivity extends ExpandableListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private String mCurrentArtistId;\n    private String mCurrentArtistName;\n    private String mCurrentAlbumId;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private ArtistAlbumListAdapter mAdapter;\n    private boolean mAdapterSent;\n    private final static int SEARCH = CHILD_MENU_BASE;\n\n    public ArtistAlbumBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mCurrentAlbumId = icicle.getString(\"selectedalbum\");\n            mCurrentAlbumName = icicle.getString(\"selectedalbumname\");\n            mCurrentArtistId = icicle.getString(\"selectedartist\");\n            mCurrentArtistName = icicle.getString(\"selectedartistname\");\n        }\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity_expanding);\n        ExpandableListView lv = getExpandableListView();\n        lv.setFastScrollEnabled(true);\n        lv.setOnCreateContextMenuListener(this);\n        lv.setTextFilterEnabled(true);\n\n        mAdapter = (ArtistAlbumListAdapter) getLastNonConfigurationInstance();\n        if (mAdapter == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            mAdapter = new ArtistAlbumListAdapter(\n                    getApplication(),\n                    this,\n                    null, // cursor\n                    R.layout.track_list_item_group,\n                    new String[] {},\n                    new int[] {},\n                    R.layout.track_list_item_child,\n                    new String[] {},\n                    new int[] {});\n            setListAdapter(mAdapter);\n            setTitle(R.string.working_artists);\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        } else {\n            mAdapter.setActivity(this);\n            setListAdapter(mAdapter);\n            mArtistCursor = mAdapter.getCursor();\n            if (mArtistCursor != null) {\n                init(mArtistCursor);\n                setTitle();\n            } else {\n                getArtistCursor(mAdapter.getQueryHandler(), null);\n            }\n        }\n    }\n\n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        mAdapterSent = true;\n        return mAdapter;\n    }\n    \n    @Override\n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putString(\"selectedalbum\", mCurrentAlbumId);\n        outcicle.putString(\"selectedalbumname\", mCurrentAlbumName);\n        outcicle.putString(\"selectedartist\", mCurrentArtistId);\n        outcicle.putString(\"selectedartistname\", mCurrentArtistName);\n        super.onSaveInstanceState(outcicle);\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        if (!mAdapterSent) {\n            Cursor c = mAdapter.getCursor();\n            if (c != null) {\n                c.close();\n            }\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        registerReceiver(mTrackListListener, f);\n        mTrackListListener.onReceive(null, null);\n\n        MusicUtils.setSpinnerState(this);\n    }\n\n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getExpandableListView().invalidateViews();\n        }\n    };\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(ArtistAlbumBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n            if (intent.getAction().equals(Intent.ACTION_MEDIA_UNMOUNTED)) {\n                MusicUtils.clearAlbumArtCache();\n            }\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            setTitle();\n            getArtistCursor(mAdapter.getQueryHandler(), null);\n        }\n    };\n\n    @Override\n    public void onPause() {\n        unregisterReceiver(mTrackListListener);\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    public void init(Cursor c) {\n\n        mAdapter.changeCursor(c); // also sets mArtistCursor\n\n        if (mArtistCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            closeContextMenu();\n            mReScanHandler.sendEmptyMessageDelayed(0, 1000);\n            return;\n        }\n\n        MusicUtils.hideDatabaseError(this);\n    }\n\n    private void setTitle() {\n      if (mArtistCursor != null && mArtistCursor.getCount() > 0) {\n        setTitle(R.string.artists_title);\n    } else {\n        setTitle(R.string.no_artists_title);\n    }\n    }\n    \n    @Override\n    public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\n        mCurrentAlbumId = Long.valueOf(id).toString();\n        \n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n        intent.putExtra(\"album\", mCurrentAlbumId);\n        Cursor c = (Cursor) getExpandableListAdapter().getChild(groupPosition, childPosition);\n        String album = c.getString(c.getColumnIndex(MediaStore.Audio.Albums.ALBUM));\n        if (album.equals(MediaFile.UNKNOWN_STRING)) {\n            // unknown album, so we should include the artist ID to limit the songs to songs only by that artist \n            mArtistCursor.moveToPosition(groupPosition);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndex(MediaStore.Audio.Artists._ID));\n            intent.putExtra(\"artist\", mCurrentArtistId);\n        }\n        startActivity(intent);\n        return true;\n    }\n    \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback);\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        return true;\n    }\n    \n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.findItem(GOTO_PLAYBACK).setVisible(MusicUtils.isMusicLoaded());\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        \n        ExpandableListContextMenuInfo mi = (ExpandableListContextMenuInfo) menuInfoIn;\n        \n        int itemtype = ExpandableListView.getPackedPositionType(mi.packedPosition);\n        int gpos = ExpandableListView.getPackedPositionGroup(mi.packedPosition);\n        int cpos = ExpandableListView.getPackedPositionChild(mi.packedPosition);\n        if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {\n            if (gpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no group\");\n                return;\n            }\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistId = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            mCurrentArtistName = mArtistCursor.getString(mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            mCurrentAlbumId = null;\n            menu.setHeaderTitle(mCurrentArtistName);\n            return;\n        } else if (itemtype == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {\n            if (cpos == -1) {\n                // this shouldn't happen\n                Log.d(\"Artist/Album\", \"no child\");\n                return;\n            }\n            Cursor c = (Cursor) getExpandableListAdapter().getChild(gpos, cpos);\n            c.moveToPosition(cpos);\n            mCurrentArtistId = null;\n            mCurrentAlbumId = Long.valueOf(mi.id).toString();\n            mCurrentAlbumName = c.getString(c.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            gpos = gpos - getExpandableListView().getHeaderViewsCount();\n            mArtistCursor.moveToPosition(gpos);\n            mCurrentArtistNameForAlbum = mArtistCursor.getString(\n                    mArtistCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n            menu.setHeaderTitle(mCurrentAlbumName);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play everything by the selected artist\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        \n                MusicUtils.playAll(this, list, 0);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list =\n                    mCurrentArtistId != null ?\n                    MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId))\n                    : MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n            \n            case DELETE_ITEM: {\n                int [] list;\n                String desc;\n                if (mCurrentArtistId != null) {\n                    list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                    String f = getString(R.string.delete_artist_desc);\n                    desc = String.format(f, mCurrentArtistName);\n                } else {\n                    list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                    String f = getString(R.string.delete_album_desc); \n                    desc = String.format(f, mCurrentAlbumName);\n                }\n                Bundle b = new Bundle();\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        if (mCurrentArtistId != null) {\n            title = mCurrentArtistName;\n            query = mCurrentArtistName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE);\n        } else {\n            title = mCurrentAlbumName;\n            query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n            i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n            i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n            i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE);\n        }\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getArtistCursor(mAdapter.getQueryHandler(), null);\n                }\n                break;\n\n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = null;\n                        if (mCurrentArtistId != null) {\n                            list = MusicUtils.getSongListForArtist(this, Integer.parseInt(mCurrentArtistId));\n                        } else if (mCurrentAlbumId != null) {\n                            list = MusicUtils.getSongListForAlbum(this, Integer.parseInt(mCurrentAlbumId));\n                        }\n                        MusicUtils.addToPlaylist(this, list, Integer.parseInt(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {\n\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Artists.ARTIST + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filter != null) {\n            String [] searchWords = filter.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \" LIKE ?\");\n            }\n        }\n\n        String whereclause = where.toString();  \n        String[] cols = new String[] {\n                MediaStore.Audio.Artists._ID,\n                MediaStore.Audio.Artists.ARTIST,\n                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,\n                MediaStore.Audio.Artists.NUMBER_OF_TRACKS\n        };\n        Cursor ret = null;\n        if (async != null) {\n            async.startQuery(0, null, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        } else {\n            ret = MusicUtils.query(this, MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,\n                    cols, whereclause , keywords, MediaStore.Audio.Artists.ARTIST_KEY);\n        }\n        return ret;\n    }\n    \n    static class ArtistAlbumListAdapter extends SimpleCursorTreeAdapter implements SectionIndexer {\n        \n        private final Drawable mNowPlayingOverlay;\n        private final BitmapDrawable mDefaultAlbumIcon;\n        private int mGroupArtistIdIdx;\n        private int mGroupArtistIdx;\n        private int mGroupAlbumIdx;\n        private int mGroupSongIdx;\n        private final Context mContext;\n        private final Resources mResources;\n        private final String mAlbumSongSeparator;\n        private final String mUnknownAlbum;\n        private final String mUnknownArtist;\n        private final StringBuilder mBuffer = new StringBuilder();\n        private final Object[] mFormatArgs = new Object[1];\n        private final Object[] mFormatArgs3 = new Object[3];\n        private MusicAlphabetIndexer mIndexer;\n        private ArtistAlbumBrowserActivity mActivity;\n        private AsyncQueryHandler mQueryHandler;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            ImageView play_indicator;\n            ImageView icon;\n        }\n\n        class QueryHandler extends AsyncQueryHandler {\n            QueryHandler(ContentResolver res) {\n                super(res);\n            }\n            \n            @Override\n            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n                //Log.i(\"@@@\", \"query complete\");\n                mActivity.init(cursor);\n                mActivity.setTitle();\n            }\n        }\n\n        ArtistAlbumListAdapter(Context context, ArtistAlbumBrowserActivity currentactivity,\n                Cursor cursor, int glayout, String[] gfrom, int[] gto, \n                int clayout, String[] cfrom, int[] cto) {\n            super(context, cursor, glayout, gfrom, gto, clayout, cfrom, cto);\n            mActivity = currentactivity;\n            mQueryHandler = new QueryHandler(context.getContentResolver());\n\n            Resources r = context.getResources();\n            mNowPlayingOverlay = r.getDrawable(R.drawable.indicator_ic_mp_playing_list);\n            mDefaultAlbumIcon = (BitmapDrawable) r.getDrawable(R.drawable.albumart_mp_unknown_list);\n            // no filter or dither, it's a lot faster and we can't tell the difference\n            mDefaultAlbumIcon.setFilterBitmap(false);\n            mDefaultAlbumIcon.setDither(false);\n            \n            mContext = context;\n            getColumnIndices(cursor);\n            mResources = context.getResources();\n            mAlbumSongSeparator = context.getString(R.string.albumsongseparator);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n        }\n        \n        private void getColumnIndices(Cursor cursor) {\n            if (cursor != null) {\n                mGroupArtistIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID);\n                mGroupArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST);\n                mGroupAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_ALBUMS);\n                mGroupSongIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.NUMBER_OF_TRACKS);\n                if (mIndexer != null) {\n                    mIndexer.setCursor(cursor);\n                } else {\n                    mIndexer = new MusicAlphabetIndexer(cursor, mGroupArtistIdx, \n                            mResources.getString(com.android.internal.R.string.fast_scroll_alphabet));\n                }\n            }\n        }\n        \n        public void setActivity(ArtistAlbumBrowserActivity newactivity) {\n            mActivity = newactivity;\n        }\n        \n        public AsyncQueryHandler getQueryHandler() {\n            return mQueryHandler;\n        }\n\n        @Override\n        public View newGroupView(Context context, Cursor cursor, boolean isExpanded, ViewGroup parent) {\n            View v = super.newGroupView(context, cursor, isExpanded, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            ViewGroup.LayoutParams p = iv.getLayoutParams();\n            p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n            p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setPadding(1, 1, 1, 1);\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public View newChildView(Context context, Cursor cursor, boolean isLastChild,\n                ViewGroup parent) {\n            View v = super.newChildView(context, cursor, isLastChild, parent);\n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.icon = (ImageView) v.findViewById(R.id.icon);\n            vh.icon.setBackgroundDrawable(mDefaultAlbumIcon);\n            vh.icon.setPadding(1, 1, 1, 1);\n            v.setTag(vh);\n            return v;\n        }\n        \n        @Override\n        public void bindGroupView(View view, Context context, Cursor cursor, boolean isexpanded) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String artist = cursor.getString(mGroupArtistIdx);\n            String displayartist = artist;\n            boolean unknown = MediaFile.UNKNOWN_STRING.equals(artist);\n            if (unknown) {\n                displayartist = mUnknownArtist;\n            }\n            vh.line1.setText(displayartist);\n\n            int numalbums = cursor.getInt(mGroupAlbumIdx);\n            int numsongs = cursor.getInt(mGroupSongIdx);\n            \n            String songs_albums = MusicUtils.makeAlbumsSongsLabel(context,\n                    numalbums, numsongs, unknown);\n            \n            vh.line2.setText(songs_albums);\n            \n            int currentartistid = MusicUtils.getCurrentArtistId();\n            int artistid = cursor.getInt(mGroupArtistIdIdx);\n            if (currentartistid == artistid && !isexpanded) {\n                vh.play_indicator.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                vh.play_indicator.setImageDrawable(null);\n            }\n        }\n\n        @Override\n        public void bindChildView(View view, Context context, Cursor cursor, boolean islast) {\n\n            ViewHolder vh = (ViewHolder) view.getTag();\n\n            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));\n            String displayname = name;\n            boolean unknown = name.equals(MediaFile.UNKNOWN_STRING); \n            if (unknown) {\n                displayname = mUnknownAlbum;\n            }\n            vh.line1.setText(displayname);\n\n            int numsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS));\n            int numartistsongs = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST));\n            int first = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.FIRST_YEAR));\n            int last = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Audio.Albums.LAST_YEAR));\n\n            if (first == 0) {\n                first = last;\n            }\n\n            final StringBuilder builder = mBuffer;\n            builder.delete(0, builder.length());\n            if (unknown) {\n                numsongs = numartistsongs;\n            }\n              \n            if (numsongs == 1) {\n                builder.append(context.getString(R.string.onesong));\n            } else {\n                if (numsongs == numartistsongs) {\n                    final Object[] args = mFormatArgs;\n                    args[0] = numsongs;\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongs, numsongs, args));\n                } else {\n                    final Object[] args = mFormatArgs3;\n                    args[0] = numsongs;\n                    args[1] = numartistsongs;\n                    args[2] = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));\n                    builder.append(mResources.getQuantityString(R.plurals.Nsongscomp, numsongs, args));\n                }\n            }\n            // If this is the unknown album, we don't really have any information about the year,\n            // since the year info is be for the entire collection of unknown album songs, not\n            // just the ones belonging to this artist.\n            if (!unknown && first != 0 && last != 0) {\n                builder.append(\"\\n\");\n                \n                builder.append(first);\n                if (first != last) {\n                    builder.append('-');\n                    builder.append(last);\n                } else {\n                }\n            }\n            vh.line2.setText(builder.toString());\n            \n            ImageView iv = vh.icon;\n            // We don't actually need the path to the thumbnail file,\n            // we just use it to see if there is album art or not\n            String art = cursor.getString(cursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Albums.ALBUM_ART));\n            if (art == null || art.length() == 0) {\n                iv.setBackgroundDrawable(mDefaultAlbumIcon);\n                iv.setImageDrawable(null);\n            } else {\n                int artIndex = cursor.getInt(0);\n                Drawable d = MusicUtils.getCachedArtwork(context, artIndex, mDefaultAlbumIcon);\n                iv.setImageDrawable(d);\n            }\n\n            int currentalbumid = MusicUtils.getCurrentAlbumId();\n            int aid = cursor.getInt(0);\n            iv = vh.play_indicator;\n            if (currentalbumid == aid) {\n                iv.setImageDrawable(mNowPlayingOverlay);\n            } else {\n                iv.setImageDrawable(null);\n            }\n        }\n\n        \n        @Override\n        protected Cursor getChildrenCursor(Cursor groupCursor) {\n            \n            int id = groupCursor.getInt(groupCursor.getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));\n            \n            String[] cols = new String[] {\n                    MediaStore.Audio.Albums._ID,\n                    MediaStore.Audio.Albums.ALBUM,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS,\n                    MediaStore.Audio.Albums.NUMBER_OF_SONGS_FOR_ARTIST,\n                    MediaStore.Audio.Albums.FIRST_YEAR,\n                    MediaStore.Audio.Albums.LAST_YEAR,\n                    MediaStore.Audio.Albums.ALBUM_ART\n            };\n            Cursor c = MusicUtils.query(mActivity,\n                    MediaStore.Audio.Artists.Albums.getContentUri(\"external\", id),\n                    cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);\n            \n            class MyCursorWrapper extends CursorWrapper {\n                String mArtistName;\n                int mMagicColumnIdx;\n                MyCursorWrapper(Cursor c, String artist) {\n                    super(c);\n                    mArtistName = artist;\n                    if (MediaFile.UNKNOWN_STRING.equals(mArtistName)) {\n                        mArtistName = mUnknownArtist;\n                    }\n                    mMagicColumnIdx = c.getColumnCount();\n                }\n                \n                @Override\n                public String getString(int columnIndex) {\n                    if (columnIndex != mMagicColumnIdx) {\n                        return super.getString(columnIndex);\n                    }\n                    return mArtistName;\n                }\n                \n                @Override\n                public int getColumnIndexOrThrow(String name) {\n                    if (name.equals(MediaStore.Audio.Albums.ARTIST)) {\n                        return mMagicColumnIdx;\n                    }\n                    return super.getColumnIndexOrThrow(name); \n                }\n                \n                @Override\n                public String getColumnName(int idx) {\n                    if (idx != mMagicColumnIdx) {\n                        return super.getColumnName(idx);\n                    }\n                    return MediaStore.Audio.Albums.ARTIST;\n                }\n                \n                @Override\n                public int getColumnCount() {\n                    return super.getColumnCount() + 1;\n                }\n            }\n            return new MyCursorWrapper(c, groupCursor.getString(mGroupArtistIdx));\n        }\n\n        @Override\n        public void changeCursor(Cursor cursor) {\n            if (cursor != mActivity.mArtistCursor) {\n                mActivity.mArtistCursor = cursor;\n                getColumnIndices(cursor);\n                super.changeCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return mActivity.getArtistCursor(null, constraint.toString());\n        }\n\n        public Object[] getSections() {\n            return mIndexer.getSections();\n        }\n        \n        public int getPositionForSection(int sectionIndex) {\n            return mIndexer.getPositionForSection(sectionIndex);\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }\n    }\n    \n    private Cursor mArtistCursor;\n}\n\n","lineNo":658}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.os.Handler;\nimport android.os.Message;\n\n/**\n * \n */\npublic class MediaButtonIntentReceiver extends BroadcastReceiver {\n\n    private static final int MSG_LONGPRESS_TIMEOUT = 1;\n    private static final int LONG_PRESS_DELAY = 1000;\n\n    private static long mLastClickTime = 0;\n    private static boolean mDown = false;\n    private static boolean mLaunched = false;\n\n    private static Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_LONGPRESS_TIMEOUT:\n                    if (!mLaunched) {\n                        Context context = (Context)msg.obj;\n                        Intent i = new Intent();\n                        i.putExtra(\"autoshuffle\", \"true\");\n                        i.setClass(context, MusicBrowserActivity.class);\n                        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                        context.startActivity(i);\n                        mLaunched = true;\n                    }\n                    break;\n            }\n        }\n    };\n    \n    @Override\n    public void onReceive(Context context, Intent intent) {\n        KeyEvent event = (KeyEvent)\n                intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);\n        \n        if (event == null) {\n            return;\n        }\n\n        int keycode = event.getKeyCode();\n        int action = event.getAction();\n        long eventtime = event.getEventTime();\n\n        // single quick press: pause/resume. \n        // double press: next track\n        // long press: start auto-shuffle mode.\n\n        if (keycode == KeyEvent.KEYCODE_HEADSETHOOK) {\n            if (action == KeyEvent.ACTION_DOWN) {\n                if (!mDown) {\n                    // only if this isn't a repeat event\n                    \n                    // We're not using the original time of the event as the\n                    // base here, because in some cases it can take more than\n                    // one second for us to receive the event, in which case\n                    // we would go immediately to auto shuffle mode, even if\n                    // the user didn't long press.\n                    mHandler.sendMessageDelayed(\n                            mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context),\n                            LONG_PRESS_DELAY);\n\n                    \n                    SharedPreferences pref = context.getSharedPreferences(\"Music\", \n                            Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE);\n                    String q = pref.getString(\"queue\", \"\");\n                    // The service may or may not be running, but we need to send it\n                    // a command.\n                    Intent i = new Intent(context, MediaPlaybackService.class);\n                    i.setAction(MediaPlaybackService.SERVICECMD);\n                    if (eventtime - mLastClickTime < 300) {\n                        i.putExtra(MediaPlaybackService.CMDNAME, MediaPlaybackService.CMDNEXT);\n                        context.startService(i);\n                        mLastClickTime = 0;\n                    } else {\n                        i.putExtra(MediaPlaybackService.CMDNAME,\n                                MediaPlaybackService.CMDTOGGLEPAUSE);\n                        context.startService(i);\n                        mLastClickTime = eventtime;\n                    }\n\n                    mLaunched = false;\n                    mDown = true;\n                }\n            } else {\n                mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);\n                mDown = false;\n            }\n            abortBroadcast();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.BroadcastReceiver;\nimport android.content.SharedPreferences;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.os.Handler;\nimport android.os.Message;\n\n/**\n * \n */\npublic class MediaButtonIntentReceiver extends BroadcastReceiver {\n\n    private static final int MSG_LONGPRESS_TIMEOUT = 1;\n    private static final int LONG_PRESS_DELAY = 1000;\n\n    private static long mLastClickTime = 0;\n    private static boolean mDown = false;\n    private static boolean mLaunched = false;\n\n    private static Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_LONGPRESS_TIMEOUT:\n                    if (!mLaunched) {\n                        Context context = (Context)msg.obj;\n                        Intent i = new Intent();\n                        i.putExtra(\"autoshuffle\", \"true\");\n                        i.setClass(context, MusicBrowserActivity.class);\n                        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                        context.startActivity(i);\n                        mLaunched = true;\n                    }\n                    break;\n            }\n        }\n    };\n    \n    @Override\n    public void onReceive(Context context, Intent intent) {\n        KeyEvent event = (KeyEvent)\n                intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);\n        \n        if (event == null) {\n            return;\n        }\n\n        int keycode = event.getKeyCode();\n        int action = event.getAction();\n        long eventtime = event.getEventTime();\n\n        // single quick press: pause/resume. \n        // double press: next track\n        // long press: start auto-shuffle mode.\n        \n        String command = null;\n        switch (keycode) {\n            case KeyEvent.KEYCODE_HEADSETHOOK:\n            case KeyEvent.KEYCODE_PLAYPAUSE:\n                command = MediaPlaybackService.CMDTOGGLEPAUSE;\n                break;\n            case KeyEvent.KEYCODE_NEXTSONG:\n                command = MediaPlaybackService.CMDNEXT;\n                break;\n            case KeyEvent.KEYCODE_PREVIOUSSONG:\n                command = MediaPlaybackService.CMDPREVIOUS;\n                break;\n        }\n\n        if (command != null) {\n            if (action == KeyEvent.ACTION_DOWN) {\n                if (!mDown) {\n                    // only if this isn't a repeat event\n                    \n                    if (MediaPlaybackService.CMDTOGGLEPAUSE.equals(command)) {\n                        // We're not using the original time of the event as the\n                        // base here, because in some cases it can take more than\n                        // one second for us to receive the event, in which case\n                        // we would go immediately to auto shuffle mode, even if\n                        // the user didn't long press.\n                        mHandler.sendMessageDelayed(\n                                mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context),\n                                LONG_PRESS_DELAY);\n                    }\n                    \n                    SharedPreferences pref = context.getSharedPreferences(\"Music\", \n                            Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE);\n                    String q = pref.getString(\"queue\", \"\");\n                    // The service may or may not be running, but we need to send it\n                    // a command.\n                    Intent i = new Intent(context, MediaPlaybackService.class);\n                    i.setAction(MediaPlaybackService.SERVICECMD);\n                    if (keycode == KeyEvent.KEYCODE_HEADSETHOOK && eventtime - mLastClickTime < 300) {\n                        i.putExtra(MediaPlaybackService.CMDNAME, MediaPlaybackService.CMDNEXT);\n                        context.startService(i);\n                        mLastClickTime = 0;\n                    } else {\n                        i.putExtra(MediaPlaybackService.CMDNAME, command);\n                        context.startService(i);\n                        mLastClickTime = eventtime;\n                    }\n\n                    mLaunched = false;\n                    mDown = true;\n                }\n            } else {\n                mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);\n                mDown = false;\n            }\n            abortBroadcast();\n        }\n    }\n}\n","lineNo":76}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs, View.OnTouchListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        registerForContextMenu(v);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        registerForContextMenu(v);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        registerForContextMenu(v);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n        }\n        return false; \n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n\n        /*\n         * A better way to do this would be to define a new \"media search\" intent (which\n         * would behave similar to a regular search intent), and have amazon, youtube, the\n         * browser and other suitable apps support it. Then we could just fire off the\n         * intent and let the user choose from the activity picker.\n         */\n        CharSequence title = null;\n        String query = null;\n        CharSequence artist = mArtistName.getText();\n        CharSequence album = mAlbumName.getText();\n        CharSequence song = mTrackName.getText();\n        if (view.equals(mArtistName.getParent()) && artist.length() > 0) {\n            title = artist;\n            query = artist.toString();\n        } else if (view.equals(mAlbumName.getParent()) &&\n                artist.length() > 0 && album.length() > 0) {\n            title = album ;\n            query = artist.toString() + \" \" + album.toString();\n        } else if (view.equals(mTrackName.getParent()) &&\n                artist.length() > 0 && song.length() > 0) {\n            title = song;\n            query = artist.toString() + \" \" + song.toString();\n        } else {\n            return;\n        }\n        \n        title = getString(R.string.mediasearch, title);\n        TextView tv = new TextView(this);\n        tv.setText(title);\n        tv.setTextSize(18);\n        tv.setPadding(8, 8, 8, 8);\n        menu.setHeaderView(tv);\n        //menu.setHeaderTitle(title);\n        \n        Intent i = new Intent();\n        i.setAction(Intent.ACTION_SEARCH);\n        i.setClassName(\"com.amazon.mp3\", \"com.amazon.mp3.android.client.SearchActivity\");\n        i.putExtra(\"query\", query);\n        PackageManager pm = getPackageManager();\n        ActivityInfo ai = i.resolveActivityInfo(pm, 0);\n        if ( ai != null) {\n            menu.add(R.string.mediasearch_amazon).setIntent(i);\n        }\n        \n        i = new Intent();\n        i.setAction(Intent.ACTION_WEB_SEARCH);\n        i.putExtra(\"query\", query);\n        menu.add(R.string.mediasearch_google).setIntent(i);\n\n        i = new Intent();\n        i.setAction(Intent.ACTION_SEARCH);\n        i.setClassName(\"com.google.android.youtube\", \"com.google.android.youtube.QueryActivity\");\n        i.putExtra(\"query\", query);\n        menu.add(R.string.mediasearch_youtube).setIntent(i);\n        return;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = Uri.parse(intent.getAction());\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            if (mService.getPath() == null) {\n                finish();\n                return;\n            }\n            String artistName = mService.getArtistName();\n            if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                artistName = getString(R.string.unknown_artist_name);\n            }\n            mArtistName.setText(artistName);\n            String albumName = mService.getAlbumName();\n            int albumid = mService.getAlbumId();\n            if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                albumName = getString(R.string.unknown_album_name);\n                albumid = -1;\n            }\n            mAlbumName.setText(albumName);\n            mTrackName.setText(mService.getTrackName());\n            mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n            mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.graphics.Bitmap;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.SystemClock;\nimport android.provider.MediaStore;\nimport android.text.Layout;\nimport android.text.TextUtils.TruncateAt;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.ImageButton;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.SeekBar.OnSeekBarChangeListener;\n\n\npublic class MediaPlaybackActivity extends Activity implements MusicUtils.Defs,\n    View.OnTouchListener, View.OnLongClickListener\n{\n    private static final int USE_AS_RINGTONE = CHILD_MENU_BASE;\n    \n    private boolean mOneShot = false;\n    private boolean mSeeking = false;\n    private boolean mTrackball;\n    private long mStartSeekPos = 0;\n    private long mLastSeekEventTime;\n    private IMediaPlaybackService mService = null;\n    private RepeatingImageButton mPrevButton;\n    private ImageButton mPauseButton;\n    private RepeatingImageButton mNextButton;\n    private ImageButton mRepeatButton;\n    private ImageButton mShuffleButton;\n    private ImageButton mQueueButton;\n    private Worker mAlbumArtWorker;\n    private AlbumArtHandler mAlbumArtHandler;\n    private Toast mToast;\n    private boolean mRelaunchAfterConfigChange;\n\n    public MediaPlaybackActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n        mAlbumArtWorker = new Worker(\"album art worker\");\n        mAlbumArtHandler = new AlbumArtHandler(mAlbumArtWorker.getLooper());\n\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.audio_player);\n\n        mCurrentTime = (TextView) findViewById(R.id.currenttime);\n        mTotalTime = (TextView) findViewById(R.id.totaltime);\n        mProgress = (ProgressBar) findViewById(android.R.id.progress);\n        mAlbum = (AlbumView) findViewById(R.id.album);\n        mArtistName = (TextView) findViewById(R.id.artistname);\n        mAlbumName = (TextView) findViewById(R.id.albumname);\n        mTrackName = (TextView) findViewById(R.id.trackname);\n\n        View v = (View)mArtistName.getParent(); \n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mAlbumName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n\n        v = (View)mTrackName.getParent();\n        v.setOnTouchListener(this);\n        v.setOnLongClickListener(this);\n        \n        mPrevButton = (RepeatingImageButton) findViewById(R.id.prev);\n        mPrevButton.setOnClickListener(mPrevListener);\n        mPrevButton.setRepeatListener(mRewListener, 260);\n        mPauseButton = (ImageButton) findViewById(R.id.pause);\n        mPauseButton.requestFocus();\n        mPauseButton.setOnClickListener(mPauseListener);\n        mNextButton = (RepeatingImageButton) findViewById(R.id.next);\n        mNextButton.setOnClickListener(mNextListener);\n        mNextButton.setRepeatListener(mFfwdListener, 260);\n        seekmethod = 1;\n\n        mTrackball = true; /* (See bug 1044348) (getResources().getConfiguration().navigation == \n            Resources.Configuration.NAVIGATION_TRACKBALL);*/\n        \n        mQueueButton = (ImageButton) findViewById(R.id.curplaylist);\n        mQueueButton.setOnClickListener(mQueueListener);\n        mShuffleButton = ((ImageButton) findViewById(R.id.shuffle));\n        mShuffleButton.setOnClickListener(mShuffleListener);\n        mRepeatButton = ((ImageButton) findViewById(R.id.repeat));\n        mRepeatButton.setOnClickListener(mRepeatListener);\n        \n        if (mProgress instanceof SeekBar) {\n            SeekBar seeker = (SeekBar) mProgress;\n            seeker.setOnSeekBarChangeListener(mSeekListener);\n        }\n        mProgress.setMax(1000);\n        \n        if (icicle != null) {\n            mRelaunchAfterConfigChange = icicle.getBoolean(\"configchange\");\n            mOneShot = icicle.getBoolean(\"oneshot\");\n        } else {\n            mOneShot = getIntent().getBooleanExtra(\"oneshot\", false);\n        }\n    }\n    \n    int mInitialX = -1;\n    int mLastX = -1;\n    int SLOP = ViewConfiguration.getTouchSlop();\n    int mTextWidth = 0;\n    int mViewWidth = 0;\n    boolean mDraggingLabel = false;\n    \n    TextView textViewForContainer(View v) {\n        View vv = v.findViewById(R.id.artistname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.albumname);\n        if (vv != null) return (TextView) vv;\n        vv = v.findViewById(R.id.trackname);\n        if (vv != null) return (TextView) vv;\n        return null;\n    }\n    \n    public boolean onTouch(View v, MotionEvent event) {\n        int action = event.getAction();\n        TextView tv = textViewForContainer(v);\n        if (tv == null) {\n            return false;\n        }\n        if (action == MotionEvent.ACTION_DOWN) {\n            v.setBackgroundColor(0xff606060);\n            mInitialX = mLastX = (int) event.getX();\n            mDraggingLabel = false;\n        } else if (action == MotionEvent.ACTION_UP ||\n                action == MotionEvent.ACTION_CANCEL) {\n            v.setBackgroundColor(0);\n            if (mDraggingLabel) {\n                Message msg = mLabelScroller.obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(msg, 1000);\n            }\n        } else if (action == MotionEvent.ACTION_MOVE) {\n            if (mDraggingLabel) {\n                int scrollx = tv.getScrollX();\n                int x = (int) event.getX();\n                int delta = mLastX - x;\n                if (delta != 0) {\n                    mLastX = x;\n                    scrollx += delta;\n                    if (scrollx > mTextWidth) {\n                        // scrolled the text completely off the view to the left\n                        scrollx -= mTextWidth;\n                        scrollx -= mViewWidth;\n                    }\n                    if (scrollx < -mViewWidth) {\n                        // scrolled the text completely off the view to the right\n                        scrollx += mViewWidth;\n                        scrollx += mTextWidth;\n                    }\n                    tv.scrollTo(scrollx, 0);\n                }\n                return true;\n            }\n            int delta = mInitialX - (int) event.getX();\n            if (Math.abs(delta) > SLOP) {\n                // start moving\n                mLabelScroller.removeMessages(0, tv);\n                \n                // Only turn ellipsizing off when it's not already off, because it\n                // causes the scroll position to be reset to 0.\n                if (tv.getEllipsize() != null) {\n                    tv.setEllipsize(null);\n                }\n                Layout ll = tv.getLayout();\n                // layout might be null if the text just changed, or ellipsizing\n                // was just turned off\n                if (ll == null) {\n                    return false;\n                }\n                // get the non-ellipsized line width, to determine whether scrolling\n                // should even be allowed\n                mTextWidth = (int) tv.getLayout().getLineWidth(0);\n                mViewWidth = tv.getWidth();\n                if (mViewWidth > mTextWidth) {\n                    tv.setEllipsize(TruncateAt.END);\n                    v.cancelLongPress();\n                    return false;\n                }\n                mDraggingLabel = true;\n                tv.setHorizontalFadingEdgeEnabled(true);\n                v.cancelLongPress();\n                return true;\n            }\n        }\n        return false; \n    }\n\n    Handler mLabelScroller = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            TextView tv = (TextView) msg.obj;\n            int x = tv.getScrollX();\n            x = x * 3 / 4;\n            tv.scrollTo(x, 0);\n            if (x == 0) {\n                tv.setEllipsize(TruncateAt.END);\n            } else {\n                Message newmsg = obtainMessage(0, tv);\n                mLabelScroller.sendMessageDelayed(newmsg, 15);\n            }\n        }\n    };\n    \n    public boolean onLongClick(View view) {\n\n        CharSequence title = null;\n        String mime = null;\n        String query = null;\n        \n        CharSequence artist = mArtistName.getText();\n        CharSequence album = mAlbumName.getText();\n        CharSequence song = mTrackName.getText();\n        \n        if (view.equals(mArtistName.getParent())) {\n            title = artist;\n            query = artist.toString();\n            mime = MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mAlbumName.getParent())) {\n            title = album;\n            query = artist + \" \" + album;\n            mime = MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE;\n        } else if (view.equals(mTrackName.getParent())) {\n            title = song;\n            query = artist + \" \" + song;\n            mime = \"audio/*\"; // the specific type doesn't matter, so don't bother retrieving it\n        } else {\n            throw new RuntimeException(\"shouldn't be here\");\n        }\n        title = getString(R.string.mediasearch, title);\n\n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        i.putExtra(SearchManager.QUERY, query);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, album);\n        i.putExtra(MediaStore.EXTRA_MEDIA_TITLE, song);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, mime);\n\n        startActivity(Intent.createChooser(i, title));\n        return true;\n    }\n\n    private OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {\n        public void onStartTrackingTouch(SeekBar bar) {\n            mLastSeekEventTime = 0;\n        }\n        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {\n            if (mService == null) return;\n            if (fromtouch) {\n                long now = SystemClock.elapsedRealtime();\n                if ((now - mLastSeekEventTime) > 250) {\n                    mLastSeekEventTime = now;\n                    mPosOverride = mDuration * progress / 1000;\n                    try {\n                        mService.seek(mPosOverride);\n                    } catch (RemoteException ex) {\n                    }\n                }\n            }\n        }\n        public void onStopTrackingTouch(SeekBar bar) {\n            mPosOverride = -1;\n        }\n    };\n    \n    private View.OnClickListener mQueueListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            startActivity(\n                    new Intent(Intent.ACTION_EDIT)\n                    .setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\")\n                    .putExtra(\"playlist\", \"nowplaying\")\n            );\n        }\n    };\n    \n    private View.OnClickListener mShuffleListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            toggleShuffle();\n        }\n    };\n\n    private View.OnClickListener mRepeatListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            cycleRepeat();\n        }\n    };\n\n    private View.OnClickListener mPauseListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            doPauseResume();\n        }\n    };\n\n    private View.OnClickListener mPrevListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                if (mService.position() < 2000) {\n                    mService.prev();\n                } else {\n                    mService.seek(0);\n                    mService.play();\n                }\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private View.OnClickListener mNextListener = new View.OnClickListener() {\n        public void onClick(View v) {\n            if (mService == null) return;\n            try {\n                mService.next();\n            } catch (RemoteException ex) {\n            }\n        }\n    };\n\n    private RepeatingImageButton.RepeatListener mRewListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanBackward(repcnt, howlong);\n        }\n    };\n    \n    private RepeatingImageButton.RepeatListener mFfwdListener =\n        new RepeatingImageButton.RepeatListener() {\n        public void onRepeat(View v, long howlong, int repcnt) {\n            scanForward(repcnt, howlong);\n        }\n    };\n   \n    @Override\n    public void onStop() {\n        paused = true;\n        if (mService != null && mOneShot && getChangingConfigurations() == 0) {\n            try {\n                mService.stop();\n            } catch (RemoteException ex) {\n            }\n        }\n        mHandler.removeMessages(REFRESH);\n        unregisterReceiver(mStatusListener);\n        MusicUtils.unbindFromService(this);\n        super.onStop();\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putBoolean(\"configchange\", getChangingConfigurations() != 0);\n        outState.putBoolean(\"oneshot\", mOneShot);\n        super.onSaveInstanceState(outState);\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        paused = false;\n\n        if (false == MusicUtils.bindToService(this, osc)) {\n            // something went wrong\n            mHandler.sendEmptyMessage(QUIT);\n        }\n        \n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.PLAYBACK_COMPLETE);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n    \n    @Override\n    public void onNewIntent(Intent intent) {\n        setIntent(intent);\n        mOneShot = intent.getBooleanExtra(\"oneshot\", false);\n    }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        updateTrackInfo();\n        setPauseButtonImage();\n    }\n    \n    @Override\n    public void onDestroy()\n    {\n        mAlbumArtWorker.quit();\n        super.onDestroy();\n        //System.out.println(\"***************** playback activity onDestroy\\n\");\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        // Don't show the menu items if we got launched by path/filedescriptor, since\n        // those tend to not be in the media database.\n        if (MusicUtils.getCurrentAudioId() >= 0) {\n            if (!mOneShot) {\n                menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n                menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n            }\n            SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0,\n                    R.string.add_to_playlist).setIcon(R.drawable.ic_menu_add);\n            MusicUtils.makePlaylistMenu(this, sub);\n            menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu_short).setIcon(R.drawable.ic_menu_set_as_ringtone);\n            menu.add(0, DELETE_ITEM, 0, R.string.delete_item).setIcon(R.drawable.ic_menu_delete);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case GOTO_START:\n                    intent = new Intent();\n                    intent.setClass(this, MusicBrowserActivity.class);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                            | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                    startActivity(intent);\n                    break;\n                case USE_AS_RINGTONE: {\n                    // Set the system setting to make this the current ringtone\n                    if (mService != null) {\n                        MusicUtils.setRingtone(this, mService.getAudioId());\n                    }\n                    return true;\n                }\n                case PARTY_SHUFFLE:\n                    if (mService != null) {\n                        int shuffle = mService.getShuffleMode();\n                        if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                        } else {\n                            mService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                        }\n                    }\n                    setShuffleButtonImage();\n                    break;\n                    \n                case NEW_PLAYLIST: {\n                    intent = new Intent();\n                    intent.setClass(this, CreatePlaylist.class);\n                    startActivityForResult(intent, NEW_PLAYLIST);\n                    return true;\n                }\n\n                case PLAYLIST_SELECTED: {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                    return true;\n                }\n                \n                case DELETE_ITEM: {\n                    if (mService != null) {\n                        int [] list = new int[1];\n                        list[0] = MusicUtils.getCurrentAudioId();\n                        Bundle b = new Bundle();\n                        b.putString(\"description\", mService.getTrackName());\n                        b.putIntArray(\"items\", list);\n                        intent = new Intent();\n                        intent.setClass(this, DeleteItems.class);\n                        intent.putExtras(b);\n                        startActivityForResult(intent, -1);\n                    }\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        if (resultCode != RESULT_OK) {\n            return;\n        }\n        switch (requestCode) {\n            case NEW_PLAYLIST:\n                Uri uri = intent.getData();\n                if (uri != null) {\n                    int [] list = new int[1];\n                    list[0] = MusicUtils.getCurrentAudioId();\n                    int playlist = Integer.parseInt(uri.getLastPathSegment());\n                    MusicUtils.addToPlaylist(this, list, playlist);\n                }\n                break;\n        }\n    }\n    private final int keyboard[][] = {\n        {\n            KeyEvent.KEYCODE_Q,\n            KeyEvent.KEYCODE_W,\n            KeyEvent.KEYCODE_E,\n            KeyEvent.KEYCODE_R,\n            KeyEvent.KEYCODE_T,\n            KeyEvent.KEYCODE_Y,\n            KeyEvent.KEYCODE_U,\n            KeyEvent.KEYCODE_I,\n            KeyEvent.KEYCODE_O,\n            KeyEvent.KEYCODE_P,\n        },\n        {\n            KeyEvent.KEYCODE_A,\n            KeyEvent.KEYCODE_S,\n            KeyEvent.KEYCODE_D,\n            KeyEvent.KEYCODE_F,\n            KeyEvent.KEYCODE_G,\n            KeyEvent.KEYCODE_H,\n            KeyEvent.KEYCODE_J,\n            KeyEvent.KEYCODE_K,\n            KeyEvent.KEYCODE_L,\n            KeyEvent.KEYCODE_DEL,\n        },\n        {\n            KeyEvent.KEYCODE_Z,\n            KeyEvent.KEYCODE_X,\n            KeyEvent.KEYCODE_C,\n            KeyEvent.KEYCODE_V,\n            KeyEvent.KEYCODE_B,\n            KeyEvent.KEYCODE_N,\n            KeyEvent.KEYCODE_M,\n            KeyEvent.KEYCODE_COMMA,\n            KeyEvent.KEYCODE_PERIOD,\n            KeyEvent.KEYCODE_ENTER\n        }\n\n    };\n\n    private int lastX;\n    private int lastY;\n\n    private boolean seekMethod1(int keyCode)\n    {\n        for(int x=0;x<10;x++) {\n            for(int y=0;y<3;y++) {\n                if(keyboard[y][x] == keyCode) {\n                    int dir = 0;\n                    // top row\n                    if(x == lastX && y == lastY) dir = 0;\n                    else if (y == 0 && lastY == 0 && x > lastX) dir = 1;\n                    else if (y == 0 && lastY == 0 && x < lastX) dir = -1;\n                    // bottom row\n                    else if (y == 2 && lastY == 2 && x > lastX) dir = -1;\n                    else if (y == 2 && lastY == 2 && x < lastX) dir = 1;\n                    // moving up\n                    else if (y < lastY && x <= 4) dir = 1; \n                    else if (y < lastY && x >= 5) dir = -1; \n                    // moving down\n                    else if (y > lastY && x <= 4) dir = -1; \n                    else if (y > lastY && x >= 5) dir = 1; \n                    lastX = x;\n                    lastY = y;\n                    try {\n                        mService.seek(mService.position() + dir * 5);\n                    } catch (RemoteException ex) {\n                    }\n                    refreshNow();\n                    return true;\n                }\n            }\n        }\n        lastX = -1;\n        lastY = -1;\n        return false;\n    }\n\n    private boolean seekMethod2(int keyCode)\n    {\n        if (mService == null) return false;\n        for(int i=0;i<10;i++) {\n            if(keyboard[0][i] == keyCode) {\n                int seekpercentage = 100*i/10;\n                try {\n                    mService.seek(mService.duration() * seekpercentage / 100);\n                } catch (RemoteException ex) {\n                }\n                refreshNow();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onKeyUp(int keyCode, KeyEvent event) {\n        try {\n            switch(keyCode)\n            {\n                case KeyEvent.KEYCODE_DPAD_LEFT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            if (mStartSeekPos < 1000) {\n                                mService.prev();\n                            } else {\n                                mService.seek(0);\n                            }\n                        } else {\n                            scanBackward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_RIGHT:\n                    if (mTrackball) {\n                        break;\n                    }\n                    if (mService != null) {\n                        if (!mSeeking && mStartSeekPos >= 0) {\n                            mPauseButton.requestFocus();\n                            mService.next();\n                        } else {\n                            scanForward(-1, event.getEventTime() - event.getDownTime());\n                            mPauseButton.requestFocus();\n                            mStartSeekPos = -1;\n                        }\n                    }\n                    mSeeking = false;\n                    mPosOverride = -1;\n                    return true;\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onKeyUp(keyCode, event);\n    }\n\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        int direction = -1;\n        int repcnt = event.getRepeatCount();\n\n        if((seekmethod==0)?seekMethod1(keyCode):seekMethod2(keyCode))\n            return true;\n\n        switch(keyCode)\n        {\n/*\n            // image scale\n            case KeyEvent.KEYCODE_Q: av.adjustParams(-0.05, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_E: av.adjustParams( 0.05, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // image translate\n            case KeyEvent.KEYCODE_W: av.adjustParams(    0.0, 0.0,-1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_X: av.adjustParams(    0.0, 0.0, 1.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_A: av.adjustParams(    0.0,-1.0, 0.0, 0.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_D: av.adjustParams(    0.0, 1.0, 0.0, 0.0, 0.0, 0.0); break;\n            // camera rotation\n            case KeyEvent.KEYCODE_R: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0,-1.0); break;\n            case KeyEvent.KEYCODE_U: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 0.0, 1.0); break;\n            // camera translate\n            case KeyEvent.KEYCODE_Y: av.adjustParams(    0.0, 0.0, 0.0, 0.0,-1.0, 0.0); break;\n            case KeyEvent.KEYCODE_N: av.adjustParams(    0.0, 0.0, 0.0, 0.0, 1.0, 0.0); break;\n            case KeyEvent.KEYCODE_G: av.adjustParams(    0.0, 0.0, 0.0,-1.0, 0.0, 0.0); break;\n            case KeyEvent.KEYCODE_J: av.adjustParams(    0.0, 0.0, 0.0, 1.0, 0.0, 0.0); break;\n\n*/\n\n            case KeyEvent.KEYCODE_SLASH:\n                seekmethod = 1 - seekmethod;\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mPrevButton.hasFocus()) {\n                    mPrevButton.requestFocus();\n                }\n                scanBackward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n                if (mTrackball) {\n                    break;\n                }\n                if (!mNextButton.hasFocus()) {\n                    mNextButton.requestFocus();\n                }\n                scanForward(repcnt, event.getEventTime() - event.getDownTime());\n                return true;\n\n            case KeyEvent.KEYCODE_S:\n                toggleShuffle();\n                return true;\n\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            case KeyEvent.KEYCODE_SPACE:\n                doPauseResume();\n                return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n    \n    private void scanBackward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos - delta;\n                if (newpos < 0) {\n                    // move to previous track\n                    mService.prev();\n                    long duration = mService.duration();\n                    mStartSeekPos += duration;\n                    newpos += duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n\n    private void scanForward(int repcnt, long delta) {\n        if(mService == null) return;\n        try {\n            if(repcnt == 0) {\n                mStartSeekPos = mService.position();\n                mLastSeekEventTime = 0;\n                mSeeking = false;\n            } else {\n                mSeeking = true;\n                if (delta < 5000) {\n                    // seek at 10x speed for the first 5 seconds\n                    delta = delta * 10; \n                } else {\n                    // seek at 40x after that\n                    delta = 50000 + (delta - 5000) * 40;\n                }\n                long newpos = mStartSeekPos + delta;\n                long duration = mService.duration();\n                if (newpos >= duration) {\n                    // move to next track\n                    mService.next();\n                    mStartSeekPos -= duration; // is OK to go negative\n                    newpos -= duration;\n                }\n                if (((delta - mLastSeekEventTime) > 250) || repcnt < 0){\n                    mService.seek(newpos);\n                    mLastSeekEventTime = delta;\n                }\n                if (repcnt >= 0) {\n                    mPosOverride = newpos;\n                } else {\n                    mPosOverride = -1;\n                }\n                refreshNow();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void doPauseResume() {\n        try {\n            if(mService != null) {\n                if (mService.isPlaying()) {\n                    mService.pause();\n                } else {\n                    mService.play();\n                }\n                refreshNow();\n                setPauseButtonImage();\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void toggleShuffle() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int shuffle = mService.getShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_NONE) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n                if (mService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {\n                    mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                    setRepeatButtonImage();\n                }\n                showToast(R.string.shuffle_on_notif);\n            } else if (shuffle == MediaPlaybackService.SHUFFLE_NORMAL ||\n                    shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                showToast(R.string.shuffle_off_notif);\n            } else {\n                Log.e(\"MediaPlaybackActivity\", \"Invalid shuffle mode: \" + shuffle);\n            }\n            setShuffleButtonImage();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void cycleRepeat() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            int mode = mService.getRepeatMode();\n            if (mode == MediaPlaybackService.REPEAT_NONE) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);\n                showToast(R.string.repeat_all_notif);\n            } else if (mode == MediaPlaybackService.REPEAT_ALL) {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_CURRENT);\n                if (mService.getShuffleMode() != MediaPlaybackService.SHUFFLE_NONE) {\n                    mService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    setShuffleButtonImage();\n                }\n                showToast(R.string.repeat_current_notif);\n            } else {\n                mService.setRepeatMode(MediaPlaybackService.REPEAT_NONE);\n                showToast(R.string.repeat_off_notif);\n            }\n            setRepeatButtonImage();\n        } catch (RemoteException ex) {\n        }\n        \n    }\n    \n    private void showToast(int resid) {\n        if (mToast == null) {\n            mToast = Toast.makeText(this, \"\", Toast.LENGTH_SHORT);\n        }\n        mToast.setText(resid);\n        mToast.show();\n    }\n\n    private void startPlayback() {\n\n        if(mService == null)\n            return;\n        Intent intent = getIntent();\n        String filename = \"\";\n        Uri uri = intent.getData();\n        if (uri != null && uri.toString().length() > 0) {\n            // If this is a file:// URI, just use the path directly instead\n            // of going through the open-from-filedescriptor codepath.\n            String scheme = uri.getScheme();\n            if (\"file\".equals(scheme)) {\n                filename = uri.getPath();\n            } else {\n                filename = uri.toString();\n            }\n            try {\n                mOneShot = true;\n                if (! mRelaunchAfterConfigChange) {\n                    mService.stop();\n                    mService.openfile(filename);\n                    mService.play();\n                }\n            } catch (Exception ex) {\n                Log.d(\"MediaPlaybackActivity\", \"couldn't start playback: \" + ex);\n            }\n        }\n\n        updateTrackInfo();\n        long next = refreshNow();\n        queueNextRefresh(next);\n    }\n\n    private ServiceConnection osc = new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                mService = IMediaPlaybackService.Stub.asInterface(obj);\n                if (MusicUtils.sService == null) {\n                    MusicUtils.sService = mService;\n                }\n                startPlayback();\n                try {\n                    // Assume something is playing when the service says it is,\n                    // but also if the audio ID is valid but the service is paused.\n                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||\n                            mService.getPath() != null) {\n                        // something is playing now, we're done\n                        if (mOneShot || mService.getAudioId() < 0) {\n                            mRepeatButton.setVisibility(View.INVISIBLE);\n                            mShuffleButton.setVisibility(View.INVISIBLE);\n                            mQueueButton.setVisibility(View.INVISIBLE);\n                        } else {\n                            mRepeatButton.setVisibility(View.VISIBLE);\n                            mShuffleButton.setVisibility(View.VISIBLE);\n                            mQueueButton.setVisibility(View.VISIBLE);\n                            setRepeatButtonImage();\n                            setShuffleButtonImage();\n                        }\n                        setPauseButtonImage();\n                        return;\n                    }\n                } catch (RemoteException ex) {\n                }\n                // Service is dead or not playing anything. If we got here as part\n                // of a \"play this file\" Intent, exit. Otherwise go to the Music\n                // app start screen.\n                if (getIntent().getData() == null) {\n                    Intent intent = new Intent(Intent.ACTION_MAIN);\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);\n                    startActivity(intent);\n                }\n                finish();\n            }\n            public void onServiceDisconnected(ComponentName classname) {\n            }\n    };\n\n    private void setRepeatButtonImage() {\n        try {\n            switch (mService.getRepeatMode()) {\n                case MediaPlaybackService.REPEAT_ALL:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_all_btn);\n                    break;\n                case MediaPlaybackService.REPEAT_CURRENT:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_once_btn);\n                    break;\n                default:\n                    mRepeatButton.setImageResource(R.drawable.ic_mp_repeat_off_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setShuffleButtonImage() {\n        try {\n            switch (mService.getShuffleMode()) {\n                case MediaPlaybackService.SHUFFLE_NONE:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_off_btn);\n                    break;\n                case MediaPlaybackService.SHUFFLE_AUTO:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_partyshuffle_on_btn);\n                    break;\n                default:\n                    mShuffleButton.setImageResource(R.drawable.ic_mp_shuffle_on_btn);\n                    break;\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private void setPauseButtonImage() {\n        try {\n            if (mService != null && mService.isPlaying()) {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);\n            } else {\n                mPauseButton.setImageResource(android.R.drawable.ic_media_play);\n            }\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    private AlbumView mAlbum;\n    private TextView mCurrentTime;\n    private TextView mTotalTime;\n    private TextView mArtistName;\n    private TextView mAlbumName;\n    private TextView mTrackName;\n    private ProgressBar mProgress;\n    private long mPosOverride = -1;\n    private long mDuration;\n    private int seekmethod;\n    private boolean paused;\n\n    private static final int REFRESH = 1;\n    private static final int QUIT = 2;\n    private static final int GET_ALBUM_ART = 3;\n    private static final int ALBUM_ART_DECODED = 4;\n\n    private void queueNextRefresh(long delay) {\n        if (!paused) {\n            Message msg = mHandler.obtainMessage(REFRESH);\n            mHandler.removeMessages(REFRESH);\n            mHandler.sendMessageDelayed(msg, delay);\n        }\n    }\n\n    private long refreshNow() {\n        if(mService == null)\n            return 500;\n        try {\n            long pos = mPosOverride < 0 ? mService.position() : mPosOverride;\n            long remaining = 1000 - (pos % 1000);\n            if ((pos >= 0) && (mDuration > 0)) {\n                mCurrentTime.setText(MusicUtils.makeTimeString(this, pos / 1000));\n                \n                if (mService.isPlaying()) {\n                    mCurrentTime.setVisibility(View.VISIBLE);\n                } else {\n                    // blink the counter\n                    int vis = mCurrentTime.getVisibility();\n                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE : View.INVISIBLE);\n                    remaining = 500;\n                }\n\n                mProgress.setProgress((int) (1000 * pos / mDuration));\n            } else {\n                mCurrentTime.setText(\"--:--\");\n                mProgress.setProgress(1000);\n            }\n            // return the number of milliseconds until the next full second, so\n            // the counter can be updated at just the right time\n            return remaining;\n        } catch (RemoteException ex) {\n        }\n        return 500;\n    }\n    \n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case ALBUM_ART_DECODED:\n                    mAlbum.setArtwork((Bitmap)msg.obj);\n                    mAlbum.invalidate();\n                    break;\n\n                case REFRESH:\n                    long next = refreshNow();\n                    queueNextRefresh(next);\n                    break;\n                    \n                case QUIT:\n                    // This can be moved back to onCreate once the bug that prevents\n                    // Dialogs from being started from onCreate/onResume is fixed.\n                    new AlertDialog.Builder(MediaPlaybackActivity.this)\n                            .setTitle(R.string.service_start_error_title)\n                            .setMessage(R.string.service_start_error_msg)\n                            .setPositiveButton(R.string.service_start_error_button,\n                                    new DialogInterface.OnClickListener() {\n                                        public void onClick(DialogInterface dialog, int whichButton) {\n                                            finish();\n                                        }\n                                    })\n                            .setCancelable(false)\n                            .show();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            if (action.equals(MediaPlaybackService.META_CHANGED)) {\n                // redraw the artist/title info and\n                // set new max for progress bar\n                updateTrackInfo();\n                setPauseButtonImage();\n                queueNextRefresh(1);\n            } else if (action.equals(MediaPlaybackService.PLAYBACK_COMPLETE)) {\n                if (mOneShot) {\n                    finish();\n                } else {\n                    setPauseButtonImage();\n                }\n            } else if (action.equals(MediaPlaybackService.PLAYSTATE_CHANGED)) {\n                setPauseButtonImage();\n            }\n        }\n    };\n\n    private void updateTrackInfo() {\n        if (mService == null) {\n            return;\n        }\n        try {\n            String path = mService.getPath();\n            if (path == null) {\n                finish();\n                return;\n            }\n            \n            if (mService.getAudioId() < 0 && path.toLowerCase().startsWith(\"http://\")) {\n                ((View) mArtistName.getParent()).setVisibility(View.INVISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.INVISIBLE);\n                mAlbum.setVisibility(View.GONE);\n                mTrackName.setText(path);\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, -1, 0).sendToTarget();\n            } else {\n                ((View) mArtistName.getParent()).setVisibility(View.VISIBLE);\n                ((View) mAlbumName.getParent()).setVisibility(View.VISIBLE);\n                String artistName = mService.getArtistName();\n                if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                    artistName = getString(R.string.unknown_artist_name);\n                }\n                mArtistName.setText(artistName);\n                String albumName = mService.getAlbumName();\n                int albumid = mService.getAlbumId();\n                if (MediaFile.UNKNOWN_STRING.equals(albumName)) {\n                    albumName = getString(R.string.unknown_album_name);\n                    albumid = -1;\n                }\n                mAlbumName.setText(albumName);\n                mTrackName.setText(mService.getTrackName());\n                mAlbumArtHandler.removeMessages(GET_ALBUM_ART);\n                mAlbumArtHandler.obtainMessage(GET_ALBUM_ART, albumid, 0).sendToTarget();\n                mAlbum.setVisibility(View.VISIBLE);\n            }\n            mDuration = mService.duration();\n            mTotalTime.setText(MusicUtils.makeTimeString(this, mDuration / 1000));\n        } catch (RemoteException ex) {\n            finish();\n        }\n    }\n    \n    public class AlbumArtHandler extends Handler {\n        private int mAlbumId = -1;\n        \n        public AlbumArtHandler(Looper looper) {\n            super(looper);\n        }\n        public void handleMessage(Message msg)\n        {\n            int albumid = msg.arg1;\n            if (msg.what == GET_ALBUM_ART && (mAlbumId != albumid || albumid < 0)) {\n                // while decoding the new image, show the default album art\n                Message numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, null);\n                mHandler.removeMessages(ALBUM_ART_DECODED);\n                mHandler.sendMessageDelayed(numsg, 300);\n                Bitmap bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, albumid);\n                if (bm == null) {\n                    bm = MusicUtils.getArtwork(MediaPlaybackActivity.this, -1);\n                    albumid = -1;\n                }\n                if (bm != null) {\n                    numsg = mHandler.obtainMessage(ALBUM_ART_DECODED, bm);\n                    mHandler.removeMessages(ALBUM_ART_DECODED);\n                    mHandler.sendMessage(numsg);\n                }\n                mAlbumId = albumid;\n            }\n        }\n    }\n    \n    private class Worker implements Runnable {\n        private final Object mLock = new Object();\n        private Looper mLooper;\n        \n        /**\n         * Creates a worker thread with the given name. The thread\n         * then runs a {@link android.os.Looper}.\n         * @param name A name for the new thread\n         */\n        Worker(String name) {\n            Thread t = new Thread(null, this, name);\n            t.setPriority(Thread.MIN_PRIORITY);\n            t.start();\n            synchronized (mLock) {\n                while (mLooper == null) {\n                    try {\n                        mLock.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }\n        \n        public Looper getLooper() {\n            return mLooper;\n        }\n        \n        public void run() {\n            synchronized (mLock) {\n                Looper.prepare();\n                mLooper = Looper.myLooper();\n                mLock.notifyAll();\n            }\n            Looper.loop();\n        }\n        \n        public void quit() {\n            mLooper.quit();\n        }\n    }\n}\n\n","lineNo":1178}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.IBinder;\nimport android.provider.MediaStore;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.widget.TextView;\n\npublic class MusicBrowserActivity extends Activity\n    implements MusicUtils.Defs, View.OnClickListener {\n    private View mNowPlayingView;\n    private TextView mTitle;\n    private TextView mArtist;\n    private boolean mAutoShuffle = false;\n    private static final int SEARCH_MUSIC = CHILD_MENU_BASE;\n\n    public MusicBrowserActivity() {\n    }\n\n    /**\n     * Called when the activity is first created.\n     */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        String shuf = getIntent().getStringExtra(\"autoshuffle\");\n        if (\"true\".equals(shuf)) {\n            mAutoShuffle = true;\n        }\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                updateMenu();\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n                updateMenu();\n            }\n        \n        });\n        setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);\n        init();\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        super.onDestroy();\n    }\n\n    public void init() {\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.music_library);\n        mNowPlayingView = findViewById(R.id.nowplaying);\n        mTitle = (TextView) mNowPlayingView.findViewById(R.id.title);\n        mArtist = (TextView) mNowPlayingView.findViewById(R.id.artist);\n        \n        findViewById(R.id.browse_button).setOnClickListener(this);\n        findViewById(R.id.albums_button).setOnClickListener(this);\n        findViewById(R.id.tracks_button).setOnClickListener(this);\n        findViewById(R.id.playlists_button).setOnClickListener(this);\n    }\n\n    private void updateMenu() {\n        try {\n            if (MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                makeNowPlayingView();\n                mNowPlayingView.setVisibility(View.VISIBLE);\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        mNowPlayingView.setVisibility(View.INVISIBLE);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateMenu();\n        if (mAutoShuffle) {\n            mAutoShuffle = false;\n            doAutoShuffle();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        unregisterReceiver(mStatusListener);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n         menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n         menu.add(0, SEARCH_MUSIC, 0, R.string.search_title).setIcon(R.drawable.ic_menu_search);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case PARTY_SHUFFLE:\n                    int shuffle = MusicUtils.sService.getShuffleMode();\n                    if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                        MusicUtils.sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    } else {\n                        MusicUtils.sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                    }\n                    break;\n                    \n                case SEARCH_MUSIC: {\n                    intent = new Intent(Intent.ACTION_PICK);\n                    intent.setClass(this, QueryBrowserActivity.class);\n                    intent.putExtra(SearchManager.QUERY, \"\");\n                    startActivity(intent);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    \n    // TODO: Activities are requested to call onSearchRequested, and to override\n    // that function in order to insert custom fields (e.g. the search bundle).  startSearch\n    // was not intended to be overridden.\n    @Override\n    public void startSearch(String initialQuery, boolean selectQuery, Bundle appSearchData,\n            boolean globalSearch) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setClass(this, QueryBrowserActivity.class);\n        intent.putExtra(SearchManager.QUERY, initialQuery);\n        startActivity(intent);\n    }\n\n    public void onClick(View v) {\n        Intent intent;\n        switch (v.getId()) {\n            case R.id.browse_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                startActivity(intent);\n                break;\n            case R.id.albums_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                startActivity(intent);\n                break;\n            case R.id.tracks_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                startActivity(intent);\n                break;\n            case R.id.playlists_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                startActivity(intent);\n                break;\n            case R.id.nowplaying:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                break;\n        }\n    }\n\n    private void doAutoShuffle() {\n        bindService((new Intent()).setClass(this, MediaPlaybackService.class), autoshuffle, 0);\n    }\n\n    private ServiceConnection autoshuffle = new ServiceConnection() {\n        public void onServiceConnected(ComponentName classname, IBinder obj) {\n            // we need to be able to bind again, so unbind\n            unbindService(this);\n            IMediaPlaybackService serv = IMediaPlaybackService.Stub.asInterface(obj);\n            if (serv != null) {\n                try {\n                    serv.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                    updateMenu();\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n\n        public void onServiceDisconnected(ComponentName classname) {\n        }\n    };\n\n    private void makeNowPlayingView() {\n        try {\n            mTitle.setText(MusicUtils.sService.getTrackName());\n            String artistName = MusicUtils.sService.getArtistName();\n            if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                artistName = getString(R.string.unknown_artist_name);\n            }\n            mArtist.setText(artistName);\n            mNowPlayingView.setOnFocusChangeListener(mFocuser);\n            mNowPlayingView.setOnClickListener(this);\n        } catch (RemoteException ex) {\n\n        }\n    }\n\n    View.OnFocusChangeListener mFocuser = new View.OnFocusChangeListener() {\n        Drawable mBack;\n\n        public void onFocusChange(View v, boolean hasFocus) {\n            if (hasFocus) {\n                if (mBack == null) {\n                    mBack = mNowPlayingView.getBackground();\n                }\n                Drawable dr = getResources().getDrawable(android.R.drawable.menuitem_background);\n                dr.setState(new int[] { android.R.attr.state_focused});\n                mNowPlayingView.setBackgroundDrawable(dr);\n            } else {\n                mNowPlayingView.setBackgroundDrawable(mBack);\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // this receiver is only used for META_CHANGED events\n            updateMenu();\n        }\n    };\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.Activity;\nimport android.app.SearchManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.graphics.drawable.Drawable;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.RemoteException;\nimport android.os.IBinder;\nimport android.provider.MediaStore;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.Window;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\n\npublic class MusicBrowserActivity extends Activity\n    implements MusicUtils.Defs, View.OnClickListener {\n    private View mNowPlayingView;\n    private TextView mTitle;\n    private TextView mArtist;\n    private boolean mAutoShuffle = false;\n    private static final int SEARCH_MUSIC = CHILD_MENU_BASE;\n\n    public MusicBrowserActivity() {\n    }\n\n    /**\n     * Called when the activity is first created.\n     */\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        String shuf = getIntent().getStringExtra(\"autoshuffle\");\n        if (\"true\".equals(shuf)) {\n            mAutoShuffle = true;\n        }\n        MusicUtils.bindToService(this, new ServiceConnection() {\n            public void onServiceConnected(ComponentName classname, IBinder obj) {\n                updateMenu();\n            }\n\n            public void onServiceDisconnected(ComponentName classname) {\n                updateMenu();\n            }\n        \n        });\n        setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);\n        init();\n    }\n\n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        super.onDestroy();\n    }\n\n    public void init() {\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        setContentView(R.layout.music_library);\n        mNowPlayingView = findViewById(R.id.nowplaying);\n        mTitle = (TextView) mNowPlayingView.findViewById(R.id.title);\n        mArtist = (TextView) mNowPlayingView.findViewById(R.id.artist);\n        \n        ImageButton b = (ImageButton) findViewById(R.id.browse_button); \n        b.setOnClickListener(this);\n        b.setOnTouchListener(mMarqueeEnablerTouch);\n        b.setOnFocusChangeListener(mMarqueeEnablerFocus);\n        \n        b = (ImageButton) findViewById(R.id.albums_button);\n        b.setOnClickListener(this);\n        b.setOnTouchListener(mMarqueeEnablerTouch);\n        b.setOnFocusChangeListener(mMarqueeEnablerFocus);\n\n        b = (ImageButton) findViewById(R.id.tracks_button);\n        b.setOnClickListener(this);\n        b.setOnTouchListener(mMarqueeEnablerTouch);\n        b.setOnFocusChangeListener(mMarqueeEnablerFocus);\n\n        b = (ImageButton) findViewById(R.id.playlists_button);\n        b.setOnClickListener(this);\n        b.setOnTouchListener(mMarqueeEnablerTouch);\n        b.setOnFocusChangeListener(mMarqueeEnablerFocus);\n    }\n    \n    private View.OnTouchListener mMarqueeEnablerTouch = new View.OnTouchListener() {\n\n        public boolean onTouch(View v, MotionEvent event) {\n            switch (event.getAction()) {\n                case MotionEvent.ACTION_DOWN:\n                    doMarquee(v, true);\n                    break;\n                case MotionEvent.ACTION_CANCEL:\n                case MotionEvent.ACTION_UP:\n                    doMarquee(v, false);\n                    break;\n            }\n            return false;\n        }\n    };\n    \n    private View.OnFocusChangeListener mMarqueeEnablerFocus = new View.OnFocusChangeListener() {\n\n        public void onFocusChange(View v, boolean hasFocus) {\n            doMarquee(v, hasFocus);\n        }\n    };\n    \n    private void doMarquee(View v, boolean hasFocus) {\n        switch (v.getId()) {\n            case R.id.browse_button:\n                findViewById(R.id.artists_label).setSelected(hasFocus);\n                break;\n            case R.id.tracks_button:\n                findViewById(R.id.tracks_label).setSelected(hasFocus);\n                break;\n            case R.id.albums_button:\n                findViewById(R.id.albums_label).setSelected(hasFocus);\n                break;\n            case R.id.playlists_button:\n                findViewById(R.id.playlists_label).setSelected(hasFocus);\n                break;\n          }\n    }\n\n    private void updateMenu() {\n        try {\n            if (MusicUtils.sService != null && MusicUtils.sService.getAudioId() != -1) {\n                makeNowPlayingView();\n                mNowPlayingView.setVisibility(View.VISIBLE);\n                return;\n            }\n        } catch (RemoteException ex) {\n        }\n        mNowPlayingView.setVisibility(View.INVISIBLE);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        registerReceiver(mStatusListener, new IntentFilter(f));\n        updateMenu();\n        if (mAutoShuffle) {\n            mAutoShuffle = false;\n            doAutoShuffle();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        unregisterReceiver(mStatusListener);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n         menu.add(0, PARTY_SHUFFLE, 0, R.string.party_shuffle); // icon will be set in onPrepareOptionsMenu()\n         menu.add(0, SEARCH_MUSIC, 0, R.string.search_title).setIcon(R.drawable.ic_menu_search);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        MenuItem item = menu.findItem(PARTY_SHUFFLE);\n        if (item != null) {\n            int shuffle = MusicUtils.getCurrentShuffleMode();\n            if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle_off);\n            } else {\n                item.setIcon(R.drawable.ic_menu_party_shuffle);\n                item.setTitle(R.string.party_shuffle);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        try {\n            switch (item.getItemId()) {\n                case PARTY_SHUFFLE:\n                    int shuffle = MusicUtils.sService.getShuffleMode();\n                    if (shuffle == MediaPlaybackService.SHUFFLE_AUTO) {\n                        MusicUtils.sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);\n                    } else {\n                        MusicUtils.sService.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                    }\n                    break;\n                    \n                case SEARCH_MUSIC: {\n                    intent = new Intent(Intent.ACTION_PICK);\n                    intent.setClass(this, QueryBrowserActivity.class);\n                    intent.putExtra(SearchManager.QUERY, \"\");\n                    startActivity(intent);\n                    return true;\n                }\n            }\n        } catch (RemoteException ex) {\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    \n    \n    // TODO: Activities are requested to call onSearchRequested, and to override\n    // that function in order to insert custom fields (e.g. the search bundle).  startSearch\n    // was not intended to be overridden.\n    @Override\n    public void startSearch(String initialQuery, boolean selectQuery, Bundle appSearchData,\n            boolean globalSearch) {\n        Intent intent = new Intent(Intent.ACTION_PICK);\n        intent.setClass(this, QueryBrowserActivity.class);\n        intent.putExtra(SearchManager.QUERY, initialQuery);\n        startActivity(intent);\n    }\n\n    public void onClick(View v) {\n        Intent intent;\n        switch (v.getId()) {\n            case R.id.browse_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/artistalbum\");\n                startActivity(intent);\n                break;\n            case R.id.albums_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/album\");\n                startActivity(intent);\n                break;\n            case R.id.tracks_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, \"vnd.android.cursor.dir/track\");\n                startActivity(intent);\n                break;\n            case R.id.playlists_button:\n                intent = new Intent(Intent.ACTION_PICK);\n                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);\n                startActivity(intent);\n                break;\n            case R.id.nowplaying:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                startActivity(intent);\n                break;\n        }\n    }\n\n    private void doAutoShuffle() {\n        bindService((new Intent()).setClass(this, MediaPlaybackService.class), autoshuffle, 0);\n    }\n\n    private ServiceConnection autoshuffle = new ServiceConnection() {\n        public void onServiceConnected(ComponentName classname, IBinder obj) {\n            // we need to be able to bind again, so unbind\n            unbindService(this);\n            IMediaPlaybackService serv = IMediaPlaybackService.Stub.asInterface(obj);\n            if (serv != null) {\n                try {\n                    serv.setShuffleMode(MediaPlaybackService.SHUFFLE_AUTO);\n                    updateMenu();\n                } catch (RemoteException ex) {\n                }\n            }\n        }\n\n        public void onServiceDisconnected(ComponentName classname) {\n        }\n    };\n\n    private void makeNowPlayingView() {\n        try {\n            mTitle.setText(MusicUtils.sService.getTrackName());\n            String artistName = MusicUtils.sService.getArtistName();\n            if (MediaFile.UNKNOWN_STRING.equals(artistName)) {\n                artistName = getString(R.string.unknown_artist_name);\n            }\n            mArtist.setText(artistName);\n            mNowPlayingView.setOnFocusChangeListener(mFocuser);\n            mNowPlayingView.setOnClickListener(this);\n        } catch (RemoteException ex) {\n\n        }\n    }\n\n    View.OnFocusChangeListener mFocuser = new View.OnFocusChangeListener() {\n        Drawable mBack;\n\n        public void onFocusChange(View v, boolean hasFocus) {\n            if (hasFocus) {\n                if (mBack == null) {\n                    mBack = mNowPlayingView.getBackground();\n                }\n                Drawable dr = getResources().getDrawable(android.R.drawable.menuitem_background);\n                dr.setState(new int[] { android.R.attr.state_focused});\n                mNowPlayingView.setBackgroundDrawable(dr);\n            } else {\n                mNowPlayingView.setBackgroundDrawable(mBack);\n            }\n        }\n    };\n\n    private BroadcastReceiver mStatusListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // this receiver is only used for META_CHANGED events\n            updateMenu();\n        }\n    };\n}\n\n","lineNo":92}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport android.app.Activity;\nimport android.app.ExpandableListActivity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.MediaFile;\nimport android.media.MediaScanner;\nimport android.net.Uri;\nimport android.os.RemoteException;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.util.Log;\nimport android.view.SubMenu;\nimport android.view.Window;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int CHILD_MENU_BASE = 12;\n        public final static int QUEUE = 13;\n    }\n    \n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static boolean bindToService(Context context) {\n        return bindToService(context, null);\n    }\n\n    public static boolean bindToService(Context context, ServiceConnection callback) {\n        context.startService(new Intent(context, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        sConnectionMap.put(context, sb);\n        return context.bindService((new Intent()).setClass(context,\n                MediaPlaybackService.class), sb, 0);\n    }\n    \n    public static void unbindFromService(Context context) {\n        ServiceBinder sb = (ServiceBinder) sConnectionMap.remove(context);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        context.unbindService(sb);\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static int getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static int getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static int getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static int [] sEmptyList = new int[0];\n    \n    public static int [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        int [] list = new int[len];\n        cursor.moveToFirst();\n        int colidx = cursor.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        if (colidx < 0) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getInt(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static int [] getSongListForArtist(Context context, int id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static int [] getSongListForAlbum(Context context, int id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static int [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        int [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static int [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            int[] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getInt(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getInt(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members._ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor == null) {\n            return;\n        }\n        cursor.moveToFirst();\n        while (!cursor.isAfterLast()) {\n            cursor.deleteRow();\n        }\n        cursor.commitUpdates();\n        cursor.close();\n        return;\n    }\n    \n    public static void deleteTracks(Context context, int [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    int id = c.getInt(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    int artIndex = c.getInt(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.commitUpdates();\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, int [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    public static void addToPlaylist(Context context, int [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentValues values [] = new ContentValues[size];\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n\n            for (int i = 0; i < size; i++) {\n                values[i] = new ContentValues();\n                values[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + i));\n                values[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[i]);\n            }\n            resolver.bulkInsert(uri, values);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, size, Integer.valueOf(size));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Uri uri = MediaStore.getMediaScannerUri();\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    public static void displayDatabaseError(Activity a) {\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else {\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        if (a instanceof ExpandableListActivity) {\n            a.setContentView(R.layout.no_sd_card_expanding);\n        } else {\n            a.setContentView(R.layout.no_sd_card);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(R.string.durationformat);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, int [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        int [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, int [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            int curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                int [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\")\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static byte [] mCachedArt;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Integer, Drawable> sArtCache = new HashMap<Integer, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, int artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, int album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel frame in the ImageView used to\n        // display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 2;\n        h -= 2;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n    \n    // Get album art for specified album. You should not pass in the album id\n    // for the \"unknown\" album here (use -1 instead)\n    public static Bitmap getArtwork(Context context, int album_id) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            Bitmap bm = getArtworkFromFile(context, null, -1);\n            if (bm != null) {\n                return bm;\n            }\n            return getDefaultArtwork(context);\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, null, album_id);\n                if (bm != null) {\n                    // Put the newly found artwork in the database.\n                    // Note that this shouldn't be done for the \"unknown\" album,\n                    // but if this method is called correctly, that won't happen.\n                    \n                    // first write it somewhere\n                    String file = Environment.getExternalStorageDirectory()\n                        + \"/albumthumbs/\" + String.valueOf(System.currentTimeMillis());\n                    if (ensureFileExists(file)) {\n                        try {\n                            OutputStream outstream = new FileOutputStream(file);\n                            if (bm.getConfig() == null) {\n                                bm = bm.copy(Bitmap.Config.RGB_565, false);\n                                if (bm == null) {\n                                    return getDefaultArtwork(context);\n                                }\n                            }\n                            boolean success = bm.compress(Bitmap.CompressFormat.JPEG, 75, outstream);\n                            outstream.close();\n                            if (success) {\n                                ContentValues values = new ContentValues();\n                                values.put(\"album_id\", album_id);\n                                values.put(\"_data\", file);\n                                Uri newuri = res.insert(sArtworkUri, values);\n                                if (newuri == null) {\n                                    // Failed to insert in to the database. The most likely\n                                    // cause of this is that the item already existed in the\n                                    // database, and the most likely cause of that is that\n                                    // the album was scanned before, but the user deleted the\n                                    // album art from the sd card.\n                                    // We can ignore that case here, since the media provider\n                                    // will regenerate the album art for those entries when\n                                    // it detects this.\n                                    success = false;\n                                }\n                            }\n                            if (!success) {\n                                File f = new File(file);\n                                f.delete();\n                            }\n                        } catch (FileNotFoundException e) {\n                            Log.e(TAG, \"error creating file\", e);\n                        } catch (IOException e) {\n                            Log.e(TAG, \"error creating file\", e);\n                        }\n                    }\n                } else {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n\n    // copied from MediaProvider\n    private static boolean ensureFileExists(String path) {\n        File file = new File(path);\n        if (file.exists()) {\n            return true;\n        } else {\n            // we will not attempt to create the first directory in the path\n            // (for example, do not create /sdcard if the SD card is not mounted)\n            int secondSlash = path.indexOf('/', 1);\n            if (secondSlash < 1) return false;\n            String directoryPath = path.substring(0, secondSlash);\n            File directory = new File(directoryPath);\n            if (!directory.exists())\n                return false;\n            file.getParentFile().mkdirs();\n            try {\n                return file.createNewFile();\n            } catch(IOException ioe) {\n                Log.e(TAG, \"File creation failed\", ioe);\n            }\n            return false;\n        }\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, Uri uri, int albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (sArtId == albumid) {\n            //Log.i(\"@@@@@@ \", \"reusing cached data\", new Exception());\n            if (mCachedBit != null) {\n                return mCachedBit;\n            }\n            art = mCachedArt;\n        } else {\n            // try reading embedded artwork\n            if (uri == null) {\n                try {\n                    int curalbum = sService.getAlbumId();\n                    if (curalbum == albumid || albumid < 0) {\n                        path = sService.getPath();\n                        if (path != null) {\n                            uri = Uri.parse(path);\n                        }\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            if (uri == null) {\n                if (albumid >= 0) {\n                    Cursor c = query(context,MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                            new String[] { MediaStore.Audio.Media._ID, MediaStore.Audio.Media.ALBUM },\n                            MediaStore.Audio.Media.ALBUM_ID + \"=?\", new String [] {String.valueOf(albumid)},\n                            null);\n                    if (c != null) {\n                        c.moveToFirst();\n                        if (!c.isAfterLast()) {\n                            int trackid = c.getInt(0);\n                            uri = ContentUris.withAppendedId(\n                                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, trackid);\n                        }\n                        if (c.getString(1).equals(MediaFile.UNKNOWN_STRING)) {\n                            albumid = -1;\n                        }\n                        c.close();\n                    }\n                }\n            }\n            if (uri != null) {\n                MediaScanner scanner = new MediaScanner(context);\n                ParcelFileDescriptor pfd = null;\n                try {\n                    pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                    if (pfd != null) {\n                        FileDescriptor fd = pfd.getFileDescriptor();\n                        art = scanner.extractAlbumArt(fd);\n                    }\n                } catch (IOException ex) {\n                } catch (SecurityException ex) {\n                } finally {\n                    try {\n                        if (pfd != null) {\n                            pfd.close();\n                        }\n                    } catch (IOException ex) {\n                    }\n                }\n            }\n        }\n        // if no embedded art exists, look for AlbumArt.jpg in same directory as the media file\n        if (art == null && path != null) {\n            if (path.startsWith(sExternalMediaUri)) {\n                // get the real path\n                Cursor c = query(context,Uri.parse(path),\n                        new String[] { MediaStore.Audio.Media.DATA},\n                        null, null, null);\n                if (c != null) {\n                    c.moveToFirst();\n                    if (!c.isAfterLast()) {\n                        path = c.getString(0);\n                    }\n                    c.close();\n                }\n            }\n            int lastSlash = path.lastIndexOf('/');\n            if (lastSlash > 0) {\n                String artPath = path.substring(0, lastSlash + 1) + \"AlbumArt.jpg\";\n                File file = new File(artPath);\n                if (file.exists()) {\n                    art = new byte[(int)file.length()];\n                    FileInputStream stream = null;\n                    try {\n                        stream = new FileInputStream(file);\n                        stream.read(art);\n                    } catch (IOException ex) {\n                        art = null;\n                    } finally {\n                        try {\n                            if (stream != null) {\n                                stream.close();\n                            }\n                        } catch (IOException ex) {\n                        }\n                    }\n                } else {\n                    // TODO: try getting album art from the web\n                }\n            }\n        }\n        \n        if (art != null) {\n            try {\n                // get the size of the bitmap\n                BitmapFactory.Options opts = new BitmapFactory.Options();\n                opts.inJustDecodeBounds = true;\n                opts.inSampleSize = 1;\n                BitmapFactory.decodeByteArray(art, 0, art.length, opts);\n                \n                // request a reasonably sized output image\n                // TODO: don't hardcode the size\n                while (opts.outHeight > 320 || opts.outWidth > 320) {\n                    opts.outHeight /= 2;\n                    opts.outWidth /= 2;\n                    opts.inSampleSize *= 2;\n                }\n                \n                // get the image for real now\n                opts.inJustDecodeBounds = false;\n                bm = BitmapFactory.decodeByteArray(art, 0, art.length, opts);\n                if (albumid != -1) {\n                    sArtId = albumid;\n                }\n                mCachedArt = art;\n                mCachedBit = bm;\n            } catch (Exception e) {\n            }\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.Locale;\n\nimport android.app.Activity;\nimport android.app.ExpandableListActivity;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.Editor;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.PixelFormat;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.media.MediaFile;\nimport android.media.MediaScanner;\nimport android.net.Uri;\nimport android.os.RemoteException;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.util.Log;\nimport android.view.SubMenu;\nimport android.view.Window;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class MusicUtils {\n\n    private static final String TAG = \"MusicUtils\";\n\n    public interface Defs {\n        public final static int OPEN_URL = 0;\n        public final static int ADD_TO_PLAYLIST = 1;\n        public final static int USE_AS_RINGTONE = 2;\n        public final static int PLAYLIST_SELECTED = 3;\n        public final static int NEW_PLAYLIST = 4;\n        public final static int PLAY_SELECTION = 5;\n        public final static int GOTO_START = 6;\n        public final static int GOTO_PLAYBACK = 7;\n        public final static int PARTY_SHUFFLE = 8;\n        public final static int SHUFFLE_ALL = 9;\n        public final static int DELETE_ITEM = 10;\n        public final static int SCAN_DONE = 11;\n        public final static int QUEUE = 12;\n        public final static int CHILD_MENU_BASE = 13; // this should be the last item\n    }\n    \n    public static String makeAlbumsSongsLabel(Context context, int numalbums, int numsongs, boolean isUnknown) {\n        // There are several formats for the albums/songs information:\n        // \"1 Song\"   - used if there is only 1 song\n        // \"N Songs\" - used for the \"unknown artist\" item\n        // \"1 Album\"/\"N Songs\" \n        // \"N Album\"/\"M Songs\"\n        // Depending on locale, these may need to be further subdivided\n        \n        StringBuilder songs_albums = new StringBuilder();\n\n        if (numsongs == 1) {\n            songs_albums.append(context.getString(R.string.onesong));\n        } else {\n            Resources r = context.getResources();\n            if (! isUnknown) {\n                String f = r.getQuantityText(R.plurals.Nalbums, numalbums).toString();\n                sFormatBuilder.setLength(0);\n                sFormatter.format(f, Integer.valueOf(numalbums));\n                songs_albums.append(sFormatBuilder);\n                songs_albums.append(context.getString(R.string.albumsongseparator));\n            }\n            String f = r.getQuantityText(R.plurals.Nsongs, numsongs).toString();\n            sFormatBuilder.setLength(0);\n            sFormatter.format(f, Integer.valueOf(numsongs));\n            songs_albums.append(sFormatBuilder);\n        }\n        return songs_albums.toString();\n    }\n    \n    public static IMediaPlaybackService sService = null;\n    private static HashMap<Context, ServiceBinder> sConnectionMap = new HashMap<Context, ServiceBinder>();\n\n    public static boolean bindToService(Context context) {\n        return bindToService(context, null);\n    }\n\n    public static boolean bindToService(Context context, ServiceConnection callback) {\n        context.startService(new Intent(context, MediaPlaybackService.class));\n        ServiceBinder sb = new ServiceBinder(callback);\n        sConnectionMap.put(context, sb);\n        return context.bindService((new Intent()).setClass(context,\n                MediaPlaybackService.class), sb, 0);\n    }\n    \n    public static void unbindFromService(Context context) {\n        ServiceBinder sb = (ServiceBinder) sConnectionMap.remove(context);\n        if (sb == null) {\n            Log.e(\"MusicUtils\", \"Trying to unbind for unknown Context\");\n            return;\n        }\n        context.unbindService(sb);\n        if (sConnectionMap.isEmpty()) {\n            // presumably there is nobody interested in the service at this point,\n            // so don't hang on to the ServiceConnection\n            sService = null;\n        }\n    }\n\n    private static class ServiceBinder implements ServiceConnection {\n        ServiceConnection mCallback;\n        ServiceBinder(ServiceConnection callback) {\n            mCallback = callback;\n        }\n        \n        public void onServiceConnected(ComponentName className, android.os.IBinder service) {\n            sService = IMediaPlaybackService.Stub.asInterface(service);\n            initAlbumArtCache();\n            if (mCallback != null) {\n                mCallback.onServiceConnected(className, service);\n            }\n        }\n        \n        public void onServiceDisconnected(ComponentName className) {\n            if (mCallback != null) {\n                mCallback.onServiceDisconnected(className);\n            }\n            sService = null;\n        }\n    }\n    \n    public static int getCurrentAlbumId() {\n        if (sService != null) {\n            try {\n                return sService.getAlbumId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static int getCurrentArtistId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getArtistId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n\n    public static int getCurrentAudioId() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getAudioId();\n            } catch (RemoteException ex) {\n            }\n        }\n        return -1;\n    }\n    \n    public static int getCurrentShuffleMode() {\n        int mode = MediaPlaybackService.SHUFFLE_NONE;\n        if (sService != null) {\n            try {\n                mode = sService.getShuffleMode();\n            } catch (RemoteException ex) {\n            }\n        }\n        return mode;\n    }\n    \n    /*\n     * Returns true if a file is currently opened for playback (regardless\n     * of whether it's playing or paused).\n     */\n    public static boolean isMusicLoaded() {\n        if (MusicUtils.sService != null) {\n            try {\n                return sService.getPath() != null;\n            } catch (RemoteException ex) {\n            }\n        }\n        return false;\n    }\n\n    private final static int [] sEmptyList = new int[0];\n    \n    public static int [] getSongListForCursor(Cursor cursor) {\n        if (cursor == null) {\n            return sEmptyList;\n        }\n        int len = cursor.getCount();\n        int [] list = new int[len];\n        cursor.moveToFirst();\n        int colidx = -1;\n        try {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        } catch (IllegalArgumentException ex) {\n            colidx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        }\n        for (int i = 0; i < len; i++) {\n            list[i] = cursor.getInt(colidx);\n            cursor.moveToNext();\n        }\n        return list;\n    }\n\n    public static int [] getSongListForArtist(Context context, int id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ARTIST_ID + \"=\" + id + \" AND \" + \n        MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null,\n                MediaStore.Audio.Media.ALBUM_KEY + \",\"  + MediaStore.Audio.Media.TRACK);\n        \n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static int [] getSongListForAlbum(Context context, int id) {\n        final String[] ccols = new String[] { MediaStore.Audio.Media._ID };\n        String where = MediaStore.Audio.Media.ALBUM_ID + \"=\" + id + \" AND \" + \n                MediaStore.Audio.Media.IS_MUSIC + \"=1\";\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                ccols, where, null, MediaStore.Audio.Media.TRACK);\n\n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n\n    public static int [] getSongListForPlaylist(Context context, long plid) {\n        final String[] ccols = new String[] { MediaStore.Audio.Playlists.Members.AUDIO_ID };\n        Cursor cursor = query(context, MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid),\n                ccols, null, null, MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);\n        \n        if (cursor != null) {\n            int [] list = getSongListForCursor(cursor);\n            cursor.close();\n            return list;\n        }\n        return sEmptyList;\n    }\n    \n    public static void playPlaylist(Context context, long plid) {\n        int [] list = getSongListForPlaylist(context, plid);\n        if (list != null) {\n            playAll(context, list, -1, false);\n        }\n    }\n\n    public static int [] getAllSongs(Context context) {\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                new String[] {MediaStore.Audio.Media._ID}, MediaStore.Audio.Media.IS_MUSIC + \"=1\",\n                null, null);\n        try {\n            if (c == null || c.getCount() == 0) {\n                return null;\n            }\n            int len = c.getCount();\n            int[] list = new int[len];\n            for (int i = 0; i < len; i++) {\n                c.moveToNext();\n                list[i] = c.getInt(0);\n            }\n\n            return list;\n        } finally {\n            if (c != null) {\n                c.close();\n            }\n        }\n    }\n\n    /**\n     * Fills out the given submenu with items for \"new playlist\" and\n     * any existing playlists. When the user selects an item, the\n     * application will receive PLAYLIST_SELECTED with the Uri of\n     * the selected playlist, NEW_PLAYLIST if a new playlist\n     * should be created, and QUEUE if the \"current playlist\" was\n     * selected.\n     * @param context The context to use for creating the menu items\n     * @param sub The submenu to add the items to.\n     */\n    public static void makePlaylistMenu(Context context, SubMenu sub) {\n        String[] cols = new String[] {\n                MediaStore.Audio.Playlists._ID,\n                MediaStore.Audio.Playlists.NAME\n        };\n        ContentResolver resolver = context.getContentResolver();\n        if (resolver == null) {\n            System.out.println(\"resolver = null\");\n        } else {\n            String whereclause = MediaStore.Audio.Playlists.NAME + \" != ''\";\n            Cursor cur = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,\n                cols, whereclause, null,\n                MediaStore.Audio.Playlists.NAME);\n            sub.clear();\n            sub.add(1, Defs.QUEUE, 0, R.string.queue);\n            sub.add(1, Defs.NEW_PLAYLIST, 0, R.string.new_playlist);\n            if (cur != null && cur.getCount() > 0) {\n                //sub.addSeparator(1, 0);\n                cur.moveToFirst();\n                while (! cur.isAfterLast()) {\n                    Intent intent = new Intent();\n                    intent.putExtra(\"playlist\", cur.getInt(0));\n//                    if (cur.getInt(0) == mLastPlaylistSelected) {\n//                        sub.add(0, MusicBaseActivity.PLAYLIST_SELECTED, cur.getString(1)).setIntent(intent);\n//                    } else {\n                        sub.add(1, Defs.PLAYLIST_SELECTED, 0, cur.getString(1)).setIntent(intent);\n//                    }\n                    cur.moveToNext();\n                }\n            }\n            if (cur != null) {\n                cur.close();\n            }\n        }\n    }\n\n    public static void clearPlaylist(Context context, int plid) {\n        \n        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", plid);\n        context.getContentResolver().delete(uri, null, null);\n        return;\n    }\n    \n    public static void deleteTracks(Context context, int [] list) {\n        \n        String [] cols = new String [] { MediaStore.Audio.Media._ID, \n                MediaStore.Audio.Media.DATA, MediaStore.Audio.Media.ALBUM_ID };\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media._ID + \" IN (\");\n        for (int i = 0; i < list.length; i++) {\n            where.append(list[i]);\n            if (i < list.length - 1) {\n                where.append(\",\");\n            }\n        }\n        where.append(\")\");\n        Cursor c = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cols,\n                where.toString(), null, null);\n\n        if (c != null) {\n\n            // step 1: remove selected tracks from the current playlist, as well\n            // as from the album art cache\n            try {\n                c.moveToFirst();\n                while (! c.isAfterLast()) {\n                    // remove from current playlist\n                    int id = c.getInt(0);\n                    sService.removeTrack(id);\n                    // remove from album art cache\n                    int artIndex = c.getInt(2);\n                    synchronized(sArtCache) {\n                        sArtCache.remove(artIndex);\n                    }\n                    c.moveToNext();\n                }\n            } catch (RemoteException ex) {\n            }\n\n            // step 2: remove selected tracks from the database\n            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, where.toString(), null);\n\n            // step 3: remove files from card\n            c.moveToFirst();\n            while (! c.isAfterLast()) {\n                String name = c.getString(1);\n                File f = new File(name);\n                try {  // File.delete can throw a security exception\n                    if (!f.delete()) {\n                        // I'm not sure if we'd ever get here (deletion would\n                        // have to fail, but no exception thrown)\n                        Log.e(\"MusicUtils\", \"Failed to delete file \" + name);\n                    }\n                    c.moveToNext();\n                } catch (SecurityException ex) {\n                    c.moveToNext();\n                }\n            }\n            c.close();\n        }\n\n        String message = context.getResources().getQuantityString(\n                R.plurals.NNNtracksdeleted, list.length, Integer.valueOf(list.length));\n        \n        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        // We deleted a number of tracks, which could affect any number of things\n        // in the media content domain, so update everything.\n        context.getContentResolver().notifyChange(Uri.parse(\"content://media\"), null);\n    }\n    \n    public static void addToCurrentPlaylist(Context context, int [] list) {\n        if (sService == null) {\n            return;\n        }\n        try {\n            sService.enqueue(list, MediaPlaybackService.LAST);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, list.length, Integer.valueOf(list.length));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    public static void addToPlaylist(Context context, int [] ids, long playlistid) {\n        if (ids == null) {\n            // this shouldn't happen (the menuitems shouldn't be visible\n            // unless the selected item represents something playable\n            Log.e(\"MusicBase\", \"ListSelection null\");\n        } else {\n            int size = ids.length;\n            ContentValues values [] = new ContentValues[size];\n            ContentResolver resolver = context.getContentResolver();\n            // need to determine the number of items currently in the playlist,\n            // so the play_order field can be maintained.\n            String[] cols = new String[] {\n                    \"count(*)\"\n            };\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\", playlistid);\n            Cursor cur = resolver.query(uri, cols, null, null, null);\n            cur.moveToFirst();\n            int base = cur.getInt(0);\n            cur.close();\n\n            for (int i = 0; i < size; i++) {\n                values[i] = new ContentValues();\n                values[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, Integer.valueOf(base + i));\n                values[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, ids[i]);\n            }\n            resolver.bulkInsert(uri, values);\n            String message = context.getResources().getQuantityString(\n                    R.plurals.NNNtrackstoplaylist, size, Integer.valueOf(size));\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            //mLastPlaylistSelected = playlistid;\n        }\n    }\n\n    public static Cursor query(Context context, Uri uri, String[] projection,\n            String selection, String[] selectionArgs, String sortOrder) {\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            if (resolver == null) {\n                return null;\n            }\n            return resolver.query(uri, projection, selection, selectionArgs, sortOrder);\n         } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n        \n    }\n    \n    public static boolean isMediaScannerScanning(Context context) {\n        boolean result = false;\n        Cursor cursor = query(context, MediaStore.getMediaScannerUri(), \n                new String [] { MediaStore.MEDIA_SCANNER_VOLUME }, null, null, null);\n        if (cursor != null) {\n            if (cursor.getCount() == 1) {\n                cursor.moveToFirst();\n                result = \"external\".equals(cursor.getString(0));\n            }\n            cursor.close(); \n        } \n\n        return result;\n    }\n    \n    public static void setSpinnerState(Activity a) {\n        if (isMediaScannerScanning(a)) {\n            // start the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_INDETERMINATE_ON);\n\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_ON);\n        } else {\n            // stop the progress spinner\n            a.getWindow().setFeatureInt(\n                    Window.FEATURE_INDETERMINATE_PROGRESS,\n                    Window.PROGRESS_VISIBILITY_OFF);\n        }\n    }\n    \n    public static void displayDatabaseError(Activity a) {\n        String status = Environment.getExternalStorageState();\n        int title = R.string.sdcard_error_title;\n        int message = R.string.sdcard_error_message;\n        \n        if (status.equals(Environment.MEDIA_SHARED)) {\n            title = R.string.sdcard_busy_title;\n            message = R.string.sdcard_busy_message;\n        } else if (status.equals(Environment.MEDIA_REMOVED)) {\n            title = R.string.sdcard_missing_title;\n            message = R.string.sdcard_missing_message;\n        } else if (status.equals(Environment.MEDIA_MOUNTED)){\n            // The card is mounted, but we didn't get a valid cursor.\n            // This probably means the mediascanner hasn't started scanning the\n            // card yet (there is a small window of time during boot where this\n            // will happen).\n            a.setTitle(\"\");\n            Intent intent = new Intent();\n            intent.setClass(a, ScanningProgress.class);\n            a.startActivityForResult(intent, Defs.SCAN_DONE);\n        } else {\n            Log.d(TAG, \"sd card: \" + status);\n        }\n\n        a.setTitle(title);\n        if (a instanceof ExpandableListActivity) {\n            a.setContentView(R.layout.no_sd_card_expanding);\n        } else {\n            a.setContentView(R.layout.no_sd_card);\n        }\n        TextView tv = (TextView) a.findViewById(R.id.sd_message);\n        tv.setText(message);\n    }\n\n    static protected Uri getContentURIForPath(String path) {\n        return Uri.fromFile(new File(path));\n    }\n\n    \n    /*  Try to use String.format() as little as possible, because it creates a\n     *  new Formatter every time you call it, which is very inefficient.\n     *  Reusing an existing Formatter more than tripled the speed of\n     *  makeTimeString().\n     *  This Formatter/StringBuilder are also used by makeAlbumSongsLabel()\n     */\n    private static StringBuilder sFormatBuilder = new StringBuilder();\n    private static Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault());\n    private static final Object[] sTimeArgs = new Object[5];\n\n    public static String makeTimeString(Context context, long secs) {\n        String durationformat = context.getString(R.string.durationformat);\n        \n        /* Provide multiple arguments so the format can be changed easily\n         * by modifying the xml.\n         */\n        sFormatBuilder.setLength(0);\n\n        final Object[] timeArgs = sTimeArgs;\n        timeArgs[0] = secs / 3600;\n        timeArgs[1] = secs / 60;\n        timeArgs[2] = (secs / 60) % 60;\n        timeArgs[3] = secs;\n        timeArgs[4] = secs % 60;\n\n        return sFormatter.format(durationformat, timeArgs).toString();\n    }\n    \n    public static void shuffleAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, true);\n    }\n\n    public static void playAll(Context context, Cursor cursor) {\n        playAll(context, cursor, 0, false);\n    }\n    \n    public static void playAll(Context context, Cursor cursor, int position) {\n        playAll(context, cursor, position, false);\n    }\n    \n    public static void playAll(Context context, int [] list, int position) {\n        playAll(context, list, position, false);\n    }\n    \n    private static void playAll(Context context, Cursor cursor, int position, boolean force_shuffle) {\n    \n        int [] list = getSongListForCursor(cursor);\n        playAll(context, list, position, force_shuffle);\n    }\n    \n    private static void playAll(Context context, int [] list, int position, boolean force_shuffle) {\n        if (list.length == 0 || sService == null) {\n            Log.d(\"MusicUtils\", \"attempt to play empty song list\");\n            // Don't try to play empty playlists. Nothing good will come of it.\n            String message = context.getString(R.string.emptyplaylist, list.length);\n            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        try {\n            if (force_shuffle) {\n                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);\n            }\n            int curid = sService.getAudioId();\n            int curpos = sService.getQueuePosition();\n            if (position != -1 && curpos == position && curid == list[position]) {\n                // The selected file is the file that's currently playing;\n                // figure out if we need to restart with a new playlist,\n                // or just launch the playback activity.\n                int [] playlist = sService.getQueue();\n                if (Arrays.equals(list, playlist)) {\n                    // we don't need to set a new list, but we should resume playback if needed\n                    sService.play();\n                    return; // the 'finally' block will still run\n                }\n            }\n            if (position < 0) {\n                position = 0;\n            }\n            sService.open(list, position);\n            sService.play();\n        } catch (RemoteException ex) {\n        } finally {\n            Intent intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\")\n                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            context.startActivity(intent);\n        }\n    }\n    \n    public static void clearQueue() {\n        try {\n            sService.removeTracks(0, Integer.MAX_VALUE);\n        } catch (RemoteException ex) {\n        }\n    }\n    \n    // A really simple BitmapDrawable-like class, that doesn't do\n    // scaling, dithering or filtering.\n    private static class FastBitmapDrawable extends Drawable {\n        private Bitmap mBitmap;\n        public FastBitmapDrawable(Bitmap b) {\n            mBitmap = b;\n        }\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(mBitmap, 0, 0, null);\n        }\n        @Override\n        public int getOpacity() {\n            return PixelFormat.OPAQUE;\n        }\n        @Override\n        public void setAlpha(int alpha) {\n        }\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n        }\n    }\n    \n    private static int sArtId = -2;\n    private static byte [] mCachedArt;\n    private static Bitmap mCachedBit = null;\n    private static final BitmapFactory.Options sBitmapOptionsCache = new BitmapFactory.Options();\n    private static final BitmapFactory.Options sBitmapOptions = new BitmapFactory.Options();\n    private static final Uri sArtworkUri = Uri.parse(\"content://media/external/audio/albumart\");\n    private static final HashMap<Integer, Drawable> sArtCache = new HashMap<Integer, Drawable>();\n    private static int sArtCacheId = -1;\n    \n    static {\n        // for the cache, \n        // 565 is faster to decode and display\n        // and we don't want to dither here because the image will be scaled down later\n        sBitmapOptionsCache.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptionsCache.inDither = false;\n\n        sBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;\n        sBitmapOptions.inDither = false;\n    }\n\n    public static void initAlbumArtCache() {\n        try {\n            int id = sService.getMediaMountedCount();\n            if (id != sArtCacheId) {\n                clearAlbumArtCache();\n                sArtCacheId = id; \n            }\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void clearAlbumArtCache() {\n        synchronized(sArtCache) {\n            sArtCache.clear();\n        }\n    }\n    \n    public static Drawable getCachedArtwork(Context context, int artIndex, BitmapDrawable defaultArtwork) {\n        Drawable d = null;\n        synchronized(sArtCache) {\n            d = sArtCache.get(artIndex);\n        }\n        if (d == null) {\n            d = defaultArtwork;\n            final Bitmap icon = defaultArtwork.getBitmap();\n            int w = icon.getWidth();\n            int h = icon.getHeight();\n            Bitmap b = MusicUtils.getArtworkQuick(context, artIndex, w, h);\n            if (b != null) {\n                d = new FastBitmapDrawable(b);\n                synchronized(sArtCache) {\n                    // the cache may have changed since we checked\n                    Drawable value = sArtCache.get(artIndex);\n                    if (value == null) {\n                        sArtCache.put(artIndex, d);\n                    } else {\n                        d = value;\n                    }\n                }\n            }\n        }\n        return d;\n    }\n\n    // Get album art for specified album. This method will not try to\n    // fall back to getting artwork directly from the file, nor will\n    // it attempt to repair the database.\n    private static Bitmap getArtworkQuick(Context context, int album_id, int w, int h) {\n        // NOTE: There is in fact a 1 pixel frame in the ImageView used to\n        // display this drawable. Take it into account now, so we don't have to\n        // scale later.\n        w -= 2;\n        h -= 2;\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            ParcelFileDescriptor fd = null;\n            try {\n                fd = res.openFileDescriptor(uri, \"r\");\n                int sampleSize = 1;\n                \n                // Compute the closest power-of-two scale factor \n                // and pass that to sBitmapOptionsCache.inSampleSize, which will\n                // result in faster decoding and better quality\n                sBitmapOptionsCache.inJustDecodeBounds = true;\n                BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n                int nextWidth = sBitmapOptionsCache.outWidth >> 1;\n                int nextHeight = sBitmapOptionsCache.outHeight >> 1;\n                while (nextWidth>w && nextHeight>h) {\n                    sampleSize <<= 1;\n                    nextWidth >>= 1;\n                    nextHeight >>= 1;\n                }\n\n                sBitmapOptionsCache.inSampleSize = sampleSize;\n                sBitmapOptionsCache.inJustDecodeBounds = false;\n                Bitmap b = BitmapFactory.decodeFileDescriptor(\n                        fd.getFileDescriptor(), null, sBitmapOptionsCache);\n\n                if (b != null) {\n                    // finally rescale to exactly the size we need\n                    if (sBitmapOptionsCache.outWidth != w || sBitmapOptionsCache.outHeight != h) {\n                        Bitmap tmp = Bitmap.createScaledBitmap(b, w, h, true);\n                        // Bitmap.createScaledBitmap() can return the same bitmap\n                        if (tmp != b) b.recycle();\n                        b = tmp;\n                    }\n                }\n                \n                return b;\n            } catch (FileNotFoundException e) {\n            } finally {\n                try {\n                    if (fd != null)\n                        fd.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return null;\n    }\n    \n    // Get album art for specified album. You should not pass in the album id\n    // for the \"unknown\" album here (use -1 instead)\n    public static Bitmap getArtwork(Context context, int album_id) {\n\n        if (album_id < 0) {\n            // This is something that is not in the database, so get the album art directly\n            // from the file.\n            Bitmap bm = getArtworkFromFile(context, null, -1);\n            if (bm != null) {\n                return bm;\n            }\n            return getDefaultArtwork(context);\n        }\n\n        ContentResolver res = context.getContentResolver();\n        Uri uri = ContentUris.withAppendedId(sArtworkUri, album_id);\n        if (uri != null) {\n            InputStream in = null;\n            try {\n                in = res.openInputStream(uri);\n                return BitmapFactory.decodeStream(in, null, sBitmapOptions);\n            } catch (FileNotFoundException ex) {\n                // The album art thumbnail does not actually exist. Maybe the user deleted it, or\n                // maybe it never existed to begin with.\n                Bitmap bm = getArtworkFromFile(context, null, album_id);\n                if (bm != null) {\n                    // Put the newly found artwork in the database.\n                    // Note that this shouldn't be done for the \"unknown\" album,\n                    // but if this method is called correctly, that won't happen.\n                    \n                    // first write it somewhere\n                    String file = Environment.getExternalStorageDirectory()\n                        + \"/albumthumbs/\" + String.valueOf(System.currentTimeMillis());\n                    if (ensureFileExists(file)) {\n                        try {\n                            OutputStream outstream = new FileOutputStream(file);\n                            if (bm.getConfig() == null) {\n                                bm = bm.copy(Bitmap.Config.RGB_565, false);\n                                if (bm == null) {\n                                    return getDefaultArtwork(context);\n                                }\n                            }\n                            boolean success = bm.compress(Bitmap.CompressFormat.JPEG, 75, outstream);\n                            outstream.close();\n                            if (success) {\n                                ContentValues values = new ContentValues();\n                                values.put(\"album_id\", album_id);\n                                values.put(\"_data\", file);\n                                Uri newuri = res.insert(sArtworkUri, values);\n                                if (newuri == null) {\n                                    // Failed to insert in to the database. The most likely\n                                    // cause of this is that the item already existed in the\n                                    // database, and the most likely cause of that is that\n                                    // the album was scanned before, but the user deleted the\n                                    // album art from the sd card.\n                                    // We can ignore that case here, since the media provider\n                                    // will regenerate the album art for those entries when\n                                    // it detects this.\n                                    success = false;\n                                }\n                            }\n                            if (!success) {\n                                File f = new File(file);\n                                f.delete();\n                            }\n                        } catch (FileNotFoundException e) {\n                            Log.e(TAG, \"error creating file\", e);\n                        } catch (IOException e) {\n                            Log.e(TAG, \"error creating file\", e);\n                        }\n                    }\n                } else {\n                    bm = getDefaultArtwork(context);\n                }\n                return bm;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                }\n            }\n        }\n        \n        return null;\n    }\n\n    // copied from MediaProvider\n    private static boolean ensureFileExists(String path) {\n        File file = new File(path);\n        if (file.exists()) {\n            return true;\n        } else {\n            // we will not attempt to create the first directory in the path\n            // (for example, do not create /sdcard if the SD card is not mounted)\n            int secondSlash = path.indexOf('/', 1);\n            if (secondSlash < 1) return false;\n            String directoryPath = path.substring(0, secondSlash);\n            File directory = new File(directoryPath);\n            if (!directory.exists())\n                return false;\n            file.getParentFile().mkdirs();\n            try {\n                return file.createNewFile();\n            } catch(IOException ioe) {\n                Log.e(TAG, \"File creation failed\", ioe);\n            }\n            return false;\n        }\n    }\n    \n    // get album art for specified file\n    private static final String sExternalMediaUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString();\n    private static Bitmap getArtworkFromFile(Context context, Uri uri, int albumid) {\n        Bitmap bm = null;\n        byte [] art = null;\n        String path = null;\n\n        if (sArtId == albumid) {\n            //Log.i(\"@@@@@@ \", \"reusing cached data\", new Exception());\n            if (mCachedBit != null) {\n                return mCachedBit;\n            }\n            art = mCachedArt;\n        } else {\n            // try reading embedded artwork\n            if (uri == null) {\n                try {\n                    int curalbum = sService.getAlbumId();\n                    if (curalbum == albumid || albumid < 0) {\n                        path = sService.getPath();\n                        if (path != null) {\n                            uri = Uri.parse(path);\n                        }\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            if (uri == null) {\n                if (albumid >= 0) {\n                    Cursor c = query(context,MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                            new String[] { MediaStore.Audio.Media._ID, MediaStore.Audio.Media.ALBUM },\n                            MediaStore.Audio.Media.ALBUM_ID + \"=?\", new String [] {String.valueOf(albumid)},\n                            null);\n                    if (c != null) {\n                        c.moveToFirst();\n                        if (!c.isAfterLast()) {\n                            int trackid = c.getInt(0);\n                            uri = ContentUris.withAppendedId(\n                                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, trackid);\n                        }\n                        if (c.getString(1).equals(MediaFile.UNKNOWN_STRING)) {\n                            albumid = -1;\n                        }\n                        c.close();\n                    }\n                }\n            }\n            if (uri != null) {\n                MediaScanner scanner = new MediaScanner(context);\n                ParcelFileDescriptor pfd = null;\n                try {\n                    pfd = context.getContentResolver().openFileDescriptor(uri, \"r\");\n                    if (pfd != null) {\n                        FileDescriptor fd = pfd.getFileDescriptor();\n                        art = scanner.extractAlbumArt(fd);\n                    }\n                } catch (IOException ex) {\n                } catch (SecurityException ex) {\n                } finally {\n                    try {\n                        if (pfd != null) {\n                            pfd.close();\n                        }\n                    } catch (IOException ex) {\n                    }\n                }\n            }\n        }\n        // if no embedded art exists, look for AlbumArt.jpg in same directory as the media file\n        if (art == null && path != null) {\n            if (path.startsWith(sExternalMediaUri)) {\n                // get the real path\n                Cursor c = query(context,Uri.parse(path),\n                        new String[] { MediaStore.Audio.Media.DATA},\n                        null, null, null);\n                if (c != null) {\n                    c.moveToFirst();\n                    if (!c.isAfterLast()) {\n                        path = c.getString(0);\n                    }\n                    c.close();\n                }\n            }\n            int lastSlash = path.lastIndexOf('/');\n            if (lastSlash > 0) {\n                String artPath = path.substring(0, lastSlash + 1) + \"AlbumArt.jpg\";\n                File file = new File(artPath);\n                if (file.exists()) {\n                    art = new byte[(int)file.length()];\n                    FileInputStream stream = null;\n                    try {\n                        stream = new FileInputStream(file);\n                        stream.read(art);\n                    } catch (IOException ex) {\n                        art = null;\n                    } finally {\n                        try {\n                            if (stream != null) {\n                                stream.close();\n                            }\n                        } catch (IOException ex) {\n                        }\n                    }\n                } else {\n                    // TODO: try getting album art from the web\n                }\n            }\n        }\n        \n        if (art != null) {\n            try {\n                // get the size of the bitmap\n                BitmapFactory.Options opts = new BitmapFactory.Options();\n                opts.inJustDecodeBounds = true;\n                opts.inSampleSize = 1;\n                BitmapFactory.decodeByteArray(art, 0, art.length, opts);\n                \n                // request a reasonably sized output image\n                // TODO: don't hardcode the size\n                while (opts.outHeight > 320 || opts.outWidth > 320) {\n                    opts.outHeight /= 2;\n                    opts.outWidth /= 2;\n                    opts.inSampleSize *= 2;\n                }\n                \n                // get the image for real now\n                opts.inJustDecodeBounds = false;\n                bm = BitmapFactory.decodeByteArray(art, 0, art.length, opts);\n                if (albumid != -1) {\n                    sArtId = albumid;\n                }\n                mCachedArt = art;\n                mCachedBit = bm;\n            } catch (Exception e) {\n            }\n        }\n        return bm;\n    }\n    \n    private static Bitmap getDefaultArtwork(Context context) {\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;\n        return BitmapFactory.decodeStream(\n                context.getResources().openRawResource(R.drawable.albumart_mp_unknown), null, opts);\n    }\n    \n    static int getIntPref(Context context, String name, int def) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        return prefs.getInt(name, def);\n    }\n    \n    static void setIntPref(Context context, String name, int value) {\n        SharedPreferences prefs =\n            context.getSharedPreferences(\"com.android.music\", Context.MODE_PRIVATE);\n        Editor ed = prefs.edit();\n        ed.putInt(name, value);\n        ed.commit();\n    }\n\n    static void setRingtone(Context context, long id) {\n        ContentResolver resolver = context.getContentResolver();\n        // Set the flag in the database to mark this as a ringtone\n        Uri ringUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);\n        try {\n            ContentValues values = new ContentValues(2);\n            values.put(MediaStore.Audio.Media.IS_RINGTONE, \"1\");\n            values.put(MediaStore.Audio.Media.IS_ALARM, \"1\");\n            resolver.update(ringUri, values, null, null);\n        } catch (UnsupportedOperationException ex) {\n            // most likely the card just got unmounted\n            Log.e(TAG, \"couldn't set ringtone flag for id \" + id);\n            return;\n        }\n\n        String[] cols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.TITLE\n        };\n\n        String where = MediaStore.Audio.Media._ID + \"=\" + id;\n        Cursor cursor = query(context, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                cols, where , null, null);\n        try {\n            if (cursor != null && cursor.getCount() == 1) {\n                // Set the system setting to make this the current ringtone\n                cursor.moveToFirst();\n                Settings.System.putString(resolver, Settings.System.RINGTONE, ringUri.toString());\n                String message = context.getString(R.string.ringtone_set, cursor.getString(2));\n                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n}\n","lineNo":366}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.content.*;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Debug;\nimport android.os.RemoteException;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.text.Collator;\nimport java.util.Arrays;\nimport java.util.Map;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private final int Q_SELECTED = CHILD_MENU_BASE;\n    private final int Q_ALL = CHILD_MENU_BASE + 1;\n    private final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private final int REMOVE = CHILD_MENU_BASE + 5;\n\n    private final int PLAY_NOW = 0;\n    private final int ADD_TO_QUEUE = 1;\n    private final int PLAY_NEXT = 2;\n    private final int JUMP_TO = 3;\n    private final int CLEAR_HISTORY = 4;\n    private final int CLEAR_ALL = 5;\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID\n        };\n\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        init();\n        //Debug.startMethodTracing();\n    }\n\n    @Override\n    public void onDestroy() {\n        //Debug.stopMethodTracing();\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiver(mNowPlayingListener);\n            } else {\n                unregisterReceiver(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        if (mTrackCursor != null) {\n            mTrackCursor.close();\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n   }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            init();\n            if (mTrackCursor == null) {\n                sendEmptyMessageDelayed(0, 1000);\n            }\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init() {\n\n        mTrackCursor = getTrackCursor(null);\n\n        setContentView(R.layout.media_picker_activity);\n        mTrackList = (ListView) findViewById(android.R.id.list);\n        if (mEditMode) {\n            //((TouchInterceptor) mTrackList).setDragListener(mDragListener);\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n        }\n\n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            return;\n        }\n\n        int numresults = mTrackCursor.getCount();\n        if (numresults > 0) {\n            mTrackCursor.moveToFirst();\n\n            CharSequence fancyName = null;\n            if (mAlbumId != null) {\n                fancyName = mTrackCursor.getString(mTrackCursor.getColumnIndex(MediaStore.Audio.Media.ALBUM));\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"='\" + \n                        mTrackCursor.getString(mTrackCursor.getColumnIndex(MediaStore.Audio.Media.ARTIST_ID)) + \"'\";\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(mTrackCursor.getColumnIndex(MediaStore.Audio.Media.ALBUM));\n                    }    \n                    cursor.deactivate();\n                }\n            } else if (mPlaylist != null) {\n                if (mPlaylist.equals(\"nowplaying\")) {\n                    if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                        fancyName = getText(R.string.partyshuffle_title);\n                    } else {\n                        fancyName = getText(R.string.nowplaying_title);\n                    }\n                } else {\n                    String [] cols = new String [] {\n                    MediaStore.Audio.Playlists.NAME\n                    };\n                    Cursor cursor = MusicUtils.query(this,\n                            ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                            cols, null, null, null);\n                    if (cursor != null) {\n                        if (cursor.getCount() != 0) {\n                            cursor.moveToFirst();\n                            fancyName = cursor.getString(0);\n                        }\n                        cursor.deactivate();\n                    }\n                }\n            } else if (mGenre != null) {\n                String [] cols = new String [] {\n                MediaStore.Audio.Genres.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n\n            if (fancyName != null) {\n                setTitle(fancyName);\n            } else {\n                setTitle(R.string.tracks_title);\n            }\n        } else {\n            setTitle(R.string.no_tracks_title);\n        }\n\n        TrackListAdapter adapter = new TrackListAdapter(\n                this,\n                mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                mTrackCursor,\n                new String[] {},\n                new int[] {},\n                \"nowplaying\".equals(mPlaylist));\n\n        setListAdapter(adapter);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setCacheColorHint(0);\n        if (!mEditMode) {\n            lv.setTextFilterEnabled(true);\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndex(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n    \n    private TouchInterceptor.DragListener mDragListener =\n        new TouchInterceptor.DragListener() {\n        public void drag(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            }\n        }\n    };\n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                int colidx = mTrackCursor.getColumnIndex(MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    mTrackCursor.updateInt(colidx, toidx);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        mTrackCursor.updateInt(colidx, i - 1);\n                    }\n                    mTrackCursor.commitUpdates();\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    mTrackCursor.updateInt(colidx, toidx);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        mTrackCursor.updateInt(colidx, i + 1);\n                    }\n                    mTrackCursor.commitUpdates();\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        mTrackCursor.moveToPosition(which);\n        mTrackCursor.deleteRow();\n        mTrackCursor.commitUpdates();\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                mTrackCursor.close();\n                mTrackCursor = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (mTrackCursor.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                ((TrackListAdapter)getListAdapter()).changeCursor(mTrackCursor);\n                getListView().invalidateViews();\n            }\n        }\n    };\n    \n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        int id_idx = mTrackCursor.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n        if (id_idx < 0 ) {\n            mSelectedId = mi.id;\n        } else {\n            mSelectedId = mTrackCursor.getInt(id_idx);\n        }\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndex(MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = new int[] { (int) mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = new int[] { (int) mSelectedId };\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                int [] list = new int[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                b.putString(\"description\", mCurrentTrackName);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 && event.isDown()) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            mTrackCursor.moveToPosition(curpos);\n            mTrackCursor.deleteRow();\n            mTrackCursor.commitUpdates();\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            mTrackCursor.moveToPosition(curpos);\n            mTrackCursor.deleteRow();\n            mTrackCursor.commitUpdates();\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndex(MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            if (up) {\n                    mTrackCursor.updateInt(colidx, currentplayidx - 1);\n                    mTrackCursor.moveToPrevious();\n            } else {\n                    mTrackCursor.updateInt(colidx, currentplayidx + 1);\n                    mTrackCursor.moveToNext();\n            }\n            mTrackCursor.updateInt(colidx, currentplayidx);\n            mTrackCursor.commitUpdates();\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    init();\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = Uri.parse(intent.getAction());\n                    if (uri != null) {\n                        int [] list = new int[] { (int) mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = Uri.parse(intent.getAction());\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n\n    private Cursor getTrackCursor(String filterstring) {\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (filterstring != null) {\n            String [] searchWords = filterstring.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            ret = MusicUtils.query(this,\n                    MediaStore.Audio.Genres.Members.getContentUri(\"external\", Integer.valueOf(mGenre)),\n                    mCursorCols, where.toString(), keywords, mSortOrder);\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                        mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId + \"'\");\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            ret = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                mCursorCols, where.toString() , keywords, mSortOrder);\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new int[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndex(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getInt(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            int newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        @Override\n        public boolean deleteRow()\n        {\n            try {\n                if (mService.removeTracks((int)mCurPos, (int)mCurPos) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) mCurPos;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            return mCurrentPlaylistCursor.getLong(column);\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private int[] mNowPlaying;\n        private int[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    class TrackListAdapter extends SimpleCursorAdapter {\n        boolean mIsNowPlaying;\n\n        final int mTitleIdx;\n        final int mArtistIdx;\n        final int mAlbumIdx;\n        final int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n\n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying) {\n            super(context, layout, cursor, from, to);\n            mIsNowPlaying = isnowplaying;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mTitleIdx = cursor.getColumnIndex(MediaStore.Audio.Media.TITLE);\n            mArtistIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST);\n            mAlbumIdx = cursor.getColumnIndex(MediaStore.Audio.Media.ALBUM);\n            mDurationIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DURATION);\n            mAudioIdIdx = cursor.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            if (mAudioIdIdx < 0) {\n                mAudioIdIdx = cursor.getColumnIndex(MediaStore.Audio.Media._ID);\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n                ViewGroup.LayoutParams p = iv.getLayoutParams();\n                p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n                p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            int id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && cursor.getInt(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            mTrackCursor = cursor;\n        }\n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            return getTrackCursor(constraint.toString());\n        }\n    }\n\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n}\n\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.music;\n\nimport android.app.ListActivity;\nimport android.app.SearchManager;\nimport android.content.AsyncQueryHandler;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.database.AbstractCursor;\nimport android.database.CharArrayBuffer;\nimport android.database.Cursor;\nimport android.media.AudioManager;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.Playlists;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.AlphabetIndexer;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.SectionIndexer;\nimport android.widget.SimpleCursorAdapter;\nimport android.widget.TextView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport java.text.Collator;\nimport java.util.Arrays;\n\npublic class TrackBrowserActivity extends ListActivity\n        implements View.OnCreateContextMenuListener, MusicUtils.Defs\n{\n    private final int Q_SELECTED = CHILD_MENU_BASE;\n    private final int Q_ALL = CHILD_MENU_BASE + 1;\n    private final int SAVE_AS_PLAYLIST = CHILD_MENU_BASE + 2;\n    private final int PLAY_ALL = CHILD_MENU_BASE + 3;\n    private final int CLEAR_PLAYLIST = CHILD_MENU_BASE + 4;\n    private final int REMOVE = CHILD_MENU_BASE + 5;\n    private final int SEARCH = CHILD_MENU_BASE + 6;\n\n\n    private static final String LOGTAG = \"TrackBrowser\";\n\n    private String[] mCursorCols;\n    private String[] mPlaylistMemberCols;\n    private boolean mDeletedOneRow = false;\n    private boolean mEditMode = false;\n    private String mCurrentTrackName;\n    private String mCurrentAlbumName;\n    private String mCurrentArtistNameForAlbum;\n    private MyQueryHandler mQueryHandler;\n    private String mFilterString = \"\";\n\n    public TrackBrowserActivity()\n    {\n    }\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle icicle)\n    {\n        super.onCreate(icicle);\n        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n        setVolumeControlStream(AudioManager.STREAM_MUSIC);\n        if (icicle != null) {\n            mSelectedId = icicle.getLong(\"selectedtrack\");\n            mAlbumId = icicle.getString(\"album\");\n            mArtistId = icicle.getString(\"artist\");\n            mPlaylist = icicle.getString(\"playlist\");\n            mGenre = icicle.getString(\"genre\");\n            mEditMode = icicle.getBoolean(\"editmode\", false);\n        } else {\n            mAlbumId = getIntent().getStringExtra(\"album\");\n            // If we have an album, show everything on the album, not just stuff\n            // by a particular artist.\n            Intent intent = getIntent();\n            mArtistId = intent.getStringExtra(\"artist\");\n            mPlaylist = intent.getStringExtra(\"playlist\");\n            mGenre = intent.getStringExtra(\"genre\");\n            mEditMode = intent.getAction().equals(Intent.ACTION_EDIT);\n        }\n\n        mCursorCols = new String[] {\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION\n        };\n        mPlaylistMemberCols = new String[] {\n                MediaStore.Audio.Playlists.Members._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.TITLE_KEY,\n                MediaStore.Audio.Media.DATA,\n                MediaStore.Audio.Media.ALBUM,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.ARTIST_ID,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Playlists.Members.PLAY_ORDER,\n                MediaStore.Audio.Playlists.Members.AUDIO_ID\n        };\n\n        MusicUtils.bindToService(this);\n\n        IntentFilter f = new IntentFilter();\n        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);\n        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);\n        f.addDataScheme(\"file\");\n        registerReceiver(mScanListener, f);\n\n        setContentView(R.layout.media_picker_activity);\n        mQueryHandler = new MyQueryHandler(getContentResolver());\n        mTrackCursor = (Cursor) getLastNonConfigurationInstance();\n        if (mTrackCursor == null) {\n            //Log.i(\"@@@\", \"starting query\");\n            setTitle(R.string.working_songs);\n            getTrackCursor(mQueryHandler);\n        } else {\n            init(mTrackCursor);\n            setTitle();\n        }\n    }\n    \n    @Override\n    public Object onRetainNonConfigurationInstance() {\n        Cursor c = mTrackCursor;\n        mTrackCursor = null;\n        return c;\n    }\n    \n    class MyQueryHandler extends AsyncQueryHandler {\n        MyQueryHandler(ContentResolver res) {\n            super(res);\n        }\n        \n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            //Log.i(\"@@@\", \"query complete\");\n            init(cursor);\n            setTitle();\n        }\n    }\n    \n    \n    @Override\n    public void onDestroy() {\n        MusicUtils.unbindFromService(this);\n        try {\n            if (\"nowplaying\".equals(mPlaylist)) {\n                unregisterReceiver(mNowPlayingListener);\n            } else {\n                unregisterReceiver(mTrackListListener);\n            }\n        } catch (IllegalArgumentException ex) {\n            // we end up here in case we never registered the listeners\n        }\n        if (mTrackCursor != null) {\n            mTrackCursor.close();\n            mTrackCursor = null;\n        }\n        unregisterReceiver(mScanListener);\n        super.onDestroy();\n   }\n    \n    @Override\n    public void onResume() {\n        super.onResume();\n        if (mTrackCursor != null) {\n            getListView().invalidateViews();\n        }\n        MusicUtils.setSpinnerState(this);\n    }\n    @Override\n    public void onPause() {\n        mReScanHandler.removeCallbacksAndMessages(null);\n        super.onPause();\n    }\n    \n    /*\n     * This listener gets called when the media scanner starts up, and when the\n     * sd card is unmounted.\n     */\n    private BroadcastReceiver mScanListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            MusicUtils.setSpinnerState(TrackBrowserActivity.this);\n            mReScanHandler.sendEmptyMessage(0);\n        }\n    };\n    \n    private Handler mReScanHandler = new Handler() {\n        public void handleMessage(Message msg) {\n            setTitle();\n            getTrackCursor(mQueryHandler);\n            if (mTrackCursor == null) {\n                sendEmptyMessageDelayed(0, 1000);\n            }\n        }\n    };\n    \n    public void onSaveInstanceState(Bundle outcicle) {\n        // need to store the selected item so we don't lose it in case\n        // of an orientation switch. Otherwise we could lose it while\n        // in the middle of specifying a playlist to add the item to.\n        outcicle.putLong(\"selectedtrack\", mSelectedId);\n        outcicle.putString(\"artist\", mArtistId);\n        outcicle.putString(\"album\", mAlbumId);\n        outcicle.putString(\"playlist\", mPlaylist);\n        outcicle.putString(\"genre\", mGenre);\n        outcicle.putBoolean(\"editmode\", mEditMode);\n        super.onSaveInstanceState(outcicle);\n    }\n    \n    public void init(Cursor newCursor) {\n\n        mTrackCursor = newCursor;\n        \n        setContentView(R.layout.media_picker_activity);\n        mTrackList = (ListView) findViewById(android.R.id.list);\n        if (mEditMode) {\n            //((TouchInterceptor) mTrackList).setDragListener(mDragListener);\n            ((TouchInterceptor) mTrackList).setDropListener(mDropListener);\n            ((TouchInterceptor) mTrackList).setRemoveListener(mRemoveListener);\n        }\n\n        if (mTrackCursor == null) {\n            MusicUtils.displayDatabaseError(this);\n            return;\n        }\n\n\n        TrackListAdapter adapter = new TrackListAdapter(\n                this,\n                mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,\n                mTrackCursor,\n                new String[] {},\n                new int[] {},\n                \"nowplaying\".equals(mPlaylist),\n                mPlaylist != null);\n\n        setTitle();\n        setListAdapter(adapter);\n        ListView lv = getListView();\n        lv.setOnCreateContextMenuListener(this);\n        lv.setCacheColorHint(0);\n        if (!mEditMode) {\n            lv.setTextFilterEnabled(true);\n        }\n\n        // When showing the queue, position the selection on the currently playing track\n        // Otherwise, position the selection on the first matching artist, if any\n        IntentFilter f = new IntentFilter();\n        f.addAction(MediaPlaybackService.META_CHANGED);\n        f.addAction(MediaPlaybackService.QUEUE_CHANGED);\n        if (\"nowplaying\".equals(mPlaylist)) {\n            try {\n                int cur = MusicUtils.sService.getQueuePosition();\n                setSelection(cur);\n                registerReceiver(mNowPlayingListener, new IntentFilter(f));\n                mNowPlayingListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n            } catch (RemoteException ex) {\n            }\n        } else {\n            String key = getIntent().getStringExtra(\"artist\");\n            if (key != null) {\n                int keyidx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST_ID);\n                mTrackCursor.moveToFirst();\n                while (! mTrackCursor.isAfterLast()) {\n                    String artist = mTrackCursor.getString(keyidx);\n                    if (artist.equals(key)) {\n                        setSelection(mTrackCursor.getPosition());\n                        break;\n                    }\n                    mTrackCursor.moveToNext();\n                }\n            }\n            registerReceiver(mTrackListListener, new IntentFilter(f));\n            mTrackListListener.onReceive(this, new Intent(MediaPlaybackService.META_CHANGED));\n        }\n    }\n\n    private void setTitle() {\n        int numresults = mTrackCursor != null ? mTrackCursor.getCount() : 0;\n        if (numresults > 0) {\n            mTrackCursor.moveToFirst();\n\n            CharSequence fancyName = null;\n            if (mAlbumId != null) {\n                int idx = mTrackCursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n                fancyName = mTrackCursor.getString(idx);\n                // For compilation albums show only the album title,\n                // but for regular albums show \"artist - album\".\n                // To determine whether something is a compilation\n                // album, do a query for the artist + album of the\n                // first item, and see if it returns the same number\n                // of results as the album query.\n                String where = MediaStore.Audio.Media.ALBUM_ID + \"='\" + mAlbumId +\n                        \"' AND \" + MediaStore.Audio.Media.ARTIST_ID + \"=\" + \n                        mTrackCursor.getLong(mTrackCursor.getColumnIndexOrThrow(\n                                MediaStore.Audio.Media.ARTIST_ID));\n                Cursor cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    new String[] {MediaStore.Audio.Media.ALBUM}, where, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != numresults) {\n                        // compilation album\n                        fancyName = mTrackCursor.getString(idx);\n                    }    \n                    cursor.deactivate();\n                }\n            } else if (mPlaylist != null) {\n                if (mPlaylist.equals(\"nowplaying\")) {\n                    if (MusicUtils.getCurrentShuffleMode() == MediaPlaybackService.SHUFFLE_AUTO) {\n                        fancyName = getText(R.string.partyshuffle_title);\n                    } else {\n                        fancyName = getText(R.string.nowplaying_title);\n                    }\n                } else {\n                    String [] cols = new String [] {\n                    MediaStore.Audio.Playlists.NAME\n                    };\n                    Cursor cursor = MusicUtils.query(this,\n                            ContentUris.withAppendedId(Playlists.EXTERNAL_CONTENT_URI, Long.valueOf(mPlaylist)),\n                            cols, null, null, null);\n                    if (cursor != null) {\n                        if (cursor.getCount() != 0) {\n                            cursor.moveToFirst();\n                            fancyName = cursor.getString(0);\n                        }\n                        cursor.deactivate();\n                    }\n                }\n            } else if (mGenre != null) {\n                String [] cols = new String [] {\n                MediaStore.Audio.Genres.NAME\n                };\n                Cursor cursor = MusicUtils.query(this,\n                        ContentUris.withAppendedId(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI, Long.valueOf(mGenre)),\n                        cols, null, null, null);\n                if (cursor != null) {\n                    if (cursor.getCount() != 0) {\n                        cursor.moveToFirst();\n                        fancyName = cursor.getString(0);\n                    }\n                    cursor.deactivate();\n                }\n            }\n\n            if (fancyName != null) {\n                setTitle(fancyName);\n            } else {\n                setTitle(R.string.tracks_title);\n            }\n        } else {\n            setTitle(R.string.no_tracks_title);\n        }\n    }\n    \n    private TouchInterceptor.DragListener mDragListener =\n        new TouchInterceptor.DragListener() {\n        public void drag(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            }\n        }\n    };\n    private TouchInterceptor.DropListener mDropListener =\n        new TouchInterceptor.DropListener() {\n        public void drop(int from, int to) {\n            if (mTrackCursor instanceof NowPlayingCursor) {\n                // update the currently playing list\n                NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n                c.moveItem(from, to);\n                ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n                getListView().invalidateViews();\n                mDeletedOneRow = true;\n            } else {\n                // update a saved playlist\n                Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                        Long.valueOf(mPlaylist));\n                ContentValues values = new ContentValues();\n                String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n                String [] wherearg = new String[1];\n                ContentResolver res = getContentResolver();\n                \n                int colidx = mTrackCursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n                if (from < to) {\n                    // move the item to somewhere later in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from + 1; i <= to; i++) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i - 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                } else if (from > to) {\n                    // move the item to somewhere earlier in the list\n                    mTrackCursor.moveToPosition(to);\n                    int toidx = mTrackCursor.getInt(colidx);\n                    mTrackCursor.moveToPosition(from);\n                    values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, toidx);\n                    wherearg[0] = mTrackCursor.getString(0);\n                    res.update(baseUri, values, where, wherearg);\n                    for (int i = from - 1; i >= to; i--) {\n                        mTrackCursor.moveToPosition(i);\n                        values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + 1);\n                        wherearg[0] = mTrackCursor.getString(0);\n                        res.update(baseUri, values, where, wherearg);\n                    }\n                }\n            }\n        }\n    };\n    \n    private TouchInterceptor.RemoveListener mRemoveListener =\n        new TouchInterceptor.RemoveListener() {\n        public void remove(int which) {\n            removePlaylistItem(which);\n        }\n    };\n\n    private void removePlaylistItem(int which) {\n        View v = mTrackList.getChildAt(which - mTrackList.getFirstVisiblePosition());\n        try {\n            if (MusicUtils.sService != null\n                    && which != MusicUtils.sService.getQueuePosition()) {\n                mDeletedOneRow = true;\n            }\n        } catch (RemoteException e) {\n            // Service died, so nothing playing.\n            mDeletedOneRow = true;\n        }\n        v.setVisibility(View.GONE);\n        mTrackList.invalidateViews();\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            ((NowPlayingCursor)mTrackCursor).removeItem(which);\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(which);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n        }\n        v.setVisibility(View.VISIBLE);\n        mTrackList.invalidateViews();\n    }\n    \n    private BroadcastReceiver mTrackListListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            getListView().invalidateViews();\n        }\n    };\n\n    private BroadcastReceiver mNowPlayingListener = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(MediaPlaybackService.META_CHANGED)) {\n                getListView().invalidateViews();\n            } else if (intent.getAction().equals(MediaPlaybackService.QUEUE_CHANGED)) {\n                if (mDeletedOneRow) {\n                    // This is the notification for a single row that was\n                    // deleted previously, which is already reflected in\n                    // the UI.\n                    mDeletedOneRow = false;\n                    return;\n                }\n                mTrackCursor.close();\n                mTrackCursor = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                if (mTrackCursor.getCount() == 0) {\n                    finish();\n                    return;\n                }\n                ((TrackListAdapter)getListAdapter()).changeCursor(mTrackCursor);\n                getListView().invalidateViews();\n            }\n        }\n    };\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenuInfo menuInfoIn) {\n        menu.add(0, PLAY_SELECTION, 0, R.string.play_selection);\n        SubMenu sub = menu.addSubMenu(0, ADD_TO_PLAYLIST, 0, R.string.add_to_playlist);\n        MusicUtils.makePlaylistMenu(this, sub);\n        if (mEditMode) {\n            menu.add(0, REMOVE, 0, R.string.remove_from_playlist);\n        }\n        menu.add(0, USE_AS_RINGTONE, 0, R.string.ringtone_menu);\n        menu.add(0, DELETE_ITEM, 0, R.string.delete_item);\n        menu.add(0, SEARCH, 0, R.string.search_title);\n        AdapterContextMenuInfo mi = (AdapterContextMenuInfo) menuInfoIn;\n        mSelectedPosition =  mi.position;\n        mTrackCursor.moveToPosition(mSelectedPosition);\n        try {\n            int id_idx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            mSelectedId = mTrackCursor.getInt(id_idx);\n        } catch (IllegalArgumentException ex) {\n            mSelectedId = mi.id;\n        }\n        mCurrentAlbumName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ALBUM));\n        mCurrentArtistNameForAlbum = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.ARTIST));\n        mCurrentTrackName = mTrackCursor.getString(mTrackCursor.getColumnIndexOrThrow(\n                MediaStore.Audio.Media.TITLE));\n        menu.setHeaderTitle(mCurrentTrackName);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case PLAY_SELECTION: {\n                // play the track\n                int position = mSelectedPosition;\n                MusicUtils.playAll(this, mTrackCursor, position);\n                return true;\n            }\n\n            case QUEUE: {\n                int [] list = new int[] { (int) mSelectedId };\n                MusicUtils.addToCurrentPlaylist(this, list);\n                return true;\n            }\n\n            case NEW_PLAYLIST: {\n                Intent intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, NEW_PLAYLIST);\n                return true;\n            }\n\n            case PLAYLIST_SELECTED: {\n                int [] list = new int[] { (int) mSelectedId };\n                int playlist = item.getIntent().getIntExtra(\"playlist\", 0);\n                MusicUtils.addToPlaylist(this, list, playlist);\n                return true;\n            }\n\n            case USE_AS_RINGTONE:\n                // Set the system setting to make this the current ringtone\n                MusicUtils.setRingtone(this, mSelectedId);\n                return true;\n\n            case DELETE_ITEM: {\n                int [] list = new int[1];\n                list[0] = (int) mSelectedId;\n                Bundle b = new Bundle();\n                String f = getString(R.string.delete_song_desc); \n                String desc = String.format(f, mCurrentTrackName);\n                b.putString(\"description\", desc);\n                b.putIntArray(\"items\", list);\n                Intent intent = new Intent();\n                intent.setClass(this, DeleteItems.class);\n                intent.putExtras(b);\n                startActivityForResult(intent, -1);\n                return true;\n            }\n            \n            case REMOVE:\n                removePlaylistItem(mSelectedPosition);\n                return true;\n                \n            case SEARCH:\n                doSearch();\n                return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    void doSearch() {\n        CharSequence title = null;\n        String query = null;\n        \n        Intent i = new Intent();\n        i.setAction(MediaStore.INTENT_ACTION_MEDIA_SEARCH);\n        \n        title = mCurrentAlbumName;\n        query = mCurrentArtistNameForAlbum + \" \" + mCurrentAlbumName;\n        i.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, mCurrentArtistNameForAlbum);\n        i.putExtra(MediaStore.EXTRA_MEDIA_ALBUM, mCurrentAlbumName);\n        i.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, \"audio/*\");\n        title = getString(R.string.mediasearch, title);\n        i.putExtra(SearchManager.QUERY, query);\n\n        startActivity(Intent.createChooser(i, title));\n    }\n\n    // In order to use alt-up/down as a shortcut for moving the selected item\n    // in the list, we need to override dispatchKeyEvent, not onKeyDown.\n    // (onKeyDown never sees these events, since they are handled by the list)\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (mPlaylist != null && event.getMetaState() != 0 &&\n                event.getAction() == KeyEvent.ACTION_DOWN) {\n            switch (event.getKeyCode()) {\n                case KeyEvent.KEYCODE_DPAD_UP:\n                    moveItem(true);\n                    return true;\n                case KeyEvent.KEYCODE_DPAD_DOWN:\n                    moveItem(false);\n                    return true;\n                case KeyEvent.KEYCODE_DEL:\n                    removeItem();\n                    return true;\n            }\n        }\n\n        return super.dispatchKeyEvent(event);\n    }\n\n    private void removeItem() {\n        int curcount = mTrackCursor.getCount();\n        int curpos = mTrackList.getSelectedItemPosition();\n        if (curcount == 0 || curpos < 0) {\n            return;\n        }\n        \n        if (\"nowplaying\".equals(mPlaylist)) {\n            // remove track from queue\n\n            // Work around bug 902971. To get quick visual feedback\n            // of the deletion of the item, hide the selected view.\n            try {\n                if (curpos != MusicUtils.sService.getQueuePosition()) {\n                    mDeletedOneRow = true;\n                }\n            } catch (RemoteException ex) {\n            }\n            View v = mTrackList.getSelectedView();\n            v.setVisibility(View.GONE);\n            mTrackList.invalidateViews();\n            ((NowPlayingCursor)mTrackCursor).removeItem(curpos);\n            v.setVisibility(View.VISIBLE);\n            mTrackList.invalidateViews();\n        } else {\n            // remove track from playlist\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members._ID);\n            mTrackCursor.moveToPosition(curpos);\n            long id = mTrackCursor.getLong(colidx);\n            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            getContentResolver().delete(\n                    ContentUris.withAppendedId(uri, id), null, null);\n            curcount--;\n            if (curcount == 0) {\n                finish();\n            } else {\n                mTrackList.setSelection(curpos < curcount ? curpos : curcount);\n            }\n        }\n    }\n    \n    private void moveItem(boolean up) {\n        int curcount = mTrackCursor.getCount(); \n        int curpos = mTrackList.getSelectedItemPosition();\n        if ( (up && curpos < 1) || (!up  && curpos >= curcount - 1)) {\n            return;\n        }\n\n        if (mTrackCursor instanceof NowPlayingCursor) {\n            NowPlayingCursor c = (NowPlayingCursor) mTrackCursor;\n            c.moveItem(curpos, up ? curpos - 1 : curpos + 1);\n            ((TrackListAdapter)getListAdapter()).notifyDataSetChanged();\n            getListView().invalidateViews();\n            mDeletedOneRow = true;\n            if (up) {\n                mTrackList.setSelection(curpos - 1);\n            } else {\n                mTrackList.setSelection(curpos + 1);\n            }\n        } else {\n            int colidx = mTrackCursor.getColumnIndexOrThrow(\n                    MediaStore.Audio.Playlists.Members.PLAY_ORDER);\n            mTrackCursor.moveToPosition(curpos);\n            int currentplayidx = mTrackCursor.getInt(colidx);\n            Uri baseUri = MediaStore.Audio.Playlists.Members.getContentUri(\"external\",\n                    Long.valueOf(mPlaylist));\n            ContentValues values = new ContentValues();\n            String where = MediaStore.Audio.Playlists.Members._ID + \"=?\";\n            String [] wherearg = new String[1];\n            ContentResolver res = getContentResolver();\n            if (up) {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx - 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToPrevious();\n            } else {\n                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx + 1);\n                wherearg[0] = mTrackCursor.getString(0);\n                res.update(baseUri, values, where, wherearg);\n                mTrackCursor.moveToNext();\n            }\n            values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, currentplayidx);\n            wherearg[0] = mTrackCursor.getString(0);\n            res.update(baseUri, values, where, wherearg);\n        }\n    }\n    \n    @Override\n    protected void onListItemClick(ListView l, View v, int position, long id)\n    {\n        if (mTrackCursor.getCount() == 0) {\n            return;\n        }\n        MusicUtils.playAll(this, mTrackCursor, position);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        /* This activity is used for a number of different browsing modes, and the menu can\n         * be different for each of them:\n         * - all tracks, optionally restricted to an album, artist or playlist\n         * - the list of currently playing songs\n         */\n        super.onCreateOptionsMenu(menu);\n        if (mPlaylist == null) {\n            menu.add(0, PLAY_ALL, 0, R.string.play_all).setIcon(R.drawable.ic_menu_play_clip);\n        }\n        menu.add(0, GOTO_START, 0, R.string.goto_start).setIcon(R.drawable.ic_menu_music_library);\n        menu.add(0, GOTO_PLAYBACK, 0, R.string.goto_playback).setIcon(R.drawable.ic_menu_playback)\n                .setVisible(MusicUtils.isMusicLoaded());\n        menu.add(0, SHUFFLE_ALL, 0, R.string.shuffle_all).setIcon(R.drawable.ic_menu_shuffle);\n        if (mPlaylist != null) {\n            menu.add(0, SAVE_AS_PLAYLIST, 0, R.string.save_as_playlist).setIcon(R.drawable.ic_menu_save);\n            if (mPlaylist.equals(\"nowplaying\")) {\n                menu.add(0, CLEAR_PLAYLIST, 0, R.string.clear_playlist).setIcon(R.drawable.ic_menu_clear_playlist);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Intent intent;\n        Cursor cursor;\n        switch (item.getItemId()) {\n            case PLAY_ALL: {\n                MusicUtils.playAll(this, mTrackCursor);\n                return true;\n            }\n\n            case GOTO_START:\n                intent = new Intent();\n                intent.setClass(this, MusicBrowserActivity.class);\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n\n            case GOTO_PLAYBACK:\n                intent = new Intent(\"com.android.music.PLAYBACK_VIEWER\");\n                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n                \n            case SHUFFLE_ALL:\n                // Should 'shuffle all' shuffle ALL, or only the tracks shown?\n                cursor = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        new String [] { MediaStore.Audio.Media._ID}, \n                        MediaStore.Audio.Media.IS_MUSIC + \"=1\", null,\n                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER);\n                if (cursor != null) {\n                    MusicUtils.shuffleAll(this, cursor);\n                    cursor.close();\n                }\n                return true;\n                \n            case SAVE_AS_PLAYLIST:\n                intent = new Intent();\n                intent.setClass(this, CreatePlaylist.class);\n                startActivityForResult(intent, SAVE_AS_PLAYLIST);\n                return true;\n                \n            case CLEAR_PLAYLIST:\n                // We only clear the current playlist\n                MusicUtils.clearQueue();\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case SCAN_DONE:\n                if (resultCode == RESULT_CANCELED) {\n                    finish();\n                } else {\n                    getTrackCursor(mQueryHandler);\n                }\n                break;\n                \n            case NEW_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = new int[] { (int) mSelectedId };\n                        MusicUtils.addToPlaylist(this, list, Integer.valueOf(uri.getLastPathSegment()));\n                    }\n                }\n                break;\n\n            case SAVE_AS_PLAYLIST:\n                if (resultCode == RESULT_OK) {\n                    Uri uri = intent.getData();\n                    if (uri != null) {\n                        int [] list = MusicUtils.getSongListForCursor(mTrackCursor);\n                        int plid = Integer.parseInt(uri.getLastPathSegment());\n                        MusicUtils.addToPlaylist(this, list, plid);\n                    }\n                }\n                break;\n        }\n    }\n    \n    private Cursor getTrackCursor(AsyncQueryHandler async) {\n        Cursor ret = null;\n        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;\n        StringBuilder where = new StringBuilder();\n        where.append(MediaStore.Audio.Media.TITLE + \" != ''\");\n        \n        // Add in the filtering constraints\n        String [] keywords = null;\n        if (mFilterString != null) {\n            String [] searchWords = mFilterString.split(\" \");\n            keywords = new String[searchWords.length];\n            Collator col = Collator.getInstance();\n            col.setStrength(Collator.PRIMARY);\n            for (int i = 0; i < searchWords.length; i++) {\n                keywords[i] = '%' + MediaStore.Audio.keyFor(searchWords[i]) + '%';\n            }\n            for (int i = 0; i < searchWords.length; i++) {\n                where.append(\" AND \");\n                where.append(MediaStore.Audio.Media.ARTIST_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.ALBUM_KEY + \"||\");\n                where.append(MediaStore.Audio.Media.TITLE_KEY + \" LIKE ?\");\n            }\n        }\n        \n        if (mGenre != null) {\n            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\",\n                        Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this,\n                        MediaStore.Audio.Genres.Members.getContentUri(\"external\", Integer.valueOf(mGenre)),\n                        mCursorCols, where.toString(), keywords, mSortOrder);\n            }\n        } else if (mPlaylist != null) {\n            if (mPlaylist.equals(\"nowplaying\")) {\n                if (MusicUtils.sService != null) {\n                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);\n                    if (ret.getCount() == 0) {\n                        finish();\n                    }\n                } else {\n                    // Nothing is playing.\n                }\n            } else {\n                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;\n                if (async != null) {\n                    async.startQuery(0, null,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                    ret = null;\n                } else {\n                    ret = MusicUtils.query(this,\n                            MediaStore.Audio.Playlists.Members.getContentUri(\"external\", Long.valueOf(mPlaylist)),\n                            mPlaylistMemberCols, where.toString(), keywords, mSortOrder);\n                }\n            }\n        } else {\n            if (mAlbumId != null) {\n                where.append(\" AND \" + MediaStore.Audio.Media.ALBUM_ID + \"=\" + mAlbumId);\n                mSortOrder = MediaStore.Audio.Media.TRACK + \", \" + mSortOrder;\n            }\n            where.append(\" AND \" + MediaStore.Audio.Media.IS_MUSIC + \"=1\");\n            if (async != null) {\n                async.startQuery(0, null,\n                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n                ret = null;\n            } else {\n                ret = MusicUtils.query(this, MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                        mCursorCols, where.toString() , keywords, mSortOrder);\n            }\n        }\n        \n        // This special case is for the \"nowplaying\" cursor, which cannot be handled\n        // asynchronously, so we do some extra initialization here.\n        if (ret != null && async != null) {\n            init(ret);\n            setTitle();\n        }\n        return ret;\n    }\n\n    private class NowPlayingCursor extends AbstractCursor\n    {\n        public NowPlayingCursor(IMediaPlaybackService service, String [] cols)\n        {\n            mCols = cols;\n            mService  = service;\n            makeNowPlayingCursor();\n        }\n        private void makeNowPlayingCursor() {\n            mCurrentPlaylistCursor = null;\n            try {\n                mNowPlaying = mService.getQueue();\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                return;\n            }\n\n            StringBuilder where = new StringBuilder();\n            where.append(MediaStore.Audio.Media._ID + \" IN (\");\n            for (int i = 0; i < mSize; i++) {\n                where.append(mNowPlaying[i]);\n                if (i < mSize - 1) {\n                    where.append(\",\");\n                }\n            }\n            where.append(\")\");\n\n            mCurrentPlaylistCursor = MusicUtils.query(TrackBrowserActivity.this,\n                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,\n                    mCols, where.toString(), null, MediaStore.Audio.Media._ID);\n\n            if (mCurrentPlaylistCursor == null) {\n                mSize = 0;\n                return;\n            }\n            \n            int size = mCurrentPlaylistCursor.getCount();\n            mCursorIdxs = new int[size];\n            mCurrentPlaylistCursor.moveToFirst();\n            int colidx = mCurrentPlaylistCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            for (int i = 0; i < size; i++) {\n                mCursorIdxs[i] = mCurrentPlaylistCursor.getInt(colidx);\n                mCurrentPlaylistCursor.moveToNext();\n            }\n            mCurrentPlaylistCursor.moveToFirst();\n            mCurPos = -1;\n            \n            // At this point we can verify the 'now playing' list we got\n            // earlier to make sure that all the items in there still exist\n            // in the database, and remove those that aren't. This way we\n            // don't get any blank items in the list.\n            try {\n                int removed = 0;\n                for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n                    int trackid = mNowPlaying[i];\n                    int crsridx = Arrays.binarySearch(mCursorIdxs, trackid);\n                    if (crsridx < 0) {\n                        //Log.i(\"@@@@@\", \"item no longer exists in db: \" + trackid);\n                        removed += mService.removeTrack(trackid);\n                    }\n                }\n                if (removed > 0) {\n                    mNowPlaying = mService.getQueue();\n                    mSize = mNowPlaying.length;\n                    if (mSize == 0) {\n                        mCursorIdxs = null;\n                        return;\n                    }\n                }\n            } catch (RemoteException ex) {\n                mNowPlaying = new int[0];\n            }\n        }\n\n        @Override\n        public int getCount()\n        {\n            return mSize;\n        }\n\n        @Override\n        public boolean onMove(int oldPosition, int newPosition)\n        {\n            if (oldPosition == newPosition)\n                return true;\n            \n            if (mNowPlaying == null || mCursorIdxs == null) {\n                return false;\n            }\n\n            // The cursor doesn't have any duplicates in it, and is not ordered\n            // in queue-order, so we need to figure out where in the cursor we\n            // should be.\n           \n            int newid = mNowPlaying[newPosition];\n            int crsridx = Arrays.binarySearch(mCursorIdxs, newid);\n            mCurrentPlaylistCursor.moveToPosition(crsridx);\n            mCurPos = newPosition;\n            \n            return true;\n        }\n\n        public boolean removeItem(int which)\n        {\n            try {\n                if (mService.removeTracks(which, which) == 0) {\n                    return false; // delete failed\n                }\n                int i = (int) which;\n                mSize--;\n                while (i < mSize) {\n                    mNowPlaying[i] = mNowPlaying[i+1];\n                    i++;\n                }\n                onMove(-1, (int) mCurPos);\n            } catch (RemoteException ex) {\n            }\n            return true;\n        }\n        \n        public void moveItem(int from, int to) {\n            try {\n                mService.moveQueueItem(from, to);\n                mNowPlaying = mService.getQueue();\n                onMove(-1, mCurPos); // update the underlying cursor\n            } catch (RemoteException ex) {\n            }\n        }\n\n        private void dump() {\n            String where = \"(\";\n            for (int i = 0; i < mSize; i++) {\n                where += mNowPlaying[i];\n                if (i < mSize - 1) {\n                    where += \",\";\n                }\n            }\n            where += \")\";\n            Log.i(\"NowPlayingCursor: \", where);\n        }\n\n        @Override\n        public String getString(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getString(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return \"\";\n            }\n        }\n\n        @Override\n        public short getShort(int column)\n        {\n            return mCurrentPlaylistCursor.getShort(column);\n        }\n\n        @Override\n        public int getInt(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getInt(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public long getLong(int column)\n        {\n            try {\n                return mCurrentPlaylistCursor.getLong(column);\n            } catch (Exception ex) {\n                onChange(true);\n                return 0;\n            }\n        }\n\n        @Override\n        public float getFloat(int column)\n        {\n            return mCurrentPlaylistCursor.getFloat(column);\n        }\n\n        @Override\n        public double getDouble(int column)\n        {\n            return mCurrentPlaylistCursor.getDouble(column);\n        }\n\n        @Override\n        public boolean isNull(int column)\n        {\n            return mCurrentPlaylistCursor.isNull(column);\n        }\n\n        @Override\n        public String[] getColumnNames()\n        {\n            return mCols;\n        }\n        \n        @Override\n        public void deactivate()\n        {\n            if (mCurrentPlaylistCursor != null)\n                mCurrentPlaylistCursor.deactivate();\n        }\n\n        @Override\n        public boolean requery()\n        {\n            makeNowPlayingCursor();\n            return true;\n        }\n\n        private String [] mCols;\n        private Cursor mCurrentPlaylistCursor;     // updated in onMove\n        private int mSize;          // size of the queue\n        private int[] mNowPlaying;\n        private int[] mCursorIdxs;\n        private int mCurPos;\n        private IMediaPlaybackService mService;\n    }\n    \n    class TrackListAdapter extends SimpleCursorAdapter implements SectionIndexer {\n        boolean mIsNowPlaying;\n        boolean mDisableNowPlayingIndicator;\n\n        final int mTitleIdx;\n        final int mArtistIdx;\n        final int mAlbumIdx;\n        final int mDurationIdx;\n        int mAudioIdIdx;\n\n        private final StringBuilder mBuilder = new StringBuilder();\n        private final String mUnknownArtist;\n        private final String mUnknownAlbum;\n        \n        private AlphabetIndexer mIndexer;\n        private String mAlphabet;\n        \n        class ViewHolder {\n            TextView line1;\n            TextView line2;\n            TextView duration;\n            ImageView play_indicator;\n            CharArrayBuffer buffer1;\n            char [] buffer2;\n        }\n        \n        TrackListAdapter(Context context, int layout, Cursor cursor, String[] from, int[] to,\n                boolean isnowplaying, boolean disablenowplayingindicator) {\n            super(context, layout, cursor, from, to);\n            mIsNowPlaying = isnowplaying;\n            mDisableNowPlayingIndicator = disablenowplayingindicator;\n            mUnknownArtist = context.getString(R.string.unknown_artist_name);\n            mUnknownAlbum = context.getString(R.string.unknown_album_name);\n            \n            mTitleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE);\n            mArtistIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST);\n            mAlbumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM);\n            mDurationIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION);\n            try {\n                mAudioIdIdx = cursor.getColumnIndexOrThrow(\n                        MediaStore.Audio.Playlists.Members.AUDIO_ID);\n            } catch (IllegalArgumentException ex) {\n                mAudioIdIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n            }\n            if (!mEditMode) {\n                mAlphabet = context.getString(\n                        com.android.internal.R.string.fast_scroll_alphabet);\n            \n                mIndexer = new MusicAlphabetIndexer(cursor, mTitleIdx, mAlphabet);\n            }\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            View v = super.newView(context, cursor, parent);\n            ImageView iv = (ImageView) v.findViewById(R.id.icon);\n            if (mEditMode) {\n                iv.setVisibility(View.VISIBLE);\n                iv.setImageResource(R.drawable.ic_mp_move);\n                ViewGroup.LayoutParams p = iv.getLayoutParams();\n                p.width = ViewGroup.LayoutParams.WRAP_CONTENT;\n                p.height = ViewGroup.LayoutParams.WRAP_CONTENT;\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n            \n            ViewHolder vh = new ViewHolder();\n            vh.line1 = (TextView) v.findViewById(R.id.line1);\n            vh.line2 = (TextView) v.findViewById(R.id.line2);\n            vh.duration = (TextView) v.findViewById(R.id.duration);\n            vh.play_indicator = (ImageView) v.findViewById(R.id.play_indicator);\n            vh.buffer1 = new CharArrayBuffer(100);\n            vh.buffer2 = new char[200];\n            v.setTag(vh);\n            return v;\n        }\n\n        @Override\n        public void bindView(View view, Context context, Cursor cursor) {\n            \n            ViewHolder vh = (ViewHolder) view.getTag();\n            \n            cursor.copyStringToBuffer(mTitleIdx, vh.buffer1);\n            vh.line1.setText(vh.buffer1.data, 0, vh.buffer1.sizeCopied);\n            \n            int secs = cursor.getInt(mDurationIdx) / 1000;\n            if (secs == 0) {\n                vh.duration.setText(\"\");\n            } else {\n                vh.duration.setText(MusicUtils.makeTimeString(context, secs));\n            }\n            \n            final StringBuilder builder = mBuilder;\n            builder.delete(0, builder.length());\n\n            String name = cursor.getString(mAlbumIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownAlbum);\n            } else {\n                builder.append(name);\n            }\n            builder.append('\\n');\n            name = cursor.getString(mArtistIdx);\n            if (name == null || name.equals(MediaFile.UNKNOWN_STRING)) {\n                builder.append(mUnknownArtist);\n            } else {\n                builder.append(name);\n            }\n            int len = builder.length();\n            if (vh.buffer2.length < len) {\n                vh.buffer2 = new char[len];\n            }\n            builder.getChars(0, len, vh.buffer2, 0);\n            vh.line2.setText(vh.buffer2, 0, len);\n\n            ImageView iv = vh.play_indicator;\n            int id = -1;\n            if (MusicUtils.sService != null) {\n                // TODO: IPC call on each bind??\n                try {\n                    if (mIsNowPlaying) {\n                        id = MusicUtils.sService.getQueuePosition();\n                    } else {\n                        id = MusicUtils.sService.getAudioId();\n                    }\n                } catch (RemoteException ex) {\n                }\n            }\n            \n            // Determining whether and where to show the \"now playing indicator\n            // is tricky, because we don't actually keep track of where the songs\n            // in the current playlist came from after they've started playing.\n            //\n            // If the \"current playlists\" is shown, then we can simply match by position,\n            // otherwise, we need to match by id. Match-by-id gets a little weird if\n            // a song appears in a playlist more than once, and you're in edit-playlist\n            // mode. In that case, both items will have the \"now playing\" indicator.\n            // For this reason, we don't show the play indicator at all when in edit\n            // playlist mode (except when you're viewing the \"current playlists\",\n            // which is not really a playlist)\n            if ( (mIsNowPlaying && cursor.getPosition() == id) ||\n                 (!mIsNowPlaying && !mDisableNowPlayingIndicator && cursor.getInt(mAudioIdIdx) == id)) {\n                iv.setImageResource(R.drawable.indicator_ic_mp_playing_list);\n                iv.setVisibility(View.VISIBLE);\n            } else {\n                iv.setVisibility(View.GONE);\n            }\n        }\n        \n        @Override\n        public void changeCursor(Cursor cursor) {\n            super.changeCursor(cursor);\n            mTrackCursor = cursor;\n            if (mIndexer != null) {\n                mIndexer.setCursor(cursor);\n            }\n        }\n        \n        @Override\n        public Cursor runQueryOnBackgroundThread(CharSequence constraint) {\n            mFilterString = constraint.toString();\n            return getTrackCursor(null);\n        }\n        \n        // SectionIndexer methods\n        \n        public Object[] getSections() {\n            if (mIndexer != null) { \n                return mIndexer.getSections();\n            } else {\n                return null;\n            }\n        }\n        \n        public int getPositionForSection(int section) {\n            int pos = mIndexer.getPositionForSection(section);\n            return pos;\n        }\n        \n        public int getSectionForPosition(int position) {\n            return 0;\n        }        \n    }\n\n    private ListView mTrackList;\n    private Cursor mTrackCursor;\n    private String mAlbumId;\n    private String mArtistId;\n    private String mPlaylist;\n    private String mGenre;\n    private String mSortOrder;\n    private int mSelectedPosition;\n    private long mSelectedId;\n}\n\n","lineNo":597}
